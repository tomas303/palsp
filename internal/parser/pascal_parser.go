// Code generated from /home/tomas/development/tomas303/projects/palsp/internal/pascal.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // pascal

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type pascalParser struct {
	*antlr.BaseParser
}

var PascalParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func pascalParserInit() {
	staticData := &PascalParserStaticData
	staticData.LiteralNames = []string{
		"", "'AND'", "'ARRAY'", "'BEGIN'", "'BOOLEAN'", "'CASE'", "'CHAR'",
		"'CHR'", "'CONST'", "'DIV'", "'DO'", "'DOWNTO'", "'ELSE'", "'END'",
		"'FILE'", "'FOR'", "'FUNCTION'", "'GOTO'", "'IF'", "'IN'", "'INTEGER'",
		"'LABEL'", "'MOD'", "'NIL'", "'NOT'", "'OF'", "'OR'", "'PACKED'", "'PROCEDURE'",
		"'PROGRAM'", "'REAL'", "'RECORD'", "'REPEAT'", "'SET'", "'THEN'", "'TO'",
		"'TYPE'", "'UNTIL'", "'VAR'", "'WHILE'", "'WITH'", "'+'", "'-'", "'*'",
		"'/'", "':='", "','", "';'", "':'", "'='", "'<>'", "'<'", "'<='", "'>='",
		"'>'", "'('", "')'", "'['", "'(.'", "']'", "'.)'", "'^'", "'@'", "'.'",
		"'..'", "'{'", "'}'", "'UNIT'", "'INTERFACE'", "'USES'", "'STRING'",
		"'IMPLEMENTATION'", "'TRUE'", "'FALSE'", "'CLASS'", "'PRIVATE'", "'PROTECTED'",
		"'PUBLIC'", "'PUBLISHED'", "", "", "'OUT'", "'PROPERTY'", "'READ'",
		"'WRITE'", "'DEFAULT'", "'INDEX'", "'AS'", "'TRY'", "'FINALLY'", "'EXCEPT'",
		"'INITIALIZATION'", "'FINALIZATION'", "", "'INHERITED'", "'ABSTRACT'",
		"'VIRTUAL'", "'OVERRIDE'", "'OVERLOAD'", "'INLINE'", "'CONSTRUCTOR'",
		"'DESTRUCTOR'", "'resourcestring'", "'FORWARD'", "'RAISE'", "", "",
		"", "", "", "", "", "", "'\\uFEFF'",
	}
	staticData.SymbolicNames = []string{
		"", "AND", "ARRAY", "BEGIN", "BOOLEAN", "CASE", "CHAR", "CHR", "CONST",
		"DIV", "DO", "DOWNTO", "ELSE", "END", "FILE", "FOR", "FUNCTION", "GOTO",
		"IF", "IN", "INTEGER", "LABEL", "MOD", "NIL", "NOT", "OF", "OR", "PACKED",
		"PROCEDURE", "PROGRAM", "REAL", "RECORD", "REPEAT", "SET", "THEN", "TO",
		"TYPE", "UNTIL", "VAR", "WHILE", "WITH", "PLUS", "MINUS", "STAR", "SLASH",
		"ASSIGN", "COMMA", "SEMI", "COLON", "EQUAL", "NOT_EQUAL", "LT", "LE",
		"GE", "GT", "LPAREN", "RPAREN", "LBRACK", "LBRACK2", "RBRACK", "RBRACK2",
		"POINTER", "AT", "DOT", "DOTDOT", "LCURLY", "RCURLY", "UNIT", "INTERFACE",
		"USES", "STRING", "IMPLEMENTATION", "TRUE", "FALSE", "CLASS", "PRIVATE",
		"PROTECTED", "PUBLIC", "PUBLISHED", "STRICTPRIVATE", "STRICTPROTECTED",
		"OUT", "PROPERTY", "READ", "WRITE", "DEFAULT", "INDEX", "AS", "TRY",
		"FINALLY", "EXCEPT", "INITIALIZATION", "FINALIZATION", "OFOBJECT", "INHERITED",
		"ABSTRACT", "VIRTUAL", "OVERRIDE", "OVERLOAD", "INLINE", "CONSTRUCTOR",
		"DESTRUCTOR", "RESOURCESTRING", "FORWARD", "RAISE", "WS", "COMMENT_1",
		"COMMENT_2", "COMMENT_3", "IDENT", "STRING_LITERAL", "NUM_INT", "NUM_REAL",
		"UTF8BOM",
	}
	staticData.RuleNames = []string{
		"source", "program", "unit", "interfaceSection", "implementationSection",
		"initializationSection", "finalizationSection", "identifier", "interfaceBlock",
		"implementationBlock", "block", "usesUnits", "labelDeclarationPart",
		"label", "constantDefinitionPart", "constantDefinition", "constantChr",
		"constant", "arrayConstant", "unsignedNumber", "unsignedInteger", "unsignedReal",
		"sign", "bool_", "string", "resourceDefinitionPart", "resourceDefinition",
		"typeDefinitionPart", "typeDefinition", "functionType", "procedureType",
		"forwardClassType", "classType", "classImplementsInterfaces", "classDeclaration",
		"classPrivateDeclaration", "classStrictPrivateDeclaration", "classProtectedDeclaration",
		"classStrictProtectedDeclaration", "classPublicDeclaration", "classPublishedDeclaration",
		"classImplicitPublishedDeclaration", "classDeclarationPart", "propertyDeclaration",
		"propertyReadDeclaration", "propertyWriteDeclaration", "propertyDefaultValueDeclaration",
		"propertyIndexDeclaration", "propertyIndexParameters", "propertyIndexParametersList",
		"methodIdentifier", "type_", "simpleType", "scalarType", "subrangeType",
		"typeIdentifier", "structuredType", "unpackedStructuredType", "stringtype",
		"arrayType", "typeList", "indexType", "componentType", "recordType",
		"fieldList", "fixedPart", "recordSection", "variantPart", "tag", "variant",
		"setType", "baseType", "fileType", "pointerType", "variableDeclarationPart",
		"variableDeclaration", "procedureHeader", "functionHeader", "procedureOrFunctionHeader",
		"procedureOrFunctionHeaderModifiers", "procedureOrFunctionDeclaration",
		"procedureDeclaration", "functionDeclaration", "resultType", "procedureOrFunctionBody",
		"formalParameterList", "formalParameterSection", "parameterGroup", "identifierList",
		"constList", "defaultValue", "statement", "unlabelledStatement", "simpleStatement",
		"assignmentStatement", "raiseExceptionStatement", "variable", "expression",
		"relationaloperator", "simpleExpression", "additiveoperator", "term",
		"multiplicativeoperator", "signedFactor", "factor", "unsignedConstant",
		"functionDesignator", "parameterList", "set_", "elementList", "element",
		"procedureStatement", "actualParameter", "parameterwidth", "gotoStatement",
		"inheritedStatement", "emptyStatement_", "empty_", "structuredStatement",
		"compoundStatement", "statements", "conditionalStatement", "ifStatement",
		"caseStatement", "caseListElement", "repetetiveStatement", "whileStatement",
		"repeatStatement", "forStatement", "forList", "initialValue", "finalValue",
		"withStatement", "tryExceptStatement", "tryFinallyStatement", "recordVariableList",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 113, 1303, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 1, 0, 1, 0, 3, 0, 275, 8, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3,
		1, 283, 8, 1, 1, 1, 1, 1, 3, 1, 287, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 301, 8, 2, 1, 2, 3, 2,
		304, 8, 2, 1, 2, 3, 2, 307, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 3, 1, 3, 3,
		3, 315, 8, 3, 1, 3, 1, 3, 1, 4, 1, 4, 3, 4, 321, 8, 4, 1, 4, 1, 4, 1, 5,
		1, 5, 1, 5, 1, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 5, 8, 339, 8, 8, 10, 8, 12, 8, 342, 9, 8, 1, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 5, 9, 354, 8, 9, 10, 9, 12, 9, 357,
		9, 9, 1, 10, 1, 10, 1, 10, 1, 10, 5, 10, 363, 8, 10, 10, 10, 12, 10, 366,
		9, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 5, 12, 376,
		8, 12, 10, 12, 12, 12, 379, 9, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 14, 1,
		14, 1, 14, 1, 14, 4, 14, 389, 8, 14, 11, 14, 12, 14, 390, 1, 15, 1, 15,
		1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1,
		17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17,
		3, 17, 416, 8, 17, 5, 17, 418, 8, 17, 10, 17, 12, 17, 421, 9, 17, 3, 17,
		423, 8, 17, 1, 18, 1, 18, 1, 18, 1, 18, 5, 18, 429, 8, 18, 10, 18, 12,
		18, 432, 9, 18, 1, 18, 1, 18, 1, 19, 1, 19, 3, 19, 438, 8, 19, 1, 20, 1,
		20, 1, 21, 1, 21, 1, 22, 1, 22, 1, 23, 1, 23, 1, 24, 1, 24, 1, 25, 1, 25,
		4, 25, 452, 8, 25, 11, 25, 12, 25, 453, 1, 26, 1, 26, 1, 26, 1, 26, 1,
		26, 1, 27, 1, 27, 1, 27, 1, 27, 4, 27, 465, 8, 27, 11, 27, 12, 27, 466,
		1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 475, 8, 28, 1, 29, 1,
		29, 3, 29, 479, 8, 29, 1, 29, 1, 29, 1, 29, 3, 29, 484, 8, 29, 1, 30, 1,
		30, 3, 30, 488, 8, 30, 1, 30, 3, 30, 491, 8, 30, 1, 31, 1, 31, 1, 32, 1,
		32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 5, 32, 502, 8, 32, 10, 32, 12, 32,
		505, 9, 32, 1, 32, 1, 32, 1, 33, 1, 33, 5, 33, 511, 8, 33, 10, 33, 12,
		33, 514, 9, 33, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 3, 34, 522, 8,
		34, 1, 35, 1, 35, 5, 35, 526, 8, 35, 10, 35, 12, 35, 529, 9, 35, 1, 36,
		1, 36, 5, 36, 533, 8, 36, 10, 36, 12, 36, 536, 9, 36, 1, 37, 1, 37, 5,
		37, 540, 8, 37, 10, 37, 12, 37, 543, 9, 37, 1, 38, 1, 38, 5, 38, 547, 8,
		38, 10, 38, 12, 38, 550, 9, 38, 1, 39, 1, 39, 5, 39, 554, 8, 39, 10, 39,
		12, 39, 557, 9, 39, 1, 40, 1, 40, 5, 40, 561, 8, 40, 10, 40, 12, 40, 564,
		9, 40, 1, 41, 5, 41, 567, 8, 41, 10, 41, 12, 41, 570, 9, 41, 1, 42, 1,
		42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 582,
		8, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 592,
		8, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 601, 8,
		42, 3, 42, 603, 8, 42, 1, 43, 1, 43, 1, 43, 3, 43, 608, 8, 43, 1, 43, 1,
		43, 1, 43, 3, 43, 613, 8, 43, 1, 43, 3, 43, 616, 8, 43, 1, 43, 3, 43, 619,
		8, 43, 1, 43, 3, 43, 622, 8, 43, 1, 43, 1, 43, 1, 43, 3, 43, 627, 8, 43,
		3, 43, 629, 8, 43, 1, 44, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 1, 46, 1,
		46, 1, 46, 1, 47, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 49, 1, 49,
		1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 5, 49, 655, 8, 49, 10, 49, 12,
		49, 658, 9, 49, 1, 50, 1, 50, 1, 50, 4, 50, 663, 8, 50, 11, 50, 12, 50,
		664, 1, 50, 1, 50, 1, 51, 1, 51, 1, 51, 3, 51, 672, 8, 51, 1, 52, 1, 52,
		1, 52, 1, 52, 3, 52, 678, 8, 52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 54, 1,
		54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55,
		3, 55, 696, 8, 55, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 702, 8, 56, 1, 57,
		1, 57, 1, 57, 3, 57, 707, 8, 57, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 713,
		8, 58, 1, 58, 1, 58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1,
		59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59,
		1, 59, 1, 59, 3, 59, 737, 8, 59, 1, 60, 1, 60, 1, 60, 5, 60, 742, 8, 60,
		10, 60, 12, 60, 745, 9, 60, 1, 61, 1, 61, 1, 62, 1, 62, 1, 63, 1, 63, 3,
		63, 753, 8, 63, 1, 63, 1, 63, 1, 64, 1, 64, 1, 64, 3, 64, 760, 8, 64, 1,
		64, 3, 64, 763, 8, 64, 1, 65, 1, 65, 1, 65, 5, 65, 768, 8, 65, 10, 65,
		12, 65, 771, 9, 65, 1, 65, 3, 65, 774, 8, 65, 1, 66, 1, 66, 1, 66, 1, 66,
		1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 5, 67, 786, 8, 67, 10, 67, 12,
		67, 789, 9, 67, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 3, 68, 796, 8, 68, 1,
		69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 71,
		1, 71, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 814, 8, 72, 1, 73, 1, 73, 1,
		73, 1, 74, 1, 74, 1, 74, 1, 74, 5, 74, 823, 8, 74, 10, 74, 12, 74, 826,
		9, 74, 1, 74, 1, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 76, 1, 76, 1, 76, 3,
		76, 837, 8, 76, 1, 76, 3, 76, 840, 8, 76, 1, 76, 1, 76, 1, 76, 1, 77, 1,
		77, 1, 77, 3, 77, 848, 8, 77, 1, 77, 3, 77, 851, 8, 77, 1, 77, 1, 77, 1,
		77, 1, 77, 1, 77, 1, 78, 1, 78, 3, 78, 860, 8, 78, 1, 79, 1, 79, 5, 79,
		864, 8, 79, 10, 79, 12, 79, 867, 9, 79, 1, 80, 1, 80, 3, 80, 871, 8, 80,
		1, 81, 1, 81, 1, 81, 1, 81, 1, 82, 1, 82, 1, 82, 1, 82, 1, 83, 1, 83, 1,
		84, 1, 84, 1, 84, 1, 85, 1, 85, 1, 85, 1, 85, 5, 85, 890, 8, 85, 10, 85,
		12, 85, 893, 9, 85, 1, 85, 1, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1,
		86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 3, 86, 908, 8, 86, 1, 87, 1, 87,
		1, 87, 1, 87, 3, 87, 914, 8, 87, 1, 87, 1, 87, 3, 87, 918, 8, 87, 1, 88,
		1, 88, 1, 88, 5, 88, 923, 8, 88, 10, 88, 12, 88, 926, 9, 88, 1, 89, 1,
		89, 1, 89, 5, 89, 931, 8, 89, 10, 89, 12, 89, 934, 9, 89, 1, 90, 1, 90,
		1, 90, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 3, 91, 944, 8, 91, 1, 92, 1,
		92, 3, 92, 948, 8, 92, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 3, 93,
		956, 8, 93, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1,
		94, 5, 94, 967, 8, 94, 10, 94, 12, 94, 970, 9, 94, 1, 94, 1, 94, 3, 94,
		974, 8, 94, 1, 94, 1, 94, 1, 94, 3, 94, 979, 8, 94, 1, 95, 1, 95, 1, 95,
		1, 96, 1, 96, 1, 96, 3, 96, 987, 8, 96, 1, 96, 1, 96, 1, 96, 1, 96, 5,
		96, 993, 8, 96, 10, 96, 12, 96, 996, 9, 96, 1, 96, 1, 96, 1, 96, 1, 96,
		1, 96, 1, 96, 5, 96, 1004, 8, 96, 10, 96, 12, 96, 1007, 9, 96, 1, 96, 1,
		96, 1, 96, 1, 96, 1, 96, 5, 96, 1014, 8, 96, 10, 96, 12, 96, 1017, 9, 96,
		1, 97, 1, 97, 1, 97, 1, 97, 3, 97, 1023, 8, 97, 1, 98, 1, 98, 1, 99, 1,
		99, 1, 99, 1, 99, 3, 99, 1031, 8, 99, 1, 100, 1, 100, 1, 101, 1, 101, 1,
		101, 1, 101, 3, 101, 1039, 8, 101, 1, 102, 1, 102, 1, 103, 3, 103, 1044,
		8, 103, 1, 103, 1, 103, 1, 104, 1, 104, 1, 104, 1, 104, 3, 104, 1052, 8,
		104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1,
		104, 1, 104, 1, 104, 3, 104, 1065, 8, 104, 1, 104, 1, 104, 1, 104, 1, 104,
		1, 104, 5, 104, 1072, 8, 104, 10, 104, 12, 104, 1075, 9, 104, 1, 104, 1,
		104, 5, 104, 1079, 8, 104, 10, 104, 12, 104, 1082, 9, 104, 1, 105, 1, 105,
		1, 105, 1, 105, 3, 105, 1088, 8, 105, 1, 106, 1, 106, 3, 106, 1092, 8,
		106, 1, 106, 1, 106, 1, 106, 1, 106, 3, 106, 1098, 8, 106, 1, 106, 1, 106,
		1, 106, 1, 106, 3, 106, 1104, 8, 106, 1, 107, 1, 107, 1, 107, 5, 107, 1109,
		8, 107, 10, 107, 12, 107, 1112, 9, 107, 1, 108, 1, 108, 1, 108, 1, 108,
		1, 108, 1, 108, 1, 108, 1, 108, 3, 108, 1122, 8, 108, 1, 109, 1, 109, 1,
		109, 5, 109, 1127, 8, 109, 10, 109, 12, 109, 1130, 9, 109, 1, 109, 3, 109,
		1133, 8, 109, 1, 110, 1, 110, 1, 110, 3, 110, 1138, 8, 110, 1, 111, 1,
		111, 1, 111, 1, 111, 1, 111, 3, 111, 1145, 8, 111, 1, 111, 1, 111, 1, 111,
		1, 111, 1, 111, 3, 111, 1152, 8, 111, 3, 111, 1154, 8, 111, 1, 112, 1,
		112, 5, 112, 1158, 8, 112, 10, 112, 12, 112, 1161, 9, 112, 1, 113, 1, 113,
		1, 113, 1, 114, 1, 114, 1, 114, 1, 115, 1, 115, 1, 115, 3, 115, 1172, 8,
		115, 1, 115, 1, 115, 1, 115, 1, 115, 3, 115, 1178, 8, 115, 1, 116, 1, 116,
		1, 117, 1, 117, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 3, 118,
		1190, 8, 118, 1, 119, 1, 119, 1, 119, 1, 119, 1, 120, 1, 120, 1, 120, 5,
		120, 1199, 8, 120, 10, 120, 12, 120, 1202, 9, 120, 1, 121, 1, 121, 3, 121,
		1206, 8, 121, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 3, 122, 1214,
		8, 122, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 5, 123, 1222, 8,
		123, 10, 123, 12, 123, 1225, 9, 123, 1, 123, 1, 123, 1, 123, 3, 123, 1230,
		8, 123, 1, 123, 3, 123, 1233, 8, 123, 1, 123, 1, 123, 1, 124, 1, 124, 1,
		124, 1, 124, 1, 125, 1, 125, 1, 125, 3, 125, 1244, 8, 125, 1, 126, 1, 126,
		1, 126, 1, 126, 1, 126, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 128,
		1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 129, 1, 129, 1, 129,
		1, 129, 1, 130, 1, 130, 1, 131, 1, 131, 1, 132, 1, 132, 1, 132, 1, 132,
		1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 3, 132, 1281, 8, 132, 1,
		133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 134, 1, 134, 1, 134, 1,
		134, 1, 134, 1, 134, 1, 135, 1, 135, 1, 135, 5, 135, 1298, 8, 135, 10,
		135, 12, 135, 1301, 9, 135, 1, 135, 0, 1, 208, 136, 0, 2, 4, 6, 8, 10,
		12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46,
		48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82,
		84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114,
		116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144,
		146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174,
		176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204,
		206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234,
		236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264,
		266, 268, 270, 0, 11, 3, 0, 83, 84, 86, 86, 109, 109, 1, 0, 41, 42, 1,
		0, 72, 73, 2, 0, 28, 28, 100, 101, 5, 0, 4, 4, 6, 6, 20, 20, 30, 30, 70,
		70, 1, 0, 95, 99, 2, 0, 8, 8, 38, 38, 2, 0, 19, 19, 49, 54, 2, 0, 26, 26,
		41, 42, 4, 0, 1, 1, 9, 9, 22, 22, 43, 44, 2, 0, 11, 11, 35, 35, 1349, 0,
		274, 1, 0, 0, 0, 2, 276, 1, 0, 0, 0, 4, 295, 1, 0, 0, 0, 6, 312, 1, 0,
		0, 0, 8, 318, 1, 0, 0, 0, 10, 324, 1, 0, 0, 0, 12, 327, 1, 0, 0, 0, 14,
		330, 1, 0, 0, 0, 16, 340, 1, 0, 0, 0, 18, 355, 1, 0, 0, 0, 20, 364, 1,
		0, 0, 0, 22, 367, 1, 0, 0, 0, 24, 371, 1, 0, 0, 0, 26, 382, 1, 0, 0, 0,
		28, 384, 1, 0, 0, 0, 30, 392, 1, 0, 0, 0, 32, 396, 1, 0, 0, 0, 34, 422,
		1, 0, 0, 0, 36, 424, 1, 0, 0, 0, 38, 437, 1, 0, 0, 0, 40, 439, 1, 0, 0,
		0, 42, 441, 1, 0, 0, 0, 44, 443, 1, 0, 0, 0, 46, 445, 1, 0, 0, 0, 48, 447,
		1, 0, 0, 0, 50, 449, 1, 0, 0, 0, 52, 455, 1, 0, 0, 0, 54, 460, 1, 0, 0,
		0, 56, 468, 1, 0, 0, 0, 58, 476, 1, 0, 0, 0, 60, 485, 1, 0, 0, 0, 62, 492,
		1, 0, 0, 0, 64, 494, 1, 0, 0, 0, 66, 512, 1, 0, 0, 0, 68, 521, 1, 0, 0,
		0, 70, 523, 1, 0, 0, 0, 72, 530, 1, 0, 0, 0, 74, 537, 1, 0, 0, 0, 76, 544,
		1, 0, 0, 0, 78, 551, 1, 0, 0, 0, 80, 558, 1, 0, 0, 0, 82, 568, 1, 0, 0,
		0, 84, 602, 1, 0, 0, 0, 86, 628, 1, 0, 0, 0, 88, 630, 1, 0, 0, 0, 90, 633,
		1, 0, 0, 0, 92, 636, 1, 0, 0, 0, 94, 639, 1, 0, 0, 0, 96, 642, 1, 0, 0,
		0, 98, 646, 1, 0, 0, 0, 100, 662, 1, 0, 0, 0, 102, 671, 1, 0, 0, 0, 104,
		677, 1, 0, 0, 0, 106, 679, 1, 0, 0, 0, 108, 683, 1, 0, 0, 0, 110, 695,
		1, 0, 0, 0, 112, 701, 1, 0, 0, 0, 114, 706, 1, 0, 0, 0, 116, 708, 1, 0,
		0, 0, 118, 736, 1, 0, 0, 0, 120, 738, 1, 0, 0, 0, 122, 746, 1, 0, 0, 0,
		124, 748, 1, 0, 0, 0, 126, 750, 1, 0, 0, 0, 128, 762, 1, 0, 0, 0, 130,
		764, 1, 0, 0, 0, 132, 775, 1, 0, 0, 0, 134, 779, 1, 0, 0, 0, 136, 795,
		1, 0, 0, 0, 138, 797, 1, 0, 0, 0, 140, 803, 1, 0, 0, 0, 142, 807, 1, 0,
		0, 0, 144, 813, 1, 0, 0, 0, 146, 815, 1, 0, 0, 0, 148, 818, 1, 0, 0, 0,
		150, 829, 1, 0, 0, 0, 152, 833, 1, 0, 0, 0, 154, 844, 1, 0, 0, 0, 156,
		859, 1, 0, 0, 0, 158, 865, 1, 0, 0, 0, 160, 870, 1, 0, 0, 0, 162, 872,
		1, 0, 0, 0, 164, 876, 1, 0, 0, 0, 166, 880, 1, 0, 0, 0, 168, 882, 1, 0,
		0, 0, 170, 885, 1, 0, 0, 0, 172, 907, 1, 0, 0, 0, 174, 917, 1, 0, 0, 0,
		176, 919, 1, 0, 0, 0, 178, 927, 1, 0, 0, 0, 180, 935, 1, 0, 0, 0, 182,
		943, 1, 0, 0, 0, 184, 947, 1, 0, 0, 0, 186, 955, 1, 0, 0, 0, 188, 978,
		1, 0, 0, 0, 190, 980, 1, 0, 0, 0, 192, 986, 1, 0, 0, 0, 194, 1018, 1, 0,
		0, 0, 196, 1024, 1, 0, 0, 0, 198, 1026, 1, 0, 0, 0, 200, 1032, 1, 0, 0,
		0, 202, 1034, 1, 0, 0, 0, 204, 1040, 1, 0, 0, 0, 206, 1043, 1, 0, 0, 0,
		208, 1064, 1, 0, 0, 0, 210, 1087, 1, 0, 0, 0, 212, 1091, 1, 0, 0, 0, 214,
		1105, 1, 0, 0, 0, 216, 1121, 1, 0, 0, 0, 218, 1132, 1, 0, 0, 0, 220, 1134,
		1, 0, 0, 0, 222, 1153, 1, 0, 0, 0, 224, 1155, 1, 0, 0, 0, 226, 1162, 1,
		0, 0, 0, 228, 1165, 1, 0, 0, 0, 230, 1168, 1, 0, 0, 0, 232, 1179, 1, 0,
		0, 0, 234, 1181, 1, 0, 0, 0, 236, 1189, 1, 0, 0, 0, 238, 1191, 1, 0, 0,
		0, 240, 1195, 1, 0, 0, 0, 242, 1205, 1, 0, 0, 0, 244, 1207, 1, 0, 0, 0,
		246, 1215, 1, 0, 0, 0, 248, 1236, 1, 0, 0, 0, 250, 1243, 1, 0, 0, 0, 252,
		1245, 1, 0, 0, 0, 254, 1250, 1, 0, 0, 0, 256, 1255, 1, 0, 0, 0, 258, 1262,
		1, 0, 0, 0, 260, 1266, 1, 0, 0, 0, 262, 1268, 1, 0, 0, 0, 264, 1280, 1,
		0, 0, 0, 266, 1282, 1, 0, 0, 0, 268, 1288, 1, 0, 0, 0, 270, 1294, 1, 0,
		0, 0, 272, 275, 3, 2, 1, 0, 273, 275, 3, 4, 2, 0, 274, 272, 1, 0, 0, 0,
		274, 273, 1, 0, 0, 0, 275, 1, 1, 0, 0, 0, 276, 277, 5, 29, 0, 0, 277, 282,
		3, 14, 7, 0, 278, 279, 5, 55, 0, 0, 279, 280, 3, 176, 88, 0, 280, 281,
		5, 56, 0, 0, 281, 283, 1, 0, 0, 0, 282, 278, 1, 0, 0, 0, 282, 283, 1, 0,
		0, 0, 283, 284, 1, 0, 0, 0, 284, 286, 5, 47, 0, 0, 285, 287, 3, 22, 11,
		0, 286, 285, 1, 0, 0, 0, 286, 287, 1, 0, 0, 0, 287, 288, 1, 0, 0, 0, 288,
		289, 3, 18, 9, 0, 289, 290, 5, 3, 0, 0, 290, 291, 3, 240, 120, 0, 291,
		292, 5, 13, 0, 0, 292, 293, 5, 63, 0, 0, 293, 294, 5, 0, 0, 1, 294, 3,
		1, 0, 0, 0, 295, 296, 5, 67, 0, 0, 296, 297, 3, 14, 7, 0, 297, 298, 5,
		47, 0, 0, 298, 300, 3, 6, 3, 0, 299, 301, 3, 8, 4, 0, 300, 299, 1, 0, 0,
		0, 300, 301, 1, 0, 0, 0, 301, 303, 1, 0, 0, 0, 302, 304, 3, 10, 5, 0, 303,
		302, 1, 0, 0, 0, 303, 304, 1, 0, 0, 0, 304, 306, 1, 0, 0, 0, 305, 307,
		3, 12, 6, 0, 306, 305, 1, 0, 0, 0, 306, 307, 1, 0, 0, 0, 307, 308, 1, 0,
		0, 0, 308, 309, 5, 13, 0, 0, 309, 310, 5, 63, 0, 0, 310, 311, 5, 0, 0,
		1, 311, 5, 1, 0, 0, 0, 312, 314, 5, 68, 0, 0, 313, 315, 3, 22, 11, 0, 314,
		313, 1, 0, 0, 0, 314, 315, 1, 0, 0, 0, 315, 316, 1, 0, 0, 0, 316, 317,
		3, 16, 8, 0, 317, 7, 1, 0, 0, 0, 318, 320, 5, 71, 0, 0, 319, 321, 3, 22,
		11, 0, 320, 319, 1, 0, 0, 0, 320, 321, 1, 0, 0, 0, 321, 322, 1, 0, 0, 0,
		322, 323, 3, 18, 9, 0, 323, 9, 1, 0, 0, 0, 324, 325, 5, 91, 0, 0, 325,
		326, 3, 240, 120, 0, 326, 11, 1, 0, 0, 0, 327, 328, 5, 92, 0, 0, 328, 329,
		3, 240, 120, 0, 329, 13, 1, 0, 0, 0, 330, 331, 7, 0, 0, 0, 331, 15, 1,
		0, 0, 0, 332, 339, 3, 24, 12, 0, 333, 339, 3, 28, 14, 0, 334, 339, 3, 50,
		25, 0, 335, 339, 3, 54, 27, 0, 336, 339, 3, 148, 74, 0, 337, 339, 3, 156,
		78, 0, 338, 332, 1, 0, 0, 0, 338, 333, 1, 0, 0, 0, 338, 334, 1, 0, 0, 0,
		338, 335, 1, 0, 0, 0, 338, 336, 1, 0, 0, 0, 338, 337, 1, 0, 0, 0, 339,
		342, 1, 0, 0, 0, 340, 338, 1, 0, 0, 0, 340, 341, 1, 0, 0, 0, 341, 17, 1,
		0, 0, 0, 342, 340, 1, 0, 0, 0, 343, 354, 3, 24, 12, 0, 344, 354, 3, 28,
		14, 0, 345, 354, 3, 50, 25, 0, 346, 354, 3, 54, 27, 0, 347, 354, 3, 148,
		74, 0, 348, 354, 3, 160, 80, 0, 349, 350, 3, 156, 78, 0, 350, 351, 5, 103,
		0, 0, 351, 352, 5, 47, 0, 0, 352, 354, 1, 0, 0, 0, 353, 343, 1, 0, 0, 0,
		353, 344, 1, 0, 0, 0, 353, 345, 1, 0, 0, 0, 353, 346, 1, 0, 0, 0, 353,
		347, 1, 0, 0, 0, 353, 348, 1, 0, 0, 0, 353, 349, 1, 0, 0, 0, 354, 357,
		1, 0, 0, 0, 355, 353, 1, 0, 0, 0, 355, 356, 1, 0, 0, 0, 356, 19, 1, 0,
		0, 0, 357, 355, 1, 0, 0, 0, 358, 363, 3, 24, 12, 0, 359, 363, 3, 28, 14,
		0, 360, 363, 3, 148, 74, 0, 361, 363, 3, 160, 80, 0, 362, 358, 1, 0, 0,
		0, 362, 359, 1, 0, 0, 0, 362, 360, 1, 0, 0, 0, 362, 361, 1, 0, 0, 0, 363,
		366, 1, 0, 0, 0, 364, 362, 1, 0, 0, 0, 364, 365, 1, 0, 0, 0, 365, 21, 1,
		0, 0, 0, 366, 364, 1, 0, 0, 0, 367, 368, 5, 69, 0, 0, 368, 369, 3, 176,
		88, 0, 369, 370, 5, 47, 0, 0, 370, 23, 1, 0, 0, 0, 371, 372, 5, 21, 0,
		0, 372, 377, 3, 26, 13, 0, 373, 374, 5, 46, 0, 0, 374, 376, 3, 26, 13,
		0, 375, 373, 1, 0, 0, 0, 376, 379, 1, 0, 0, 0, 377, 375, 1, 0, 0, 0, 377,
		378, 1, 0, 0, 0, 378, 380, 1, 0, 0, 0, 379, 377, 1, 0, 0, 0, 380, 381,
		5, 47, 0, 0, 381, 25, 1, 0, 0, 0, 382, 383, 3, 40, 20, 0, 383, 27, 1, 0,
		0, 0, 384, 388, 5, 8, 0, 0, 385, 386, 3, 30, 15, 0, 386, 387, 5, 47, 0,
		0, 387, 389, 1, 0, 0, 0, 388, 385, 1, 0, 0, 0, 389, 390, 1, 0, 0, 0, 390,
		388, 1, 0, 0, 0, 390, 391, 1, 0, 0, 0, 391, 29, 1, 0, 0, 0, 392, 393, 3,
		14, 7, 0, 393, 394, 5, 49, 0, 0, 394, 395, 3, 34, 17, 0, 395, 31, 1, 0,
		0, 0, 396, 397, 5, 7, 0, 0, 397, 398, 5, 55, 0, 0, 398, 399, 3, 40, 20,
		0, 399, 400, 5, 56, 0, 0, 400, 33, 1, 0, 0, 0, 401, 423, 3, 38, 19, 0,
		402, 403, 3, 44, 22, 0, 403, 404, 3, 38, 19, 0, 404, 423, 1, 0, 0, 0, 405,
		423, 3, 14, 7, 0, 406, 407, 3, 44, 22, 0, 407, 408, 3, 14, 7, 0, 408, 423,
		1, 0, 0, 0, 409, 423, 3, 48, 24, 0, 410, 423, 3, 32, 16, 0, 411, 419, 3,
		36, 18, 0, 412, 415, 5, 41, 0, 0, 413, 416, 3, 36, 18, 0, 414, 416, 3,
		14, 7, 0, 415, 413, 1, 0, 0, 0, 415, 414, 1, 0, 0, 0, 416, 418, 1, 0, 0,
		0, 417, 412, 1, 0, 0, 0, 418, 421, 1, 0, 0, 0, 419, 417, 1, 0, 0, 0, 419,
		420, 1, 0, 0, 0, 420, 423, 1, 0, 0, 0, 421, 419, 1, 0, 0, 0, 422, 401,
		1, 0, 0, 0, 422, 402, 1, 0, 0, 0, 422, 405, 1, 0, 0, 0, 422, 406, 1, 0,
		0, 0, 422, 409, 1, 0, 0, 0, 422, 410, 1, 0, 0, 0, 422, 411, 1, 0, 0, 0,
		423, 35, 1, 0, 0, 0, 424, 425, 5, 57, 0, 0, 425, 430, 3, 34, 17, 0, 426,
		427, 5, 46, 0, 0, 427, 429, 3, 34, 17, 0, 428, 426, 1, 0, 0, 0, 429, 432,
		1, 0, 0, 0, 430, 428, 1, 0, 0, 0, 430, 431, 1, 0, 0, 0, 431, 433, 1, 0,
		0, 0, 432, 430, 1, 0, 0, 0, 433, 434, 5, 59, 0, 0, 434, 37, 1, 0, 0, 0,
		435, 438, 3, 40, 20, 0, 436, 438, 3, 42, 21, 0, 437, 435, 1, 0, 0, 0, 437,
		436, 1, 0, 0, 0, 438, 39, 1, 0, 0, 0, 439, 440, 5, 111, 0, 0, 440, 41,
		1, 0, 0, 0, 441, 442, 5, 112, 0, 0, 442, 43, 1, 0, 0, 0, 443, 444, 7, 1,
		0, 0, 444, 45, 1, 0, 0, 0, 445, 446, 7, 2, 0, 0, 446, 47, 1, 0, 0, 0, 447,
		448, 5, 110, 0, 0, 448, 49, 1, 0, 0, 0, 449, 451, 5, 102, 0, 0, 450, 452,
		3, 52, 26, 0, 451, 450, 1, 0, 0, 0, 452, 453, 1, 0, 0, 0, 453, 451, 1,
		0, 0, 0, 453, 454, 1, 0, 0, 0, 454, 51, 1, 0, 0, 0, 455, 456, 3, 14, 7,
		0, 456, 457, 5, 49, 0, 0, 457, 458, 3, 48, 24, 0, 458, 459, 5, 47, 0, 0,
		459, 53, 1, 0, 0, 0, 460, 464, 5, 36, 0, 0, 461, 462, 3, 56, 28, 0, 462,
		463, 5, 47, 0, 0, 463, 465, 1, 0, 0, 0, 464, 461, 1, 0, 0, 0, 465, 466,
		1, 0, 0, 0, 466, 464, 1, 0, 0, 0, 466, 467, 1, 0, 0, 0, 467, 55, 1, 0,
		0, 0, 468, 469, 3, 14, 7, 0, 469, 474, 5, 49, 0, 0, 470, 475, 3, 102, 51,
		0, 471, 475, 3, 58, 29, 0, 472, 475, 3, 60, 30, 0, 473, 475, 3, 62, 31,
		0, 474, 470, 1, 0, 0, 0, 474, 471, 1, 0, 0, 0, 474, 472, 1, 0, 0, 0, 474,
		473, 1, 0, 0, 0, 475, 57, 1, 0, 0, 0, 476, 478, 5, 16, 0, 0, 477, 479,
		3, 170, 85, 0, 478, 477, 1, 0, 0, 0, 478, 479, 1, 0, 0, 0, 479, 480, 1,
		0, 0, 0, 480, 481, 5, 48, 0, 0, 481, 483, 3, 166, 83, 0, 482, 484, 5, 93,
		0, 0, 483, 482, 1, 0, 0, 0, 483, 484, 1, 0, 0, 0, 484, 59, 1, 0, 0, 0,
		485, 487, 5, 28, 0, 0, 486, 488, 3, 170, 85, 0, 487, 486, 1, 0, 0, 0, 487,
		488, 1, 0, 0, 0, 488, 490, 1, 0, 0, 0, 489, 491, 5, 93, 0, 0, 490, 489,
		1, 0, 0, 0, 490, 491, 1, 0, 0, 0, 491, 61, 1, 0, 0, 0, 492, 493, 5, 74,
		0, 0, 493, 63, 1, 0, 0, 0, 494, 495, 5, 74, 0, 0, 495, 496, 5, 55, 0, 0,
		496, 497, 3, 14, 7, 0, 497, 498, 3, 66, 33, 0, 498, 499, 5, 56, 0, 0, 499,
		503, 3, 82, 41, 0, 500, 502, 3, 68, 34, 0, 501, 500, 1, 0, 0, 0, 502, 505,
		1, 0, 0, 0, 503, 501, 1, 0, 0, 0, 503, 504, 1, 0, 0, 0, 504, 506, 1, 0,
		0, 0, 505, 503, 1, 0, 0, 0, 506, 507, 5, 13, 0, 0, 507, 65, 1, 0, 0, 0,
		508, 509, 5, 46, 0, 0, 509, 511, 3, 110, 55, 0, 510, 508, 1, 0, 0, 0, 511,
		514, 1, 0, 0, 0, 512, 510, 1, 0, 0, 0, 512, 513, 1, 0, 0, 0, 513, 67, 1,
		0, 0, 0, 514, 512, 1, 0, 0, 0, 515, 522, 3, 70, 35, 0, 516, 522, 3, 72,
		36, 0, 517, 522, 3, 74, 37, 0, 518, 522, 3, 76, 38, 0, 519, 522, 3, 78,
		39, 0, 520, 522, 3, 80, 40, 0, 521, 515, 1, 0, 0, 0, 521, 516, 1, 0, 0,
		0, 521, 517, 1, 0, 0, 0, 521, 518, 1, 0, 0, 0, 521, 519, 1, 0, 0, 0, 521,
		520, 1, 0, 0, 0, 522, 69, 1, 0, 0, 0, 523, 527, 5, 75, 0, 0, 524, 526,
		3, 84, 42, 0, 525, 524, 1, 0, 0, 0, 526, 529, 1, 0, 0, 0, 527, 525, 1,
		0, 0, 0, 527, 528, 1, 0, 0, 0, 528, 71, 1, 0, 0, 0, 529, 527, 1, 0, 0,
		0, 530, 534, 5, 79, 0, 0, 531, 533, 3, 84, 42, 0, 532, 531, 1, 0, 0, 0,
		533, 536, 1, 0, 0, 0, 534, 532, 1, 0, 0, 0, 534, 535, 1, 0, 0, 0, 535,
		73, 1, 0, 0, 0, 536, 534, 1, 0, 0, 0, 537, 541, 5, 76, 0, 0, 538, 540,
		3, 84, 42, 0, 539, 538, 1, 0, 0, 0, 540, 543, 1, 0, 0, 0, 541, 539, 1,
		0, 0, 0, 541, 542, 1, 0, 0, 0, 542, 75, 1, 0, 0, 0, 543, 541, 1, 0, 0,
		0, 544, 548, 5, 80, 0, 0, 545, 547, 3, 84, 42, 0, 546, 545, 1, 0, 0, 0,
		547, 550, 1, 0, 0, 0, 548, 546, 1, 0, 0, 0, 548, 549, 1, 0, 0, 0, 549,
		77, 1, 0, 0, 0, 550, 548, 1, 0, 0, 0, 551, 555, 5, 77, 0, 0, 552, 554,
		3, 84, 42, 0, 553, 552, 1, 0, 0, 0, 554, 557, 1, 0, 0, 0, 555, 553, 1,
		0, 0, 0, 555, 556, 1, 0, 0, 0, 556, 79, 1, 0, 0, 0, 557, 555, 1, 0, 0,
		0, 558, 562, 5, 78, 0, 0, 559, 561, 3, 84, 42, 0, 560, 559, 1, 0, 0, 0,
		561, 564, 1, 0, 0, 0, 562, 560, 1, 0, 0, 0, 562, 563, 1, 0, 0, 0, 563,
		81, 1, 0, 0, 0, 564, 562, 1, 0, 0, 0, 565, 567, 3, 84, 42, 0, 566, 565,
		1, 0, 0, 0, 567, 570, 1, 0, 0, 0, 568, 566, 1, 0, 0, 0, 568, 569, 1, 0,
		0, 0, 569, 83, 1, 0, 0, 0, 570, 568, 1, 0, 0, 0, 571, 572, 3, 176, 88,
		0, 572, 573, 5, 48, 0, 0, 573, 574, 3, 110, 55, 0, 574, 575, 5, 47, 0,
		0, 575, 603, 1, 0, 0, 0, 576, 603, 3, 54, 27, 0, 577, 603, 3, 28, 14, 0,
		578, 579, 5, 16, 0, 0, 579, 581, 3, 14, 7, 0, 580, 582, 3, 170, 85, 0,
		581, 580, 1, 0, 0, 0, 581, 582, 1, 0, 0, 0, 582, 583, 1, 0, 0, 0, 583,
		584, 5, 48, 0, 0, 584, 585, 3, 166, 83, 0, 585, 586, 5, 47, 0, 0, 586,
		587, 3, 158, 79, 0, 587, 603, 1, 0, 0, 0, 588, 589, 7, 3, 0, 0, 589, 591,
		3, 14, 7, 0, 590, 592, 3, 170, 85, 0, 591, 590, 1, 0, 0, 0, 591, 592, 1,
		0, 0, 0, 592, 593, 1, 0, 0, 0, 593, 594, 5, 47, 0, 0, 594, 595, 3, 158,
		79, 0, 595, 603, 1, 0, 0, 0, 596, 597, 3, 86, 43, 0, 597, 600, 5, 47, 0,
		0, 598, 599, 5, 85, 0, 0, 599, 601, 5, 47, 0, 0, 600, 598, 1, 0, 0, 0,
		600, 601, 1, 0, 0, 0, 601, 603, 1, 0, 0, 0, 602, 571, 1, 0, 0, 0, 602,
		576, 1, 0, 0, 0, 602, 577, 1, 0, 0, 0, 602, 578, 1, 0, 0, 0, 602, 588,
		1, 0, 0, 0, 602, 596, 1, 0, 0, 0, 603, 85, 1, 0, 0, 0, 604, 605, 5, 82,
		0, 0, 605, 607, 3, 14, 7, 0, 606, 608, 3, 96, 48, 0, 607, 606, 1, 0, 0,
		0, 607, 608, 1, 0, 0, 0, 608, 609, 1, 0, 0, 0, 609, 610, 5, 48, 0, 0, 610,
		612, 3, 110, 55, 0, 611, 613, 3, 88, 44, 0, 612, 611, 1, 0, 0, 0, 612,
		613, 1, 0, 0, 0, 613, 615, 1, 0, 0, 0, 614, 616, 3, 90, 45, 0, 615, 614,
		1, 0, 0, 0, 615, 616, 1, 0, 0, 0, 616, 618, 1, 0, 0, 0, 617, 619, 3, 92,
		46, 0, 618, 617, 1, 0, 0, 0, 618, 619, 1, 0, 0, 0, 619, 621, 1, 0, 0, 0,
		620, 622, 3, 94, 47, 0, 621, 620, 1, 0, 0, 0, 621, 622, 1, 0, 0, 0, 622,
		629, 1, 0, 0, 0, 623, 624, 5, 82, 0, 0, 624, 626, 3, 14, 7, 0, 625, 627,
		3, 92, 46, 0, 626, 625, 1, 0, 0, 0, 626, 627, 1, 0, 0, 0, 627, 629, 1,
		0, 0, 0, 628, 604, 1, 0, 0, 0, 628, 623, 1, 0, 0, 0, 629, 87, 1, 0, 0,
		0, 630, 631, 5, 83, 0, 0, 631, 632, 3, 14, 7, 0, 632, 89, 1, 0, 0, 0, 633,
		634, 5, 84, 0, 0, 634, 635, 3, 14, 7, 0, 635, 91, 1, 0, 0, 0, 636, 637,
		5, 85, 0, 0, 637, 638, 3, 194, 97, 0, 638, 93, 1, 0, 0, 0, 639, 640, 5,
		86, 0, 0, 640, 641, 3, 38, 19, 0, 641, 95, 1, 0, 0, 0, 642, 643, 5, 57,
		0, 0, 643, 644, 3, 98, 49, 0, 644, 645, 5, 59, 0, 0, 645, 97, 1, 0, 0,
		0, 646, 647, 3, 176, 88, 0, 647, 648, 5, 48, 0, 0, 648, 656, 3, 122, 61,
		0, 649, 650, 5, 47, 0, 0, 650, 651, 3, 176, 88, 0, 651, 652, 5, 48, 0,
		0, 652, 653, 3, 122, 61, 0, 653, 655, 1, 0, 0, 0, 654, 649, 1, 0, 0, 0,
		655, 658, 1, 0, 0, 0, 656, 654, 1, 0, 0, 0, 656, 657, 1, 0, 0, 0, 657,
		99, 1, 0, 0, 0, 658, 656, 1, 0, 0, 0, 659, 660, 3, 110, 55, 0, 660, 661,
		5, 63, 0, 0, 661, 663, 1, 0, 0, 0, 662, 659, 1, 0, 0, 0, 663, 664, 1, 0,
		0, 0, 664, 662, 1, 0, 0, 0, 664, 665, 1, 0, 0, 0, 665, 666, 1, 0, 0, 0,
		666, 667, 3, 14, 7, 0, 667, 101, 1, 0, 0, 0, 668, 672, 3, 104, 52, 0, 669,
		672, 3, 112, 56, 0, 670, 672, 3, 146, 73, 0, 671, 668, 1, 0, 0, 0, 671,
		669, 1, 0, 0, 0, 671, 670, 1, 0, 0, 0, 672, 103, 1, 0, 0, 0, 673, 678,
		3, 106, 53, 0, 674, 678, 3, 108, 54, 0, 675, 678, 3, 110, 55, 0, 676, 678,
		3, 116, 58, 0, 677, 673, 1, 0, 0, 0, 677, 674, 1, 0, 0, 0, 677, 675, 1,
		0, 0, 0, 677, 676, 1, 0, 0, 0, 678, 105, 1, 0, 0, 0, 679, 680, 5, 55, 0,
		0, 680, 681, 3, 176, 88, 0, 681, 682, 5, 56, 0, 0, 682, 107, 1, 0, 0, 0,
		683, 684, 3, 34, 17, 0, 684, 685, 5, 64, 0, 0, 685, 686, 3, 34, 17, 0,
		686, 109, 1, 0, 0, 0, 687, 696, 3, 14, 7, 0, 688, 696, 7, 4, 0, 0, 689,
		690, 3, 14, 7, 0, 690, 691, 5, 51, 0, 0, 691, 692, 3, 110, 55, 0, 692,
		693, 5, 54, 0, 0, 693, 696, 1, 0, 0, 0, 694, 696, 3, 118, 59, 0, 695, 687,
		1, 0, 0, 0, 695, 688, 1, 0, 0, 0, 695, 689, 1, 0, 0, 0, 695, 694, 1, 0,
		0, 0, 696, 111, 1, 0, 0, 0, 697, 698, 5, 27, 0, 0, 698, 702, 3, 114, 57,
		0, 699, 702, 3, 114, 57, 0, 700, 702, 3, 64, 32, 0, 701, 697, 1, 0, 0,
		0, 701, 699, 1, 0, 0, 0, 701, 700, 1, 0, 0, 0, 702, 113, 1, 0, 0, 0, 703,
		707, 3, 126, 63, 0, 704, 707, 3, 140, 70, 0, 705, 707, 3, 144, 72, 0, 706,
		703, 1, 0, 0, 0, 706, 704, 1, 0, 0, 0, 706, 705, 1, 0, 0, 0, 707, 115,
		1, 0, 0, 0, 708, 709, 5, 70, 0, 0, 709, 712, 5, 57, 0, 0, 710, 713, 3,
		14, 7, 0, 711, 713, 3, 38, 19, 0, 712, 710, 1, 0, 0, 0, 712, 711, 1, 0,
		0, 0, 713, 714, 1, 0, 0, 0, 714, 715, 5, 59, 0, 0, 715, 117, 1, 0, 0, 0,
		716, 717, 5, 2, 0, 0, 717, 718, 5, 57, 0, 0, 718, 719, 3, 120, 60, 0, 719,
		720, 5, 59, 0, 0, 720, 721, 5, 25, 0, 0, 721, 722, 3, 124, 62, 0, 722,
		737, 1, 0, 0, 0, 723, 724, 5, 2, 0, 0, 724, 725, 5, 58, 0, 0, 725, 726,
		3, 120, 60, 0, 726, 727, 5, 60, 0, 0, 727, 728, 5, 25, 0, 0, 728, 729,
		3, 124, 62, 0, 729, 737, 1, 0, 0, 0, 730, 731, 5, 2, 0, 0, 731, 732, 5,
		25, 0, 0, 732, 737, 5, 8, 0, 0, 733, 734, 5, 2, 0, 0, 734, 735, 5, 25,
		0, 0, 735, 737, 3, 124, 62, 0, 736, 716, 1, 0, 0, 0, 736, 723, 1, 0, 0,
		0, 736, 730, 1, 0, 0, 0, 736, 733, 1, 0, 0, 0, 737, 119, 1, 0, 0, 0, 738,
		743, 3, 122, 61, 0, 739, 740, 5, 46, 0, 0, 740, 742, 3, 122, 61, 0, 741,
		739, 1, 0, 0, 0, 742, 745, 1, 0, 0, 0, 743, 741, 1, 0, 0, 0, 743, 744,
		1, 0, 0, 0, 744, 121, 1, 0, 0, 0, 745, 743, 1, 0, 0, 0, 746, 747, 3, 104,
		52, 0, 747, 123, 1, 0, 0, 0, 748, 749, 3, 102, 51, 0, 749, 125, 1, 0, 0,
		0, 750, 752, 5, 31, 0, 0, 751, 753, 3, 128, 64, 0, 752, 751, 1, 0, 0, 0,
		752, 753, 1, 0, 0, 0, 753, 754, 1, 0, 0, 0, 754, 755, 5, 13, 0, 0, 755,
		127, 1, 0, 0, 0, 756, 759, 3, 130, 65, 0, 757, 758, 5, 47, 0, 0, 758, 760,
		3, 134, 67, 0, 759, 757, 1, 0, 0, 0, 759, 760, 1, 0, 0, 0, 760, 763, 1,
		0, 0, 0, 761, 763, 3, 134, 67, 0, 762, 756, 1, 0, 0, 0, 762, 761, 1, 0,
		0, 0, 763, 129, 1, 0, 0, 0, 764, 769, 3, 132, 66, 0, 765, 766, 5, 47, 0,
		0, 766, 768, 3, 132, 66, 0, 767, 765, 1, 0, 0, 0, 768, 771, 1, 0, 0, 0,
		769, 767, 1, 0, 0, 0, 769, 770, 1, 0, 0, 0, 770, 773, 1, 0, 0, 0, 771,
		769, 1, 0, 0, 0, 772, 774, 5, 47, 0, 0, 773, 772, 1, 0, 0, 0, 773, 774,
		1, 0, 0, 0, 774, 131, 1, 0, 0, 0, 775, 776, 3, 176, 88, 0, 776, 777, 5,
		48, 0, 0, 777, 778, 3, 102, 51, 0, 778, 133, 1, 0, 0, 0, 779, 780, 5, 5,
		0, 0, 780, 781, 3, 136, 68, 0, 781, 782, 5, 25, 0, 0, 782, 787, 3, 138,
		69, 0, 783, 784, 5, 47, 0, 0, 784, 786, 3, 138, 69, 0, 785, 783, 1, 0,
		0, 0, 786, 789, 1, 0, 0, 0, 787, 785, 1, 0, 0, 0, 787, 788, 1, 0, 0, 0,
		788, 135, 1, 0, 0, 0, 789, 787, 1, 0, 0, 0, 790, 791, 3, 14, 7, 0, 791,
		792, 5, 48, 0, 0, 792, 793, 3, 110, 55, 0, 793, 796, 1, 0, 0, 0, 794, 796,
		3, 110, 55, 0, 795, 790, 1, 0, 0, 0, 795, 794, 1, 0, 0, 0, 796, 137, 1,
		0, 0, 0, 797, 798, 3, 178, 89, 0, 798, 799, 5, 48, 0, 0, 799, 800, 5, 55,
		0, 0, 800, 801, 3, 128, 64, 0, 801, 802, 5, 56, 0, 0, 802, 139, 1, 0, 0,
		0, 803, 804, 5, 33, 0, 0, 804, 805, 5, 25, 0, 0, 805, 806, 3, 142, 71,
		0, 806, 141, 1, 0, 0, 0, 807, 808, 3, 104, 52, 0, 808, 143, 1, 0, 0, 0,
		809, 810, 5, 14, 0, 0, 810, 811, 5, 25, 0, 0, 811, 814, 3, 102, 51, 0,
		812, 814, 5, 14, 0, 0, 813, 809, 1, 0, 0, 0, 813, 812, 1, 0, 0, 0, 814,
		145, 1, 0, 0, 0, 815, 816, 5, 61, 0, 0, 816, 817, 3, 110, 55, 0, 817, 147,
		1, 0, 0, 0, 818, 819, 5, 38, 0, 0, 819, 824, 3, 150, 75, 0, 820, 821, 5,
		47, 0, 0, 821, 823, 3, 150, 75, 0, 822, 820, 1, 0, 0, 0, 823, 826, 1, 0,
		0, 0, 824, 822, 1, 0, 0, 0, 824, 825, 1, 0, 0, 0, 825, 827, 1, 0, 0, 0,
		826, 824, 1, 0, 0, 0, 827, 828, 5, 47, 0, 0, 828, 149, 1, 0, 0, 0, 829,
		830, 3, 176, 88, 0, 830, 831, 5, 48, 0, 0, 831, 832, 3, 102, 51, 0, 832,
		151, 1, 0, 0, 0, 833, 836, 7, 3, 0, 0, 834, 837, 3, 14, 7, 0, 835, 837,
		3, 100, 50, 0, 836, 834, 1, 0, 0, 0, 836, 835, 1, 0, 0, 0, 837, 839, 1,
		0, 0, 0, 838, 840, 3, 170, 85, 0, 839, 838, 1, 0, 0, 0, 839, 840, 1, 0,
		0, 0, 840, 841, 1, 0, 0, 0, 841, 842, 5, 47, 0, 0, 842, 843, 3, 158, 79,
		0, 843, 153, 1, 0, 0, 0, 844, 847, 5, 16, 0, 0, 845, 848, 3, 14, 7, 0,
		846, 848, 3, 100, 50, 0, 847, 845, 1, 0, 0, 0, 847, 846, 1, 0, 0, 0, 848,
		850, 1, 0, 0, 0, 849, 851, 3, 170, 85, 0, 850, 849, 1, 0, 0, 0, 850, 851,
		1, 0, 0, 0, 851, 852, 1, 0, 0, 0, 852, 853, 5, 48, 0, 0, 853, 854, 3, 166,
		83, 0, 854, 855, 5, 47, 0, 0, 855, 856, 3, 158, 79, 0, 856, 155, 1, 0,
		0, 0, 857, 860, 3, 152, 76, 0, 858, 860, 3, 154, 77, 0, 859, 857, 1, 0,
		0, 0, 859, 858, 1, 0, 0, 0, 860, 157, 1, 0, 0, 0, 861, 862, 7, 5, 0, 0,
		862, 864, 5, 47, 0, 0, 863, 861, 1, 0, 0, 0, 864, 867, 1, 0, 0, 0, 865,
		863, 1, 0, 0, 0, 865, 866, 1, 0, 0, 0, 866, 159, 1, 0, 0, 0, 867, 865,
		1, 0, 0, 0, 868, 871, 3, 162, 81, 0, 869, 871, 3, 164, 82, 0, 870, 868,
		1, 0, 0, 0, 870, 869, 1, 0, 0, 0, 871, 161, 1, 0, 0, 0, 872, 873, 3, 152,
		76, 0, 873, 874, 3, 168, 84, 0, 874, 875, 5, 47, 0, 0, 875, 163, 1, 0,
		0, 0, 876, 877, 3, 154, 77, 0, 877, 878, 3, 168, 84, 0, 878, 879, 5, 47,
		0, 0, 879, 165, 1, 0, 0, 0, 880, 881, 3, 110, 55, 0, 881, 167, 1, 0, 0,
		0, 882, 883, 3, 20, 10, 0, 883, 884, 3, 238, 119, 0, 884, 169, 1, 0, 0,
		0, 885, 886, 5, 55, 0, 0, 886, 891, 3, 172, 86, 0, 887, 888, 5, 47, 0,
		0, 888, 890, 3, 172, 86, 0, 889, 887, 1, 0, 0, 0, 890, 893, 1, 0, 0, 0,
		891, 889, 1, 0, 0, 0, 891, 892, 1, 0, 0, 0, 892, 894, 1, 0, 0, 0, 893,
		891, 1, 0, 0, 0, 894, 895, 5, 56, 0, 0, 895, 171, 1, 0, 0, 0, 896, 908,
		3, 174, 87, 0, 897, 898, 5, 38, 0, 0, 898, 908, 3, 174, 87, 0, 899, 900,
		5, 8, 0, 0, 900, 908, 3, 174, 87, 0, 901, 902, 5, 81, 0, 0, 902, 908, 3,
		174, 87, 0, 903, 904, 5, 16, 0, 0, 904, 908, 3, 174, 87, 0, 905, 906, 5,
		28, 0, 0, 906, 908, 3, 174, 87, 0, 907, 896, 1, 0, 0, 0, 907, 897, 1, 0,
		0, 0, 907, 899, 1, 0, 0, 0, 907, 901, 1, 0, 0, 0, 907, 903, 1, 0, 0, 0,
		907, 905, 1, 0, 0, 0, 908, 173, 1, 0, 0, 0, 909, 910, 3, 176, 88, 0, 910,
		911, 5, 48, 0, 0, 911, 913, 3, 110, 55, 0, 912, 914, 3, 180, 90, 0, 913,
		912, 1, 0, 0, 0, 913, 914, 1, 0, 0, 0, 914, 918, 1, 0, 0, 0, 915, 916,
		7, 6, 0, 0, 916, 918, 3, 176, 88, 0, 917, 909, 1, 0, 0, 0, 917, 915, 1,
		0, 0, 0, 918, 175, 1, 0, 0, 0, 919, 924, 3, 14, 7, 0, 920, 921, 5, 46,
		0, 0, 921, 923, 3, 14, 7, 0, 922, 920, 1, 0, 0, 0, 923, 926, 1, 0, 0, 0,
		924, 922, 1, 0, 0, 0, 924, 925, 1, 0, 0, 0, 925, 177, 1, 0, 0, 0, 926,
		924, 1, 0, 0, 0, 927, 932, 3, 34, 17, 0, 928, 929, 5, 46, 0, 0, 929, 931,
		3, 34, 17, 0, 930, 928, 1, 0, 0, 0, 931, 934, 1, 0, 0, 0, 932, 930, 1,
		0, 0, 0, 932, 933, 1, 0, 0, 0, 933, 179, 1, 0, 0, 0, 934, 932, 1, 0, 0,
		0, 935, 936, 5, 49, 0, 0, 936, 937, 3, 194, 97, 0, 937, 181, 1, 0, 0, 0,
		938, 939, 3, 26, 13, 0, 939, 940, 5, 48, 0, 0, 940, 941, 3, 184, 92, 0,
		941, 944, 1, 0, 0, 0, 942, 944, 3, 184, 92, 0, 943, 938, 1, 0, 0, 0, 943,
		942, 1, 0, 0, 0, 944, 183, 1, 0, 0, 0, 945, 948, 3, 186, 93, 0, 946, 948,
		3, 236, 118, 0, 947, 945, 1, 0, 0, 0, 947, 946, 1, 0, 0, 0, 948, 185, 1,
		0, 0, 0, 949, 956, 3, 188, 94, 0, 950, 956, 3, 222, 111, 0, 951, 956, 3,
		228, 114, 0, 952, 956, 3, 230, 115, 0, 953, 956, 3, 232, 116, 0, 954, 956,
		3, 190, 95, 0, 955, 949, 1, 0, 0, 0, 955, 950, 1, 0, 0, 0, 955, 951, 1,
		0, 0, 0, 955, 952, 1, 0, 0, 0, 955, 953, 1, 0, 0, 0, 955, 954, 1, 0, 0,
		0, 956, 187, 1, 0, 0, 0, 957, 958, 3, 192, 96, 0, 958, 959, 5, 45, 0, 0,
		959, 960, 3, 194, 97, 0, 960, 979, 1, 0, 0, 0, 961, 973, 3, 212, 106, 0,
		962, 963, 5, 57, 0, 0, 963, 968, 3, 194, 97, 0, 964, 965, 5, 46, 0, 0,
		965, 967, 3, 194, 97, 0, 966, 964, 1, 0, 0, 0, 967, 970, 1, 0, 0, 0, 968,
		966, 1, 0, 0, 0, 968, 969, 1, 0, 0, 0, 969, 971, 1, 0, 0, 0, 970, 968,
		1, 0, 0, 0, 971, 972, 5, 59, 0, 0, 972, 974, 1, 0, 0, 0, 973, 962, 1, 0,
		0, 0, 973, 974, 1, 0, 0, 0, 974, 975, 1, 0, 0, 0, 975, 976, 5, 45, 0, 0,
		976, 977, 3, 194, 97, 0, 977, 979, 1, 0, 0, 0, 978, 957, 1, 0, 0, 0, 978,
		961, 1, 0, 0, 0, 979, 189, 1, 0, 0, 0, 980, 981, 5, 104, 0, 0, 981, 982,
		3, 194, 97, 0, 982, 191, 1, 0, 0, 0, 983, 984, 5, 62, 0, 0, 984, 987, 3,
		14, 7, 0, 985, 987, 3, 14, 7, 0, 986, 983, 1, 0, 0, 0, 986, 985, 1, 0,
		0, 0, 987, 1015, 1, 0, 0, 0, 988, 989, 5, 57, 0, 0, 989, 994, 3, 194, 97,
		0, 990, 991, 5, 46, 0, 0, 991, 993, 3, 194, 97, 0, 992, 990, 1, 0, 0, 0,
		993, 996, 1, 0, 0, 0, 994, 992, 1, 0, 0, 0, 994, 995, 1, 0, 0, 0, 995,
		997, 1, 0, 0, 0, 996, 994, 1, 0, 0, 0, 997, 998, 5, 59, 0, 0, 998, 1014,
		1, 0, 0, 0, 999, 1000, 5, 58, 0, 0, 1000, 1005, 3, 194, 97, 0, 1001, 1002,
		5, 46, 0, 0, 1002, 1004, 3, 194, 97, 0, 1003, 1001, 1, 0, 0, 0, 1004, 1007,
		1, 0, 0, 0, 1005, 1003, 1, 0, 0, 0, 1005, 1006, 1, 0, 0, 0, 1006, 1008,
		1, 0, 0, 0, 1007, 1005, 1, 0, 0, 0, 1008, 1009, 5, 60, 0, 0, 1009, 1014,
		1, 0, 0, 0, 1010, 1011, 5, 63, 0, 0, 1011, 1014, 3, 14, 7, 0, 1012, 1014,
		5, 61, 0, 0, 1013, 988, 1, 0, 0, 0, 1013, 999, 1, 0, 0, 0, 1013, 1010,
		1, 0, 0, 0, 1013, 1012, 1, 0, 0, 0, 1014, 1017, 1, 0, 0, 0, 1015, 1013,
		1, 0, 0, 0, 1015, 1016, 1, 0, 0, 0, 1016, 193, 1, 0, 0, 0, 1017, 1015,
		1, 0, 0, 0, 1018, 1022, 3, 198, 99, 0, 1019, 1020, 3, 196, 98, 0, 1020,
		1021, 3, 194, 97, 0, 1021, 1023, 1, 0, 0, 0, 1022, 1019, 1, 0, 0, 0, 1022,
		1023, 1, 0, 0, 0, 1023, 195, 1, 0, 0, 0, 1024, 1025, 7, 7, 0, 0, 1025,
		197, 1, 0, 0, 0, 1026, 1030, 3, 202, 101, 0, 1027, 1028, 3, 200, 100, 0,
		1028, 1029, 3, 198, 99, 0, 1029, 1031, 1, 0, 0, 0, 1030, 1027, 1, 0, 0,
		0, 1030, 1031, 1, 0, 0, 0, 1031, 199, 1, 0, 0, 0, 1032, 1033, 7, 8, 0,
		0, 1033, 201, 1, 0, 0, 0, 1034, 1038, 3, 206, 103, 0, 1035, 1036, 3, 204,
		102, 0, 1036, 1037, 3, 202, 101, 0, 1037, 1039, 1, 0, 0, 0, 1038, 1035,
		1, 0, 0, 0, 1038, 1039, 1, 0, 0, 0, 1039, 203, 1, 0, 0, 0, 1040, 1041,
		7, 9, 0, 0, 1041, 205, 1, 0, 0, 0, 1042, 1044, 7, 1, 0, 0, 1043, 1042,
		1, 0, 0, 0, 1043, 1044, 1, 0, 0, 0, 1044, 1045, 1, 0, 0, 0, 1045, 1046,
		3, 208, 104, 0, 1046, 207, 1, 0, 0, 0, 1047, 1048, 6, 104, -1, 0, 1048,
		1051, 3, 192, 96, 0, 1049, 1050, 5, 87, 0, 0, 1050, 1052, 3, 14, 7, 0,
		1051, 1049, 1, 0, 0, 0, 1051, 1052, 1, 0, 0, 0, 1052, 1065, 1, 0, 0, 0,
		1053, 1054, 5, 55, 0, 0, 1054, 1055, 3, 194, 97, 0, 1055, 1056, 5, 56,
		0, 0, 1056, 1065, 1, 0, 0, 0, 1057, 1065, 3, 212, 106, 0, 1058, 1065, 3,
		210, 105, 0, 1059, 1065, 3, 216, 108, 0, 1060, 1061, 5, 24, 0, 0, 1061,
		1065, 3, 208, 104, 4, 1062, 1065, 3, 46, 23, 0, 1063, 1065, 3, 110, 55,
		0, 1064, 1047, 1, 0, 0, 0, 1064, 1053, 1, 0, 0, 0, 1064, 1057, 1, 0, 0,
		0, 1064, 1058, 1, 0, 0, 0, 1064, 1059, 1, 0, 0, 0, 1064, 1060, 1, 0, 0,
		0, 1064, 1062, 1, 0, 0, 0, 1064, 1063, 1, 0, 0, 0, 1065, 1080, 1, 0, 0,
		0, 1066, 1067, 10, 2, 0, 0, 1067, 1068, 5, 57, 0, 0, 1068, 1073, 3, 194,
		97, 0, 1069, 1070, 5, 46, 0, 0, 1070, 1072, 3, 194, 97, 0, 1071, 1069,
		1, 0, 0, 0, 1072, 1075, 1, 0, 0, 0, 1073, 1071, 1, 0, 0, 0, 1073, 1074,
		1, 0, 0, 0, 1074, 1076, 1, 0, 0, 0, 1075, 1073, 1, 0, 0, 0, 1076, 1077,
		5, 59, 0, 0, 1077, 1079, 1, 0, 0, 0, 1078, 1066, 1, 0, 0, 0, 1079, 1082,
		1, 0, 0, 0, 1080, 1078, 1, 0, 0, 0, 1080, 1081, 1, 0, 0, 0, 1081, 209,
		1, 0, 0, 0, 1082, 1080, 1, 0, 0, 0, 1083, 1088, 3, 38, 19, 0, 1084, 1088,
		3, 32, 16, 0, 1085, 1088, 3, 48, 24, 0, 1086, 1088, 5, 23, 0, 0, 1087,
		1083, 1, 0, 0, 0, 1087, 1084, 1, 0, 0, 0, 1087, 1085, 1, 0, 0, 0, 1087,
		1086, 1, 0, 0, 0, 1088, 211, 1, 0, 0, 0, 1089, 1092, 3, 14, 7, 0, 1090,
		1092, 3, 100, 50, 0, 1091, 1089, 1, 0, 0, 0, 1091, 1090, 1, 0, 0, 0, 1092,
		1097, 1, 0, 0, 0, 1093, 1094, 5, 51, 0, 0, 1094, 1095, 3, 110, 55, 0, 1095,
		1096, 5, 54, 0, 0, 1096, 1098, 1, 0, 0, 0, 1097, 1093, 1, 0, 0, 0, 1097,
		1098, 1, 0, 0, 0, 1098, 1103, 1, 0, 0, 0, 1099, 1100, 5, 55, 0, 0, 1100,
		1101, 3, 214, 107, 0, 1101, 1102, 5, 56, 0, 0, 1102, 1104, 1, 0, 0, 0,
		1103, 1099, 1, 0, 0, 0, 1103, 1104, 1, 0, 0, 0, 1104, 213, 1, 0, 0, 0,
		1105, 1110, 3, 224, 112, 0, 1106, 1107, 5, 46, 0, 0, 1107, 1109, 3, 224,
		112, 0, 1108, 1106, 1, 0, 0, 0, 1109, 1112, 1, 0, 0, 0, 1110, 1108, 1,
		0, 0, 0, 1110, 1111, 1, 0, 0, 0, 1111, 215, 1, 0, 0, 0, 1112, 1110, 1,
		0, 0, 0, 1113, 1114, 5, 57, 0, 0, 1114, 1115, 3, 218, 109, 0, 1115, 1116,
		5, 59, 0, 0, 1116, 1122, 1, 0, 0, 0, 1117, 1118, 5, 58, 0, 0, 1118, 1119,
		3, 218, 109, 0, 1119, 1120, 5, 60, 0, 0, 1120, 1122, 1, 0, 0, 0, 1121,
		1113, 1, 0, 0, 0, 1121, 1117, 1, 0, 0, 0, 1122, 217, 1, 0, 0, 0, 1123,
		1128, 3, 220, 110, 0, 1124, 1125, 5, 46, 0, 0, 1125, 1127, 3, 220, 110,
		0, 1126, 1124, 1, 0, 0, 0, 1127, 1130, 1, 0, 0, 0, 1128, 1126, 1, 0, 0,
		0, 1128, 1129, 1, 0, 0, 0, 1129, 1133, 1, 0, 0, 0, 1130, 1128, 1, 0, 0,
		0, 1131, 1133, 1, 0, 0, 0, 1132, 1123, 1, 0, 0, 0, 1132, 1131, 1, 0, 0,
		0, 1133, 219, 1, 0, 0, 0, 1134, 1137, 3, 194, 97, 0, 1135, 1136, 5, 64,
		0, 0, 1136, 1138, 3, 194, 97, 0, 1137, 1135, 1, 0, 0, 0, 1137, 1138, 1,
		0, 0, 0, 1138, 221, 1, 0, 0, 0, 1139, 1144, 3, 14, 7, 0, 1140, 1141, 5,
		55, 0, 0, 1141, 1142, 3, 214, 107, 0, 1142, 1143, 5, 56, 0, 0, 1143, 1145,
		1, 0, 0, 0, 1144, 1140, 1, 0, 0, 0, 1144, 1145, 1, 0, 0, 0, 1145, 1154,
		1, 0, 0, 0, 1146, 1151, 3, 100, 50, 0, 1147, 1148, 5, 55, 0, 0, 1148, 1149,
		3, 214, 107, 0, 1149, 1150, 5, 56, 0, 0, 1150, 1152, 1, 0, 0, 0, 1151,
		1147, 1, 0, 0, 0, 1151, 1152, 1, 0, 0, 0, 1152, 1154, 1, 0, 0, 0, 1153,
		1139, 1, 0, 0, 0, 1153, 1146, 1, 0, 0, 0, 1154, 223, 1, 0, 0, 0, 1155,
		1159, 3, 194, 97, 0, 1156, 1158, 3, 226, 113, 0, 1157, 1156, 1, 0, 0, 0,
		1158, 1161, 1, 0, 0, 0, 1159, 1157, 1, 0, 0, 0, 1159, 1160, 1, 0, 0, 0,
		1160, 225, 1, 0, 0, 0, 1161, 1159, 1, 0, 0, 0, 1162, 1163, 5, 48, 0, 0,
		1163, 1164, 3, 194, 97, 0, 1164, 227, 1, 0, 0, 0, 1165, 1166, 5, 17, 0,
		0, 1166, 1167, 3, 26, 13, 0, 1167, 229, 1, 0, 0, 0, 1168, 1171, 5, 94,
		0, 0, 1169, 1172, 3, 14, 7, 0, 1170, 1172, 3, 100, 50, 0, 1171, 1169, 1,
		0, 0, 0, 1171, 1170, 1, 0, 0, 0, 1172, 1177, 1, 0, 0, 0, 1173, 1174, 5,
		55, 0, 0, 1174, 1175, 3, 214, 107, 0, 1175, 1176, 5, 56, 0, 0, 1176, 1178,
		1, 0, 0, 0, 1177, 1173, 1, 0, 0, 0, 1177, 1178, 1, 0, 0, 0, 1178, 231,
		1, 0, 0, 0, 1179, 1180, 1, 0, 0, 0, 1180, 233, 1, 0, 0, 0, 1181, 1182,
		1, 0, 0, 0, 1182, 235, 1, 0, 0, 0, 1183, 1190, 3, 238, 119, 0, 1184, 1190,
		3, 242, 121, 0, 1185, 1190, 3, 250, 125, 0, 1186, 1190, 3, 264, 132, 0,
		1187, 1190, 3, 266, 133, 0, 1188, 1190, 3, 268, 134, 0, 1189, 1183, 1,
		0, 0, 0, 1189, 1184, 1, 0, 0, 0, 1189, 1185, 1, 0, 0, 0, 1189, 1186, 1,
		0, 0, 0, 1189, 1187, 1, 0, 0, 0, 1189, 1188, 1, 0, 0, 0, 1190, 237, 1,
		0, 0, 0, 1191, 1192, 5, 3, 0, 0, 1192, 1193, 3, 240, 120, 0, 1193, 1194,
		5, 13, 0, 0, 1194, 239, 1, 0, 0, 0, 1195, 1200, 3, 182, 91, 0, 1196, 1197,
		5, 47, 0, 0, 1197, 1199, 3, 182, 91, 0, 1198, 1196, 1, 0, 0, 0, 1199, 1202,
		1, 0, 0, 0, 1200, 1198, 1, 0, 0, 0, 1200, 1201, 1, 0, 0, 0, 1201, 241,
		1, 0, 0, 0, 1202, 1200, 1, 0, 0, 0, 1203, 1206, 3, 244, 122, 0, 1204, 1206,
		3, 246, 123, 0, 1205, 1203, 1, 0, 0, 0, 1205, 1204, 1, 0, 0, 0, 1206, 243,
		1, 0, 0, 0, 1207, 1208, 5, 18, 0, 0, 1208, 1209, 3, 194, 97, 0, 1209, 1210,
		5, 34, 0, 0, 1210, 1213, 3, 182, 91, 0, 1211, 1212, 5, 12, 0, 0, 1212,
		1214, 3, 182, 91, 0, 1213, 1211, 1, 0, 0, 0, 1213, 1214, 1, 0, 0, 0, 1214,
		245, 1, 0, 0, 0, 1215, 1216, 5, 5, 0, 0, 1216, 1217, 3, 194, 97, 0, 1217,
		1218, 5, 25, 0, 0, 1218, 1223, 3, 248, 124, 0, 1219, 1220, 5, 47, 0, 0,
		1220, 1222, 3, 248, 124, 0, 1221, 1219, 1, 0, 0, 0, 1222, 1225, 1, 0, 0,
		0, 1223, 1221, 1, 0, 0, 0, 1223, 1224, 1, 0, 0, 0, 1224, 1229, 1, 0, 0,
		0, 1225, 1223, 1, 0, 0, 0, 1226, 1227, 5, 47, 0, 0, 1227, 1228, 5, 12,
		0, 0, 1228, 1230, 3, 240, 120, 0, 1229, 1226, 1, 0, 0, 0, 1229, 1230, 1,
		0, 0, 0, 1230, 1232, 1, 0, 0, 0, 1231, 1233, 5, 47, 0, 0, 1232, 1231, 1,
		0, 0, 0, 1232, 1233, 1, 0, 0, 0, 1233, 1234, 1, 0, 0, 0, 1234, 1235, 5,
		13, 0, 0, 1235, 247, 1, 0, 0, 0, 1236, 1237, 3, 178, 89, 0, 1237, 1238,
		5, 48, 0, 0, 1238, 1239, 3, 182, 91, 0, 1239, 249, 1, 0, 0, 0, 1240, 1244,
		3, 252, 126, 0, 1241, 1244, 3, 254, 127, 0, 1242, 1244, 3, 256, 128, 0,
		1243, 1240, 1, 0, 0, 0, 1243, 1241, 1, 0, 0, 0, 1243, 1242, 1, 0, 0, 0,
		1244, 251, 1, 0, 0, 0, 1245, 1246, 5, 39, 0, 0, 1246, 1247, 3, 194, 97,
		0, 1247, 1248, 5, 10, 0, 0, 1248, 1249, 3, 182, 91, 0, 1249, 253, 1, 0,
		0, 0, 1250, 1251, 5, 32, 0, 0, 1251, 1252, 3, 240, 120, 0, 1252, 1253,
		5, 37, 0, 0, 1253, 1254, 3, 194, 97, 0, 1254, 255, 1, 0, 0, 0, 1255, 1256,
		5, 15, 0, 0, 1256, 1257, 3, 14, 7, 0, 1257, 1258, 5, 45, 0, 0, 1258, 1259,
		3, 258, 129, 0, 1259, 1260, 5, 10, 0, 0, 1260, 1261, 3, 182, 91, 0, 1261,
		257, 1, 0, 0, 0, 1262, 1263, 3, 260, 130, 0, 1263, 1264, 7, 10, 0, 0, 1264,
		1265, 3, 262, 131, 0, 1265, 259, 1, 0, 0, 0, 1266, 1267, 3, 194, 97, 0,
		1267, 261, 1, 0, 0, 0, 1268, 1269, 3, 194, 97, 0, 1269, 263, 1, 0, 0, 0,
		1270, 1271, 5, 40, 0, 0, 1271, 1272, 3, 270, 135, 0, 1272, 1273, 5, 10,
		0, 0, 1273, 1274, 3, 182, 91, 0, 1274, 1281, 1, 0, 0, 0, 1275, 1276, 5,
		40, 0, 0, 1276, 1277, 3, 194, 97, 0, 1277, 1278, 5, 10, 0, 0, 1278, 1279,
		3, 182, 91, 0, 1279, 1281, 1, 0, 0, 0, 1280, 1270, 1, 0, 0, 0, 1280, 1275,
		1, 0, 0, 0, 1281, 265, 1, 0, 0, 0, 1282, 1283, 5, 88, 0, 0, 1283, 1284,
		3, 240, 120, 0, 1284, 1285, 5, 90, 0, 0, 1285, 1286, 3, 240, 120, 0, 1286,
		1287, 5, 13, 0, 0, 1287, 267, 1, 0, 0, 0, 1288, 1289, 5, 88, 0, 0, 1289,
		1290, 3, 240, 120, 0, 1290, 1291, 5, 89, 0, 0, 1291, 1292, 3, 240, 120,
		0, 1292, 1293, 5, 13, 0, 0, 1293, 269, 1, 0, 0, 0, 1294, 1299, 3, 192,
		96, 0, 1295, 1296, 5, 46, 0, 0, 1296, 1298, 3, 192, 96, 0, 1297, 1295,
		1, 0, 0, 0, 1298, 1301, 1, 0, 0, 0, 1299, 1297, 1, 0, 0, 0, 1299, 1300,
		1, 0, 0, 0, 1300, 271, 1, 0, 0, 0, 1301, 1299, 1, 0, 0, 0, 125, 274, 282,
		286, 300, 303, 306, 314, 320, 338, 340, 353, 355, 362, 364, 377, 390, 415,
		419, 422, 430, 437, 453, 466, 474, 478, 483, 487, 490, 503, 512, 521, 527,
		534, 541, 548, 555, 562, 568, 581, 591, 600, 602, 607, 612, 615, 618, 621,
		626, 628, 656, 664, 671, 677, 695, 701, 706, 712, 736, 743, 752, 759, 762,
		769, 773, 787, 795, 813, 824, 836, 839, 847, 850, 859, 865, 870, 891, 907,
		913, 917, 924, 932, 943, 947, 955, 968, 973, 978, 986, 994, 1005, 1013,
		1015, 1022, 1030, 1038, 1043, 1051, 1064, 1073, 1080, 1087, 1091, 1097,
		1103, 1110, 1121, 1128, 1132, 1137, 1144, 1151, 1153, 1159, 1171, 1177,
		1189, 1200, 1205, 1213, 1223, 1229, 1232, 1243, 1280, 1299,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// pascalParserInit initializes any static state used to implement pascalParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewpascalParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func PascalParserInit() {
	staticData := &PascalParserStaticData
	staticData.once.Do(pascalParserInit)
}

// NewpascalParser produces a new parser instance for the optional input antlr.TokenStream.
func NewpascalParser(input antlr.TokenStream) *pascalParser {
	PascalParserInit()
	this := new(pascalParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &PascalParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "pascal.g4"

	return this
}

// pascalParser tokens.
const (
	pascalParserEOF             = antlr.TokenEOF
	pascalParserAND             = 1
	pascalParserARRAY           = 2
	pascalParserBEGIN           = 3
	pascalParserBOOLEAN         = 4
	pascalParserCASE            = 5
	pascalParserCHAR            = 6
	pascalParserCHR             = 7
	pascalParserCONST           = 8
	pascalParserDIV             = 9
	pascalParserDO              = 10
	pascalParserDOWNTO          = 11
	pascalParserELSE            = 12
	pascalParserEND             = 13
	pascalParserFILE            = 14
	pascalParserFOR             = 15
	pascalParserFUNCTION        = 16
	pascalParserGOTO            = 17
	pascalParserIF              = 18
	pascalParserIN              = 19
	pascalParserINTEGER         = 20
	pascalParserLABEL           = 21
	pascalParserMOD             = 22
	pascalParserNIL             = 23
	pascalParserNOT             = 24
	pascalParserOF              = 25
	pascalParserOR              = 26
	pascalParserPACKED          = 27
	pascalParserPROCEDURE       = 28
	pascalParserPROGRAM         = 29
	pascalParserREAL            = 30
	pascalParserRECORD          = 31
	pascalParserREPEAT          = 32
	pascalParserSET             = 33
	pascalParserTHEN            = 34
	pascalParserTO              = 35
	pascalParserTYPE            = 36
	pascalParserUNTIL           = 37
	pascalParserVAR             = 38
	pascalParserWHILE           = 39
	pascalParserWITH            = 40
	pascalParserPLUS            = 41
	pascalParserMINUS           = 42
	pascalParserSTAR            = 43
	pascalParserSLASH           = 44
	pascalParserASSIGN          = 45
	pascalParserCOMMA           = 46
	pascalParserSEMI            = 47
	pascalParserCOLON           = 48
	pascalParserEQUAL           = 49
	pascalParserNOT_EQUAL       = 50
	pascalParserLT              = 51
	pascalParserLE              = 52
	pascalParserGE              = 53
	pascalParserGT              = 54
	pascalParserLPAREN          = 55
	pascalParserRPAREN          = 56
	pascalParserLBRACK          = 57
	pascalParserLBRACK2         = 58
	pascalParserRBRACK          = 59
	pascalParserRBRACK2         = 60
	pascalParserPOINTER         = 61
	pascalParserAT              = 62
	pascalParserDOT             = 63
	pascalParserDOTDOT          = 64
	pascalParserLCURLY          = 65
	pascalParserRCURLY          = 66
	pascalParserUNIT            = 67
	pascalParserINTERFACE       = 68
	pascalParserUSES            = 69
	pascalParserSTRING          = 70
	pascalParserIMPLEMENTATION  = 71
	pascalParserTRUE            = 72
	pascalParserFALSE           = 73
	pascalParserCLASS           = 74
	pascalParserPRIVATE         = 75
	pascalParserPROTECTED       = 76
	pascalParserPUBLIC          = 77
	pascalParserPUBLISHED       = 78
	pascalParserSTRICTPRIVATE   = 79
	pascalParserSTRICTPROTECTED = 80
	pascalParserOUT             = 81
	pascalParserPROPERTY        = 82
	pascalParserREAD            = 83
	pascalParserWRITE           = 84
	pascalParserDEFAULT         = 85
	pascalParserINDEX           = 86
	pascalParserAS              = 87
	pascalParserTRY             = 88
	pascalParserFINALLY         = 89
	pascalParserEXCEPT          = 90
	pascalParserINITIALIZATION  = 91
	pascalParserFINALIZATION    = 92
	pascalParserOFOBJECT        = 93
	pascalParserINHERITED       = 94
	pascalParserABSTRACT        = 95
	pascalParserVIRTUAL         = 96
	pascalParserOVERRIDE        = 97
	pascalParserOVERLOAD        = 98
	pascalParserINLINE          = 99
	pascalParserCONSTRUCTOR     = 100
	pascalParserDESTRUCTOR      = 101
	pascalParserRESOURCESTRING  = 102
	pascalParserFORWARD         = 103
	pascalParserRAISE           = 104
	pascalParserWS              = 105
	pascalParserCOMMENT_1       = 106
	pascalParserCOMMENT_2       = 107
	pascalParserCOMMENT_3       = 108
	pascalParserIDENT           = 109
	pascalParserSTRING_LITERAL  = 110
	pascalParserNUM_INT         = 111
	pascalParserNUM_REAL        = 112
	pascalParserUTF8BOM         = 113
)

// pascalParser rules.
const (
	pascalParserRULE_source                             = 0
	pascalParserRULE_program                            = 1
	pascalParserRULE_unit                               = 2
	pascalParserRULE_interfaceSection                   = 3
	pascalParserRULE_implementationSection              = 4
	pascalParserRULE_initializationSection              = 5
	pascalParserRULE_finalizationSection                = 6
	pascalParserRULE_identifier                         = 7
	pascalParserRULE_interfaceBlock                     = 8
	pascalParserRULE_implementationBlock                = 9
	pascalParserRULE_block                              = 10
	pascalParserRULE_usesUnits                          = 11
	pascalParserRULE_labelDeclarationPart               = 12
	pascalParserRULE_label                              = 13
	pascalParserRULE_constantDefinitionPart             = 14
	pascalParserRULE_constantDefinition                 = 15
	pascalParserRULE_constantChr                        = 16
	pascalParserRULE_constant                           = 17
	pascalParserRULE_arrayConstant                      = 18
	pascalParserRULE_unsignedNumber                     = 19
	pascalParserRULE_unsignedInteger                    = 20
	pascalParserRULE_unsignedReal                       = 21
	pascalParserRULE_sign                               = 22
	pascalParserRULE_bool_                              = 23
	pascalParserRULE_string                             = 24
	pascalParserRULE_resourceDefinitionPart             = 25
	pascalParserRULE_resourceDefinition                 = 26
	pascalParserRULE_typeDefinitionPart                 = 27
	pascalParserRULE_typeDefinition                     = 28
	pascalParserRULE_functionType                       = 29
	pascalParserRULE_procedureType                      = 30
	pascalParserRULE_forwardClassType                   = 31
	pascalParserRULE_classType                          = 32
	pascalParserRULE_classImplementsInterfaces          = 33
	pascalParserRULE_classDeclaration                   = 34
	pascalParserRULE_classPrivateDeclaration            = 35
	pascalParserRULE_classStrictPrivateDeclaration      = 36
	pascalParserRULE_classProtectedDeclaration          = 37
	pascalParserRULE_classStrictProtectedDeclaration    = 38
	pascalParserRULE_classPublicDeclaration             = 39
	pascalParserRULE_classPublishedDeclaration          = 40
	pascalParserRULE_classImplicitPublishedDeclaration  = 41
	pascalParserRULE_classDeclarationPart               = 42
	pascalParserRULE_propertyDeclaration                = 43
	pascalParserRULE_propertyReadDeclaration            = 44
	pascalParserRULE_propertyWriteDeclaration           = 45
	pascalParserRULE_propertyDefaultValueDeclaration    = 46
	pascalParserRULE_propertyIndexDeclaration           = 47
	pascalParserRULE_propertyIndexParameters            = 48
	pascalParserRULE_propertyIndexParametersList        = 49
	pascalParserRULE_methodIdentifier                   = 50
	pascalParserRULE_type_                              = 51
	pascalParserRULE_simpleType                         = 52
	pascalParserRULE_scalarType                         = 53
	pascalParserRULE_subrangeType                       = 54
	pascalParserRULE_typeIdentifier                     = 55
	pascalParserRULE_structuredType                     = 56
	pascalParserRULE_unpackedStructuredType             = 57
	pascalParserRULE_stringtype                         = 58
	pascalParserRULE_arrayType                          = 59
	pascalParserRULE_typeList                           = 60
	pascalParserRULE_indexType                          = 61
	pascalParserRULE_componentType                      = 62
	pascalParserRULE_recordType                         = 63
	pascalParserRULE_fieldList                          = 64
	pascalParserRULE_fixedPart                          = 65
	pascalParserRULE_recordSection                      = 66
	pascalParserRULE_variantPart                        = 67
	pascalParserRULE_tag                                = 68
	pascalParserRULE_variant                            = 69
	pascalParserRULE_setType                            = 70
	pascalParserRULE_baseType                           = 71
	pascalParserRULE_fileType                           = 72
	pascalParserRULE_pointerType                        = 73
	pascalParserRULE_variableDeclarationPart            = 74
	pascalParserRULE_variableDeclaration                = 75
	pascalParserRULE_procedureHeader                    = 76
	pascalParserRULE_functionHeader                     = 77
	pascalParserRULE_procedureOrFunctionHeader          = 78
	pascalParserRULE_procedureOrFunctionHeaderModifiers = 79
	pascalParserRULE_procedureOrFunctionDeclaration     = 80
	pascalParserRULE_procedureDeclaration               = 81
	pascalParserRULE_functionDeclaration                = 82
	pascalParserRULE_resultType                         = 83
	pascalParserRULE_procedureOrFunctionBody            = 84
	pascalParserRULE_formalParameterList                = 85
	pascalParserRULE_formalParameterSection             = 86
	pascalParserRULE_parameterGroup                     = 87
	pascalParserRULE_identifierList                     = 88
	pascalParserRULE_constList                          = 89
	pascalParserRULE_defaultValue                       = 90
	pascalParserRULE_statement                          = 91
	pascalParserRULE_unlabelledStatement                = 92
	pascalParserRULE_simpleStatement                    = 93
	pascalParserRULE_assignmentStatement                = 94
	pascalParserRULE_raiseExceptionStatement            = 95
	pascalParserRULE_variable                           = 96
	pascalParserRULE_expression                         = 97
	pascalParserRULE_relationaloperator                 = 98
	pascalParserRULE_simpleExpression                   = 99
	pascalParserRULE_additiveoperator                   = 100
	pascalParserRULE_term                               = 101
	pascalParserRULE_multiplicativeoperator             = 102
	pascalParserRULE_signedFactor                       = 103
	pascalParserRULE_factor                             = 104
	pascalParserRULE_unsignedConstant                   = 105
	pascalParserRULE_functionDesignator                 = 106
	pascalParserRULE_parameterList                      = 107
	pascalParserRULE_set_                               = 108
	pascalParserRULE_elementList                        = 109
	pascalParserRULE_element                            = 110
	pascalParserRULE_procedureStatement                 = 111
	pascalParserRULE_actualParameter                    = 112
	pascalParserRULE_parameterwidth                     = 113
	pascalParserRULE_gotoStatement                      = 114
	pascalParserRULE_inheritedStatement                 = 115
	pascalParserRULE_emptyStatement_                    = 116
	pascalParserRULE_empty_                             = 117
	pascalParserRULE_structuredStatement                = 118
	pascalParserRULE_compoundStatement                  = 119
	pascalParserRULE_statements                         = 120
	pascalParserRULE_conditionalStatement               = 121
	pascalParserRULE_ifStatement                        = 122
	pascalParserRULE_caseStatement                      = 123
	pascalParserRULE_caseListElement                    = 124
	pascalParserRULE_repetetiveStatement                = 125
	pascalParserRULE_whileStatement                     = 126
	pascalParserRULE_repeatStatement                    = 127
	pascalParserRULE_forStatement                       = 128
	pascalParserRULE_forList                            = 129
	pascalParserRULE_initialValue                       = 130
	pascalParserRULE_finalValue                         = 131
	pascalParserRULE_withStatement                      = 132
	pascalParserRULE_tryExceptStatement                 = 133
	pascalParserRULE_tryFinallyStatement                = 134
	pascalParserRULE_recordVariableList                 = 135
)

// ISourceContext is an interface to support dynamic dispatch.
type ISourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Program() IProgramContext
	Unit() IUnitContext

	// IsSourceContext differentiates from other interfaces.
	IsSourceContext()
}

type SourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceContext() *SourceContext {
	var p = new(SourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_source
	return p
}

func InitEmptySourceContext(p *SourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_source
}

func (*SourceContext) IsSourceContext() {}

func NewSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceContext {
	var p = new(SourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_source

	return p
}

func (s *SourceContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceContext) Program() IProgramContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProgramContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProgramContext)
}

func (s *SourceContext) Unit() IUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitContext)
}

func (s *SourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSource(s)
	}
}

func (s *SourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSource(s)
	}
}

func (s *SourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSource(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Source() (localctx ISourceContext) {
	localctx = NewSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, pascalParserRULE_source)
	p.SetState(274)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserPROGRAM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(272)
			p.Program()
		}

	case pascalParserUNIT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(273)
			p.Unit()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROGRAM() antlr.TerminalNode
	Identifier() IIdentifierContext
	SEMI() antlr.TerminalNode
	ImplementationBlock() IImplementationBlockContext
	BEGIN() antlr.TerminalNode
	Statements() IStatementsContext
	END() antlr.TerminalNode
	DOT() antlr.TerminalNode
	EOF() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	RPAREN() antlr.TerminalNode
	UsesUnits() IUsesUnitsContext

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) PROGRAM() antlr.TerminalNode {
	return s.GetToken(pascalParserPROGRAM, 0)
}

func (s *ProgramContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ProgramContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ProgramContext) ImplementationBlock() IImplementationBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplementationBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplementationBlockContext)
}

func (s *ProgramContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(pascalParserBEGIN, 0)
}

func (s *ProgramContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *ProgramContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *ProgramContext) DOT() antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, 0)
}

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(pascalParserEOF, 0)
}

func (s *ProgramContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ProgramContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ProgramContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ProgramContext) UsesUnits() IUsesUnitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsesUnitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsesUnitsContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProgram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, pascalParserRULE_program)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(276)
		p.Match(pascalParserPROGRAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(277)
		p.Identifier()
	}
	p.SetState(282)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(278)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(279)
			p.IdentifierList()
		}
		{
			p.SetState(280)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(284)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserUSES {
		{
			p.SetState(285)
			p.UsesUnits()
		}

	}
	{
		p.SetState(288)
		p.ImplementationBlock()
	}
	{
		p.SetState(289)
		p.Match(pascalParserBEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(290)
		p.Statements()
	}
	{
		p.SetState(291)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(292)
		p.Match(pascalParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(293)
		p.Match(pascalParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitContext is an interface to support dynamic dispatch.
type IUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNIT() antlr.TerminalNode
	Identifier() IIdentifierContext
	SEMI() antlr.TerminalNode
	InterfaceSection() IInterfaceSectionContext
	END() antlr.TerminalNode
	DOT() antlr.TerminalNode
	EOF() antlr.TerminalNode
	ImplementationSection() IImplementationSectionContext
	InitializationSection() IInitializationSectionContext
	FinalizationSection() IFinalizationSectionContext

	// IsUnitContext differentiates from other interfaces.
	IsUnitContext()
}

type UnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitContext() *UnitContext {
	var p = new(UnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unit
	return p
}

func InitEmptyUnitContext(p *UnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unit
}

func (*UnitContext) IsUnitContext() {}

func NewUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitContext {
	var p = new(UnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unit

	return p
}

func (s *UnitContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitContext) UNIT() antlr.TerminalNode {
	return s.GetToken(pascalParserUNIT, 0)
}

func (s *UnitContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnitContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *UnitContext) InterfaceSection() IInterfaceSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceSectionContext)
}

func (s *UnitContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *UnitContext) DOT() antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, 0)
}

func (s *UnitContext) EOF() antlr.TerminalNode {
	return s.GetToken(pascalParserEOF, 0)
}

func (s *UnitContext) ImplementationSection() IImplementationSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplementationSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplementationSectionContext)
}

func (s *UnitContext) InitializationSection() IInitializationSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializationSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializationSectionContext)
}

func (s *UnitContext) FinalizationSection() IFinalizationSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinalizationSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinalizationSectionContext)
}

func (s *UnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnit(s)
	}
}

func (s *UnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnit(s)
	}
}

func (s *UnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Unit() (localctx IUnitContext) {
	localctx = NewUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, pascalParserRULE_unit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(295)
		p.Match(pascalParserUNIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(296)
		p.Identifier()
	}
	{
		p.SetState(297)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(298)
		p.InterfaceSection()
	}
	p.SetState(300)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserIMPLEMENTATION {
		{
			p.SetState(299)
			p.ImplementationSection()
		}

	}
	p.SetState(303)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserINITIALIZATION {
		{
			p.SetState(302)
			p.InitializationSection()
		}

	}
	p.SetState(306)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserFINALIZATION {
		{
			p.SetState(305)
			p.FinalizationSection()
		}

	}
	{
		p.SetState(308)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(309)
		p.Match(pascalParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(310)
		p.Match(pascalParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceSectionContext is an interface to support dynamic dispatch.
type IInterfaceSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	InterfaceBlock() IInterfaceBlockContext
	UsesUnits() IUsesUnitsContext

	// IsInterfaceSectionContext differentiates from other interfaces.
	IsInterfaceSectionContext()
}

type InterfaceSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceSectionContext() *InterfaceSectionContext {
	var p = new(InterfaceSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceSection
	return p
}

func InitEmptyInterfaceSectionContext(p *InterfaceSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceSection
}

func (*InterfaceSectionContext) IsInterfaceSectionContext() {}

func NewInterfaceSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceSectionContext {
	var p = new(InterfaceSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceSection

	return p
}

func (s *InterfaceSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceSectionContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(pascalParserINTERFACE, 0)
}

func (s *InterfaceSectionContext) InterfaceBlock() IInterfaceBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceBlockContext)
}

func (s *InterfaceSectionContext) UsesUnits() IUsesUnitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsesUnitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsesUnitsContext)
}

func (s *InterfaceSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceSection(s)
	}
}

func (s *InterfaceSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceSection(s)
	}
}

func (s *InterfaceSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceSection() (localctx IInterfaceSectionContext) {
	localctx = NewInterfaceSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, pascalParserRULE_interfaceSection)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(312)
		p.Match(pascalParserINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(314)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserUSES {
		{
			p.SetState(313)
			p.UsesUnits()
		}

	}
	{
		p.SetState(316)
		p.InterfaceBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImplementationSectionContext is an interface to support dynamic dispatch.
type IImplementationSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPLEMENTATION() antlr.TerminalNode
	ImplementationBlock() IImplementationBlockContext
	UsesUnits() IUsesUnitsContext

	// IsImplementationSectionContext differentiates from other interfaces.
	IsImplementationSectionContext()
}

type ImplementationSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplementationSectionContext() *ImplementationSectionContext {
	var p = new(ImplementationSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_implementationSection
	return p
}

func InitEmptyImplementationSectionContext(p *ImplementationSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_implementationSection
}

func (*ImplementationSectionContext) IsImplementationSectionContext() {}

func NewImplementationSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplementationSectionContext {
	var p = new(ImplementationSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_implementationSection

	return p
}

func (s *ImplementationSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplementationSectionContext) IMPLEMENTATION() antlr.TerminalNode {
	return s.GetToken(pascalParserIMPLEMENTATION, 0)
}

func (s *ImplementationSectionContext) ImplementationBlock() IImplementationBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplementationBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplementationBlockContext)
}

func (s *ImplementationSectionContext) UsesUnits() IUsesUnitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsesUnitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsesUnitsContext)
}

func (s *ImplementationSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplementationSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplementationSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterImplementationSection(s)
	}
}

func (s *ImplementationSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitImplementationSection(s)
	}
}

func (s *ImplementationSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitImplementationSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ImplementationSection() (localctx IImplementationSectionContext) {
	localctx = NewImplementationSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, pascalParserRULE_implementationSection)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(318)
		p.Match(pascalParserIMPLEMENTATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(320)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserUSES {
		{
			p.SetState(319)
			p.UsesUnits()
		}

	}
	{
		p.SetState(322)
		p.ImplementationBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitializationSectionContext is an interface to support dynamic dispatch.
type IInitializationSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INITIALIZATION() antlr.TerminalNode
	Statements() IStatementsContext

	// IsInitializationSectionContext differentiates from other interfaces.
	IsInitializationSectionContext()
}

type InitializationSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializationSectionContext() *InitializationSectionContext {
	var p = new(InitializationSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_initializationSection
	return p
}

func InitEmptyInitializationSectionContext(p *InitializationSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_initializationSection
}

func (*InitializationSectionContext) IsInitializationSectionContext() {}

func NewInitializationSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializationSectionContext {
	var p = new(InitializationSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_initializationSection

	return p
}

func (s *InitializationSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializationSectionContext) INITIALIZATION() antlr.TerminalNode {
	return s.GetToken(pascalParserINITIALIZATION, 0)
}

func (s *InitializationSectionContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *InitializationSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializationSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializationSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInitializationSection(s)
	}
}

func (s *InitializationSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInitializationSection(s)
	}
}

func (s *InitializationSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInitializationSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InitializationSection() (localctx IInitializationSectionContext) {
	localctx = NewInitializationSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, pascalParserRULE_initializationSection)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(324)
		p.Match(pascalParserINITIALIZATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(325)
		p.Statements()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFinalizationSectionContext is an interface to support dynamic dispatch.
type IFinalizationSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FINALIZATION() antlr.TerminalNode
	Statements() IStatementsContext

	// IsFinalizationSectionContext differentiates from other interfaces.
	IsFinalizationSectionContext()
}

type FinalizationSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinalizationSectionContext() *FinalizationSectionContext {
	var p = new(FinalizationSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_finalizationSection
	return p
}

func InitEmptyFinalizationSectionContext(p *FinalizationSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_finalizationSection
}

func (*FinalizationSectionContext) IsFinalizationSectionContext() {}

func NewFinalizationSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinalizationSectionContext {
	var p = new(FinalizationSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_finalizationSection

	return p
}

func (s *FinalizationSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *FinalizationSectionContext) FINALIZATION() antlr.TerminalNode {
	return s.GetToken(pascalParserFINALIZATION, 0)
}

func (s *FinalizationSectionContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *FinalizationSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinalizationSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinalizationSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFinalizationSection(s)
	}
}

func (s *FinalizationSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFinalizationSection(s)
	}
}

func (s *FinalizationSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFinalizationSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FinalizationSection() (localctx IFinalizationSectionContext) {
	localctx = NewFinalizationSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, pascalParserRULE_finalizationSection)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(327)
		p.Match(pascalParserFINALIZATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(328)
		p.Statements()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENT() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	READ() antlr.TerminalNode
	WRITE() antlr.TerminalNode

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) IDENT() antlr.TerminalNode {
	return s.GetToken(pascalParserIDENT, 0)
}

func (s *IdentifierContext) INDEX() antlr.TerminalNode {
	return s.GetToken(pascalParserINDEX, 0)
}

func (s *IdentifierContext) READ() antlr.TerminalNode {
	return s.GetToken(pascalParserREAD, 0)
}

func (s *IdentifierContext) WRITE() antlr.TerminalNode {
	return s.GetToken(pascalParserWRITE, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, pascalParserRULE_identifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(330)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-83)) & ^0x3f) == 0 && ((int64(1)<<(_la-83))&67108875) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceBlockContext is an interface to support dynamic dispatch.
type IInterfaceBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLabelDeclarationPart() []ILabelDeclarationPartContext
	LabelDeclarationPart(i int) ILabelDeclarationPartContext
	AllConstantDefinitionPart() []IConstantDefinitionPartContext
	ConstantDefinitionPart(i int) IConstantDefinitionPartContext
	AllResourceDefinitionPart() []IResourceDefinitionPartContext
	ResourceDefinitionPart(i int) IResourceDefinitionPartContext
	AllTypeDefinitionPart() []ITypeDefinitionPartContext
	TypeDefinitionPart(i int) ITypeDefinitionPartContext
	AllVariableDeclarationPart() []IVariableDeclarationPartContext
	VariableDeclarationPart(i int) IVariableDeclarationPartContext
	AllProcedureOrFunctionHeader() []IProcedureOrFunctionHeaderContext
	ProcedureOrFunctionHeader(i int) IProcedureOrFunctionHeaderContext

	// IsInterfaceBlockContext differentiates from other interfaces.
	IsInterfaceBlockContext()
}

type InterfaceBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceBlockContext() *InterfaceBlockContext {
	var p = new(InterfaceBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceBlock
	return p
}

func InitEmptyInterfaceBlockContext(p *InterfaceBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceBlock
}

func (*InterfaceBlockContext) IsInterfaceBlockContext() {}

func NewInterfaceBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceBlockContext {
	var p = new(InterfaceBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceBlock

	return p
}

func (s *InterfaceBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceBlockContext) AllLabelDeclarationPart() []ILabelDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]ILabelDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelDeclarationPartContext); ok {
			tst[i] = t.(ILabelDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) LabelDeclarationPart(i int) ILabelDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelDeclarationPartContext)
}

func (s *InterfaceBlockContext) AllConstantDefinitionPart() []IConstantDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IConstantDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantDefinitionPartContext); ok {
			tst[i] = t.(IConstantDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) ConstantDefinitionPart(i int) IConstantDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *InterfaceBlockContext) AllResourceDefinitionPart() []IResourceDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResourceDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IResourceDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResourceDefinitionPartContext); ok {
			tst[i] = t.(IResourceDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) ResourceDefinitionPart(i int) IResourceDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceDefinitionPartContext)
}

func (s *InterfaceBlockContext) AllTypeDefinitionPart() []ITypeDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]ITypeDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeDefinitionPartContext); ok {
			tst[i] = t.(ITypeDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) TypeDefinitionPart(i int) ITypeDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionPartContext)
}

func (s *InterfaceBlockContext) AllVariableDeclarationPart() []IVariableDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationPartContext); ok {
			tst[i] = t.(IVariableDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) VariableDeclarationPart(i int) IVariableDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationPartContext)
}

func (s *InterfaceBlockContext) AllProcedureOrFunctionHeader() []IProcedureOrFunctionHeaderContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			len++
		}
	}

	tst := make([]IProcedureOrFunctionHeaderContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			tst[i] = t.(IProcedureOrFunctionHeaderContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) ProcedureOrFunctionHeader(i int) IProcedureOrFunctionHeaderContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderContext)
}

func (s *InterfaceBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceBlock(s)
	}
}

func (s *InterfaceBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceBlock(s)
	}
}

func (s *InterfaceBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceBlock() (localctx IInterfaceBlockContext) {
	localctx = NewInterfaceBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, pascalParserRULE_interfaceBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&343867982080) != 0) || ((int64((_la-100)) & ^0x3f) == 0 && ((int64(1)<<(_la-100))&7) != 0) {
		p.SetState(338)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case pascalParserLABEL:
			{
				p.SetState(332)
				p.LabelDeclarationPart()
			}

		case pascalParserCONST:
			{
				p.SetState(333)
				p.ConstantDefinitionPart()
			}

		case pascalParserRESOURCESTRING:
			{
				p.SetState(334)
				p.ResourceDefinitionPart()
			}

		case pascalParserTYPE:
			{
				p.SetState(335)
				p.TypeDefinitionPart()
			}

		case pascalParserVAR:
			{
				p.SetState(336)
				p.VariableDeclarationPart()
			}

		case pascalParserFUNCTION, pascalParserPROCEDURE, pascalParserCONSTRUCTOR, pascalParserDESTRUCTOR:
			{
				p.SetState(337)
				p.ProcedureOrFunctionHeader()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(342)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImplementationBlockContext is an interface to support dynamic dispatch.
type IImplementationBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLabelDeclarationPart() []ILabelDeclarationPartContext
	LabelDeclarationPart(i int) ILabelDeclarationPartContext
	AllConstantDefinitionPart() []IConstantDefinitionPartContext
	ConstantDefinitionPart(i int) IConstantDefinitionPartContext
	AllResourceDefinitionPart() []IResourceDefinitionPartContext
	ResourceDefinitionPart(i int) IResourceDefinitionPartContext
	AllTypeDefinitionPart() []ITypeDefinitionPartContext
	TypeDefinitionPart(i int) ITypeDefinitionPartContext
	AllVariableDeclarationPart() []IVariableDeclarationPartContext
	VariableDeclarationPart(i int) IVariableDeclarationPartContext
	AllProcedureOrFunctionDeclaration() []IProcedureOrFunctionDeclarationContext
	ProcedureOrFunctionDeclaration(i int) IProcedureOrFunctionDeclarationContext
	AllProcedureOrFunctionHeader() []IProcedureOrFunctionHeaderContext
	ProcedureOrFunctionHeader(i int) IProcedureOrFunctionHeaderContext
	AllFORWARD() []antlr.TerminalNode
	FORWARD(i int) antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsImplementationBlockContext differentiates from other interfaces.
	IsImplementationBlockContext()
}

type ImplementationBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplementationBlockContext() *ImplementationBlockContext {
	var p = new(ImplementationBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_implementationBlock
	return p
}

func InitEmptyImplementationBlockContext(p *ImplementationBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_implementationBlock
}

func (*ImplementationBlockContext) IsImplementationBlockContext() {}

func NewImplementationBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplementationBlockContext {
	var p = new(ImplementationBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_implementationBlock

	return p
}

func (s *ImplementationBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplementationBlockContext) AllLabelDeclarationPart() []ILabelDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]ILabelDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelDeclarationPartContext); ok {
			tst[i] = t.(ILabelDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) LabelDeclarationPart(i int) ILabelDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelDeclarationPartContext)
}

func (s *ImplementationBlockContext) AllConstantDefinitionPart() []IConstantDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IConstantDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantDefinitionPartContext); ok {
			tst[i] = t.(IConstantDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) ConstantDefinitionPart(i int) IConstantDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *ImplementationBlockContext) AllResourceDefinitionPart() []IResourceDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResourceDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IResourceDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResourceDefinitionPartContext); ok {
			tst[i] = t.(IResourceDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) ResourceDefinitionPart(i int) IResourceDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceDefinitionPartContext)
}

func (s *ImplementationBlockContext) AllTypeDefinitionPart() []ITypeDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]ITypeDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeDefinitionPartContext); ok {
			tst[i] = t.(ITypeDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) TypeDefinitionPart(i int) ITypeDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionPartContext)
}

func (s *ImplementationBlockContext) AllVariableDeclarationPart() []IVariableDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationPartContext); ok {
			tst[i] = t.(IVariableDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) VariableDeclarationPart(i int) IVariableDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationPartContext)
}

func (s *ImplementationBlockContext) AllProcedureOrFunctionDeclaration() []IProcedureOrFunctionDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IProcedureOrFunctionDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			tst[i] = t.(IProcedureOrFunctionDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) ProcedureOrFunctionDeclaration(i int) IProcedureOrFunctionDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionDeclarationContext)
}

func (s *ImplementationBlockContext) AllProcedureOrFunctionHeader() []IProcedureOrFunctionHeaderContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			len++
		}
	}

	tst := make([]IProcedureOrFunctionHeaderContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			tst[i] = t.(IProcedureOrFunctionHeaderContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) ProcedureOrFunctionHeader(i int) IProcedureOrFunctionHeaderContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderContext)
}

func (s *ImplementationBlockContext) AllFORWARD() []antlr.TerminalNode {
	return s.GetTokens(pascalParserFORWARD)
}

func (s *ImplementationBlockContext) FORWARD(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserFORWARD, i)
}

func (s *ImplementationBlockContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ImplementationBlockContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ImplementationBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplementationBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplementationBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterImplementationBlock(s)
	}
}

func (s *ImplementationBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitImplementationBlock(s)
	}
}

func (s *ImplementationBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitImplementationBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ImplementationBlock() (localctx IImplementationBlockContext) {
	localctx = NewImplementationBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, pascalParserRULE_implementationBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(355)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&343867982080) != 0) || ((int64((_la-100)) & ^0x3f) == 0 && ((int64(1)<<(_la-100))&7) != 0) {
		p.SetState(353)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(343)
				p.LabelDeclarationPart()
			}

		case 2:
			{
				p.SetState(344)
				p.ConstantDefinitionPart()
			}

		case 3:
			{
				p.SetState(345)
				p.ResourceDefinitionPart()
			}

		case 4:
			{
				p.SetState(346)
				p.TypeDefinitionPart()
			}

		case 5:
			{
				p.SetState(347)
				p.VariableDeclarationPart()
			}

		case 6:
			{
				p.SetState(348)
				p.ProcedureOrFunctionDeclaration()
			}

		case 7:
			{
				p.SetState(349)
				p.ProcedureOrFunctionHeader()
			}
			{
				p.SetState(350)
				p.Match(pascalParserFORWARD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(351)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(357)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLabelDeclarationPart() []ILabelDeclarationPartContext
	LabelDeclarationPart(i int) ILabelDeclarationPartContext
	AllConstantDefinitionPart() []IConstantDefinitionPartContext
	ConstantDefinitionPart(i int) IConstantDefinitionPartContext
	AllVariableDeclarationPart() []IVariableDeclarationPartContext
	VariableDeclarationPart(i int) IVariableDeclarationPartContext
	AllProcedureOrFunctionDeclaration() []IProcedureOrFunctionDeclarationContext
	ProcedureOrFunctionDeclaration(i int) IProcedureOrFunctionDeclarationContext

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) AllLabelDeclarationPart() []ILabelDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]ILabelDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelDeclarationPartContext); ok {
			tst[i] = t.(ILabelDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) LabelDeclarationPart(i int) ILabelDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelDeclarationPartContext)
}

func (s *BlockContext) AllConstantDefinitionPart() []IConstantDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IConstantDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantDefinitionPartContext); ok {
			tst[i] = t.(IConstantDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) ConstantDefinitionPart(i int) IConstantDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *BlockContext) AllVariableDeclarationPart() []IVariableDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationPartContext); ok {
			tst[i] = t.(IVariableDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) VariableDeclarationPart(i int) IVariableDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationPartContext)
}

func (s *BlockContext) AllProcedureOrFunctionDeclaration() []IProcedureOrFunctionDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IProcedureOrFunctionDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			tst[i] = t.(IProcedureOrFunctionDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) ProcedureOrFunctionDeclaration(i int) IProcedureOrFunctionDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionDeclarationContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (s *BlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, pascalParserRULE_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&275148505344) != 0) || _la == pascalParserCONSTRUCTOR || _la == pascalParserDESTRUCTOR {
		p.SetState(362)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case pascalParserLABEL:
			{
				p.SetState(358)
				p.LabelDeclarationPart()
			}

		case pascalParserCONST:
			{
				p.SetState(359)
				p.ConstantDefinitionPart()
			}

		case pascalParserVAR:
			{
				p.SetState(360)
				p.VariableDeclarationPart()
			}

		case pascalParserFUNCTION, pascalParserPROCEDURE, pascalParserCONSTRUCTOR, pascalParserDESTRUCTOR:
			{
				p.SetState(361)
				p.ProcedureOrFunctionDeclaration()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(366)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsesUnitsContext is an interface to support dynamic dispatch.
type IUsesUnitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USES() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	SEMI() antlr.TerminalNode

	// IsUsesUnitsContext differentiates from other interfaces.
	IsUsesUnitsContext()
}

type UsesUnitsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsesUnitsContext() *UsesUnitsContext {
	var p = new(UsesUnitsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_usesUnits
	return p
}

func InitEmptyUsesUnitsContext(p *UsesUnitsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_usesUnits
}

func (*UsesUnitsContext) IsUsesUnitsContext() {}

func NewUsesUnitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsesUnitsContext {
	var p = new(UsesUnitsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_usesUnits

	return p
}

func (s *UsesUnitsContext) GetParser() antlr.Parser { return s.parser }

func (s *UsesUnitsContext) USES() antlr.TerminalNode {
	return s.GetToken(pascalParserUSES, 0)
}

func (s *UsesUnitsContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *UsesUnitsContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *UsesUnitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsesUnitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsesUnitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUsesUnits(s)
	}
}

func (s *UsesUnitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUsesUnits(s)
	}
}

func (s *UsesUnitsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUsesUnits(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UsesUnits() (localctx IUsesUnitsContext) {
	localctx = NewUsesUnitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, pascalParserRULE_usesUnits)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(367)
		p.Match(pascalParserUSES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(368)
		p.IdentifierList()
	}
	{
		p.SetState(369)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelDeclarationPartContext is an interface to support dynamic dispatch.
type ILabelDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LABEL() antlr.TerminalNode
	AllLabel() []ILabelContext
	Label(i int) ILabelContext
	SEMI() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLabelDeclarationPartContext differentiates from other interfaces.
	IsLabelDeclarationPartContext()
}

type LabelDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelDeclarationPartContext() *LabelDeclarationPartContext {
	var p = new(LabelDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_labelDeclarationPart
	return p
}

func InitEmptyLabelDeclarationPartContext(p *LabelDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_labelDeclarationPart
}

func (*LabelDeclarationPartContext) IsLabelDeclarationPartContext() {}

func NewLabelDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelDeclarationPartContext {
	var p = new(LabelDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_labelDeclarationPart

	return p
}

func (s *LabelDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelDeclarationPartContext) LABEL() antlr.TerminalNode {
	return s.GetToken(pascalParserLABEL, 0)
}

func (s *LabelDeclarationPartContext) AllLabel() []ILabelContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelContext); ok {
			len++
		}
	}

	tst := make([]ILabelContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelContext); ok {
			tst[i] = t.(ILabelContext)
			i++
		}
	}

	return tst
}

func (s *LabelDeclarationPartContext) Label(i int) ILabelContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *LabelDeclarationPartContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *LabelDeclarationPartContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *LabelDeclarationPartContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *LabelDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterLabelDeclarationPart(s)
	}
}

func (s *LabelDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitLabelDeclarationPart(s)
	}
}

func (s *LabelDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitLabelDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) LabelDeclarationPart() (localctx ILabelDeclarationPartContext) {
	localctx = NewLabelDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, pascalParserRULE_labelDeclarationPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(371)
		p.Match(pascalParserLABEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(372)
		p.Label()
	}
	p.SetState(377)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(373)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(374)
			p.Label()
		}

		p.SetState(379)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(380)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelContext is an interface to support dynamic dispatch.
type ILabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedInteger() IUnsignedIntegerContext

	// IsLabelContext differentiates from other interfaces.
	IsLabelContext()
}

type LabelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelContext() *LabelContext {
	var p = new(LabelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_label
	return p
}

func InitEmptyLabelContext(p *LabelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_label
}

func (*LabelContext) IsLabelContext() {}

func NewLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelContext {
	var p = new(LabelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_label

	return p
}

func (s *LabelContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelContext) UnsignedInteger() IUnsignedIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerContext)
}

func (s *LabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterLabel(s)
	}
}

func (s *LabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitLabel(s)
	}
}

func (s *LabelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitLabel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Label() (localctx ILabelContext) {
	localctx = NewLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, pascalParserRULE_label)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(382)
		p.UnsignedInteger()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantDefinitionPartContext is an interface to support dynamic dispatch.
type IConstantDefinitionPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONST() antlr.TerminalNode
	AllConstantDefinition() []IConstantDefinitionContext
	ConstantDefinition(i int) IConstantDefinitionContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsConstantDefinitionPartContext differentiates from other interfaces.
	IsConstantDefinitionPartContext()
}

type ConstantDefinitionPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantDefinitionPartContext() *ConstantDefinitionPartContext {
	var p = new(ConstantDefinitionPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantDefinitionPart
	return p
}

func InitEmptyConstantDefinitionPartContext(p *ConstantDefinitionPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantDefinitionPart
}

func (*ConstantDefinitionPartContext) IsConstantDefinitionPartContext() {}

func NewConstantDefinitionPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantDefinitionPartContext {
	var p = new(ConstantDefinitionPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constantDefinitionPart

	return p
}

func (s *ConstantDefinitionPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantDefinitionPartContext) CONST() antlr.TerminalNode {
	return s.GetToken(pascalParserCONST, 0)
}

func (s *ConstantDefinitionPartContext) AllConstantDefinition() []IConstantDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IConstantDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantDefinitionContext); ok {
			tst[i] = t.(IConstantDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *ConstantDefinitionPartContext) ConstantDefinition(i int) IConstantDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionContext)
}

func (s *ConstantDefinitionPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ConstantDefinitionPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ConstantDefinitionPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantDefinitionPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantDefinitionPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstantDefinitionPart(s)
	}
}

func (s *ConstantDefinitionPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstantDefinitionPart(s)
	}
}

func (s *ConstantDefinitionPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstantDefinitionPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConstantDefinitionPart() (localctx IConstantDefinitionPartContext) {
	localctx = NewConstantDefinitionPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, pascalParserRULE_constantDefinitionPart)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(384)
		p.Match(pascalParserCONST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(388)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(385)
				p.ConstantDefinition()
			}
			{
				p.SetState(386)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(390)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantDefinitionContext is an interface to support dynamic dispatch.
type IConstantDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQUAL() antlr.TerminalNode
	Constant() IConstantContext

	// IsConstantDefinitionContext differentiates from other interfaces.
	IsConstantDefinitionContext()
}

type ConstantDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantDefinitionContext() *ConstantDefinitionContext {
	var p = new(ConstantDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantDefinition
	return p
}

func InitEmptyConstantDefinitionContext(p *ConstantDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantDefinition
}

func (*ConstantDefinitionContext) IsConstantDefinitionContext() {}

func NewConstantDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantDefinitionContext {
	var p = new(ConstantDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constantDefinition

	return p
}

func (s *ConstantDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConstantDefinitionContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *ConstantDefinitionContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstantDefinition(s)
	}
}

func (s *ConstantDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstantDefinition(s)
	}
}

func (s *ConstantDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstantDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConstantDefinition() (localctx IConstantDefinitionContext) {
	localctx = NewConstantDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, pascalParserRULE_constantDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(392)
		p.Identifier()
	}
	{
		p.SetState(393)
		p.Match(pascalParserEQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(394)
		p.Constant()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantChrContext is an interface to support dynamic dispatch.
type IConstantChrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHR() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	UnsignedInteger() IUnsignedIntegerContext
	RPAREN() antlr.TerminalNode

	// IsConstantChrContext differentiates from other interfaces.
	IsConstantChrContext()
}

type ConstantChrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantChrContext() *ConstantChrContext {
	var p = new(ConstantChrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantChr
	return p
}

func InitEmptyConstantChrContext(p *ConstantChrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantChr
}

func (*ConstantChrContext) IsConstantChrContext() {}

func NewConstantChrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantChrContext {
	var p = new(ConstantChrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constantChr

	return p
}

func (s *ConstantChrContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantChrContext) CHR() antlr.TerminalNode {
	return s.GetToken(pascalParserCHR, 0)
}

func (s *ConstantChrContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ConstantChrContext) UnsignedInteger() IUnsignedIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerContext)
}

func (s *ConstantChrContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ConstantChrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantChrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantChrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstantChr(s)
	}
}

func (s *ConstantChrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstantChr(s)
	}
}

func (s *ConstantChrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstantChr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConstantChr() (localctx IConstantChrContext) {
	localctx = NewConstantChrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, pascalParserRULE_constantChr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(396)
		p.Match(pascalParserCHR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(397)
		p.Match(pascalParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(398)
		p.UnsignedInteger()
	}
	{
		p.SetState(399)
		p.Match(pascalParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedNumber() IUnsignedNumberContext
	Sign() ISignContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	String_() IStringContext
	ConstantChr() IConstantChrContext
	AllArrayConstant() []IArrayConstantContext
	ArrayConstant(i int) IArrayConstantContext
	AllPLUS() []antlr.TerminalNode
	PLUS(i int) antlr.TerminalNode

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constant
	return p
}

func InitEmptyConstantContext(p *ConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constant
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) UnsignedNumber() IUnsignedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedNumberContext)
}

func (s *ConstantContext) Sign() ISignContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignContext)
}

func (s *ConstantContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ConstantContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConstantContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ConstantContext) ConstantChr() IConstantChrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantChrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantChrContext)
}

func (s *ConstantContext) AllArrayConstant() []IArrayConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayConstantContext); ok {
			len++
		}
	}

	tst := make([]IArrayConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayConstantContext); ok {
			tst[i] = t.(IArrayConstantContext)
			i++
		}
	}

	return tst
}

func (s *ConstantContext) ArrayConstant(i int) IArrayConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayConstantContext)
}

func (s *ConstantContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPLUS)
}

func (s *ConstantContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPLUS, i)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstant(s)
	}
}

func (s *ConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, pascalParserRULE_constant)
	var _alt int

	p.SetState(422)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(401)
			p.UnsignedNumber()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(402)
			p.Sign()
		}
		{
			p.SetState(403)
			p.UnsignedNumber()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(405)
			p.Identifier()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(406)
			p.Sign()
		}
		{
			p.SetState(407)
			p.Identifier()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(409)
			p.String_()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(410)
			p.ConstantChr()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(411)
			p.ArrayConstant()
		}
		p.SetState(419)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(412)
					p.Match(pascalParserPLUS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(415)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case pascalParserLBRACK:
					{
						p.SetState(413)
						p.ArrayConstant()
					}

				case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
					{
						p.SetState(414)
						p.Identifier()
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			}
			p.SetState(421)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayConstantContext is an interface to support dynamic dispatch.
type IArrayConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	RBRACK() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsArrayConstantContext differentiates from other interfaces.
	IsArrayConstantContext()
}

type ArrayConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayConstantContext() *ArrayConstantContext {
	var p = new(ArrayConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_arrayConstant
	return p
}

func InitEmptyArrayConstantContext(p *ArrayConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_arrayConstant
}

func (*ArrayConstantContext) IsArrayConstantContext() {}

func NewArrayConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayConstantContext {
	var p = new(ArrayConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_arrayConstant

	return p
}

func (s *ArrayConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayConstantContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *ArrayConstantContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *ArrayConstantContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ArrayConstantContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *ArrayConstantContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ArrayConstantContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ArrayConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterArrayConstant(s)
	}
}

func (s *ArrayConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitArrayConstant(s)
	}
}

func (s *ArrayConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitArrayConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ArrayConstant() (localctx IArrayConstantContext) {
	localctx = NewArrayConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, pascalParserRULE_arrayConstant)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(424)
		p.Match(pascalParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(425)
		p.Constant()
	}
	p.SetState(430)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(426)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(427)
			p.Constant()
		}

		p.SetState(432)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(433)
		p.Match(pascalParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedNumberContext is an interface to support dynamic dispatch.
type IUnsignedNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedInteger() IUnsignedIntegerContext
	UnsignedReal() IUnsignedRealContext

	// IsUnsignedNumberContext differentiates from other interfaces.
	IsUnsignedNumberContext()
}

type UnsignedNumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedNumberContext() *UnsignedNumberContext {
	var p = new(UnsignedNumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedNumber
	return p
}

func InitEmptyUnsignedNumberContext(p *UnsignedNumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedNumber
}

func (*UnsignedNumberContext) IsUnsignedNumberContext() {}

func NewUnsignedNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedNumberContext {
	var p = new(UnsignedNumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unsignedNumber

	return p
}

func (s *UnsignedNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedNumberContext) UnsignedInteger() IUnsignedIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerContext)
}

func (s *UnsignedNumberContext) UnsignedReal() IUnsignedRealContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedRealContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedRealContext)
}

func (s *UnsignedNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnsignedNumber(s)
	}
}

func (s *UnsignedNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnsignedNumber(s)
	}
}

func (s *UnsignedNumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnsignedNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnsignedNumber() (localctx IUnsignedNumberContext) {
	localctx = NewUnsignedNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, pascalParserRULE_unsignedNumber)
	p.SetState(437)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserNUM_INT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(435)
			p.UnsignedInteger()
		}

	case pascalParserNUM_REAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(436)
			p.UnsignedReal()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedIntegerContext is an interface to support dynamic dispatch.
type IUnsignedIntegerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUM_INT() antlr.TerminalNode

	// IsUnsignedIntegerContext differentiates from other interfaces.
	IsUnsignedIntegerContext()
}

type UnsignedIntegerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedIntegerContext() *UnsignedIntegerContext {
	var p = new(UnsignedIntegerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedInteger
	return p
}

func InitEmptyUnsignedIntegerContext(p *UnsignedIntegerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedInteger
}

func (*UnsignedIntegerContext) IsUnsignedIntegerContext() {}

func NewUnsignedIntegerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedIntegerContext {
	var p = new(UnsignedIntegerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unsignedInteger

	return p
}

func (s *UnsignedIntegerContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedIntegerContext) NUM_INT() antlr.TerminalNode {
	return s.GetToken(pascalParserNUM_INT, 0)
}

func (s *UnsignedIntegerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedIntegerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedIntegerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnsignedInteger(s)
	}
}

func (s *UnsignedIntegerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnsignedInteger(s)
	}
}

func (s *UnsignedIntegerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnsignedInteger(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnsignedInteger() (localctx IUnsignedIntegerContext) {
	localctx = NewUnsignedIntegerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, pascalParserRULE_unsignedInteger)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(439)
		p.Match(pascalParserNUM_INT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedRealContext is an interface to support dynamic dispatch.
type IUnsignedRealContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUM_REAL() antlr.TerminalNode

	// IsUnsignedRealContext differentiates from other interfaces.
	IsUnsignedRealContext()
}

type UnsignedRealContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedRealContext() *UnsignedRealContext {
	var p = new(UnsignedRealContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedReal
	return p
}

func InitEmptyUnsignedRealContext(p *UnsignedRealContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedReal
}

func (*UnsignedRealContext) IsUnsignedRealContext() {}

func NewUnsignedRealContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedRealContext {
	var p = new(UnsignedRealContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unsignedReal

	return p
}

func (s *UnsignedRealContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedRealContext) NUM_REAL() antlr.TerminalNode {
	return s.GetToken(pascalParserNUM_REAL, 0)
}

func (s *UnsignedRealContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedRealContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedRealContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnsignedReal(s)
	}
}

func (s *UnsignedRealContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnsignedReal(s)
	}
}

func (s *UnsignedRealContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnsignedReal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnsignedReal() (localctx IUnsignedRealContext) {
	localctx = NewUnsignedRealContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, pascalParserRULE_unsignedReal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(441)
		p.Match(pascalParserNUM_REAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignContext is an interface to support dynamic dispatch.
type ISignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsSignContext differentiates from other interfaces.
	IsSignContext()
}

type SignContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignContext() *SignContext {
	var p = new(SignContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_sign
	return p
}

func InitEmptySignContext(p *SignContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_sign
}

func (*SignContext) IsSignContext() {}

func NewSignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignContext {
	var p = new(SignContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_sign

	return p
}

func (s *SignContext) GetParser() antlr.Parser { return s.parser }

func (s *SignContext) PLUS() antlr.TerminalNode {
	return s.GetToken(pascalParserPLUS, 0)
}

func (s *SignContext) MINUS() antlr.TerminalNode {
	return s.GetToken(pascalParserMINUS, 0)
}

func (s *SignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSign(s)
	}
}

func (s *SignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSign(s)
	}
}

func (s *SignContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSign(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Sign() (localctx ISignContext) {
	localctx = NewSignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, pascalParserRULE_sign)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(443)
		_la = p.GetTokenStream().LA(1)

		if !(_la == pascalParserPLUS || _la == pascalParserMINUS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_Context is an interface to support dynamic dispatch.
type IBool_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBool_Context differentiates from other interfaces.
	IsBool_Context()
}

type Bool_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_Context() *Bool_Context {
	var p = new(Bool_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_bool_
	return p
}

func InitEmptyBool_Context(p *Bool_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_bool_
}

func (*Bool_Context) IsBool_Context() {}

func NewBool_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_Context {
	var p = new(Bool_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_bool_

	return p
}

func (s *Bool_Context) GetParser() antlr.Parser { return s.parser }

func (s *Bool_Context) TRUE() antlr.TerminalNode {
	return s.GetToken(pascalParserTRUE, 0)
}

func (s *Bool_Context) FALSE() antlr.TerminalNode {
	return s.GetToken(pascalParserFALSE, 0)
}

func (s *Bool_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterBool_(s)
	}
}

func (s *Bool_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitBool_(s)
	}
}

func (s *Bool_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitBool_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Bool_() (localctx IBool_Context) {
	localctx = NewBool_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, pascalParserRULE_bool_)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(445)
		_la = p.GetTokenStream().LA(1)

		if !(_la == pascalParserTRUE || _la == pascalParserFALSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringContext is an interface to support dynamic dispatch.
type IStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_LITERAL() antlr.TerminalNode

	// IsStringContext differentiates from other interfaces.
	IsStringContext()
}

type StringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringContext() *StringContext {
	var p = new(StringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_string
	return p
}

func InitEmptyStringContext(p *StringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_string
}

func (*StringContext) IsStringContext() {}

func NewStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringContext {
	var p = new(StringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_string

	return p
}

func (s *StringContext) GetParser() antlr.Parser { return s.parser }

func (s *StringContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(pascalParserSTRING_LITERAL, 0)
}

func (s *StringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterString(s)
	}
}

func (s *StringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitString(s)
	}
}

func (s *StringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) String_() (localctx IStringContext) {
	localctx = NewStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, pascalParserRULE_string)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(447)
		p.Match(pascalParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceDefinitionPartContext is an interface to support dynamic dispatch.
type IResourceDefinitionPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESOURCESTRING() antlr.TerminalNode
	AllResourceDefinition() []IResourceDefinitionContext
	ResourceDefinition(i int) IResourceDefinitionContext

	// IsResourceDefinitionPartContext differentiates from other interfaces.
	IsResourceDefinitionPartContext()
}

type ResourceDefinitionPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceDefinitionPartContext() *ResourceDefinitionPartContext {
	var p = new(ResourceDefinitionPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resourceDefinitionPart
	return p
}

func InitEmptyResourceDefinitionPartContext(p *ResourceDefinitionPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resourceDefinitionPart
}

func (*ResourceDefinitionPartContext) IsResourceDefinitionPartContext() {}

func NewResourceDefinitionPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceDefinitionPartContext {
	var p = new(ResourceDefinitionPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_resourceDefinitionPart

	return p
}

func (s *ResourceDefinitionPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceDefinitionPartContext) RESOURCESTRING() antlr.TerminalNode {
	return s.GetToken(pascalParserRESOURCESTRING, 0)
}

func (s *ResourceDefinitionPartContext) AllResourceDefinition() []IResourceDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResourceDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IResourceDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResourceDefinitionContext); ok {
			tst[i] = t.(IResourceDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *ResourceDefinitionPartContext) ResourceDefinition(i int) IResourceDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceDefinitionContext)
}

func (s *ResourceDefinitionPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceDefinitionPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceDefinitionPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterResourceDefinitionPart(s)
	}
}

func (s *ResourceDefinitionPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitResourceDefinitionPart(s)
	}
}

func (s *ResourceDefinitionPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitResourceDefinitionPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ResourceDefinitionPart() (localctx IResourceDefinitionPartContext) {
	localctx = NewResourceDefinitionPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, pascalParserRULE_resourceDefinitionPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(449)
		p.Match(pascalParserRESOURCESTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(451)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64((_la-83)) & ^0x3f) == 0 && ((int64(1)<<(_la-83))&67108875) != 0) {
		{
			p.SetState(450)
			p.ResourceDefinition()
		}

		p.SetState(453)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceDefinitionContext is an interface to support dynamic dispatch.
type IResourceDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQUAL() antlr.TerminalNode
	String_() IStringContext
	SEMI() antlr.TerminalNode

	// IsResourceDefinitionContext differentiates from other interfaces.
	IsResourceDefinitionContext()
}

type ResourceDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceDefinitionContext() *ResourceDefinitionContext {
	var p = new(ResourceDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resourceDefinition
	return p
}

func InitEmptyResourceDefinitionContext(p *ResourceDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resourceDefinition
}

func (*ResourceDefinitionContext) IsResourceDefinitionContext() {}

func NewResourceDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceDefinitionContext {
	var p = new(ResourceDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_resourceDefinition

	return p
}

func (s *ResourceDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ResourceDefinitionContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *ResourceDefinitionContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ResourceDefinitionContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ResourceDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterResourceDefinition(s)
	}
}

func (s *ResourceDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitResourceDefinition(s)
	}
}

func (s *ResourceDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitResourceDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ResourceDefinition() (localctx IResourceDefinitionContext) {
	localctx = NewResourceDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, pascalParserRULE_resourceDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(455)
		p.Identifier()
	}
	{
		p.SetState(456)
		p.Match(pascalParserEQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(457)
		p.String_()
	}
	{
		p.SetState(458)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDefinitionPartContext is an interface to support dynamic dispatch.
type ITypeDefinitionPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE() antlr.TerminalNode
	AllTypeDefinition() []ITypeDefinitionContext
	TypeDefinition(i int) ITypeDefinitionContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsTypeDefinitionPartContext differentiates from other interfaces.
	IsTypeDefinitionPartContext()
}

type TypeDefinitionPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDefinitionPartContext() *TypeDefinitionPartContext {
	var p = new(TypeDefinitionPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeDefinitionPart
	return p
}

func InitEmptyTypeDefinitionPartContext(p *TypeDefinitionPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeDefinitionPart
}

func (*TypeDefinitionPartContext) IsTypeDefinitionPartContext() {}

func NewTypeDefinitionPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDefinitionPartContext {
	var p = new(TypeDefinitionPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typeDefinitionPart

	return p
}

func (s *TypeDefinitionPartContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDefinitionPartContext) TYPE() antlr.TerminalNode {
	return s.GetToken(pascalParserTYPE, 0)
}

func (s *TypeDefinitionPartContext) AllTypeDefinition() []ITypeDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ITypeDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeDefinitionContext); ok {
			tst[i] = t.(ITypeDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *TypeDefinitionPartContext) TypeDefinition(i int) ITypeDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionContext)
}

func (s *TypeDefinitionPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *TypeDefinitionPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *TypeDefinitionPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDefinitionPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDefinitionPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypeDefinitionPart(s)
	}
}

func (s *TypeDefinitionPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypeDefinitionPart(s)
	}
}

func (s *TypeDefinitionPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypeDefinitionPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypeDefinitionPart() (localctx ITypeDefinitionPartContext) {
	localctx = NewTypeDefinitionPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, pascalParserRULE_typeDefinitionPart)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(460)
		p.Match(pascalParserTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(464)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(461)
				p.TypeDefinition()
			}
			{
				p.SetState(462)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(466)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDefinitionContext is an interface to support dynamic dispatch.
type ITypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQUAL() antlr.TerminalNode
	Type_() IType_Context
	FunctionType() IFunctionTypeContext
	ProcedureType() IProcedureTypeContext
	ForwardClassType() IForwardClassTypeContext

	// IsTypeDefinitionContext differentiates from other interfaces.
	IsTypeDefinitionContext()
}

type TypeDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDefinitionContext() *TypeDefinitionContext {
	var p = new(TypeDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeDefinition
	return p
}

func InitEmptyTypeDefinitionContext(p *TypeDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeDefinition
}

func (*TypeDefinitionContext) IsTypeDefinitionContext() {}

func NewTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDefinitionContext {
	var p = new(TypeDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typeDefinition

	return p
}

func (s *TypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeDefinitionContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *TypeDefinitionContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeDefinitionContext) FunctionType() IFunctionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *TypeDefinitionContext) ProcedureType() IProcedureTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureTypeContext)
}

func (s *TypeDefinitionContext) ForwardClassType() IForwardClassTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForwardClassTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForwardClassTypeContext)
}

func (s *TypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypeDefinition(s)
	}
}

func (s *TypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypeDefinition(s)
	}
}

func (s *TypeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypeDefinition() (localctx ITypeDefinitionContext) {
	localctx = NewTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, pascalParserRULE_typeDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(468)
		p.Identifier()
	}
	{
		p.SetState(469)
		p.Match(pascalParserEQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(474)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(470)
			p.Type_()
		}

	case 2:
		{
			p.SetState(471)
			p.FunctionType()
		}

	case 3:
		{
			p.SetState(472)
			p.ProcedureType()
		}

	case 4:
		{
			p.SetState(473)
			p.ForwardClassType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTypeContext is an interface to support dynamic dispatch.
type IFunctionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNCTION() antlr.TerminalNode
	COLON() antlr.TerminalNode
	ResultType() IResultTypeContext
	FormalParameterList() IFormalParameterListContext
	OFOBJECT() antlr.TerminalNode

	// IsFunctionTypeContext differentiates from other interfaces.
	IsFunctionTypeContext()
}

type FunctionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeContext() *FunctionTypeContext {
	var p = new(FunctionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionType
	return p
}

func InitEmptyFunctionTypeContext(p *FunctionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionType
}

func (*FunctionTypeContext) IsFunctionTypeContext() {}

func NewFunctionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeContext {
	var p = new(FunctionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_functionType

	return p
}

func (s *FunctionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(pascalParserFUNCTION, 0)
}

func (s *FunctionTypeContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *FunctionTypeContext) ResultType() IResultTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultTypeContext)
}

func (s *FunctionTypeContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionTypeContext) OFOBJECT() antlr.TerminalNode {
	return s.GetToken(pascalParserOFOBJECT, 0)
}

func (s *FunctionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFunctionType(s)
	}
}

func (s *FunctionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFunctionType(s)
	}
}

func (s *FunctionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFunctionType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FunctionType() (localctx IFunctionTypeContext) {
	localctx = NewFunctionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, pascalParserRULE_functionType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(476)
		p.Match(pascalParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(478)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(477)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(480)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(481)
		p.ResultType()
	}
	p.SetState(483)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserOFOBJECT {
		{
			p.SetState(482)
			p.Match(pascalParserOFOBJECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureTypeContext is an interface to support dynamic dispatch.
type IProcedureTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROCEDURE() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext
	OFOBJECT() antlr.TerminalNode

	// IsProcedureTypeContext differentiates from other interfaces.
	IsProcedureTypeContext()
}

type ProcedureTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureTypeContext() *ProcedureTypeContext {
	var p = new(ProcedureTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureType
	return p
}

func InitEmptyProcedureTypeContext(p *ProcedureTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureType
}

func (*ProcedureTypeContext) IsProcedureTypeContext() {}

func NewProcedureTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureTypeContext {
	var p = new(ProcedureTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureType

	return p
}

func (s *ProcedureTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureTypeContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(pascalParserPROCEDURE, 0)
}

func (s *ProcedureTypeContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ProcedureTypeContext) OFOBJECT() antlr.TerminalNode {
	return s.GetToken(pascalParserOFOBJECT, 0)
}

func (s *ProcedureTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureType(s)
	}
}

func (s *ProcedureTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureType(s)
	}
}

func (s *ProcedureTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureType() (localctx IProcedureTypeContext) {
	localctx = NewProcedureTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, pascalParserRULE_procedureType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(485)
		p.Match(pascalParserPROCEDURE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(487)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(486)
			p.FormalParameterList()
		}

	}
	p.SetState(490)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserOFOBJECT {
		{
			p.SetState(489)
			p.Match(pascalParserOFOBJECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForwardClassTypeContext is an interface to support dynamic dispatch.
type IForwardClassTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode

	// IsForwardClassTypeContext differentiates from other interfaces.
	IsForwardClassTypeContext()
}

type ForwardClassTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForwardClassTypeContext() *ForwardClassTypeContext {
	var p = new(ForwardClassTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forwardClassType
	return p
}

func InitEmptyForwardClassTypeContext(p *ForwardClassTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forwardClassType
}

func (*ForwardClassTypeContext) IsForwardClassTypeContext() {}

func NewForwardClassTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForwardClassTypeContext {
	var p = new(ForwardClassTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_forwardClassType

	return p
}

func (s *ForwardClassTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ForwardClassTypeContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *ForwardClassTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForwardClassTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForwardClassTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterForwardClassType(s)
	}
}

func (s *ForwardClassTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitForwardClassType(s)
	}
}

func (s *ForwardClassTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitForwardClassType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ForwardClassType() (localctx IForwardClassTypeContext) {
	localctx = NewForwardClassTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, pascalParserRULE_forwardClassType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(492)
		p.Match(pascalParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassTypeContext is an interface to support dynamic dispatch.
type IClassTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	ClassImplementsInterfaces() IClassImplementsInterfacesContext
	RPAREN() antlr.TerminalNode
	ClassImplicitPublishedDeclaration() IClassImplicitPublishedDeclarationContext
	END() antlr.TerminalNode
	AllClassDeclaration() []IClassDeclarationContext
	ClassDeclaration(i int) IClassDeclarationContext

	// IsClassTypeContext differentiates from other interfaces.
	IsClassTypeContext()
}

type ClassTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassTypeContext() *ClassTypeContext {
	var p = new(ClassTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classType
	return p
}

func InitEmptyClassTypeContext(p *ClassTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classType
}

func (*ClassTypeContext) IsClassTypeContext() {}

func NewClassTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassTypeContext {
	var p = new(ClassTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classType

	return p
}

func (s *ClassTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassTypeContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *ClassTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ClassTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassTypeContext) ClassImplementsInterfaces() IClassImplementsInterfacesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassImplementsInterfacesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassImplementsInterfacesContext)
}

func (s *ClassTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ClassTypeContext) ClassImplicitPublishedDeclaration() IClassImplicitPublishedDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassImplicitPublishedDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassImplicitPublishedDeclarationContext)
}

func (s *ClassTypeContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *ClassTypeContext) AllClassDeclaration() []IClassDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassDeclarationContext); ok {
			tst[i] = t.(IClassDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ClassTypeContext) ClassDeclaration(i int) IClassDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *ClassTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassType(s)
	}
}

func (s *ClassTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassType(s)
	}
}

func (s *ClassTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassType() (localctx IClassTypeContext) {
	localctx = NewClassTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, pascalParserRULE_classType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(494)
		p.Match(pascalParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(495)
		p.Match(pascalParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(496)
		p.Identifier()
	}
	{
		p.SetState(497)
		p.ClassImplementsInterfaces()
	}
	{
		p.SetState(498)
		p.Match(pascalParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(499)
		p.ClassImplicitPublishedDeclaration()
	}
	p.SetState(503)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-75)) & ^0x3f) == 0 && ((int64(1)<<(_la-75))&63) != 0 {
		{
			p.SetState(500)
			p.ClassDeclaration()
		}

		p.SetState(505)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(506)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassImplementsInterfacesContext is an interface to support dynamic dispatch.
type IClassImplementsInterfacesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllTypeIdentifier() []ITypeIdentifierContext
	TypeIdentifier(i int) ITypeIdentifierContext

	// IsClassImplementsInterfacesContext differentiates from other interfaces.
	IsClassImplementsInterfacesContext()
}

type ClassImplementsInterfacesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassImplementsInterfacesContext() *ClassImplementsInterfacesContext {
	var p = new(ClassImplementsInterfacesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classImplementsInterfaces
	return p
}

func InitEmptyClassImplementsInterfacesContext(p *ClassImplementsInterfacesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classImplementsInterfaces
}

func (*ClassImplementsInterfacesContext) IsClassImplementsInterfacesContext() {}

func NewClassImplementsInterfacesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassImplementsInterfacesContext {
	var p = new(ClassImplementsInterfacesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classImplementsInterfaces

	return p
}

func (s *ClassImplementsInterfacesContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassImplementsInterfacesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ClassImplementsInterfacesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ClassImplementsInterfacesContext) AllTypeIdentifier() []ITypeIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			len++
		}
	}

	tst := make([]ITypeIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeIdentifierContext); ok {
			tst[i] = t.(ITypeIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ClassImplementsInterfacesContext) TypeIdentifier(i int) ITypeIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ClassImplementsInterfacesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassImplementsInterfacesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassImplementsInterfacesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassImplementsInterfaces(s)
	}
}

func (s *ClassImplementsInterfacesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassImplementsInterfaces(s)
	}
}

func (s *ClassImplementsInterfacesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassImplementsInterfaces(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassImplementsInterfaces() (localctx IClassImplementsInterfacesContext) {
	localctx = NewClassImplementsInterfacesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, pascalParserRULE_classImplementsInterfaces)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(512)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(508)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(509)
			p.TypeIdentifier()
		}

		p.SetState(514)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassPrivateDeclaration() IClassPrivateDeclarationContext
	ClassStrictPrivateDeclaration() IClassStrictPrivateDeclarationContext
	ClassProtectedDeclaration() IClassProtectedDeclarationContext
	ClassStrictProtectedDeclaration() IClassStrictProtectedDeclarationContext
	ClassPublicDeclaration() IClassPublicDeclarationContext
	ClassPublishedDeclaration() IClassPublishedDeclarationContext

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classDeclaration
	return p
}

func InitEmptyClassDeclarationContext(p *ClassDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classDeclaration
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) ClassPrivateDeclaration() IClassPrivateDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassPrivateDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassPrivateDeclarationContext)
}

func (s *ClassDeclarationContext) ClassStrictPrivateDeclaration() IClassStrictPrivateDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassStrictPrivateDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassStrictPrivateDeclarationContext)
}

func (s *ClassDeclarationContext) ClassProtectedDeclaration() IClassProtectedDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassProtectedDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassProtectedDeclarationContext)
}

func (s *ClassDeclarationContext) ClassStrictProtectedDeclaration() IClassStrictProtectedDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassStrictProtectedDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassStrictProtectedDeclarationContext)
}

func (s *ClassDeclarationContext) ClassPublicDeclaration() IClassPublicDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassPublicDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassPublicDeclarationContext)
}

func (s *ClassDeclarationContext) ClassPublishedDeclaration() IClassPublishedDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassPublishedDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassPublishedDeclarationContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, pascalParserRULE_classDeclaration)
	p.SetState(521)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserPRIVATE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(515)
			p.ClassPrivateDeclaration()
		}

	case pascalParserSTRICTPRIVATE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(516)
			p.ClassStrictPrivateDeclaration()
		}

	case pascalParserPROTECTED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(517)
			p.ClassProtectedDeclaration()
		}

	case pascalParserSTRICTPROTECTED:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(518)
			p.ClassStrictProtectedDeclaration()
		}

	case pascalParserPUBLIC:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(519)
			p.ClassPublicDeclaration()
		}

	case pascalParserPUBLISHED:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(520)
			p.ClassPublishedDeclaration()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassPrivateDeclarationContext is an interface to support dynamic dispatch.
type IClassPrivateDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRIVATE() antlr.TerminalNode
	AllClassDeclarationPart() []IClassDeclarationPartContext
	ClassDeclarationPart(i int) IClassDeclarationPartContext

	// IsClassPrivateDeclarationContext differentiates from other interfaces.
	IsClassPrivateDeclarationContext()
}

type ClassPrivateDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassPrivateDeclarationContext() *ClassPrivateDeclarationContext {
	var p = new(ClassPrivateDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classPrivateDeclaration
	return p
}

func InitEmptyClassPrivateDeclarationContext(p *ClassPrivateDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classPrivateDeclaration
}

func (*ClassPrivateDeclarationContext) IsClassPrivateDeclarationContext() {}

func NewClassPrivateDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassPrivateDeclarationContext {
	var p = new(ClassPrivateDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classPrivateDeclaration

	return p
}

func (s *ClassPrivateDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassPrivateDeclarationContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(pascalParserPRIVATE, 0)
}

func (s *ClassPrivateDeclarationContext) AllClassDeclarationPart() []IClassDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IClassDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassDeclarationPartContext); ok {
			tst[i] = t.(IClassDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ClassPrivateDeclarationContext) ClassDeclarationPart(i int) IClassDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationPartContext)
}

func (s *ClassPrivateDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassPrivateDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassPrivateDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassPrivateDeclaration(s)
	}
}

func (s *ClassPrivateDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassPrivateDeclaration(s)
	}
}

func (s *ClassPrivateDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassPrivateDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassPrivateDeclaration() (localctx IClassPrivateDeclarationContext) {
	localctx = NewClassPrivateDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, pascalParserRULE_classPrivateDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(523)
		p.Match(pascalParserPRIVATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(527)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&68987977984) != 0) || ((int64((_la-82)) & ^0x3f) == 0 && ((int64(1)<<(_la-82))&135004183) != 0) {
		{
			p.SetState(524)
			p.ClassDeclarationPart()
		}

		p.SetState(529)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassStrictPrivateDeclarationContext is an interface to support dynamic dispatch.
type IClassStrictPrivateDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRICTPRIVATE() antlr.TerminalNode
	AllClassDeclarationPart() []IClassDeclarationPartContext
	ClassDeclarationPart(i int) IClassDeclarationPartContext

	// IsClassStrictPrivateDeclarationContext differentiates from other interfaces.
	IsClassStrictPrivateDeclarationContext()
}

type ClassStrictPrivateDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassStrictPrivateDeclarationContext() *ClassStrictPrivateDeclarationContext {
	var p = new(ClassStrictPrivateDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classStrictPrivateDeclaration
	return p
}

func InitEmptyClassStrictPrivateDeclarationContext(p *ClassStrictPrivateDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classStrictPrivateDeclaration
}

func (*ClassStrictPrivateDeclarationContext) IsClassStrictPrivateDeclarationContext() {}

func NewClassStrictPrivateDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassStrictPrivateDeclarationContext {
	var p = new(ClassStrictPrivateDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classStrictPrivateDeclaration

	return p
}

func (s *ClassStrictPrivateDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassStrictPrivateDeclarationContext) STRICTPRIVATE() antlr.TerminalNode {
	return s.GetToken(pascalParserSTRICTPRIVATE, 0)
}

func (s *ClassStrictPrivateDeclarationContext) AllClassDeclarationPart() []IClassDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IClassDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassDeclarationPartContext); ok {
			tst[i] = t.(IClassDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ClassStrictPrivateDeclarationContext) ClassDeclarationPart(i int) IClassDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationPartContext)
}

func (s *ClassStrictPrivateDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassStrictPrivateDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassStrictPrivateDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassStrictPrivateDeclaration(s)
	}
}

func (s *ClassStrictPrivateDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassStrictPrivateDeclaration(s)
	}
}

func (s *ClassStrictPrivateDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassStrictPrivateDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassStrictPrivateDeclaration() (localctx IClassStrictPrivateDeclarationContext) {
	localctx = NewClassStrictPrivateDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, pascalParserRULE_classStrictPrivateDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(530)
		p.Match(pascalParserSTRICTPRIVATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(534)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&68987977984) != 0) || ((int64((_la-82)) & ^0x3f) == 0 && ((int64(1)<<(_la-82))&135004183) != 0) {
		{
			p.SetState(531)
			p.ClassDeclarationPart()
		}

		p.SetState(536)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassProtectedDeclarationContext is an interface to support dynamic dispatch.
type IClassProtectedDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROTECTED() antlr.TerminalNode
	AllClassDeclarationPart() []IClassDeclarationPartContext
	ClassDeclarationPart(i int) IClassDeclarationPartContext

	// IsClassProtectedDeclarationContext differentiates from other interfaces.
	IsClassProtectedDeclarationContext()
}

type ClassProtectedDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassProtectedDeclarationContext() *ClassProtectedDeclarationContext {
	var p = new(ClassProtectedDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classProtectedDeclaration
	return p
}

func InitEmptyClassProtectedDeclarationContext(p *ClassProtectedDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classProtectedDeclaration
}

func (*ClassProtectedDeclarationContext) IsClassProtectedDeclarationContext() {}

func NewClassProtectedDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassProtectedDeclarationContext {
	var p = new(ClassProtectedDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classProtectedDeclaration

	return p
}

func (s *ClassProtectedDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassProtectedDeclarationContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(pascalParserPROTECTED, 0)
}

func (s *ClassProtectedDeclarationContext) AllClassDeclarationPart() []IClassDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IClassDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassDeclarationPartContext); ok {
			tst[i] = t.(IClassDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ClassProtectedDeclarationContext) ClassDeclarationPart(i int) IClassDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationPartContext)
}

func (s *ClassProtectedDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassProtectedDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassProtectedDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassProtectedDeclaration(s)
	}
}

func (s *ClassProtectedDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassProtectedDeclaration(s)
	}
}

func (s *ClassProtectedDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassProtectedDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassProtectedDeclaration() (localctx IClassProtectedDeclarationContext) {
	localctx = NewClassProtectedDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, pascalParserRULE_classProtectedDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(537)
		p.Match(pascalParserPROTECTED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(541)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&68987977984) != 0) || ((int64((_la-82)) & ^0x3f) == 0 && ((int64(1)<<(_la-82))&135004183) != 0) {
		{
			p.SetState(538)
			p.ClassDeclarationPart()
		}

		p.SetState(543)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassStrictProtectedDeclarationContext is an interface to support dynamic dispatch.
type IClassStrictProtectedDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRICTPROTECTED() antlr.TerminalNode
	AllClassDeclarationPart() []IClassDeclarationPartContext
	ClassDeclarationPart(i int) IClassDeclarationPartContext

	// IsClassStrictProtectedDeclarationContext differentiates from other interfaces.
	IsClassStrictProtectedDeclarationContext()
}

type ClassStrictProtectedDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassStrictProtectedDeclarationContext() *ClassStrictProtectedDeclarationContext {
	var p = new(ClassStrictProtectedDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classStrictProtectedDeclaration
	return p
}

func InitEmptyClassStrictProtectedDeclarationContext(p *ClassStrictProtectedDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classStrictProtectedDeclaration
}

func (*ClassStrictProtectedDeclarationContext) IsClassStrictProtectedDeclarationContext() {}

func NewClassStrictProtectedDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassStrictProtectedDeclarationContext {
	var p = new(ClassStrictProtectedDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classStrictProtectedDeclaration

	return p
}

func (s *ClassStrictProtectedDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassStrictProtectedDeclarationContext) STRICTPROTECTED() antlr.TerminalNode {
	return s.GetToken(pascalParserSTRICTPROTECTED, 0)
}

func (s *ClassStrictProtectedDeclarationContext) AllClassDeclarationPart() []IClassDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IClassDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassDeclarationPartContext); ok {
			tst[i] = t.(IClassDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ClassStrictProtectedDeclarationContext) ClassDeclarationPart(i int) IClassDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationPartContext)
}

func (s *ClassStrictProtectedDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassStrictProtectedDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassStrictProtectedDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassStrictProtectedDeclaration(s)
	}
}

func (s *ClassStrictProtectedDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassStrictProtectedDeclaration(s)
	}
}

func (s *ClassStrictProtectedDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassStrictProtectedDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassStrictProtectedDeclaration() (localctx IClassStrictProtectedDeclarationContext) {
	localctx = NewClassStrictProtectedDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, pascalParserRULE_classStrictProtectedDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(544)
		p.Match(pascalParserSTRICTPROTECTED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(548)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&68987977984) != 0) || ((int64((_la-82)) & ^0x3f) == 0 && ((int64(1)<<(_la-82))&135004183) != 0) {
		{
			p.SetState(545)
			p.ClassDeclarationPart()
		}

		p.SetState(550)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassPublicDeclarationContext is an interface to support dynamic dispatch.
type IClassPublicDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PUBLIC() antlr.TerminalNode
	AllClassDeclarationPart() []IClassDeclarationPartContext
	ClassDeclarationPart(i int) IClassDeclarationPartContext

	// IsClassPublicDeclarationContext differentiates from other interfaces.
	IsClassPublicDeclarationContext()
}

type ClassPublicDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassPublicDeclarationContext() *ClassPublicDeclarationContext {
	var p = new(ClassPublicDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classPublicDeclaration
	return p
}

func InitEmptyClassPublicDeclarationContext(p *ClassPublicDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classPublicDeclaration
}

func (*ClassPublicDeclarationContext) IsClassPublicDeclarationContext() {}

func NewClassPublicDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassPublicDeclarationContext {
	var p = new(ClassPublicDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classPublicDeclaration

	return p
}

func (s *ClassPublicDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassPublicDeclarationContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLIC, 0)
}

func (s *ClassPublicDeclarationContext) AllClassDeclarationPart() []IClassDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IClassDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassDeclarationPartContext); ok {
			tst[i] = t.(IClassDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ClassPublicDeclarationContext) ClassDeclarationPart(i int) IClassDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationPartContext)
}

func (s *ClassPublicDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassPublicDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassPublicDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassPublicDeclaration(s)
	}
}

func (s *ClassPublicDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassPublicDeclaration(s)
	}
}

func (s *ClassPublicDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassPublicDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassPublicDeclaration() (localctx IClassPublicDeclarationContext) {
	localctx = NewClassPublicDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, pascalParserRULE_classPublicDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(551)
		p.Match(pascalParserPUBLIC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(555)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&68987977984) != 0) || ((int64((_la-82)) & ^0x3f) == 0 && ((int64(1)<<(_la-82))&135004183) != 0) {
		{
			p.SetState(552)
			p.ClassDeclarationPart()
		}

		p.SetState(557)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassPublishedDeclarationContext is an interface to support dynamic dispatch.
type IClassPublishedDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PUBLISHED() antlr.TerminalNode
	AllClassDeclarationPart() []IClassDeclarationPartContext
	ClassDeclarationPart(i int) IClassDeclarationPartContext

	// IsClassPublishedDeclarationContext differentiates from other interfaces.
	IsClassPublishedDeclarationContext()
}

type ClassPublishedDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassPublishedDeclarationContext() *ClassPublishedDeclarationContext {
	var p = new(ClassPublishedDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classPublishedDeclaration
	return p
}

func InitEmptyClassPublishedDeclarationContext(p *ClassPublishedDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classPublishedDeclaration
}

func (*ClassPublishedDeclarationContext) IsClassPublishedDeclarationContext() {}

func NewClassPublishedDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassPublishedDeclarationContext {
	var p = new(ClassPublishedDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classPublishedDeclaration

	return p
}

func (s *ClassPublishedDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassPublishedDeclarationContext) PUBLISHED() antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLISHED, 0)
}

func (s *ClassPublishedDeclarationContext) AllClassDeclarationPart() []IClassDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IClassDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassDeclarationPartContext); ok {
			tst[i] = t.(IClassDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ClassPublishedDeclarationContext) ClassDeclarationPart(i int) IClassDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationPartContext)
}

func (s *ClassPublishedDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassPublishedDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassPublishedDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassPublishedDeclaration(s)
	}
}

func (s *ClassPublishedDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassPublishedDeclaration(s)
	}
}

func (s *ClassPublishedDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassPublishedDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassPublishedDeclaration() (localctx IClassPublishedDeclarationContext) {
	localctx = NewClassPublishedDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, pascalParserRULE_classPublishedDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(558)
		p.Match(pascalParserPUBLISHED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(562)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&68987977984) != 0) || ((int64((_la-82)) & ^0x3f) == 0 && ((int64(1)<<(_la-82))&135004183) != 0) {
		{
			p.SetState(559)
			p.ClassDeclarationPart()
		}

		p.SetState(564)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassImplicitPublishedDeclarationContext is an interface to support dynamic dispatch.
type IClassImplicitPublishedDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllClassDeclarationPart() []IClassDeclarationPartContext
	ClassDeclarationPart(i int) IClassDeclarationPartContext

	// IsClassImplicitPublishedDeclarationContext differentiates from other interfaces.
	IsClassImplicitPublishedDeclarationContext()
}

type ClassImplicitPublishedDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassImplicitPublishedDeclarationContext() *ClassImplicitPublishedDeclarationContext {
	var p = new(ClassImplicitPublishedDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classImplicitPublishedDeclaration
	return p
}

func InitEmptyClassImplicitPublishedDeclarationContext(p *ClassImplicitPublishedDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classImplicitPublishedDeclaration
}

func (*ClassImplicitPublishedDeclarationContext) IsClassImplicitPublishedDeclarationContext() {}

func NewClassImplicitPublishedDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassImplicitPublishedDeclarationContext {
	var p = new(ClassImplicitPublishedDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classImplicitPublishedDeclaration

	return p
}

func (s *ClassImplicitPublishedDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassImplicitPublishedDeclarationContext) AllClassDeclarationPart() []IClassDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IClassDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassDeclarationPartContext); ok {
			tst[i] = t.(IClassDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ClassImplicitPublishedDeclarationContext) ClassDeclarationPart(i int) IClassDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationPartContext)
}

func (s *ClassImplicitPublishedDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassImplicitPublishedDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassImplicitPublishedDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassImplicitPublishedDeclaration(s)
	}
}

func (s *ClassImplicitPublishedDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassImplicitPublishedDeclaration(s)
	}
}

func (s *ClassImplicitPublishedDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassImplicitPublishedDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassImplicitPublishedDeclaration() (localctx IClassImplicitPublishedDeclarationContext) {
	localctx = NewClassImplicitPublishedDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, pascalParserRULE_classImplicitPublishedDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(568)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&68987977984) != 0) || ((int64((_la-82)) & ^0x3f) == 0 && ((int64(1)<<(_la-82))&135004183) != 0) {
		{
			p.SetState(565)
			p.ClassDeclarationPart()
		}

		p.SetState(570)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassDeclarationPartContext is an interface to support dynamic dispatch.
type IClassDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierList() IIdentifierListContext
	COLON() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	TypeDefinitionPart() ITypeDefinitionPartContext
	ConstantDefinitionPart() IConstantDefinitionPartContext
	FUNCTION() antlr.TerminalNode
	Identifier() IIdentifierContext
	ResultType() IResultTypeContext
	ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext
	FormalParameterList() IFormalParameterListContext
	PROCEDURE() antlr.TerminalNode
	CONSTRUCTOR() antlr.TerminalNode
	DESTRUCTOR() antlr.TerminalNode
	PropertyDeclaration() IPropertyDeclarationContext
	DEFAULT() antlr.TerminalNode

	// IsClassDeclarationPartContext differentiates from other interfaces.
	IsClassDeclarationPartContext()
}

type ClassDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationPartContext() *ClassDeclarationPartContext {
	var p = new(ClassDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classDeclarationPart
	return p
}

func InitEmptyClassDeclarationPartContext(p *ClassDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classDeclarationPart
}

func (*ClassDeclarationPartContext) IsClassDeclarationPartContext() {}

func NewClassDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationPartContext {
	var p = new(ClassDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classDeclarationPart

	return p
}

func (s *ClassDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationPartContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ClassDeclarationPartContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *ClassDeclarationPartContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ClassDeclarationPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ClassDeclarationPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ClassDeclarationPartContext) TypeDefinitionPart() ITypeDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionPartContext)
}

func (s *ClassDeclarationPartContext) ConstantDefinitionPart() IConstantDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *ClassDeclarationPartContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(pascalParserFUNCTION, 0)
}

func (s *ClassDeclarationPartContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassDeclarationPartContext) ResultType() IResultTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultTypeContext)
}

func (s *ClassDeclarationPartContext) ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderModifiersContext)
}

func (s *ClassDeclarationPartContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ClassDeclarationPartContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(pascalParserPROCEDURE, 0)
}

func (s *ClassDeclarationPartContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(pascalParserCONSTRUCTOR, 0)
}

func (s *ClassDeclarationPartContext) DESTRUCTOR() antlr.TerminalNode {
	return s.GetToken(pascalParserDESTRUCTOR, 0)
}

func (s *ClassDeclarationPartContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *ClassDeclarationPartContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *ClassDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassDeclarationPart(s)
	}
}

func (s *ClassDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassDeclarationPart(s)
	}
}

func (s *ClassDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassDeclarationPart() (localctx IClassDeclarationPartContext) {
	localctx = NewClassDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, pascalParserRULE_classDeclarationPart)
	var _la int

	p.SetState(602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(571)
			p.IdentifierList()
		}
		{
			p.SetState(572)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(573)
			p.TypeIdentifier()
		}
		{
			p.SetState(574)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case pascalParserTYPE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(576)
			p.TypeDefinitionPart()
		}

	case pascalParserCONST:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(577)
			p.ConstantDefinitionPart()
		}

	case pascalParserFUNCTION:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(578)
			p.Match(pascalParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(579)
			p.Identifier()
		}
		p.SetState(581)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLPAREN {
			{
				p.SetState(580)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(583)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(584)
			p.ResultType()
		}
		{
			p.SetState(585)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(586)
			p.ProcedureOrFunctionHeaderModifiers()
		}

	case pascalParserPROCEDURE, pascalParserCONSTRUCTOR, pascalParserDESTRUCTOR:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(588)
			_la = p.GetTokenStream().LA(1)

			if !(_la == pascalParserPROCEDURE || _la == pascalParserCONSTRUCTOR || _la == pascalParserDESTRUCTOR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(589)
			p.Identifier()
		}
		p.SetState(591)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLPAREN {
			{
				p.SetState(590)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(593)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(594)
			p.ProcedureOrFunctionHeaderModifiers()
		}

	case pascalParserPROPERTY:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(596)
			p.PropertyDeclaration()
		}
		{
			p.SetState(597)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(600)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserDEFAULT {
			{
				p.SetState(598)
				p.Match(pascalParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(599)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyDeclarationContext is an interface to support dynamic dispatch.
type IPropertyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROPERTY() antlr.TerminalNode
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	PropertyIndexParameters() IPropertyIndexParametersContext
	PropertyReadDeclaration() IPropertyReadDeclarationContext
	PropertyWriteDeclaration() IPropertyWriteDeclarationContext
	PropertyDefaultValueDeclaration() IPropertyDefaultValueDeclarationContext
	PropertyIndexDeclaration() IPropertyIndexDeclarationContext

	// IsPropertyDeclarationContext differentiates from other interfaces.
	IsPropertyDeclarationContext()
}

type PropertyDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDeclarationContext() *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDeclaration
	return p
}

func InitEmptyPropertyDeclarationContext(p *PropertyDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDeclaration
}

func (*PropertyDeclarationContext) IsPropertyDeclarationContext() {}

func NewPropertyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyDeclaration

	return p
}

func (s *PropertyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDeclarationContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(pascalParserPROPERTY, 0)
}

func (s *PropertyDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *PropertyDeclarationContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *PropertyDeclarationContext) PropertyIndexParameters() IPropertyIndexParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyIndexParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyIndexParametersContext)
}

func (s *PropertyDeclarationContext) PropertyReadDeclaration() IPropertyReadDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyReadDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyReadDeclarationContext)
}

func (s *PropertyDeclarationContext) PropertyWriteDeclaration() IPropertyWriteDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyWriteDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyWriteDeclarationContext)
}

func (s *PropertyDeclarationContext) PropertyDefaultValueDeclaration() IPropertyDefaultValueDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDefaultValueDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDefaultValueDeclarationContext)
}

func (s *PropertyDeclarationContext) PropertyIndexDeclaration() IPropertyIndexDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyIndexDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyIndexDeclarationContext)
}

func (s *PropertyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyDeclaration(s)
	}
}

func (s *PropertyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyDeclaration(s)
	}
}

func (s *PropertyDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyDeclaration() (localctx IPropertyDeclarationContext) {
	localctx = NewPropertyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, pascalParserRULE_propertyDeclaration)
	var _la int

	p.SetState(628)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(604)
			p.Match(pascalParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(605)
			p.Identifier()
		}
		p.SetState(607)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(606)
				p.PropertyIndexParameters()
			}

		}
		{
			p.SetState(609)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(610)
			p.TypeIdentifier()
		}
		p.SetState(612)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserREAD {
			{
				p.SetState(611)
				p.PropertyReadDeclaration()
			}

		}
		p.SetState(615)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserWRITE {
			{
				p.SetState(614)
				p.PropertyWriteDeclaration()
			}

		}
		p.SetState(618)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserDEFAULT {
			{
				p.SetState(617)
				p.PropertyDefaultValueDeclaration()
			}

		}
		p.SetState(621)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserINDEX {
			{
				p.SetState(620)
				p.PropertyIndexDeclaration()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(623)
			p.Match(pascalParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(624)
			p.Identifier()
		}
		p.SetState(626)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserDEFAULT {
			{
				p.SetState(625)
				p.PropertyDefaultValueDeclaration()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyReadDeclarationContext is an interface to support dynamic dispatch.
type IPropertyReadDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsPropertyReadDeclarationContext differentiates from other interfaces.
	IsPropertyReadDeclarationContext()
}

type PropertyReadDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyReadDeclarationContext() *PropertyReadDeclarationContext {
	var p = new(PropertyReadDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyReadDeclaration
	return p
}

func InitEmptyPropertyReadDeclarationContext(p *PropertyReadDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyReadDeclaration
}

func (*PropertyReadDeclarationContext) IsPropertyReadDeclarationContext() {}

func NewPropertyReadDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyReadDeclarationContext {
	var p = new(PropertyReadDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyReadDeclaration

	return p
}

func (s *PropertyReadDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyReadDeclarationContext) READ() antlr.TerminalNode {
	return s.GetToken(pascalParserREAD, 0)
}

func (s *PropertyReadDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyReadDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyReadDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyReadDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyReadDeclaration(s)
	}
}

func (s *PropertyReadDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyReadDeclaration(s)
	}
}

func (s *PropertyReadDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyReadDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyReadDeclaration() (localctx IPropertyReadDeclarationContext) {
	localctx = NewPropertyReadDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, pascalParserRULE_propertyReadDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(630)
		p.Match(pascalParserREAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(631)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyWriteDeclarationContext is an interface to support dynamic dispatch.
type IPropertyWriteDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WRITE() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsPropertyWriteDeclarationContext differentiates from other interfaces.
	IsPropertyWriteDeclarationContext()
}

type PropertyWriteDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyWriteDeclarationContext() *PropertyWriteDeclarationContext {
	var p = new(PropertyWriteDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyWriteDeclaration
	return p
}

func InitEmptyPropertyWriteDeclarationContext(p *PropertyWriteDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyWriteDeclaration
}

func (*PropertyWriteDeclarationContext) IsPropertyWriteDeclarationContext() {}

func NewPropertyWriteDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyWriteDeclarationContext {
	var p = new(PropertyWriteDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyWriteDeclaration

	return p
}

func (s *PropertyWriteDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyWriteDeclarationContext) WRITE() antlr.TerminalNode {
	return s.GetToken(pascalParserWRITE, 0)
}

func (s *PropertyWriteDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyWriteDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyWriteDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyWriteDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyWriteDeclaration(s)
	}
}

func (s *PropertyWriteDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyWriteDeclaration(s)
	}
}

func (s *PropertyWriteDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyWriteDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyWriteDeclaration() (localctx IPropertyWriteDeclarationContext) {
	localctx = NewPropertyWriteDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, pascalParserRULE_propertyWriteDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(633)
		p.Match(pascalParserWRITE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(634)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyDefaultValueDeclarationContext is an interface to support dynamic dispatch.
type IPropertyDefaultValueDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	Expression() IExpressionContext

	// IsPropertyDefaultValueDeclarationContext differentiates from other interfaces.
	IsPropertyDefaultValueDeclarationContext()
}

type PropertyDefaultValueDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDefaultValueDeclarationContext() *PropertyDefaultValueDeclarationContext {
	var p = new(PropertyDefaultValueDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDefaultValueDeclaration
	return p
}

func InitEmptyPropertyDefaultValueDeclarationContext(p *PropertyDefaultValueDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDefaultValueDeclaration
}

func (*PropertyDefaultValueDeclarationContext) IsPropertyDefaultValueDeclarationContext() {}

func NewPropertyDefaultValueDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDefaultValueDeclarationContext {
	var p = new(PropertyDefaultValueDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyDefaultValueDeclaration

	return p
}

func (s *PropertyDefaultValueDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDefaultValueDeclarationContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *PropertyDefaultValueDeclarationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PropertyDefaultValueDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDefaultValueDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyDefaultValueDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyDefaultValueDeclaration(s)
	}
}

func (s *PropertyDefaultValueDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyDefaultValueDeclaration(s)
	}
}

func (s *PropertyDefaultValueDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyDefaultValueDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyDefaultValueDeclaration() (localctx IPropertyDefaultValueDeclarationContext) {
	localctx = NewPropertyDefaultValueDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, pascalParserRULE_propertyDefaultValueDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(636)
		p.Match(pascalParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(637)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyIndexDeclarationContext is an interface to support dynamic dispatch.
type IPropertyIndexDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INDEX() antlr.TerminalNode
	UnsignedNumber() IUnsignedNumberContext

	// IsPropertyIndexDeclarationContext differentiates from other interfaces.
	IsPropertyIndexDeclarationContext()
}

type PropertyIndexDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyIndexDeclarationContext() *PropertyIndexDeclarationContext {
	var p = new(PropertyIndexDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexDeclaration
	return p
}

func InitEmptyPropertyIndexDeclarationContext(p *PropertyIndexDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexDeclaration
}

func (*PropertyIndexDeclarationContext) IsPropertyIndexDeclarationContext() {}

func NewPropertyIndexDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyIndexDeclarationContext {
	var p = new(PropertyIndexDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyIndexDeclaration

	return p
}

func (s *PropertyIndexDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyIndexDeclarationContext) INDEX() antlr.TerminalNode {
	return s.GetToken(pascalParserINDEX, 0)
}

func (s *PropertyIndexDeclarationContext) UnsignedNumber() IUnsignedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedNumberContext)
}

func (s *PropertyIndexDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyIndexDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyIndexDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyIndexDeclaration(s)
	}
}

func (s *PropertyIndexDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyIndexDeclaration(s)
	}
}

func (s *PropertyIndexDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyIndexDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyIndexDeclaration() (localctx IPropertyIndexDeclarationContext) {
	localctx = NewPropertyIndexDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, pascalParserRULE_propertyIndexDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(639)
		p.Match(pascalParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(640)
		p.UnsignedNumber()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyIndexParametersContext is an interface to support dynamic dispatch.
type IPropertyIndexParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	PropertyIndexParametersList() IPropertyIndexParametersListContext
	RBRACK() antlr.TerminalNode

	// IsPropertyIndexParametersContext differentiates from other interfaces.
	IsPropertyIndexParametersContext()
}

type PropertyIndexParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyIndexParametersContext() *PropertyIndexParametersContext {
	var p = new(PropertyIndexParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexParameters
	return p
}

func InitEmptyPropertyIndexParametersContext(p *PropertyIndexParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexParameters
}

func (*PropertyIndexParametersContext) IsPropertyIndexParametersContext() {}

func NewPropertyIndexParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyIndexParametersContext {
	var p = new(PropertyIndexParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyIndexParameters

	return p
}

func (s *PropertyIndexParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyIndexParametersContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *PropertyIndexParametersContext) PropertyIndexParametersList() IPropertyIndexParametersListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyIndexParametersListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyIndexParametersListContext)
}

func (s *PropertyIndexParametersContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *PropertyIndexParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyIndexParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyIndexParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyIndexParameters(s)
	}
}

func (s *PropertyIndexParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyIndexParameters(s)
	}
}

func (s *PropertyIndexParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyIndexParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyIndexParameters() (localctx IPropertyIndexParametersContext) {
	localctx = NewPropertyIndexParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, pascalParserRULE_propertyIndexParameters)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(642)
		p.Match(pascalParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(643)
		p.PropertyIndexParametersList()
	}
	{
		p.SetState(644)
		p.Match(pascalParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyIndexParametersListContext is an interface to support dynamic dispatch.
type IPropertyIndexParametersListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierList() []IIdentifierListContext
	IdentifierList(i int) IIdentifierListContext
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllIndexType() []IIndexTypeContext
	IndexType(i int) IIndexTypeContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsPropertyIndexParametersListContext differentiates from other interfaces.
	IsPropertyIndexParametersListContext()
}

type PropertyIndexParametersListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyIndexParametersListContext() *PropertyIndexParametersListContext {
	var p = new(PropertyIndexParametersListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexParametersList
	return p
}

func InitEmptyPropertyIndexParametersListContext(p *PropertyIndexParametersListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexParametersList
}

func (*PropertyIndexParametersListContext) IsPropertyIndexParametersListContext() {}

func NewPropertyIndexParametersListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyIndexParametersListContext {
	var p = new(PropertyIndexParametersListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyIndexParametersList

	return p
}

func (s *PropertyIndexParametersListContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyIndexParametersListContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *PropertyIndexParametersListContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PropertyIndexParametersListContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOLON)
}

func (s *PropertyIndexParametersListContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, i)
}

func (s *PropertyIndexParametersListContext) AllIndexType() []IIndexTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexTypeContext); ok {
			len++
		}
	}

	tst := make([]IIndexTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexTypeContext); ok {
			tst[i] = t.(IIndexTypeContext)
			i++
		}
	}

	return tst
}

func (s *PropertyIndexParametersListContext) IndexType(i int) IIndexTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *PropertyIndexParametersListContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *PropertyIndexParametersListContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *PropertyIndexParametersListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyIndexParametersListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyIndexParametersListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyIndexParametersList(s)
	}
}

func (s *PropertyIndexParametersListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyIndexParametersList(s)
	}
}

func (s *PropertyIndexParametersListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyIndexParametersList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyIndexParametersList() (localctx IPropertyIndexParametersListContext) {
	localctx = NewPropertyIndexParametersListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, pascalParserRULE_propertyIndexParametersList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(646)
		p.IdentifierList()
	}
	{
		p.SetState(647)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(648)
		p.IndexType()
	}
	p.SetState(656)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserSEMI {
		{
			p.SetState(649)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(650)
			p.IdentifierList()
		}
		{
			p.SetState(651)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(652)
			p.IndexType()
		}

		p.SetState(658)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodIdentifierContext is an interface to support dynamic dispatch.
type IMethodIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AllTypeIdentifier() []ITypeIdentifierContext
	TypeIdentifier(i int) ITypeIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsMethodIdentifierContext differentiates from other interfaces.
	IsMethodIdentifierContext()
}

type MethodIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodIdentifierContext() *MethodIdentifierContext {
	var p = new(MethodIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_methodIdentifier
	return p
}

func InitEmptyMethodIdentifierContext(p *MethodIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_methodIdentifier
}

func (*MethodIdentifierContext) IsMethodIdentifierContext() {}

func NewMethodIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodIdentifierContext {
	var p = new(MethodIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_methodIdentifier

	return p
}

func (s *MethodIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MethodIdentifierContext) AllTypeIdentifier() []ITypeIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			len++
		}
	}

	tst := make([]ITypeIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeIdentifierContext); ok {
			tst[i] = t.(ITypeIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *MethodIdentifierContext) TypeIdentifier(i int) ITypeIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *MethodIdentifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDOT)
}

func (s *MethodIdentifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, i)
}

func (s *MethodIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterMethodIdentifier(s)
	}
}

func (s *MethodIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitMethodIdentifier(s)
	}
}

func (s *MethodIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitMethodIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) MethodIdentifier() (localctx IMethodIdentifierContext) {
	localctx = NewMethodIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, pascalParserRULE_methodIdentifier)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(662)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(659)
				p.TypeIdentifier()
			}
			{
				p.SetState(660)
				p.Match(pascalParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(664)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(666)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_Context is an interface to support dynamic dispatch.
type IType_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleType() ISimpleTypeContext
	StructuredType() IStructuredTypeContext
	PointerType() IPointerTypeContext

	// IsType_Context differentiates from other interfaces.
	IsType_Context()
}

type Type_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_Context() *Type_Context {
	var p = new(Type_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_type_
	return p
}

func InitEmptyType_Context(p *Type_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_type_
}

func (*Type_Context) IsType_Context() {}

func NewType_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_Context {
	var p = new(Type_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_type_

	return p
}

func (s *Type_Context) GetParser() antlr.Parser { return s.parser }

func (s *Type_Context) SimpleType() ISimpleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeContext)
}

func (s *Type_Context) StructuredType() IStructuredTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructuredTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructuredTypeContext)
}

func (s *Type_Context) PointerType() IPointerTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerTypeContext)
}

func (s *Type_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterType_(s)
	}
}

func (s *Type_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitType_(s)
	}
}

func (s *Type_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitType_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Type_() (localctx IType_Context) {
	localctx = NewType_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, pascalParserRULE_type_)
	p.SetState(671)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserARRAY, pascalParserBOOLEAN, pascalParserCHAR, pascalParserCHR, pascalParserINTEGER, pascalParserREAL, pascalParserPLUS, pascalParserMINUS, pascalParserLPAREN, pascalParserLBRACK, pascalParserSTRING, pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT, pascalParserSTRING_LITERAL, pascalParserNUM_INT, pascalParserNUM_REAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(668)
			p.SimpleType()
		}

	case pascalParserFILE, pascalParserPACKED, pascalParserRECORD, pascalParserSET, pascalParserCLASS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(669)
			p.StructuredType()
		}

	case pascalParserPOINTER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(670)
			p.PointerType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleTypeContext is an interface to support dynamic dispatch.
type ISimpleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ScalarType() IScalarTypeContext
	SubrangeType() ISubrangeTypeContext
	TypeIdentifier() ITypeIdentifierContext
	Stringtype() IStringtypeContext

	// IsSimpleTypeContext differentiates from other interfaces.
	IsSimpleTypeContext()
}

type SimpleTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleTypeContext() *SimpleTypeContext {
	var p = new(SimpleTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleType
	return p
}

func InitEmptySimpleTypeContext(p *SimpleTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleType
}

func (*SimpleTypeContext) IsSimpleTypeContext() {}

func NewSimpleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleTypeContext {
	var p = new(SimpleTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_simpleType

	return p
}

func (s *SimpleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleTypeContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *SimpleTypeContext) SubrangeType() ISubrangeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubrangeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubrangeTypeContext)
}

func (s *SimpleTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *SimpleTypeContext) Stringtype() IStringtypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringtypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringtypeContext)
}

func (s *SimpleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSimpleType(s)
	}
}

func (s *SimpleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSimpleType(s)
	}
}

func (s *SimpleTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSimpleType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SimpleType() (localctx ISimpleTypeContext) {
	localctx = NewSimpleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, pascalParserRULE_simpleType)
	p.SetState(677)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(673)
			p.ScalarType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(674)
			p.SubrangeType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(675)
			p.TypeIdentifier()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(676)
			p.Stringtype()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScalarTypeContext is an interface to support dynamic dispatch.
type IScalarTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	RPAREN() antlr.TerminalNode

	// IsScalarTypeContext differentiates from other interfaces.
	IsScalarTypeContext()
}

type ScalarTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalarTypeContext() *ScalarTypeContext {
	var p = new(ScalarTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalarType
	return p
}

func InitEmptyScalarTypeContext(p *ScalarTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalarType
}

func (*ScalarTypeContext) IsScalarTypeContext() {}

func NewScalarTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalarTypeContext {
	var p = new(ScalarTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_scalarType

	return p
}

func (s *ScalarTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalarTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ScalarTypeContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ScalarTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ScalarTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalarTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterScalarType(s)
	}
}

func (s *ScalarTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitScalarType(s)
	}
}

func (s *ScalarTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitScalarType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ScalarType() (localctx IScalarTypeContext) {
	localctx = NewScalarTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, pascalParserRULE_scalarType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(679)
		p.Match(pascalParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(680)
		p.IdentifierList()
	}
	{
		p.SetState(681)
		p.Match(pascalParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubrangeTypeContext is an interface to support dynamic dispatch.
type ISubrangeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	DOTDOT() antlr.TerminalNode

	// IsSubrangeTypeContext differentiates from other interfaces.
	IsSubrangeTypeContext()
}

type SubrangeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubrangeTypeContext() *SubrangeTypeContext {
	var p = new(SubrangeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_subrangeType
	return p
}

func InitEmptySubrangeTypeContext(p *SubrangeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_subrangeType
}

func (*SubrangeTypeContext) IsSubrangeTypeContext() {}

func NewSubrangeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubrangeTypeContext {
	var p = new(SubrangeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_subrangeType

	return p
}

func (s *SubrangeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SubrangeTypeContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *SubrangeTypeContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *SubrangeTypeContext) DOTDOT() antlr.TerminalNode {
	return s.GetToken(pascalParserDOTDOT, 0)
}

func (s *SubrangeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubrangeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubrangeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSubrangeType(s)
	}
}

func (s *SubrangeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSubrangeType(s)
	}
}

func (s *SubrangeTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSubrangeType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SubrangeType() (localctx ISubrangeTypeContext) {
	localctx = NewSubrangeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, pascalParserRULE_subrangeType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(683)
		p.Constant()
	}
	{
		p.SetState(684)
		p.Match(pascalParserDOTDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(685)
		p.Constant()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeIdentifierContext is an interface to support dynamic dispatch.
type ITypeIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	CHAR() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	REAL() antlr.TerminalNode
	STRING() antlr.TerminalNode
	LT() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	GT() antlr.TerminalNode
	ArrayType() IArrayTypeContext

	// IsTypeIdentifierContext differentiates from other interfaces.
	IsTypeIdentifierContext()
}

type TypeIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeIdentifierContext() *TypeIdentifierContext {
	var p = new(TypeIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeIdentifier
	return p
}

func InitEmptyTypeIdentifierContext(p *TypeIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeIdentifier
}

func (*TypeIdentifierContext) IsTypeIdentifierContext() {}

func NewTypeIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeIdentifierContext {
	var p = new(TypeIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typeIdentifier

	return p
}

func (s *TypeIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeIdentifierContext) CHAR() antlr.TerminalNode {
	return s.GetToken(pascalParserCHAR, 0)
}

func (s *TypeIdentifierContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(pascalParserBOOLEAN, 0)
}

func (s *TypeIdentifierContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(pascalParserINTEGER, 0)
}

func (s *TypeIdentifierContext) REAL() antlr.TerminalNode {
	return s.GetToken(pascalParserREAL, 0)
}

func (s *TypeIdentifierContext) STRING() antlr.TerminalNode {
	return s.GetToken(pascalParserSTRING, 0)
}

func (s *TypeIdentifierContext) LT() antlr.TerminalNode {
	return s.GetToken(pascalParserLT, 0)
}

func (s *TypeIdentifierContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *TypeIdentifierContext) GT() antlr.TerminalNode {
	return s.GetToken(pascalParserGT, 0)
}

func (s *TypeIdentifierContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *TypeIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypeIdentifier(s)
	}
}

func (s *TypeIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypeIdentifier(s)
	}
}

func (s *TypeIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypeIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypeIdentifier() (localctx ITypeIdentifierContext) {
	localctx = NewTypeIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, pascalParserRULE_typeIdentifier)
	var _la int

	p.SetState(695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(687)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(688)
			_la = p.GetTokenStream().LA(1)

			if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1074790480) != 0) || _la == pascalParserSTRING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(689)
			p.Identifier()
		}
		{
			p.SetState(690)
			p.Match(pascalParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(691)
			p.TypeIdentifier()
		}
		{
			p.SetState(692)
			p.Match(pascalParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(694)
			p.ArrayType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructuredTypeContext is an interface to support dynamic dispatch.
type IStructuredTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PACKED() antlr.TerminalNode
	UnpackedStructuredType() IUnpackedStructuredTypeContext
	ClassType() IClassTypeContext

	// IsStructuredTypeContext differentiates from other interfaces.
	IsStructuredTypeContext()
}

type StructuredTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructuredTypeContext() *StructuredTypeContext {
	var p = new(StructuredTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_structuredType
	return p
}

func InitEmptyStructuredTypeContext(p *StructuredTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_structuredType
}

func (*StructuredTypeContext) IsStructuredTypeContext() {}

func NewStructuredTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructuredTypeContext {
	var p = new(StructuredTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_structuredType

	return p
}

func (s *StructuredTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StructuredTypeContext) PACKED() antlr.TerminalNode {
	return s.GetToken(pascalParserPACKED, 0)
}

func (s *StructuredTypeContext) UnpackedStructuredType() IUnpackedStructuredTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpackedStructuredTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpackedStructuredTypeContext)
}

func (s *StructuredTypeContext) ClassType() IClassTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTypeContext)
}

func (s *StructuredTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructuredTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructuredTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStructuredType(s)
	}
}

func (s *StructuredTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStructuredType(s)
	}
}

func (s *StructuredTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStructuredType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) StructuredType() (localctx IStructuredTypeContext) {
	localctx = NewStructuredTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, pascalParserRULE_structuredType)
	p.SetState(701)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserPACKED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(697)
			p.Match(pascalParserPACKED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(698)
			p.UnpackedStructuredType()
		}

	case pascalParserFILE, pascalParserRECORD, pascalParserSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(699)
			p.UnpackedStructuredType()
		}

	case pascalParserCLASS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(700)
			p.ClassType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpackedStructuredTypeContext is an interface to support dynamic dispatch.
type IUnpackedStructuredTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RecordType() IRecordTypeContext
	SetType() ISetTypeContext
	FileType() IFileTypeContext

	// IsUnpackedStructuredTypeContext differentiates from other interfaces.
	IsUnpackedStructuredTypeContext()
}

type UnpackedStructuredTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpackedStructuredTypeContext() *UnpackedStructuredTypeContext {
	var p = new(UnpackedStructuredTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unpackedStructuredType
	return p
}

func InitEmptyUnpackedStructuredTypeContext(p *UnpackedStructuredTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unpackedStructuredType
}

func (*UnpackedStructuredTypeContext) IsUnpackedStructuredTypeContext() {}

func NewUnpackedStructuredTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpackedStructuredTypeContext {
	var p = new(UnpackedStructuredTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unpackedStructuredType

	return p
}

func (s *UnpackedStructuredTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpackedStructuredTypeContext) RecordType() IRecordTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordTypeContext)
}

func (s *UnpackedStructuredTypeContext) SetType() ISetTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetTypeContext)
}

func (s *UnpackedStructuredTypeContext) FileType() IFileTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileTypeContext)
}

func (s *UnpackedStructuredTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpackedStructuredTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpackedStructuredTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnpackedStructuredType(s)
	}
}

func (s *UnpackedStructuredTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnpackedStructuredType(s)
	}
}

func (s *UnpackedStructuredTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnpackedStructuredType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnpackedStructuredType() (localctx IUnpackedStructuredTypeContext) {
	localctx = NewUnpackedStructuredTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, pascalParserRULE_unpackedStructuredType)
	p.SetState(706)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserRECORD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(703)
			p.RecordType()
		}

	case pascalParserSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(704)
			p.SetType()
		}

	case pascalParserFILE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(705)
			p.FileType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringtypeContext is an interface to support dynamic dispatch.
type IStringtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	Identifier() IIdentifierContext
	UnsignedNumber() IUnsignedNumberContext

	// IsStringtypeContext differentiates from other interfaces.
	IsStringtypeContext()
}

type StringtypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringtypeContext() *StringtypeContext {
	var p = new(StringtypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_stringtype
	return p
}

func InitEmptyStringtypeContext(p *StringtypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_stringtype
}

func (*StringtypeContext) IsStringtypeContext() {}

func NewStringtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringtypeContext {
	var p = new(StringtypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_stringtype

	return p
}

func (s *StringtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StringtypeContext) STRING() antlr.TerminalNode {
	return s.GetToken(pascalParserSTRING, 0)
}

func (s *StringtypeContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *StringtypeContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *StringtypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StringtypeContext) UnsignedNumber() IUnsignedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedNumberContext)
}

func (s *StringtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStringtype(s)
	}
}

func (s *StringtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStringtype(s)
	}
}

func (s *StringtypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStringtype(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Stringtype() (localctx IStringtypeContext) {
	localctx = NewStringtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, pascalParserRULE_stringtype)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(708)
		p.Match(pascalParserSTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(709)
		p.Match(pascalParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(712)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
		{
			p.SetState(710)
			p.Identifier()
		}

	case pascalParserNUM_INT, pascalParserNUM_REAL:
		{
			p.SetState(711)
			p.UnsignedNumber()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(714)
		p.Match(pascalParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY() antlr.TerminalNode
	LBRACK() antlr.TerminalNode
	TypeList() ITypeListContext
	RBRACK() antlr.TerminalNode
	OF() antlr.TerminalNode
	ComponentType() IComponentTypeContext
	LBRACK2() antlr.TerminalNode
	RBRACK2() antlr.TerminalNode
	CONST() antlr.TerminalNode

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_arrayType
	return p
}

func InitEmptyArrayTypeContext(p *ArrayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_arrayType
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(pascalParserARRAY, 0)
}

func (s *ArrayTypeContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *ArrayTypeContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *ArrayTypeContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *ArrayTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *ArrayTypeContext) ComponentType() IComponentTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComponentTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComponentTypeContext)
}

func (s *ArrayTypeContext) LBRACK2() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK2, 0)
}

func (s *ArrayTypeContext) RBRACK2() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK2, 0)
}

func (s *ArrayTypeContext) CONST() antlr.TerminalNode {
	return s.GetToken(pascalParserCONST, 0)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (s *ArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, pascalParserRULE_arrayType)
	p.SetState(736)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(716)
			p.Match(pascalParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(717)
			p.Match(pascalParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(718)
			p.TypeList()
		}
		{
			p.SetState(719)
			p.Match(pascalParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(720)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(721)
			p.ComponentType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(723)
			p.Match(pascalParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(724)
			p.Match(pascalParserLBRACK2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(725)
			p.TypeList()
		}
		{
			p.SetState(726)
			p.Match(pascalParserRBRACK2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(727)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(728)
			p.ComponentType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(730)
			p.Match(pascalParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(731)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(732)
			p.Match(pascalParserCONST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(733)
			p.Match(pascalParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(734)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(735)
			p.ComponentType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIndexType() []IIndexTypeContext
	IndexType(i int) IIndexTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeList
	return p
}

func InitEmptyTypeListContext(p *TypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeList
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllIndexType() []IIndexTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexTypeContext); ok {
			len++
		}
	}

	tst := make([]IIndexTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexTypeContext); ok {
			tst[i] = t.(IIndexTypeContext)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) IndexType(i int) IIndexTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *TypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *TypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypeList(s)
	}
}

func (s *TypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypeList(s)
	}
}

func (s *TypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, pascalParserRULE_typeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(738)
		p.IndexType()
	}
	p.SetState(743)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(739)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(740)
			p.IndexType()
		}

		p.SetState(745)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexTypeContext is an interface to support dynamic dispatch.
type IIndexTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleType() ISimpleTypeContext

	// IsIndexTypeContext differentiates from other interfaces.
	IsIndexTypeContext()
}

type IndexTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexTypeContext() *IndexTypeContext {
	var p = new(IndexTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_indexType
	return p
}

func InitEmptyIndexTypeContext(p *IndexTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_indexType
}

func (*IndexTypeContext) IsIndexTypeContext() {}

func NewIndexTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexTypeContext {
	var p = new(IndexTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_indexType

	return p
}

func (s *IndexTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexTypeContext) SimpleType() ISimpleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeContext)
}

func (s *IndexTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterIndexType(s)
	}
}

func (s *IndexTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitIndexType(s)
	}
}

func (s *IndexTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitIndexType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) IndexType() (localctx IIndexTypeContext) {
	localctx = NewIndexTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, pascalParserRULE_indexType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(746)
		p.SimpleType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComponentTypeContext is an interface to support dynamic dispatch.
type IComponentTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() IType_Context

	// IsComponentTypeContext differentiates from other interfaces.
	IsComponentTypeContext()
}

type ComponentTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentTypeContext() *ComponentTypeContext {
	var p = new(ComponentTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_componentType
	return p
}

func InitEmptyComponentTypeContext(p *ComponentTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_componentType
}

func (*ComponentTypeContext) IsComponentTypeContext() {}

func NewComponentTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentTypeContext {
	var p = new(ComponentTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_componentType

	return p
}

func (s *ComponentTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ComponentTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterComponentType(s)
	}
}

func (s *ComponentTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitComponentType(s)
	}
}

func (s *ComponentTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitComponentType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ComponentType() (localctx IComponentTypeContext) {
	localctx = NewComponentTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, pascalParserRULE_componentType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(748)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordTypeContext is an interface to support dynamic dispatch.
type IRecordTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RECORD() antlr.TerminalNode
	END() antlr.TerminalNode
	FieldList() IFieldListContext

	// IsRecordTypeContext differentiates from other interfaces.
	IsRecordTypeContext()
}

type RecordTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordTypeContext() *RecordTypeContext {
	var p = new(RecordTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordType
	return p
}

func InitEmptyRecordTypeContext(p *RecordTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordType
}

func (*RecordTypeContext) IsRecordTypeContext() {}

func NewRecordTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordTypeContext {
	var p = new(RecordTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordType

	return p
}

func (s *RecordTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordTypeContext) RECORD() antlr.TerminalNode {
	return s.GetToken(pascalParserRECORD, 0)
}

func (s *RecordTypeContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *RecordTypeContext) FieldList() IFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *RecordTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordType(s)
	}
}

func (s *RecordTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordType(s)
	}
}

func (s *RecordTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordType() (localctx IRecordTypeContext) {
	localctx = NewRecordTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, pascalParserRULE_recordType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(750)
		p.Match(pascalParserRECORD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(752)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserCASE || ((int64((_la-83)) & ^0x3f) == 0 && ((int64(1)<<(_la-83))&67108875) != 0) {
		{
			p.SetState(751)
			p.FieldList()
		}

	}
	{
		p.SetState(754)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldListContext is an interface to support dynamic dispatch.
type IFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FixedPart() IFixedPartContext
	SEMI() antlr.TerminalNode
	VariantPart() IVariantPartContext

	// IsFieldListContext differentiates from other interfaces.
	IsFieldListContext()
}

type FieldListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldListContext() *FieldListContext {
	var p = new(FieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_fieldList
	return p
}

func InitEmptyFieldListContext(p *FieldListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_fieldList
}

func (*FieldListContext) IsFieldListContext() {}

func NewFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldListContext {
	var p = new(FieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_fieldList

	return p
}

func (s *FieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldListContext) FixedPart() IFixedPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFixedPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFixedPartContext)
}

func (s *FieldListContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *FieldListContext) VariantPart() IVariantPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariantPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariantPartContext)
}

func (s *FieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFieldList(s)
	}
}

func (s *FieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFieldList(s)
	}
}

func (s *FieldListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFieldList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FieldList() (localctx IFieldListContext) {
	localctx = NewFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, pascalParserRULE_fieldList)
	var _la int

	p.SetState(762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(756)
			p.FixedPart()
		}
		p.SetState(759)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserSEMI {
			{
				p.SetState(757)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(758)
				p.VariantPart()
			}

		}

	case pascalParserCASE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(761)
			p.VariantPart()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFixedPartContext is an interface to support dynamic dispatch.
type IFixedPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRecordSection() []IRecordSectionContext
	RecordSection(i int) IRecordSectionContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsFixedPartContext differentiates from other interfaces.
	IsFixedPartContext()
}

type FixedPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFixedPartContext() *FixedPartContext {
	var p = new(FixedPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_fixedPart
	return p
}

func InitEmptyFixedPartContext(p *FixedPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_fixedPart
}

func (*FixedPartContext) IsFixedPartContext() {}

func NewFixedPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FixedPartContext {
	var p = new(FixedPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_fixedPart

	return p
}

func (s *FixedPartContext) GetParser() antlr.Parser { return s.parser }

func (s *FixedPartContext) AllRecordSection() []IRecordSectionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordSectionContext); ok {
			len++
		}
	}

	tst := make([]IRecordSectionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordSectionContext); ok {
			tst[i] = t.(IRecordSectionContext)
			i++
		}
	}

	return tst
}

func (s *FixedPartContext) RecordSection(i int) IRecordSectionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordSectionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordSectionContext)
}

func (s *FixedPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *FixedPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *FixedPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FixedPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FixedPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFixedPart(s)
	}
}

func (s *FixedPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFixedPart(s)
	}
}

func (s *FixedPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFixedPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FixedPart() (localctx IFixedPartContext) {
	localctx = NewFixedPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, pascalParserRULE_fixedPart)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(764)
		p.RecordSection()
	}
	p.SetState(769)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(765)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(766)
				p.RecordSection()
			}

		}
		p.SetState(771)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(773)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(772)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordSectionContext is an interface to support dynamic dispatch.
type IRecordSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierList() IIdentifierListContext
	COLON() antlr.TerminalNode
	Type_() IType_Context

	// IsRecordSectionContext differentiates from other interfaces.
	IsRecordSectionContext()
}

type RecordSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordSectionContext() *RecordSectionContext {
	var p = new(RecordSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordSection
	return p
}

func InitEmptyRecordSectionContext(p *RecordSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordSection
}

func (*RecordSectionContext) IsRecordSectionContext() {}

func NewRecordSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordSectionContext {
	var p = new(RecordSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordSection

	return p
}

func (s *RecordSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordSectionContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *RecordSectionContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *RecordSectionContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *RecordSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordSection(s)
	}
}

func (s *RecordSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordSection(s)
	}
}

func (s *RecordSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordSection() (localctx IRecordSectionContext) {
	localctx = NewRecordSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, pascalParserRULE_recordSection)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(775)
		p.IdentifierList()
	}
	{
		p.SetState(776)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(777)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariantPartContext is an interface to support dynamic dispatch.
type IVariantPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	Tag() ITagContext
	OF() antlr.TerminalNode
	AllVariant() []IVariantContext
	Variant(i int) IVariantContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsVariantPartContext differentiates from other interfaces.
	IsVariantPartContext()
}

type VariantPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariantPartContext() *VariantPartContext {
	var p = new(VariantPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variantPart
	return p
}

func InitEmptyVariantPartContext(p *VariantPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variantPart
}

func (*VariantPartContext) IsVariantPartContext() {}

func NewVariantPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariantPartContext {
	var p = new(VariantPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_variantPart

	return p
}

func (s *VariantPartContext) GetParser() antlr.Parser { return s.parser }

func (s *VariantPartContext) CASE() antlr.TerminalNode {
	return s.GetToken(pascalParserCASE, 0)
}

func (s *VariantPartContext) Tag() ITagContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITagContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITagContext)
}

func (s *VariantPartContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *VariantPartContext) AllVariant() []IVariantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariantContext); ok {
			len++
		}
	}

	tst := make([]IVariantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariantContext); ok {
			tst[i] = t.(IVariantContext)
			i++
		}
	}

	return tst
}

func (s *VariantPartContext) Variant(i int) IVariantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariantContext)
}

func (s *VariantPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *VariantPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *VariantPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariantPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariantPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterVariantPart(s)
	}
}

func (s *VariantPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitVariantPart(s)
	}
}

func (s *VariantPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitVariantPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) VariantPart() (localctx IVariantPartContext) {
	localctx = NewVariantPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, pascalParserRULE_variantPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(779)
		p.Match(pascalParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(780)
		p.Tag()
	}
	{
		p.SetState(781)
		p.Match(pascalParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(782)
		p.Variant()
	}
	p.SetState(787)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserSEMI {
		{
			p.SetState(783)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(784)
			p.Variant()
		}

		p.SetState(789)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITagContext is an interface to support dynamic dispatch.
type ITagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext

	// IsTagContext differentiates from other interfaces.
	IsTagContext()
}

type TagContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTagContext() *TagContext {
	var p = new(TagContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tag
	return p
}

func InitEmptyTagContext(p *TagContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tag
}

func (*TagContext) IsTagContext() {}

func NewTagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TagContext {
	var p = new(TagContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_tag

	return p
}

func (s *TagContext) GetParser() antlr.Parser { return s.parser }

func (s *TagContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TagContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *TagContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *TagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTag(s)
	}
}

func (s *TagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTag(s)
	}
}

func (s *TagContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTag(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Tag() (localctx ITagContext) {
	localctx = NewTagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, pascalParserRULE_tag)
	p.SetState(795)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(790)
			p.Identifier()
		}
		{
			p.SetState(791)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(792)
			p.TypeIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(794)
			p.TypeIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariantContext is an interface to support dynamic dispatch.
type IVariantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConstList() IConstListContext
	COLON() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	FieldList() IFieldListContext
	RPAREN() antlr.TerminalNode

	// IsVariantContext differentiates from other interfaces.
	IsVariantContext()
}

type VariantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariantContext() *VariantContext {
	var p = new(VariantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variant
	return p
}

func InitEmptyVariantContext(p *VariantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variant
}

func (*VariantContext) IsVariantContext() {}

func NewVariantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariantContext {
	var p = new(VariantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_variant

	return p
}

func (s *VariantContext) GetParser() antlr.Parser { return s.parser }

func (s *VariantContext) ConstList() IConstListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstListContext)
}

func (s *VariantContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *VariantContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *VariantContext) FieldList() IFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *VariantContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *VariantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterVariant(s)
	}
}

func (s *VariantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitVariant(s)
	}
}

func (s *VariantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitVariant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Variant() (localctx IVariantContext) {
	localctx = NewVariantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, pascalParserRULE_variant)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(797)
		p.ConstList()
	}
	{
		p.SetState(798)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(799)
		p.Match(pascalParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(800)
		p.FieldList()
	}
	{
		p.SetState(801)
		p.Match(pascalParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetTypeContext is an interface to support dynamic dispatch.
type ISetTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	OF() antlr.TerminalNode
	BaseType() IBaseTypeContext

	// IsSetTypeContext differentiates from other interfaces.
	IsSetTypeContext()
}

type SetTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetTypeContext() *SetTypeContext {
	var p = new(SetTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_setType
	return p
}

func InitEmptySetTypeContext(p *SetTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_setType
}

func (*SetTypeContext) IsSetTypeContext() {}

func NewSetTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetTypeContext {
	var p = new(SetTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_setType

	return p
}

func (s *SetTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SetTypeContext) SET() antlr.TerminalNode {
	return s.GetToken(pascalParserSET, 0)
}

func (s *SetTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *SetTypeContext) BaseType() IBaseTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTypeContext)
}

func (s *SetTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSetType(s)
	}
}

func (s *SetTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSetType(s)
	}
}

func (s *SetTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSetType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SetType() (localctx ISetTypeContext) {
	localctx = NewSetTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, pascalParserRULE_setType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(803)
		p.Match(pascalParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(804)
		p.Match(pascalParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(805)
		p.BaseType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBaseTypeContext is an interface to support dynamic dispatch.
type IBaseTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleType() ISimpleTypeContext

	// IsBaseTypeContext differentiates from other interfaces.
	IsBaseTypeContext()
}

type BaseTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseTypeContext() *BaseTypeContext {
	var p = new(BaseTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_baseType
	return p
}

func InitEmptyBaseTypeContext(p *BaseTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_baseType
}

func (*BaseTypeContext) IsBaseTypeContext() {}

func NewBaseTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseTypeContext {
	var p = new(BaseTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_baseType

	return p
}

func (s *BaseTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseTypeContext) SimpleType() ISimpleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeContext)
}

func (s *BaseTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterBaseType(s)
	}
}

func (s *BaseTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitBaseType(s)
	}
}

func (s *BaseTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitBaseType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) BaseType() (localctx IBaseTypeContext) {
	localctx = NewBaseTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, pascalParserRULE_baseType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(807)
		p.SimpleType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFileTypeContext is an interface to support dynamic dispatch.
type IFileTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FILE() antlr.TerminalNode
	OF() antlr.TerminalNode
	Type_() IType_Context

	// IsFileTypeContext differentiates from other interfaces.
	IsFileTypeContext()
}

type FileTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileTypeContext() *FileTypeContext {
	var p = new(FileTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_fileType
	return p
}

func InitEmptyFileTypeContext(p *FileTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_fileType
}

func (*FileTypeContext) IsFileTypeContext() {}

func NewFileTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileTypeContext {
	var p = new(FileTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_fileType

	return p
}

func (s *FileTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FileTypeContext) FILE() antlr.TerminalNode {
	return s.GetToken(pascalParserFILE, 0)
}

func (s *FileTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *FileTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *FileTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFileType(s)
	}
}

func (s *FileTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFileType(s)
	}
}

func (s *FileTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFileType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FileType() (localctx IFileTypeContext) {
	localctx = NewFileTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, pascalParserRULE_fileType)
	p.SetState(813)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(809)
			p.Match(pascalParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(810)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(811)
			p.Type_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(812)
			p.Match(pascalParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPointerTypeContext is an interface to support dynamic dispatch.
type IPointerTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	POINTER() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext

	// IsPointerTypeContext differentiates from other interfaces.
	IsPointerTypeContext()
}

type PointerTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPointerTypeContext() *PointerTypeContext {
	var p = new(PointerTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_pointerType
	return p
}

func InitEmptyPointerTypeContext(p *PointerTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_pointerType
}

func (*PointerTypeContext) IsPointerTypeContext() {}

func NewPointerTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PointerTypeContext {
	var p = new(PointerTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_pointerType

	return p
}

func (s *PointerTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PointerTypeContext) POINTER() antlr.TerminalNode {
	return s.GetToken(pascalParserPOINTER, 0)
}

func (s *PointerTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *PointerTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PointerTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PointerTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPointerType(s)
	}
}

func (s *PointerTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPointerType(s)
	}
}

func (s *PointerTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPointerType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PointerType() (localctx IPointerTypeContext) {
	localctx = NewPointerTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, pascalParserRULE_pointerType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(815)
		p.Match(pascalParserPOINTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(816)
		p.TypeIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationPartContext is an interface to support dynamic dispatch.
type IVariableDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VAR() antlr.TerminalNode
	AllVariableDeclaration() []IVariableDeclarationContext
	VariableDeclaration(i int) IVariableDeclarationContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsVariableDeclarationPartContext differentiates from other interfaces.
	IsVariableDeclarationPartContext()
}

type VariableDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationPartContext() *VariableDeclarationPartContext {
	var p = new(VariableDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclarationPart
	return p
}

func InitEmptyVariableDeclarationPartContext(p *VariableDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclarationPart
}

func (*VariableDeclarationPartContext) IsVariableDeclarationPartContext() {}

func NewVariableDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationPartContext {
	var p = new(VariableDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_variableDeclarationPart

	return p
}

func (s *VariableDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationPartContext) VAR() antlr.TerminalNode {
	return s.GetToken(pascalParserVAR, 0)
}

func (s *VariableDeclarationPartContext) AllVariableDeclaration() []IVariableDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationContext); ok {
			tst[i] = t.(IVariableDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclarationPartContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *VariableDeclarationPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *VariableDeclarationPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *VariableDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterVariableDeclarationPart(s)
	}
}

func (s *VariableDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitVariableDeclarationPart(s)
	}
}

func (s *VariableDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitVariableDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) VariableDeclarationPart() (localctx IVariableDeclarationPartContext) {
	localctx = NewVariableDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, pascalParserRULE_variableDeclarationPart)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(818)
		p.Match(pascalParserVAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(819)
		p.VariableDeclaration()
	}
	p.SetState(824)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(820)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(821)
				p.VariableDeclaration()
			}

		}
		p.SetState(826)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(827)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierList() IIdentifierListContext
	COLON() antlr.TerminalNode
	Type_() IType_Context

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclaration
	return p
}

func InitEmptyVariableDeclarationContext(p *VariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclaration
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *VariableDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *VariableDeclarationContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitVariableDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, pascalParserRULE_variableDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(829)
		p.IdentifierList()
	}
	{
		p.SetState(830)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(831)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureHeaderContext is an interface to support dynamic dispatch.
type IProcedureHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMI() antlr.TerminalNode
	ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext
	PROCEDURE() antlr.TerminalNode
	CONSTRUCTOR() antlr.TerminalNode
	DESTRUCTOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	MethodIdentifier() IMethodIdentifierContext
	FormalParameterList() IFormalParameterListContext

	// IsProcedureHeaderContext differentiates from other interfaces.
	IsProcedureHeaderContext()
}

type ProcedureHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureHeaderContext() *ProcedureHeaderContext {
	var p = new(ProcedureHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureHeader
	return p
}

func InitEmptyProcedureHeaderContext(p *ProcedureHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureHeader
}

func (*ProcedureHeaderContext) IsProcedureHeaderContext() {}

func NewProcedureHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureHeaderContext {
	var p = new(ProcedureHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureHeader

	return p
}

func (s *ProcedureHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureHeaderContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ProcedureHeaderContext) ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderModifiersContext)
}

func (s *ProcedureHeaderContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(pascalParserPROCEDURE, 0)
}

func (s *ProcedureHeaderContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(pascalParserCONSTRUCTOR, 0)
}

func (s *ProcedureHeaderContext) DESTRUCTOR() antlr.TerminalNode {
	return s.GetToken(pascalParserDESTRUCTOR, 0)
}

func (s *ProcedureHeaderContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ProcedureHeaderContext) MethodIdentifier() IMethodIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodIdentifierContext)
}

func (s *ProcedureHeaderContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ProcedureHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureHeader(s)
	}
}

func (s *ProcedureHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureHeader(s)
	}
}

func (s *ProcedureHeaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureHeader(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureHeader() (localctx IProcedureHeaderContext) {
	localctx = NewProcedureHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, pascalParserRULE_procedureHeader)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(833)
		_la = p.GetTokenStream().LA(1)

		if !(_la == pascalParserPROCEDURE || _la == pascalParserCONSTRUCTOR || _la == pascalParserDESTRUCTOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(836)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(834)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(835)
			p.MethodIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(838)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(841)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(842)
		p.ProcedureOrFunctionHeaderModifiers()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionHeaderContext is an interface to support dynamic dispatch.
type IFunctionHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNCTION() antlr.TerminalNode
	COLON() antlr.TerminalNode
	ResultType() IResultTypeContext
	SEMI() antlr.TerminalNode
	ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext
	Identifier() IIdentifierContext
	MethodIdentifier() IMethodIdentifierContext
	FormalParameterList() IFormalParameterListContext

	// IsFunctionHeaderContext differentiates from other interfaces.
	IsFunctionHeaderContext()
}

type FunctionHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionHeaderContext() *FunctionHeaderContext {
	var p = new(FunctionHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionHeader
	return p
}

func InitEmptyFunctionHeaderContext(p *FunctionHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionHeader
}

func (*FunctionHeaderContext) IsFunctionHeaderContext() {}

func NewFunctionHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionHeaderContext {
	var p = new(FunctionHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_functionHeader

	return p
}

func (s *FunctionHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionHeaderContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(pascalParserFUNCTION, 0)
}

func (s *FunctionHeaderContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *FunctionHeaderContext) ResultType() IResultTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultTypeContext)
}

func (s *FunctionHeaderContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *FunctionHeaderContext) ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderModifiersContext)
}

func (s *FunctionHeaderContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionHeaderContext) MethodIdentifier() IMethodIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodIdentifierContext)
}

func (s *FunctionHeaderContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFunctionHeader(s)
	}
}

func (s *FunctionHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFunctionHeader(s)
	}
}

func (s *FunctionHeaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFunctionHeader(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FunctionHeader() (localctx IFunctionHeaderContext) {
	localctx = NewFunctionHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, pascalParserRULE_functionHeader)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(844)
		p.Match(pascalParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(847)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(845)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(846)
			p.MethodIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(850)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(849)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(852)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(853)
		p.ResultType()
	}
	{
		p.SetState(854)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(855)
		p.ProcedureOrFunctionHeaderModifiers()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureOrFunctionHeaderContext is an interface to support dynamic dispatch.
type IProcedureOrFunctionHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ProcedureHeader() IProcedureHeaderContext
	FunctionHeader() IFunctionHeaderContext

	// IsProcedureOrFunctionHeaderContext differentiates from other interfaces.
	IsProcedureOrFunctionHeaderContext()
}

type ProcedureOrFunctionHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureOrFunctionHeaderContext() *ProcedureOrFunctionHeaderContext {
	var p = new(ProcedureOrFunctionHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeader
	return p
}

func InitEmptyProcedureOrFunctionHeaderContext(p *ProcedureOrFunctionHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeader
}

func (*ProcedureOrFunctionHeaderContext) IsProcedureOrFunctionHeaderContext() {}

func NewProcedureOrFunctionHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureOrFunctionHeaderContext {
	var p = new(ProcedureOrFunctionHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeader

	return p
}

func (s *ProcedureOrFunctionHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureOrFunctionHeaderContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *ProcedureOrFunctionHeaderContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *ProcedureOrFunctionHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureOrFunctionHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureOrFunctionHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureOrFunctionHeader(s)
	}
}

func (s *ProcedureOrFunctionHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureOrFunctionHeader(s)
	}
}

func (s *ProcedureOrFunctionHeaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureOrFunctionHeader(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureOrFunctionHeader() (localctx IProcedureOrFunctionHeaderContext) {
	localctx = NewProcedureOrFunctionHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, pascalParserRULE_procedureOrFunctionHeader)
	p.SetState(859)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserPROCEDURE, pascalParserCONSTRUCTOR, pascalParserDESTRUCTOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(857)
			p.ProcedureHeader()
		}

	case pascalParserFUNCTION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(858)
			p.FunctionHeader()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureOrFunctionHeaderModifiersContext is an interface to support dynamic dispatch.
type IProcedureOrFunctionHeaderModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AllABSTRACT() []antlr.TerminalNode
	ABSTRACT(i int) antlr.TerminalNode
	AllVIRTUAL() []antlr.TerminalNode
	VIRTUAL(i int) antlr.TerminalNode
	AllOVERRIDE() []antlr.TerminalNode
	OVERRIDE(i int) antlr.TerminalNode
	AllOVERLOAD() []antlr.TerminalNode
	OVERLOAD(i int) antlr.TerminalNode
	AllINLINE() []antlr.TerminalNode
	INLINE(i int) antlr.TerminalNode

	// IsProcedureOrFunctionHeaderModifiersContext differentiates from other interfaces.
	IsProcedureOrFunctionHeaderModifiersContext()
}

type ProcedureOrFunctionHeaderModifiersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureOrFunctionHeaderModifiersContext() *ProcedureOrFunctionHeaderModifiersContext {
	var p = new(ProcedureOrFunctionHeaderModifiersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeaderModifiers
	return p
}

func InitEmptyProcedureOrFunctionHeaderModifiersContext(p *ProcedureOrFunctionHeaderModifiersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeaderModifiers
}

func (*ProcedureOrFunctionHeaderModifiersContext) IsProcedureOrFunctionHeaderModifiersContext() {}

func NewProcedureOrFunctionHeaderModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureOrFunctionHeaderModifiersContext {
	var p = new(ProcedureOrFunctionHeaderModifiersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeaderModifiers

	return p
}

func (s *ProcedureOrFunctionHeaderModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureOrFunctionHeaderModifiersContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllABSTRACT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserABSTRACT)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) ABSTRACT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserABSTRACT, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllVIRTUAL() []antlr.TerminalNode {
	return s.GetTokens(pascalParserVIRTUAL)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) VIRTUAL(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserVIRTUAL, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllOVERRIDE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserOVERRIDE)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) OVERRIDE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserOVERRIDE, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllOVERLOAD() []antlr.TerminalNode {
	return s.GetTokens(pascalParserOVERLOAD)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) OVERLOAD(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserOVERLOAD, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllINLINE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserINLINE)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) INLINE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserINLINE, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureOrFunctionHeaderModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureOrFunctionHeaderModifiers(s)
	}
}

func (s *ProcedureOrFunctionHeaderModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureOrFunctionHeaderModifiers(s)
	}
}

func (s *ProcedureOrFunctionHeaderModifiersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureOrFunctionHeaderModifiers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureOrFunctionHeaderModifiers() (localctx IProcedureOrFunctionHeaderModifiersContext) {
	localctx = NewProcedureOrFunctionHeaderModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, pascalParserRULE_procedureOrFunctionHeaderModifiers)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(865)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&31) != 0 {
		{
			p.SetState(861)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&31) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(862)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(867)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureOrFunctionDeclarationContext is an interface to support dynamic dispatch.
type IProcedureOrFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ProcedureDeclaration() IProcedureDeclarationContext
	FunctionDeclaration() IFunctionDeclarationContext

	// IsProcedureOrFunctionDeclarationContext differentiates from other interfaces.
	IsProcedureOrFunctionDeclarationContext()
}

type ProcedureOrFunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureOrFunctionDeclarationContext() *ProcedureOrFunctionDeclarationContext {
	var p = new(ProcedureOrFunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionDeclaration
	return p
}

func InitEmptyProcedureOrFunctionDeclarationContext(p *ProcedureOrFunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionDeclaration
}

func (*ProcedureOrFunctionDeclarationContext) IsProcedureOrFunctionDeclarationContext() {}

func NewProcedureOrFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureOrFunctionDeclarationContext {
	var p = new(ProcedureOrFunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureOrFunctionDeclaration

	return p
}

func (s *ProcedureOrFunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureOrFunctionDeclarationContext) ProcedureDeclaration() IProcedureDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureDeclarationContext)
}

func (s *ProcedureOrFunctionDeclarationContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *ProcedureOrFunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureOrFunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureOrFunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureOrFunctionDeclaration(s)
	}
}

func (s *ProcedureOrFunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureOrFunctionDeclaration(s)
	}
}

func (s *ProcedureOrFunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureOrFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureOrFunctionDeclaration() (localctx IProcedureOrFunctionDeclarationContext) {
	localctx = NewProcedureOrFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, pascalParserRULE_procedureOrFunctionDeclaration)
	p.SetState(870)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserPROCEDURE, pascalParserCONSTRUCTOR, pascalParserDESTRUCTOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(868)
			p.ProcedureDeclaration()
		}

	case pascalParserFUNCTION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(869)
			p.FunctionDeclaration()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureDeclarationContext is an interface to support dynamic dispatch.
type IProcedureDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ProcedureHeader() IProcedureHeaderContext
	ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext
	SEMI() antlr.TerminalNode

	// IsProcedureDeclarationContext differentiates from other interfaces.
	IsProcedureDeclarationContext()
}

type ProcedureDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDeclarationContext() *ProcedureDeclarationContext {
	var p = new(ProcedureDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureDeclaration
	return p
}

func InitEmptyProcedureDeclarationContext(p *ProcedureDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureDeclaration
}

func (*ProcedureDeclarationContext) IsProcedureDeclarationContext() {}

func NewProcedureDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDeclarationContext {
	var p = new(ProcedureDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureDeclaration

	return p
}

func (s *ProcedureDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDeclarationContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *ProcedureDeclarationContext) ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionBodyContext)
}

func (s *ProcedureDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ProcedureDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureDeclaration(s)
	}
}

func (s *ProcedureDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureDeclaration(s)
	}
}

func (s *ProcedureDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureDeclaration() (localctx IProcedureDeclarationContext) {
	localctx = NewProcedureDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, pascalParserRULE_procedureDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(872)
		p.ProcedureHeader()
	}
	{
		p.SetState(873)
		p.ProcedureOrFunctionBody()
	}
	{
		p.SetState(874)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionHeader() IFunctionHeaderContext
	ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext
	SEMI() antlr.TerminalNode

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionDeclaration
	return p
}

func InitEmptyFunctionDeclarationContext(p *FunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionDeclaration
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *FunctionDeclarationContext) ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionBodyContext)
}

func (s *FunctionDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, pascalParserRULE_functionDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(876)
		p.FunctionHeader()
	}
	{
		p.SetState(877)
		p.ProcedureOrFunctionBody()
	}
	{
		p.SetState(878)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResultTypeContext is an interface to support dynamic dispatch.
type IResultTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIdentifier() ITypeIdentifierContext

	// IsResultTypeContext differentiates from other interfaces.
	IsResultTypeContext()
}

type ResultTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResultTypeContext() *ResultTypeContext {
	var p = new(ResultTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resultType
	return p
}

func InitEmptyResultTypeContext(p *ResultTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resultType
}

func (*ResultTypeContext) IsResultTypeContext() {}

func NewResultTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResultTypeContext {
	var p = new(ResultTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_resultType

	return p
}

func (s *ResultTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ResultTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ResultTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResultTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResultTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterResultType(s)
	}
}

func (s *ResultTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitResultType(s)
	}
}

func (s *ResultTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitResultType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ResultType() (localctx IResultTypeContext) {
	localctx = NewResultTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, pascalParserRULE_resultType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(880)
		p.TypeIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureOrFunctionBodyContext is an interface to support dynamic dispatch.
type IProcedureOrFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	CompoundStatement() ICompoundStatementContext

	// IsProcedureOrFunctionBodyContext differentiates from other interfaces.
	IsProcedureOrFunctionBodyContext()
}

type ProcedureOrFunctionBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureOrFunctionBodyContext() *ProcedureOrFunctionBodyContext {
	var p = new(ProcedureOrFunctionBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionBody
	return p
}

func InitEmptyProcedureOrFunctionBodyContext(p *ProcedureOrFunctionBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionBody
}

func (*ProcedureOrFunctionBodyContext) IsProcedureOrFunctionBodyContext() {}

func NewProcedureOrFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureOrFunctionBodyContext {
	var p = new(ProcedureOrFunctionBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureOrFunctionBody

	return p
}

func (s *ProcedureOrFunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureOrFunctionBodyContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ProcedureOrFunctionBodyContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *ProcedureOrFunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureOrFunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureOrFunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureOrFunctionBody(s)
	}
}

func (s *ProcedureOrFunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureOrFunctionBody(s)
	}
}

func (s *ProcedureOrFunctionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureOrFunctionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureOrFunctionBody() (localctx IProcedureOrFunctionBodyContext) {
	localctx = NewProcedureOrFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, pascalParserRULE_procedureOrFunctionBody)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(882)
		p.Block()
	}
	{
		p.SetState(883)
		p.CompoundStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllFormalParameterSection() []IFormalParameterSectionContext
	FormalParameterSection(i int) IFormalParameterSectionContext
	RPAREN() antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_formalParameterList
	return p
}

func InitEmptyFormalParameterListContext(p *FormalParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_formalParameterList
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *FormalParameterListContext) AllFormalParameterSection() []IFormalParameterSectionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormalParameterSectionContext); ok {
			len++
		}
	}

	tst := make([]IFormalParameterSectionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormalParameterSectionContext); ok {
			tst[i] = t.(IFormalParameterSectionContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameterSection(i int) IFormalParameterSectionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterSectionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterSectionContext)
}

func (s *FormalParameterListContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *FormalParameterListContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *FormalParameterListContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFormalParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FormalParameterList() (localctx IFormalParameterListContext) {
	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, pascalParserRULE_formalParameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(885)
		p.Match(pascalParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(886)
		p.FormalParameterSection()
	}
	p.SetState(891)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserSEMI {
		{
			p.SetState(887)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(888)
			p.FormalParameterSection()
		}

		p.SetState(893)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(894)
		p.Match(pascalParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterSectionContext is an interface to support dynamic dispatch.
type IFormalParameterSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParameterGroup() IParameterGroupContext
	VAR() antlr.TerminalNode
	CONST() antlr.TerminalNode
	OUT() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode

	// IsFormalParameterSectionContext differentiates from other interfaces.
	IsFormalParameterSectionContext()
}

type FormalParameterSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterSectionContext() *FormalParameterSectionContext {
	var p = new(FormalParameterSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_formalParameterSection
	return p
}

func InitEmptyFormalParameterSectionContext(p *FormalParameterSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_formalParameterSection
}

func (*FormalParameterSectionContext) IsFormalParameterSectionContext() {}

func NewFormalParameterSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterSectionContext {
	var p = new(FormalParameterSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_formalParameterSection

	return p
}

func (s *FormalParameterSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterSectionContext) ParameterGroup() IParameterGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterGroupContext)
}

func (s *FormalParameterSectionContext) VAR() antlr.TerminalNode {
	return s.GetToken(pascalParserVAR, 0)
}

func (s *FormalParameterSectionContext) CONST() antlr.TerminalNode {
	return s.GetToken(pascalParserCONST, 0)
}

func (s *FormalParameterSectionContext) OUT() antlr.TerminalNode {
	return s.GetToken(pascalParserOUT, 0)
}

func (s *FormalParameterSectionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(pascalParserFUNCTION, 0)
}

func (s *FormalParameterSectionContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(pascalParserPROCEDURE, 0)
}

func (s *FormalParameterSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFormalParameterSection(s)
	}
}

func (s *FormalParameterSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFormalParameterSection(s)
	}
}

func (s *FormalParameterSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFormalParameterSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FormalParameterSection() (localctx IFormalParameterSectionContext) {
	localctx = NewFormalParameterSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, pascalParserRULE_formalParameterSection)
	p.SetState(907)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(896)
			p.ParameterGroup()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(897)
			p.Match(pascalParserVAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(898)
			p.ParameterGroup()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(899)
			p.Match(pascalParserCONST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(900)
			p.ParameterGroup()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(901)
			p.Match(pascalParserOUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(902)
			p.ParameterGroup()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(903)
			p.Match(pascalParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(904)
			p.ParameterGroup()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(905)
			p.Match(pascalParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(906)
			p.ParameterGroup()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterGroupContext is an interface to support dynamic dispatch.
type IParameterGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierList() IIdentifierListContext
	COLON() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	DefaultValue() IDefaultValueContext
	VAR() antlr.TerminalNode
	CONST() antlr.TerminalNode

	// IsParameterGroupContext differentiates from other interfaces.
	IsParameterGroupContext()
}

type ParameterGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterGroupContext() *ParameterGroupContext {
	var p = new(ParameterGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterGroup
	return p
}

func InitEmptyParameterGroupContext(p *ParameterGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterGroup
}

func (*ParameterGroupContext) IsParameterGroupContext() {}

func NewParameterGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterGroupContext {
	var p = new(ParameterGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_parameterGroup

	return p
}

func (s *ParameterGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterGroupContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ParameterGroupContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *ParameterGroupContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ParameterGroupContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *ParameterGroupContext) VAR() antlr.TerminalNode {
	return s.GetToken(pascalParserVAR, 0)
}

func (s *ParameterGroupContext) CONST() antlr.TerminalNode {
	return s.GetToken(pascalParserCONST, 0)
}

func (s *ParameterGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterParameterGroup(s)
	}
}

func (s *ParameterGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitParameterGroup(s)
	}
}

func (s *ParameterGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitParameterGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ParameterGroup() (localctx IParameterGroupContext) {
	localctx = NewParameterGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, pascalParserRULE_parameterGroup)
	var _la int

	p.SetState(917)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(909)
			p.IdentifierList()
		}
		{
			p.SetState(910)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(911)
			p.TypeIdentifier()
		}
		p.SetState(913)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserEQUAL {
			{
				p.SetState(912)
				p.DefaultValue()
			}

		}

	case pascalParserCONST, pascalParserVAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(915)
			_la = p.GetTokenStream().LA(1)

			if !(_la == pascalParserCONST || _la == pascalParserVAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(916)
			p.IdentifierList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifierList
	return p
}

func InitEmptyIdentifierListContext(p *IdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifierList
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierListContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *IdentifierListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (s *IdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, pascalParserRULE_identifierList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(919)
		p.Identifier()
	}
	p.SetState(924)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(920)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(921)
			p.Identifier()
		}

		p.SetState(926)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstListContext is an interface to support dynamic dispatch.
type IConstListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsConstListContext differentiates from other interfaces.
	IsConstListContext()
}

type ConstListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstListContext() *ConstListContext {
	var p = new(ConstListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constList
	return p
}

func InitEmptyConstListContext(p *ConstListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constList
}

func (*ConstListContext) IsConstListContext() {}

func NewConstListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstListContext {
	var p = new(ConstListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constList

	return p
}

func (s *ConstListContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstListContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *ConstListContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ConstListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ConstListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstList(s)
	}
}

func (s *ConstListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstList(s)
	}
}

func (s *ConstListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConstList() (localctx IConstListContext) {
	localctx = NewConstListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, pascalParserRULE_constList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(927)
		p.Constant()
	}
	p.SetState(932)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(928)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(929)
			p.Constant()
		}

		p.SetState(934)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultValueContext is an interface to support dynamic dispatch.
type IDefaultValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsDefaultValueContext differentiates from other interfaces.
	IsDefaultValueContext()
}

type DefaultValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultValueContext() *DefaultValueContext {
	var p = new(DefaultValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_defaultValue
	return p
}

func InitEmptyDefaultValueContext(p *DefaultValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_defaultValue
}

func (*DefaultValueContext) IsDefaultValueContext() {}

func NewDefaultValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultValueContext {
	var p = new(DefaultValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_defaultValue

	return p
}

func (s *DefaultValueContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultValueContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *DefaultValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DefaultValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterDefaultValue(s)
	}
}

func (s *DefaultValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitDefaultValue(s)
	}
}

func (s *DefaultValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitDefaultValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) DefaultValue() (localctx IDefaultValueContext) {
	localctx = NewDefaultValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, pascalParserRULE_defaultValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(935)
		p.Match(pascalParserEQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(936)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Label() ILabelContext
	COLON() antlr.TerminalNode
	UnlabelledStatement() IUnlabelledStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Label() ILabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *StatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *StatementContext) UnlabelledStatement() IUnlabelledStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnlabelledStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnlabelledStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, pascalParserRULE_statement)
	p.SetState(943)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserNUM_INT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(938)
			p.Label()
		}
		{
			p.SetState(939)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(940)
			p.UnlabelledStatement()
		}

	case pascalParserARRAY, pascalParserBEGIN, pascalParserBOOLEAN, pascalParserCASE, pascalParserCHAR, pascalParserELSE, pascalParserEND, pascalParserFOR, pascalParserGOTO, pascalParserIF, pascalParserINTEGER, pascalParserREAL, pascalParserREPEAT, pascalParserUNTIL, pascalParserWHILE, pascalParserWITH, pascalParserSEMI, pascalParserAT, pascalParserSTRING, pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserTRY, pascalParserFINALLY, pascalParserEXCEPT, pascalParserFINALIZATION, pascalParserINHERITED, pascalParserRAISE, pascalParserIDENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(942)
			p.UnlabelledStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnlabelledStatementContext is an interface to support dynamic dispatch.
type IUnlabelledStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleStatement() ISimpleStatementContext
	StructuredStatement() IStructuredStatementContext

	// IsUnlabelledStatementContext differentiates from other interfaces.
	IsUnlabelledStatementContext()
}

type UnlabelledStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnlabelledStatementContext() *UnlabelledStatementContext {
	var p = new(UnlabelledStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unlabelledStatement
	return p
}

func InitEmptyUnlabelledStatementContext(p *UnlabelledStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unlabelledStatement
}

func (*UnlabelledStatementContext) IsUnlabelledStatementContext() {}

func NewUnlabelledStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnlabelledStatementContext {
	var p = new(UnlabelledStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unlabelledStatement

	return p
}

func (s *UnlabelledStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnlabelledStatementContext) SimpleStatement() ISimpleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStatementContext)
}

func (s *UnlabelledStatementContext) StructuredStatement() IStructuredStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructuredStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructuredStatementContext)
}

func (s *UnlabelledStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnlabelledStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnlabelledStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnlabelledStatement(s)
	}
}

func (s *UnlabelledStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnlabelledStatement(s)
	}
}

func (s *UnlabelledStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnlabelledStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnlabelledStatement() (localctx IUnlabelledStatementContext) {
	localctx = NewUnlabelledStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, pascalParserRULE_unlabelledStatement)
	p.SetState(947)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserARRAY, pascalParserBOOLEAN, pascalParserCHAR, pascalParserELSE, pascalParserEND, pascalParserGOTO, pascalParserINTEGER, pascalParserREAL, pascalParserUNTIL, pascalParserSEMI, pascalParserAT, pascalParserSTRING, pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserFINALLY, pascalParserEXCEPT, pascalParserFINALIZATION, pascalParserINHERITED, pascalParserRAISE, pascalParserIDENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(945)
			p.SimpleStatement()
		}

	case pascalParserBEGIN, pascalParserCASE, pascalParserFOR, pascalParserIF, pascalParserREPEAT, pascalParserWHILE, pascalParserWITH, pascalParserTRY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(946)
			p.StructuredStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleStatementContext is an interface to support dynamic dispatch.
type ISimpleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssignmentStatement() IAssignmentStatementContext
	ProcedureStatement() IProcedureStatementContext
	GotoStatement() IGotoStatementContext
	InheritedStatement() IInheritedStatementContext
	EmptyStatement_() IEmptyStatement_Context
	RaiseExceptionStatement() IRaiseExceptionStatementContext

	// IsSimpleStatementContext differentiates from other interfaces.
	IsSimpleStatementContext()
}

type SimpleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleStatementContext() *SimpleStatementContext {
	var p = new(SimpleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleStatement
	return p
}

func InitEmptySimpleStatementContext(p *SimpleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleStatement
}

func (*SimpleStatementContext) IsSimpleStatementContext() {}

func NewSimpleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleStatementContext {
	var p = new(SimpleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_simpleStatement

	return p
}

func (s *SimpleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleStatementContext) AssignmentStatement() IAssignmentStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentStatementContext)
}

func (s *SimpleStatementContext) ProcedureStatement() IProcedureStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureStatementContext)
}

func (s *SimpleStatementContext) GotoStatement() IGotoStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGotoStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGotoStatementContext)
}

func (s *SimpleStatementContext) InheritedStatement() IInheritedStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInheritedStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInheritedStatementContext)
}

func (s *SimpleStatementContext) EmptyStatement_() IEmptyStatement_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatement_Context)
}

func (s *SimpleStatementContext) RaiseExceptionStatement() IRaiseExceptionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRaiseExceptionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRaiseExceptionStatementContext)
}

func (s *SimpleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSimpleStatement(s)
	}
}

func (s *SimpleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSimpleStatement(s)
	}
}

func (s *SimpleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSimpleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SimpleStatement() (localctx ISimpleStatementContext) {
	localctx = NewSimpleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, pascalParserRULE_simpleStatement)
	p.SetState(955)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(949)
			p.AssignmentStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(950)
			p.ProcedureStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(951)
			p.GotoStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(952)
			p.InheritedStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(953)
			p.EmptyStatement_()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(954)
			p.RaiseExceptionStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentStatementContext is an interface to support dynamic dispatch.
type IAssignmentStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Variable() IVariableContext
	ASSIGN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	FunctionDesignator() IFunctionDesignatorContext
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAssignmentStatementContext differentiates from other interfaces.
	IsAssignmentStatementContext()
}

type AssignmentStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentStatementContext() *AssignmentStatementContext {
	var p = new(AssignmentStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_assignmentStatement
	return p
}

func InitEmptyAssignmentStatementContext(p *AssignmentStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_assignmentStatement
}

func (*AssignmentStatementContext) IsAssignmentStatementContext() {}

func NewAssignmentStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentStatementContext {
	var p = new(AssignmentStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_assignmentStatement

	return p
}

func (s *AssignmentStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentStatementContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *AssignmentStatementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(pascalParserASSIGN, 0)
}

func (s *AssignmentStatementContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentStatementContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentStatementContext) FunctionDesignator() IFunctionDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDesignatorContext)
}

func (s *AssignmentStatementContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *AssignmentStatementContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *AssignmentStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *AssignmentStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *AssignmentStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAssignmentStatement(s)
	}
}

func (s *AssignmentStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAssignmentStatement(s)
	}
}

func (s *AssignmentStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAssignmentStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) AssignmentStatement() (localctx IAssignmentStatementContext) {
	localctx = NewAssignmentStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, pascalParserRULE_assignmentStatement)
	var _la int

	p.SetState(978)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(957)
			p.Variable()
		}
		{
			p.SetState(958)
			p.Match(pascalParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(959)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(961)
			p.FunctionDesignator()
		}
		p.SetState(973)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(962)
				p.Match(pascalParserLBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(963)
				p.Expression()
			}
			p.SetState(968)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == pascalParserCOMMA {
				{
					p.SetState(964)
					p.Match(pascalParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(965)
					p.Expression()
				}

				p.SetState(970)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(971)
				p.Match(pascalParserRBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(975)
			p.Match(pascalParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(976)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRaiseExceptionStatementContext is an interface to support dynamic dispatch.
type IRaiseExceptionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RAISE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsRaiseExceptionStatementContext differentiates from other interfaces.
	IsRaiseExceptionStatementContext()
}

type RaiseExceptionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaiseExceptionStatementContext() *RaiseExceptionStatementContext {
	var p = new(RaiseExceptionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_raiseExceptionStatement
	return p
}

func InitEmptyRaiseExceptionStatementContext(p *RaiseExceptionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_raiseExceptionStatement
}

func (*RaiseExceptionStatementContext) IsRaiseExceptionStatementContext() {}

func NewRaiseExceptionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RaiseExceptionStatementContext {
	var p = new(RaiseExceptionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_raiseExceptionStatement

	return p
}

func (s *RaiseExceptionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RaiseExceptionStatementContext) RAISE() antlr.TerminalNode {
	return s.GetToken(pascalParserRAISE, 0)
}

func (s *RaiseExceptionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RaiseExceptionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RaiseExceptionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RaiseExceptionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRaiseExceptionStatement(s)
	}
}

func (s *RaiseExceptionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRaiseExceptionStatement(s)
	}
}

func (s *RaiseExceptionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRaiseExceptionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RaiseExceptionStatement() (localctx IRaiseExceptionStatementContext) {
	localctx = NewRaiseExceptionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, pascalParserRULE_raiseExceptionStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(980)
		p.Match(pascalParserRAISE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(981)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableContext is an interface to support dynamic dispatch.
type IVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllLBRACK() []antlr.TerminalNode
	LBRACK(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllRBRACK() []antlr.TerminalNode
	RBRACK(i int) antlr.TerminalNode
	AllLBRACK2() []antlr.TerminalNode
	LBRACK2(i int) antlr.TerminalNode
	AllRBRACK2() []antlr.TerminalNode
	RBRACK2(i int) antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllPOINTER() []antlr.TerminalNode
	POINTER(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsVariableContext differentiates from other interfaces.
	IsVariableContext()
}

type VariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableContext() *VariableContext {
	var p = new(VariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variable
	return p
}

func InitEmptyVariableContext(p *VariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variable
}

func (*VariableContext) IsVariableContext() {}

func NewVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableContext {
	var p = new(VariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_variable

	return p
}

func (s *VariableContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableContext) AT() antlr.TerminalNode {
	return s.GetToken(pascalParserAT, 0)
}

func (s *VariableContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *VariableContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(pascalParserLBRACK)
}

func (s *VariableContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, i)
}

func (s *VariableContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *VariableContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(pascalParserRBRACK)
}

func (s *VariableContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, i)
}

func (s *VariableContext) AllLBRACK2() []antlr.TerminalNode {
	return s.GetTokens(pascalParserLBRACK2)
}

func (s *VariableContext) LBRACK2(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK2, i)
}

func (s *VariableContext) AllRBRACK2() []antlr.TerminalNode {
	return s.GetTokens(pascalParserRBRACK2)
}

func (s *VariableContext) RBRACK2(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK2, i)
}

func (s *VariableContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDOT)
}

func (s *VariableContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, i)
}

func (s *VariableContext) AllPOINTER() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPOINTER)
}

func (s *VariableContext) POINTER(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPOINTER, i)
}

func (s *VariableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *VariableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *VariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterVariable(s)
	}
}

func (s *VariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitVariable(s)
	}
}

func (s *VariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Variable() (localctx IVariableContext) {
	localctx = NewVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, pascalParserRULE_variable)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(986)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserAT:
		{
			p.SetState(983)
			p.Match(pascalParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(984)
			p.Identifier()
		}

	case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
		{
			p.SetState(985)
			p.Identifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1015)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1013)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case pascalParserLBRACK:
				{
					p.SetState(988)
					p.Match(pascalParserLBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(989)
					p.Expression()
				}
				p.SetState(994)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == pascalParserCOMMA {
					{
						p.SetState(990)
						p.Match(pascalParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(991)
						p.Expression()
					}

					p.SetState(996)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(997)
					p.Match(pascalParserRBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case pascalParserLBRACK2:
				{
					p.SetState(999)
					p.Match(pascalParserLBRACK2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1000)
					p.Expression()
				}
				p.SetState(1005)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == pascalParserCOMMA {
					{
						p.SetState(1001)
						p.Match(pascalParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1002)
						p.Expression()
					}

					p.SetState(1007)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1008)
					p.Match(pascalParserRBRACK2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case pascalParserDOT:
				{
					p.SetState(1010)
					p.Match(pascalParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1011)
					p.Identifier()
				}

			case pascalParserPOINTER:
				{
					p.SetState(1012)
					p.Match(pascalParserPOINTER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(1017)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleExpression() ISimpleExpressionContext
	Relationaloperator() IRelationaloperatorContext
	Expression() IExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) SimpleExpression() ISimpleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExpressionContext)
}

func (s *ExpressionContext) Relationaloperator() IRelationaloperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationaloperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationaloperatorContext)
}

func (s *ExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, pascalParserRULE_expression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1018)
		p.SimpleExpression()
	}
	p.SetState(1022)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&35465847066066944) != 0 {
		{
			p.SetState(1019)
			p.Relationaloperator()
		}
		{
			p.SetState(1020)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationaloperatorContext is an interface to support dynamic dispatch.
type IRelationaloperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL() antlr.TerminalNode
	NOT_EQUAL() antlr.TerminalNode
	LT() antlr.TerminalNode
	LE() antlr.TerminalNode
	GE() antlr.TerminalNode
	GT() antlr.TerminalNode
	IN() antlr.TerminalNode

	// IsRelationaloperatorContext differentiates from other interfaces.
	IsRelationaloperatorContext()
}

type RelationaloperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationaloperatorContext() *RelationaloperatorContext {
	var p = new(RelationaloperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_relationaloperator
	return p
}

func InitEmptyRelationaloperatorContext(p *RelationaloperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_relationaloperator
}

func (*RelationaloperatorContext) IsRelationaloperatorContext() {}

func NewRelationaloperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationaloperatorContext {
	var p = new(RelationaloperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_relationaloperator

	return p
}

func (s *RelationaloperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationaloperatorContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *RelationaloperatorContext) NOT_EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserNOT_EQUAL, 0)
}

func (s *RelationaloperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(pascalParserLT, 0)
}

func (s *RelationaloperatorContext) LE() antlr.TerminalNode {
	return s.GetToken(pascalParserLE, 0)
}

func (s *RelationaloperatorContext) GE() antlr.TerminalNode {
	return s.GetToken(pascalParserGE, 0)
}

func (s *RelationaloperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(pascalParserGT, 0)
}

func (s *RelationaloperatorContext) IN() antlr.TerminalNode {
	return s.GetToken(pascalParserIN, 0)
}

func (s *RelationaloperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationaloperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationaloperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRelationaloperator(s)
	}
}

func (s *RelationaloperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRelationaloperator(s)
	}
}

func (s *RelationaloperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRelationaloperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Relationaloperator() (localctx IRelationaloperatorContext) {
	localctx = NewRelationaloperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, pascalParserRULE_relationaloperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1024)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&35465847066066944) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleExpressionContext is an interface to support dynamic dispatch.
type ISimpleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Term() ITermContext
	Additiveoperator() IAdditiveoperatorContext
	SimpleExpression() ISimpleExpressionContext

	// IsSimpleExpressionContext differentiates from other interfaces.
	IsSimpleExpressionContext()
}

type SimpleExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleExpressionContext() *SimpleExpressionContext {
	var p = new(SimpleExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleExpression
	return p
}

func InitEmptySimpleExpressionContext(p *SimpleExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleExpression
}

func (*SimpleExpressionContext) IsSimpleExpressionContext() {}

func NewSimpleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleExpressionContext {
	var p = new(SimpleExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_simpleExpression

	return p
}

func (s *SimpleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleExpressionContext) Term() ITermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *SimpleExpressionContext) Additiveoperator() IAdditiveoperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveoperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveoperatorContext)
}

func (s *SimpleExpressionContext) SimpleExpression() ISimpleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExpressionContext)
}

func (s *SimpleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSimpleExpression(s)
	}
}

func (s *SimpleExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSimpleExpression(s)
	}
}

func (s *SimpleExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSimpleExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SimpleExpression() (localctx ISimpleExpressionContext) {
	localctx = NewSimpleExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, pascalParserRULE_simpleExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1026)
		p.Term()
	}
	p.SetState(1030)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6597136875520) != 0 {
		{
			p.SetState(1027)
			p.Additiveoperator()
		}
		{
			p.SetState(1028)
			p.SimpleExpression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdditiveoperatorContext is an interface to support dynamic dispatch.
type IAdditiveoperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	OR() antlr.TerminalNode

	// IsAdditiveoperatorContext differentiates from other interfaces.
	IsAdditiveoperatorContext()
}

type AdditiveoperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveoperatorContext() *AdditiveoperatorContext {
	var p = new(AdditiveoperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_additiveoperator
	return p
}

func InitEmptyAdditiveoperatorContext(p *AdditiveoperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_additiveoperator
}

func (*AdditiveoperatorContext) IsAdditiveoperatorContext() {}

func NewAdditiveoperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveoperatorContext {
	var p = new(AdditiveoperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_additiveoperator

	return p
}

func (s *AdditiveoperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveoperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(pascalParserPLUS, 0)
}

func (s *AdditiveoperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(pascalParserMINUS, 0)
}

func (s *AdditiveoperatorContext) OR() antlr.TerminalNode {
	return s.GetToken(pascalParserOR, 0)
}

func (s *AdditiveoperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveoperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveoperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAdditiveoperator(s)
	}
}

func (s *AdditiveoperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAdditiveoperator(s)
	}
}

func (s *AdditiveoperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAdditiveoperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Additiveoperator() (localctx IAdditiveoperatorContext) {
	localctx = NewAdditiveoperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, pascalParserRULE_additiveoperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1032)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6597136875520) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SignedFactor() ISignedFactorContext
	Multiplicativeoperator() IMultiplicativeoperatorContext
	Term() ITermContext

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_term
	return p
}

func InitEmptyTermContext(p *TermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_term
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) SignedFactor() ISignedFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignedFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignedFactorContext)
}

func (s *TermContext) Multiplicativeoperator() IMultiplicativeoperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeoperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeoperatorContext)
}

func (s *TermContext) Term() ITermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTerm(s)
	}
}

func (s *TermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTerm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, pascalParserRULE_term)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1034)
		p.SignedFactor()
	}
	p.SetState(1038)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&26388283261442) != 0 {
		{
			p.SetState(1035)
			p.Multiplicativeoperator()
		}
		{
			p.SetState(1036)
			p.Term()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplicativeoperatorContext is an interface to support dynamic dispatch.
type IMultiplicativeoperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	SLASH() antlr.TerminalNode
	DIV() antlr.TerminalNode
	MOD() antlr.TerminalNode
	AND() antlr.TerminalNode

	// IsMultiplicativeoperatorContext differentiates from other interfaces.
	IsMultiplicativeoperatorContext()
}

type MultiplicativeoperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeoperatorContext() *MultiplicativeoperatorContext {
	var p = new(MultiplicativeoperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_multiplicativeoperator
	return p
}

func InitEmptyMultiplicativeoperatorContext(p *MultiplicativeoperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_multiplicativeoperator
}

func (*MultiplicativeoperatorContext) IsMultiplicativeoperatorContext() {}

func NewMultiplicativeoperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeoperatorContext {
	var p = new(MultiplicativeoperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_multiplicativeoperator

	return p
}

func (s *MultiplicativeoperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeoperatorContext) STAR() antlr.TerminalNode {
	return s.GetToken(pascalParserSTAR, 0)
}

func (s *MultiplicativeoperatorContext) SLASH() antlr.TerminalNode {
	return s.GetToken(pascalParserSLASH, 0)
}

func (s *MultiplicativeoperatorContext) DIV() antlr.TerminalNode {
	return s.GetToken(pascalParserDIV, 0)
}

func (s *MultiplicativeoperatorContext) MOD() antlr.TerminalNode {
	return s.GetToken(pascalParserMOD, 0)
}

func (s *MultiplicativeoperatorContext) AND() antlr.TerminalNode {
	return s.GetToken(pascalParserAND, 0)
}

func (s *MultiplicativeoperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeoperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeoperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterMultiplicativeoperator(s)
	}
}

func (s *MultiplicativeoperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitMultiplicativeoperator(s)
	}
}

func (s *MultiplicativeoperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitMultiplicativeoperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Multiplicativeoperator() (localctx IMultiplicativeoperatorContext) {
	localctx = NewMultiplicativeoperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, pascalParserRULE_multiplicativeoperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1040)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&26388283261442) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignedFactorContext is an interface to support dynamic dispatch.
type ISignedFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Factor() IFactorContext
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsSignedFactorContext differentiates from other interfaces.
	IsSignedFactorContext()
}

type SignedFactorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignedFactorContext() *SignedFactorContext {
	var p = new(SignedFactorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_signedFactor
	return p
}

func InitEmptySignedFactorContext(p *SignedFactorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_signedFactor
}

func (*SignedFactorContext) IsSignedFactorContext() {}

func NewSignedFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignedFactorContext {
	var p = new(SignedFactorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_signedFactor

	return p
}

func (s *SignedFactorContext) GetParser() antlr.Parser { return s.parser }

func (s *SignedFactorContext) Factor() IFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *SignedFactorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(pascalParserPLUS, 0)
}

func (s *SignedFactorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(pascalParserMINUS, 0)
}

func (s *SignedFactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignedFactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignedFactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSignedFactor(s)
	}
}

func (s *SignedFactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSignedFactor(s)
	}
}

func (s *SignedFactorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSignedFactor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SignedFactor() (localctx ISignedFactorContext) {
	localctx = NewSignedFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, pascalParserRULE_signedFactor)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1043)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserPLUS || _la == pascalParserMINUS {
		{
			p.SetState(1042)
			_la = p.GetTokenStream().LA(1)

			if !(_la == pascalParserPLUS || _la == pascalParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1045)
		p.factor(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFactorContext is an interface to support dynamic dispatch.
type IFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Variable() IVariableContext
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	RPAREN() antlr.TerminalNode
	FunctionDesignator() IFunctionDesignatorContext
	UnsignedConstant() IUnsignedConstantContext
	Set_() ISet_Context
	NOT() antlr.TerminalNode
	Factor() IFactorContext
	Bool_() IBool_Context
	TypeIdentifier() ITypeIdentifierContext
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFactorContext differentiates from other interfaces.
	IsFactorContext()
}

type FactorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFactorContext() *FactorContext {
	var p = new(FactorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_factor
	return p
}

func InitEmptyFactorContext(p *FactorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_factor
}

func (*FactorContext) IsFactorContext() {}

func NewFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FactorContext {
	var p = new(FactorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_factor

	return p
}

func (s *FactorContext) GetParser() antlr.Parser { return s.parser }

func (s *FactorContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *FactorContext) AS() antlr.TerminalNode {
	return s.GetToken(pascalParserAS, 0)
}

func (s *FactorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FactorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *FactorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *FactorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FactorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *FactorContext) FunctionDesignator() IFunctionDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDesignatorContext)
}

func (s *FactorContext) UnsignedConstant() IUnsignedConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedConstantContext)
}

func (s *FactorContext) Set_() ISet_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_Context)
}

func (s *FactorContext) NOT() antlr.TerminalNode {
	return s.GetToken(pascalParserNOT, 0)
}

func (s *FactorContext) Factor() IFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *FactorContext) Bool_() IBool_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_Context)
}

func (s *FactorContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *FactorContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *FactorContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *FactorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *FactorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *FactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFactor(s)
	}
}

func (s *FactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFactor(s)
	}
}

func (s *FactorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFactor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Factor() (localctx IFactorContext) {
	return p.factor(0)
}

func (p *pascalParser) factor(_p int) (localctx IFactorContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewFactorContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IFactorContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 208
	p.EnterRecursionRule(localctx, 208, pascalParserRULE_factor, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1064)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1048)
			p.Variable()
		}
		p.SetState(1051)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1049)
				p.Match(pascalParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1050)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		{
			p.SetState(1053)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1054)
			p.Expression()
		}
		{
			p.SetState(1055)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(1057)
			p.FunctionDesignator()
		}

	case 4:
		{
			p.SetState(1058)
			p.UnsignedConstant()
		}

	case 5:
		{
			p.SetState(1059)
			p.Set_()
		}

	case 6:
		{
			p.SetState(1060)
			p.Match(pascalParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1061)
			p.factor(4)
		}

	case 7:
		{
			p.SetState(1062)
			p.Bool_()
		}

	case 8:
		{
			p.SetState(1063)
			p.TypeIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1080)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewFactorContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, pascalParserRULE_factor)
			p.SetState(1066)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(1067)
				p.Match(pascalParserLBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1068)
				p.Expression()
			}
			p.SetState(1073)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == pascalParserCOMMA {
				{
					p.SetState(1069)
					p.Match(pascalParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1070)
					p.Expression()
				}

				p.SetState(1075)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1076)
				p.Match(pascalParserRBRACK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1082)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedConstantContext is an interface to support dynamic dispatch.
type IUnsignedConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedNumber() IUnsignedNumberContext
	ConstantChr() IConstantChrContext
	String_() IStringContext
	NIL() antlr.TerminalNode

	// IsUnsignedConstantContext differentiates from other interfaces.
	IsUnsignedConstantContext()
}

type UnsignedConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedConstantContext() *UnsignedConstantContext {
	var p = new(UnsignedConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedConstant
	return p
}

func InitEmptyUnsignedConstantContext(p *UnsignedConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedConstant
}

func (*UnsignedConstantContext) IsUnsignedConstantContext() {}

func NewUnsignedConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedConstantContext {
	var p = new(UnsignedConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unsignedConstant

	return p
}

func (s *UnsignedConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedConstantContext) UnsignedNumber() IUnsignedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedNumberContext)
}

func (s *UnsignedConstantContext) ConstantChr() IConstantChrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantChrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantChrContext)
}

func (s *UnsignedConstantContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *UnsignedConstantContext) NIL() antlr.TerminalNode {
	return s.GetToken(pascalParserNIL, 0)
}

func (s *UnsignedConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnsignedConstant(s)
	}
}

func (s *UnsignedConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnsignedConstant(s)
	}
}

func (s *UnsignedConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnsignedConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnsignedConstant() (localctx IUnsignedConstantContext) {
	localctx = NewUnsignedConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, pascalParserRULE_unsignedConstant)
	p.SetState(1087)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserNUM_INT, pascalParserNUM_REAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1083)
			p.UnsignedNumber()
		}

	case pascalParserCHR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1084)
			p.ConstantChr()
		}

	case pascalParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1085)
			p.String_()
		}

	case pascalParserNIL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1086)
			p.Match(pascalParserNIL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDesignatorContext is an interface to support dynamic dispatch.
type IFunctionDesignatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	MethodIdentifier() IMethodIdentifierContext
	LT() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	GT() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext
	RPAREN() antlr.TerminalNode

	// IsFunctionDesignatorContext differentiates from other interfaces.
	IsFunctionDesignatorContext()
}

type FunctionDesignatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDesignatorContext() *FunctionDesignatorContext {
	var p = new(FunctionDesignatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionDesignator
	return p
}

func InitEmptyFunctionDesignatorContext(p *FunctionDesignatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionDesignator
}

func (*FunctionDesignatorContext) IsFunctionDesignatorContext() {}

func NewFunctionDesignatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDesignatorContext {
	var p = new(FunctionDesignatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_functionDesignator

	return p
}

func (s *FunctionDesignatorContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDesignatorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionDesignatorContext) MethodIdentifier() IMethodIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodIdentifierContext)
}

func (s *FunctionDesignatorContext) LT() antlr.TerminalNode {
	return s.GetToken(pascalParserLT, 0)
}

func (s *FunctionDesignatorContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *FunctionDesignatorContext) GT() antlr.TerminalNode {
	return s.GetToken(pascalParserGT, 0)
}

func (s *FunctionDesignatorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *FunctionDesignatorContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *FunctionDesignatorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *FunctionDesignatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDesignatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDesignatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFunctionDesignator(s)
	}
}

func (s *FunctionDesignatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFunctionDesignator(s)
	}
}

func (s *FunctionDesignatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFunctionDesignator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FunctionDesignator() (localctx IFunctionDesignatorContext) {
	localctx = NewFunctionDesignatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, pascalParserRULE_functionDesignator)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1091)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1089)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(1090)
			p.MethodIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(1097)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1093)
			p.Match(pascalParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1094)
			p.TypeIdentifier()
		}
		{
			p.SetState(1095)
			p.Match(pascalParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1103)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1099)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1100)
			p.ParameterList()
		}
		{
			p.SetState(1101)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterListContext is an interface to support dynamic dispatch.
type IParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllActualParameter() []IActualParameterContext
	ActualParameter(i int) IActualParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsParameterListContext differentiates from other interfaces.
	IsParameterListContext()
}

type ParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterListContext() *ParameterListContext {
	var p = new(ParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterList
	return p
}

func InitEmptyParameterListContext(p *ParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterList
}

func (*ParameterListContext) IsParameterListContext() {}

func NewParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterListContext {
	var p = new(ParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_parameterList

	return p
}

func (s *ParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterListContext) AllActualParameter() []IActualParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IActualParameterContext); ok {
			len++
		}
	}

	tst := make([]IActualParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IActualParameterContext); ok {
			tst[i] = t.(IActualParameterContext)
			i++
		}
	}

	return tst
}

func (s *ParameterListContext) ActualParameter(i int) IActualParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IActualParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IActualParameterContext)
}

func (s *ParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterParameterList(s)
	}
}

func (s *ParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitParameterList(s)
	}
}

func (s *ParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ParameterList() (localctx IParameterListContext) {
	localctx = NewParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, pascalParserRULE_parameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1105)
		p.ActualParameter()
	}
	p.SetState(1110)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(1106)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1107)
			p.ActualParameter()
		}

		p.SetState(1112)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_Context is an interface to support dynamic dispatch.
type ISet_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	ElementList() IElementListContext
	RBRACK() antlr.TerminalNode
	LBRACK2() antlr.TerminalNode
	RBRACK2() antlr.TerminalNode

	// IsSet_Context differentiates from other interfaces.
	IsSet_Context()
}

type Set_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_Context() *Set_Context {
	var p = new(Set_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_set_
	return p
}

func InitEmptySet_Context(p *Set_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_set_
}

func (*Set_Context) IsSet_Context() {}

func NewSet_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_Context {
	var p = new(Set_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_set_

	return p
}

func (s *Set_Context) GetParser() antlr.Parser { return s.parser }

func (s *Set_Context) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *Set_Context) ElementList() IElementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementListContext)
}

func (s *Set_Context) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *Set_Context) LBRACK2() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK2, 0)
}

func (s *Set_Context) RBRACK2() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK2, 0)
}

func (s *Set_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSet_(s)
	}
}

func (s *Set_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSet_(s)
	}
}

func (s *Set_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSet_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Set_() (localctx ISet_Context) {
	localctx = NewSet_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, pascalParserRULE_set_)
	p.SetState(1121)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserLBRACK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1113)
			p.Match(pascalParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1114)
			p.ElementList()
		}
		{
			p.SetState(1115)
			p.Match(pascalParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case pascalParserLBRACK2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1117)
			p.Match(pascalParserLBRACK2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1118)
			p.ElementList()
		}
		{
			p.SetState(1119)
			p.Match(pascalParserRBRACK2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementListContext is an interface to support dynamic dispatch.
type IElementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllElement() []IElementContext
	Element(i int) IElementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsElementListContext differentiates from other interfaces.
	IsElementListContext()
}

type ElementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementListContext() *ElementListContext {
	var p = new(ElementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_elementList
	return p
}

func InitEmptyElementListContext(p *ElementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_elementList
}

func (*ElementListContext) IsElementListContext() {}

func NewElementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementListContext {
	var p = new(ElementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_elementList

	return p
}

func (s *ElementListContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementListContext) AllElement() []IElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElementContext); ok {
			len++
		}
	}

	tst := make([]IElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElementContext); ok {
			tst[i] = t.(IElementContext)
			i++
		}
	}

	return tst
}

func (s *ElementListContext) Element(i int) IElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementContext)
}

func (s *ElementListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ElementListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ElementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterElementList(s)
	}
}

func (s *ElementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitElementList(s)
	}
}

func (s *ElementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitElementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ElementList() (localctx IElementListContext) {
	localctx = NewElementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, pascalParserRULE_elementList)
	var _la int

	p.SetState(1132)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserARRAY, pascalParserBOOLEAN, pascalParserCHAR, pascalParserCHR, pascalParserINTEGER, pascalParserNIL, pascalParserNOT, pascalParserREAL, pascalParserPLUS, pascalParserMINUS, pascalParserLPAREN, pascalParserLBRACK, pascalParserLBRACK2, pascalParserAT, pascalParserSTRING, pascalParserTRUE, pascalParserFALSE, pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT, pascalParserSTRING_LITERAL, pascalParserNUM_INT, pascalParserNUM_REAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1123)
			p.Element()
		}
		p.SetState(1128)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == pascalParserCOMMA {
			{
				p.SetState(1124)
				p.Match(pascalParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1125)
				p.Element()
			}

			p.SetState(1130)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case pascalParserRBRACK, pascalParserRBRACK2:
		p.EnterOuterAlt(localctx, 2)

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementContext is an interface to support dynamic dispatch.
type IElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	DOTDOT() antlr.TerminalNode

	// IsElementContext differentiates from other interfaces.
	IsElementContext()
}

type ElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementContext() *ElementContext {
	var p = new(ElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_element
	return p
}

func InitEmptyElementContext(p *ElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_element
}

func (*ElementContext) IsElementContext() {}

func NewElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementContext {
	var p = new(ElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_element

	return p
}

func (s *ElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ElementContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ElementContext) DOTDOT() antlr.TerminalNode {
	return s.GetToken(pascalParserDOTDOT, 0)
}

func (s *ElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterElement(s)
	}
}

func (s *ElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitElement(s)
	}
}

func (s *ElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Element() (localctx IElementContext) {
	localctx = NewElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, pascalParserRULE_element)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1134)
		p.Expression()
	}
	p.SetState(1137)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserDOTDOT {
		{
			p.SetState(1135)
			p.Match(pascalParserDOTDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1136)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureStatementContext is an interface to support dynamic dispatch.
type IProcedureStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext
	RPAREN() antlr.TerminalNode
	MethodIdentifier() IMethodIdentifierContext

	// IsProcedureStatementContext differentiates from other interfaces.
	IsProcedureStatementContext()
}

type ProcedureStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureStatementContext() *ProcedureStatementContext {
	var p = new(ProcedureStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureStatement
	return p
}

func InitEmptyProcedureStatementContext(p *ProcedureStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureStatement
}

func (*ProcedureStatementContext) IsProcedureStatementContext() {}

func NewProcedureStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureStatementContext {
	var p = new(ProcedureStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureStatement

	return p
}

func (s *ProcedureStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ProcedureStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ProcedureStatementContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *ProcedureStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ProcedureStatementContext) MethodIdentifier() IMethodIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodIdentifierContext)
}

func (s *ProcedureStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureStatement(s)
	}
}

func (s *ProcedureStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureStatement(s)
	}
}

func (s *ProcedureStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureStatement() (localctx IProcedureStatementContext) {
	localctx = NewProcedureStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, pascalParserRULE_procedureStatement)
	var _la int

	p.SetState(1153)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 111, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1139)
			p.Identifier()
		}
		p.SetState(1144)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLPAREN {
			{
				p.SetState(1140)
				p.Match(pascalParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1141)
				p.ParameterList()
			}
			{
				p.SetState(1142)
				p.Match(pascalParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1146)
			p.MethodIdentifier()
		}
		p.SetState(1151)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLPAREN {
			{
				p.SetState(1147)
				p.Match(pascalParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1148)
				p.ParameterList()
			}
			{
				p.SetState(1149)
				p.Match(pascalParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IActualParameterContext is an interface to support dynamic dispatch.
type IActualParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	AllParameterwidth() []IParameterwidthContext
	Parameterwidth(i int) IParameterwidthContext

	// IsActualParameterContext differentiates from other interfaces.
	IsActualParameterContext()
}

type ActualParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActualParameterContext() *ActualParameterContext {
	var p = new(ActualParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_actualParameter
	return p
}

func InitEmptyActualParameterContext(p *ActualParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_actualParameter
}

func (*ActualParameterContext) IsActualParameterContext() {}

func NewActualParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ActualParameterContext {
	var p = new(ActualParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_actualParameter

	return p
}

func (s *ActualParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ActualParameterContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ActualParameterContext) AllParameterwidth() []IParameterwidthContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterwidthContext); ok {
			len++
		}
	}

	tst := make([]IParameterwidthContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterwidthContext); ok {
			tst[i] = t.(IParameterwidthContext)
			i++
		}
	}

	return tst
}

func (s *ActualParameterContext) Parameterwidth(i int) IParameterwidthContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterwidthContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterwidthContext)
}

func (s *ActualParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ActualParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ActualParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterActualParameter(s)
	}
}

func (s *ActualParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitActualParameter(s)
	}
}

func (s *ActualParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitActualParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ActualParameter() (localctx IActualParameterContext) {
	localctx = NewActualParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, pascalParserRULE_actualParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1155)
		p.Expression()
	}
	p.SetState(1159)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOLON {
		{
			p.SetState(1156)
			p.Parameterwidth()
		}

		p.SetState(1161)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterwidthContext is an interface to support dynamic dispatch.
type IParameterwidthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode
	Expression() IExpressionContext

	// IsParameterwidthContext differentiates from other interfaces.
	IsParameterwidthContext()
}

type ParameterwidthContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterwidthContext() *ParameterwidthContext {
	var p = new(ParameterwidthContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterwidth
	return p
}

func InitEmptyParameterwidthContext(p *ParameterwidthContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterwidth
}

func (*ParameterwidthContext) IsParameterwidthContext() {}

func NewParameterwidthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterwidthContext {
	var p = new(ParameterwidthContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_parameterwidth

	return p
}

func (s *ParameterwidthContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterwidthContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *ParameterwidthContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParameterwidthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterwidthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterwidthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterParameterwidth(s)
	}
}

func (s *ParameterwidthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitParameterwidth(s)
	}
}

func (s *ParameterwidthContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitParameterwidth(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Parameterwidth() (localctx IParameterwidthContext) {
	localctx = NewParameterwidthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, pascalParserRULE_parameterwidth)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1162)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1163)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGotoStatementContext is an interface to support dynamic dispatch.
type IGotoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GOTO() antlr.TerminalNode
	Label() ILabelContext

	// IsGotoStatementContext differentiates from other interfaces.
	IsGotoStatementContext()
}

type GotoStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGotoStatementContext() *GotoStatementContext {
	var p = new(GotoStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_gotoStatement
	return p
}

func InitEmptyGotoStatementContext(p *GotoStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_gotoStatement
}

func (*GotoStatementContext) IsGotoStatementContext() {}

func NewGotoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GotoStatementContext {
	var p = new(GotoStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_gotoStatement

	return p
}

func (s *GotoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GotoStatementContext) GOTO() antlr.TerminalNode {
	return s.GetToken(pascalParserGOTO, 0)
}

func (s *GotoStatementContext) Label() ILabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *GotoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GotoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GotoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterGotoStatement(s)
	}
}

func (s *GotoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitGotoStatement(s)
	}
}

func (s *GotoStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitGotoStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) GotoStatement() (localctx IGotoStatementContext) {
	localctx = NewGotoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, pascalParserRULE_gotoStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1165)
		p.Match(pascalParserGOTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1166)
		p.Label()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInheritedStatementContext is an interface to support dynamic dispatch.
type IInheritedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INHERITED() antlr.TerminalNode
	Identifier() IIdentifierContext
	MethodIdentifier() IMethodIdentifierContext
	LPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext
	RPAREN() antlr.TerminalNode

	// IsInheritedStatementContext differentiates from other interfaces.
	IsInheritedStatementContext()
}

type InheritedStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInheritedStatementContext() *InheritedStatementContext {
	var p = new(InheritedStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_inheritedStatement
	return p
}

func InitEmptyInheritedStatementContext(p *InheritedStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_inheritedStatement
}

func (*InheritedStatementContext) IsInheritedStatementContext() {}

func NewInheritedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InheritedStatementContext {
	var p = new(InheritedStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_inheritedStatement

	return p
}

func (s *InheritedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InheritedStatementContext) INHERITED() antlr.TerminalNode {
	return s.GetToken(pascalParserINHERITED, 0)
}

func (s *InheritedStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InheritedStatementContext) MethodIdentifier() IMethodIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodIdentifierContext)
}

func (s *InheritedStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *InheritedStatementContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *InheritedStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *InheritedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InheritedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InheritedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInheritedStatement(s)
	}
}

func (s *InheritedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInheritedStatement(s)
	}
}

func (s *InheritedStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInheritedStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InheritedStatement() (localctx IInheritedStatementContext) {
	localctx = NewInheritedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, pascalParserRULE_inheritedStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1168)
		p.Match(pascalParserINHERITED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1171)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1169)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(1170)
			p.MethodIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(1177)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1173)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1174)
			p.ParameterList()
		}
		{
			p.SetState(1175)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmptyStatement_Context is an interface to support dynamic dispatch.
type IEmptyStatement_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsEmptyStatement_Context differentiates from other interfaces.
	IsEmptyStatement_Context()
}

type EmptyStatement_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatement_Context() *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_emptyStatement_
	return p
}

func InitEmptyEmptyStatement_Context(p *EmptyStatement_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_emptyStatement_
}

func (*EmptyStatement_Context) IsEmptyStatement_Context() {}

func NewEmptyStatement_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_emptyStatement_

	return p
}

func (s *EmptyStatement_Context) GetParser() antlr.Parser { return s.parser }
func (s *EmptyStatement_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatement_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatement_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitEmptyStatement_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) EmptyStatement_() (localctx IEmptyStatement_Context) {
	localctx = NewEmptyStatement_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, pascalParserRULE_emptyStatement_)
	p.EnterOuterAlt(localctx, 1)

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmpty_Context is an interface to support dynamic dispatch.
type IEmpty_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsEmpty_Context differentiates from other interfaces.
	IsEmpty_Context()
}

type Empty_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmpty_Context() *Empty_Context {
	var p = new(Empty_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_empty_
	return p
}

func InitEmptyEmpty_Context(p *Empty_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_empty_
}

func (*Empty_Context) IsEmpty_Context() {}

func NewEmpty_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Empty_Context {
	var p = new(Empty_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_empty_

	return p
}

func (s *Empty_Context) GetParser() antlr.Parser { return s.parser }
func (s *Empty_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Empty_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Empty_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterEmpty_(s)
	}
}

func (s *Empty_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitEmpty_(s)
	}
}

func (s *Empty_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitEmpty_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Empty_() (localctx IEmpty_Context) {
	localctx = NewEmpty_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, pascalParserRULE_empty_)
	p.EnterOuterAlt(localctx, 1)

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructuredStatementContext is an interface to support dynamic dispatch.
type IStructuredStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CompoundStatement() ICompoundStatementContext
	ConditionalStatement() IConditionalStatementContext
	RepetetiveStatement() IRepetetiveStatementContext
	WithStatement() IWithStatementContext
	TryExceptStatement() ITryExceptStatementContext
	TryFinallyStatement() ITryFinallyStatementContext

	// IsStructuredStatementContext differentiates from other interfaces.
	IsStructuredStatementContext()
}

type StructuredStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructuredStatementContext() *StructuredStatementContext {
	var p = new(StructuredStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_structuredStatement
	return p
}

func InitEmptyStructuredStatementContext(p *StructuredStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_structuredStatement
}

func (*StructuredStatementContext) IsStructuredStatementContext() {}

func NewStructuredStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructuredStatementContext {
	var p = new(StructuredStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_structuredStatement

	return p
}

func (s *StructuredStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StructuredStatementContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *StructuredStatementContext) ConditionalStatement() IConditionalStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalStatementContext)
}

func (s *StructuredStatementContext) RepetetiveStatement() IRepetetiveStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepetetiveStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepetetiveStatementContext)
}

func (s *StructuredStatementContext) WithStatement() IWithStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithStatementContext)
}

func (s *StructuredStatementContext) TryExceptStatement() ITryExceptStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryExceptStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryExceptStatementContext)
}

func (s *StructuredStatementContext) TryFinallyStatement() ITryFinallyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryFinallyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryFinallyStatementContext)
}

func (s *StructuredStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructuredStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructuredStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStructuredStatement(s)
	}
}

func (s *StructuredStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStructuredStatement(s)
	}
}

func (s *StructuredStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStructuredStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) StructuredStatement() (localctx IStructuredStatementContext) {
	localctx = NewStructuredStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, pascalParserRULE_structuredStatement)
	p.SetState(1189)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1183)
			p.CompoundStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1184)
			p.ConditionalStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1185)
			p.RepetetiveStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1186)
			p.WithStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1187)
			p.TryExceptStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1188)
			p.TryFinallyStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompoundStatementContext is an interface to support dynamic dispatch.
type ICompoundStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEGIN() antlr.TerminalNode
	Statements() IStatementsContext
	END() antlr.TerminalNode

	// IsCompoundStatementContext differentiates from other interfaces.
	IsCompoundStatementContext()
}

type CompoundStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundStatementContext() *CompoundStatementContext {
	var p = new(CompoundStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_compoundStatement
	return p
}

func InitEmptyCompoundStatementContext(p *CompoundStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_compoundStatement
}

func (*CompoundStatementContext) IsCompoundStatementContext() {}

func NewCompoundStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundStatementContext {
	var p = new(CompoundStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_compoundStatement

	return p
}

func (s *CompoundStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundStatementContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(pascalParserBEGIN, 0)
}

func (s *CompoundStatementContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *CompoundStatementContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *CompoundStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitCompoundStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) CompoundStatement() (localctx ICompoundStatementContext) {
	localctx = NewCompoundStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, pascalParserRULE_compoundStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1191)
		p.Match(pascalParserBEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1192)
		p.Statements()
	}
	{
		p.SetState(1193)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementsContext is an interface to support dynamic dispatch.
type IStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsStatementsContext differentiates from other interfaces.
	IsStatementsContext()
}

type StatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsContext() *StatementsContext {
	var p = new(StatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_statements
	return p
}

func InitEmptyStatementsContext(p *StatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_statements
}

func (*StatementsContext) IsStatementsContext() {}

func NewStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsContext {
	var p = new(StatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_statements

	return p
}

func (s *StatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementsContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementsContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *StatementsContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *StatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStatements(s)
	}
}

func (s *StatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStatements(s)
	}
}

func (s *StatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Statements() (localctx IStatementsContext) {
	localctx = NewStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, pascalParserRULE_statements)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1195)
		p.Statement()
	}
	p.SetState(1200)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 116, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1196)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1197)
				p.Statement()
			}

		}
		p.SetState(1202)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 116, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionalStatementContext is an interface to support dynamic dispatch.
type IConditionalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IfStatement() IIfStatementContext
	CaseStatement() ICaseStatementContext

	// IsConditionalStatementContext differentiates from other interfaces.
	IsConditionalStatementContext()
}

type ConditionalStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalStatementContext() *ConditionalStatementContext {
	var p = new(ConditionalStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_conditionalStatement
	return p
}

func InitEmptyConditionalStatementContext(p *ConditionalStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_conditionalStatement
}

func (*ConditionalStatementContext) IsConditionalStatementContext() {}

func NewConditionalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalStatementContext {
	var p = new(ConditionalStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_conditionalStatement

	return p
}

func (s *ConditionalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalStatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *ConditionalStatementContext) CaseStatement() ICaseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseStatementContext)
}

func (s *ConditionalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConditionalStatement(s)
	}
}

func (s *ConditionalStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConditionalStatement(s)
	}
}

func (s *ConditionalStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConditionalStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConditionalStatement() (localctx IConditionalStatementContext) {
	localctx = NewConditionalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, pascalParserRULE_conditionalStatement)
	p.SetState(1205)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserIF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1203)
			p.IfStatement()
		}

	case pascalParserCASE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1204)
			p.CaseStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	Expression() IExpressionContext
	THEN() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	ELSE() antlr.TerminalNode

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_ifStatement
	return p
}

func InitEmptyIfStatementContext(p *IfStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_ifStatement
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(pascalParserIF, 0)
}

func (s *IfStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfStatementContext) THEN() antlr.TerminalNode {
	return s.GetToken(pascalParserTHEN, 0)
}

func (s *IfStatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(pascalParserELSE, 0)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, pascalParserRULE_ifStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1207)
		p.Match(pascalParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1208)
		p.Expression()
	}
	{
		p.SetState(1209)
		p.Match(pascalParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1210)
		p.Statement()
	}
	p.SetState(1213)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1211)
			p.Match(pascalParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1212)
			p.Statement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseStatementContext is an interface to support dynamic dispatch.
type ICaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	Expression() IExpressionContext
	OF() antlr.TerminalNode
	AllCaseListElement() []ICaseListElementContext
	CaseListElement(i int) ICaseListElementContext
	END() antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	ELSE() antlr.TerminalNode
	Statements() IStatementsContext

	// IsCaseStatementContext differentiates from other interfaces.
	IsCaseStatementContext()
}

type CaseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseStatementContext() *CaseStatementContext {
	var p = new(CaseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_caseStatement
	return p
}

func InitEmptyCaseStatementContext(p *CaseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_caseStatement
}

func (*CaseStatementContext) IsCaseStatementContext() {}

func NewCaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseStatementContext {
	var p = new(CaseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_caseStatement

	return p
}

func (s *CaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseStatementContext) CASE() antlr.TerminalNode {
	return s.GetToken(pascalParserCASE, 0)
}

func (s *CaseStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseStatementContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *CaseStatementContext) AllCaseListElement() []ICaseListElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseListElementContext); ok {
			len++
		}
	}

	tst := make([]ICaseListElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseListElementContext); ok {
			tst[i] = t.(ICaseListElementContext)
			i++
		}
	}

	return tst
}

func (s *CaseStatementContext) CaseListElement(i int) ICaseListElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseListElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseListElementContext)
}

func (s *CaseStatementContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *CaseStatementContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *CaseStatementContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *CaseStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(pascalParserELSE, 0)
}

func (s *CaseStatementContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *CaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterCaseStatement(s)
	}
}

func (s *CaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitCaseStatement(s)
	}
}

func (s *CaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitCaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) CaseStatement() (localctx ICaseStatementContext) {
	localctx = NewCaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, pascalParserRULE_caseStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1215)
		p.Match(pascalParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1216)
		p.Expression()
	}
	{
		p.SetState(1217)
		p.Match(pascalParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1218)
		p.CaseListElement()
	}
	p.SetState(1223)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1219)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1220)
				p.CaseListElement()
			}

		}
		p.SetState(1225)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1229)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1226)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1227)
			p.Match(pascalParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1228)
			p.Statements()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1232)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserSEMI {
		{
			p.SetState(1231)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1234)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseListElementContext is an interface to support dynamic dispatch.
type ICaseListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConstList() IConstListContext
	COLON() antlr.TerminalNode
	Statement() IStatementContext

	// IsCaseListElementContext differentiates from other interfaces.
	IsCaseListElementContext()
}

type CaseListElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseListElementContext() *CaseListElementContext {
	var p = new(CaseListElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_caseListElement
	return p
}

func InitEmptyCaseListElementContext(p *CaseListElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_caseListElement
}

func (*CaseListElementContext) IsCaseListElementContext() {}

func NewCaseListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseListElementContext {
	var p = new(CaseListElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_caseListElement

	return p
}

func (s *CaseListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseListElementContext) ConstList() IConstListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstListContext)
}

func (s *CaseListElementContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *CaseListElementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *CaseListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseListElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterCaseListElement(s)
	}
}

func (s *CaseListElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitCaseListElement(s)
	}
}

func (s *CaseListElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitCaseListElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) CaseListElement() (localctx ICaseListElementContext) {
	localctx = NewCaseListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, pascalParserRULE_caseListElement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1236)
		p.ConstList()
	}
	{
		p.SetState(1237)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1238)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRepetetiveStatementContext is an interface to support dynamic dispatch.
type IRepetetiveStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WhileStatement() IWhileStatementContext
	RepeatStatement() IRepeatStatementContext
	ForStatement() IForStatementContext

	// IsRepetetiveStatementContext differentiates from other interfaces.
	IsRepetetiveStatementContext()
}

type RepetetiveStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepetetiveStatementContext() *RepetetiveStatementContext {
	var p = new(RepetetiveStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_repetetiveStatement
	return p
}

func InitEmptyRepetetiveStatementContext(p *RepetetiveStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_repetetiveStatement
}

func (*RepetetiveStatementContext) IsRepetetiveStatementContext() {}

func NewRepetetiveStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RepetetiveStatementContext {
	var p = new(RepetetiveStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_repetetiveStatement

	return p
}

func (s *RepetetiveStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RepetetiveStatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *RepetetiveStatementContext) RepeatStatement() IRepeatStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepeatStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepeatStatementContext)
}

func (s *RepetetiveStatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *RepetetiveStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepetetiveStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RepetetiveStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRepetetiveStatement(s)
	}
}

func (s *RepetetiveStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRepetetiveStatement(s)
	}
}

func (s *RepetetiveStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRepetetiveStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RepetetiveStatement() (localctx IRepetetiveStatementContext) {
	localctx = NewRepetetiveStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, pascalParserRULE_repetetiveStatement)
	p.SetState(1243)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserWHILE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1240)
			p.WhileStatement()
		}

	case pascalParserREPEAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1241)
			p.RepeatStatement()
		}

	case pascalParserFOR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1242)
			p.ForStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHILE() antlr.TerminalNode
	Expression() IExpressionContext
	DO() antlr.TerminalNode
	Statement() IStatementContext

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_whileStatement
	return p
}

func InitEmptyWhileStatementContext(p *WhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_whileStatement
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(pascalParserWHILE, 0)
}

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(pascalParserDO, 0)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (s *WhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, pascalParserRULE_whileStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1245)
		p.Match(pascalParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1246)
		p.Expression()
	}
	{
		p.SetState(1247)
		p.Match(pascalParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1248)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRepeatStatementContext is an interface to support dynamic dispatch.
type IRepeatStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPEAT() antlr.TerminalNode
	Statements() IStatementsContext
	UNTIL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsRepeatStatementContext differentiates from other interfaces.
	IsRepeatStatementContext()
}

type RepeatStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepeatStatementContext() *RepeatStatementContext {
	var p = new(RepeatStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_repeatStatement
	return p
}

func InitEmptyRepeatStatementContext(p *RepeatStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_repeatStatement
}

func (*RepeatStatementContext) IsRepeatStatementContext() {}

func NewRepeatStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RepeatStatementContext {
	var p = new(RepeatStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_repeatStatement

	return p
}

func (s *RepeatStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RepeatStatementContext) REPEAT() antlr.TerminalNode {
	return s.GetToken(pascalParserREPEAT, 0)
}

func (s *RepeatStatementContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *RepeatStatementContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(pascalParserUNTIL, 0)
}

func (s *RepeatStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RepeatStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepeatStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RepeatStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRepeatStatement(s)
	}
}

func (s *RepeatStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRepeatStatement(s)
	}
}

func (s *RepeatStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRepeatStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RepeatStatement() (localctx IRepeatStatementContext) {
	localctx = NewRepeatStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, pascalParserRULE_repeatStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1250)
		p.Match(pascalParserREPEAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1251)
		p.Statements()
	}
	{
		p.SetState(1252)
		p.Match(pascalParserUNTIL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1253)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode
	ForList() IForListContext
	DO() antlr.TerminalNode
	Statement() IStatementContext

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forStatement
	return p
}

func InitEmptyForStatementContext(p *ForStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forStatement
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(pascalParserFOR, 0)
}

func (s *ForStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ForStatementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(pascalParserASSIGN, 0)
}

func (s *ForStatementContext) ForList() IForListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForListContext)
}

func (s *ForStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(pascalParserDO, 0)
}

func (s *ForStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (s *ForStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitForStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ForStatement() (localctx IForStatementContext) {
	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, pascalParserRULE_forStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1255)
		p.Match(pascalParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1256)
		p.Identifier()
	}
	{
		p.SetState(1257)
		p.Match(pascalParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1258)
		p.ForList()
	}
	{
		p.SetState(1259)
		p.Match(pascalParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1260)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForListContext is an interface to support dynamic dispatch.
type IForListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InitialValue() IInitialValueContext
	FinalValue() IFinalValueContext
	TO() antlr.TerminalNode
	DOWNTO() antlr.TerminalNode

	// IsForListContext differentiates from other interfaces.
	IsForListContext()
}

type ForListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForListContext() *ForListContext {
	var p = new(ForListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forList
	return p
}

func InitEmptyForListContext(p *ForListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forList
}

func (*ForListContext) IsForListContext() {}

func NewForListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForListContext {
	var p = new(ForListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_forList

	return p
}

func (s *ForListContext) GetParser() antlr.Parser { return s.parser }

func (s *ForListContext) InitialValue() IInitialValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitialValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitialValueContext)
}

func (s *ForListContext) FinalValue() IFinalValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinalValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinalValueContext)
}

func (s *ForListContext) TO() antlr.TerminalNode {
	return s.GetToken(pascalParserTO, 0)
}

func (s *ForListContext) DOWNTO() antlr.TerminalNode {
	return s.GetToken(pascalParserDOWNTO, 0)
}

func (s *ForListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterForList(s)
	}
}

func (s *ForListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitForList(s)
	}
}

func (s *ForListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitForList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ForList() (localctx IForListContext) {
	localctx = NewForListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, pascalParserRULE_forList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1262)
		p.InitialValue()
	}
	{
		p.SetState(1263)
		_la = p.GetTokenStream().LA(1)

		if !(_la == pascalParserDOWNTO || _la == pascalParserTO) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1264)
		p.FinalValue()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitialValueContext is an interface to support dynamic dispatch.
type IInitialValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsInitialValueContext differentiates from other interfaces.
	IsInitialValueContext()
}

type InitialValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitialValueContext() *InitialValueContext {
	var p = new(InitialValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_initialValue
	return p
}

func InitEmptyInitialValueContext(p *InitialValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_initialValue
}

func (*InitialValueContext) IsInitialValueContext() {}

func NewInitialValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitialValueContext {
	var p = new(InitialValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_initialValue

	return p
}

func (s *InitialValueContext) GetParser() antlr.Parser { return s.parser }

func (s *InitialValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InitialValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitialValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitialValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInitialValue(s)
	}
}

func (s *InitialValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInitialValue(s)
	}
}

func (s *InitialValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInitialValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InitialValue() (localctx IInitialValueContext) {
	localctx = NewInitialValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, pascalParserRULE_initialValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1266)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFinalValueContext is an interface to support dynamic dispatch.
type IFinalValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsFinalValueContext differentiates from other interfaces.
	IsFinalValueContext()
}

type FinalValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinalValueContext() *FinalValueContext {
	var p = new(FinalValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_finalValue
	return p
}

func InitEmptyFinalValueContext(p *FinalValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_finalValue
}

func (*FinalValueContext) IsFinalValueContext() {}

func NewFinalValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinalValueContext {
	var p = new(FinalValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_finalValue

	return p
}

func (s *FinalValueContext) GetParser() antlr.Parser { return s.parser }

func (s *FinalValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FinalValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinalValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinalValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFinalValue(s)
	}
}

func (s *FinalValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFinalValue(s)
	}
}

func (s *FinalValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFinalValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FinalValue() (localctx IFinalValueContext) {
	localctx = NewFinalValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, pascalParserRULE_finalValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1268)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithStatementContext is an interface to support dynamic dispatch.
type IWithStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	RecordVariableList() IRecordVariableListContext
	DO() antlr.TerminalNode
	Statement() IStatementContext
	Expression() IExpressionContext

	// IsWithStatementContext differentiates from other interfaces.
	IsWithStatementContext()
}

type WithStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithStatementContext() *WithStatementContext {
	var p = new(WithStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_withStatement
	return p
}

func InitEmptyWithStatementContext(p *WithStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_withStatement
}

func (*WithStatementContext) IsWithStatementContext() {}

func NewWithStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithStatementContext {
	var p = new(WithStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_withStatement

	return p
}

func (s *WithStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WithStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(pascalParserWITH, 0)
}

func (s *WithStatementContext) RecordVariableList() IRecordVariableListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordVariableListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordVariableListContext)
}

func (s *WithStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(pascalParserDO, 0)
}

func (s *WithStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WithStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WithStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterWithStatement(s)
	}
}

func (s *WithStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitWithStatement(s)
	}
}

func (s *WithStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitWithStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) WithStatement() (localctx IWithStatementContext) {
	localctx = NewWithStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, pascalParserRULE_withStatement)
	p.SetState(1280)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1270)
			p.Match(pascalParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1271)
			p.RecordVariableList()
		}
		{
			p.SetState(1272)
			p.Match(pascalParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1273)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1275)
			p.Match(pascalParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1276)
			p.Expression()
		}
		{
			p.SetState(1277)
			p.Match(pascalParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1278)
			p.Statement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryExceptStatementContext is an interface to support dynamic dispatch.
type ITryExceptStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRY() antlr.TerminalNode
	AllStatements() []IStatementsContext
	Statements(i int) IStatementsContext
	EXCEPT() antlr.TerminalNode
	END() antlr.TerminalNode

	// IsTryExceptStatementContext differentiates from other interfaces.
	IsTryExceptStatementContext()
}

type TryExceptStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryExceptStatementContext() *TryExceptStatementContext {
	var p = new(TryExceptStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tryExceptStatement
	return p
}

func InitEmptyTryExceptStatementContext(p *TryExceptStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tryExceptStatement
}

func (*TryExceptStatementContext) IsTryExceptStatementContext() {}

func NewTryExceptStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryExceptStatementContext {
	var p = new(TryExceptStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_tryExceptStatement

	return p
}

func (s *TryExceptStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryExceptStatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(pascalParserTRY, 0)
}

func (s *TryExceptStatementContext) AllStatements() []IStatementsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementsContext); ok {
			len++
		}
	}

	tst := make([]IStatementsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementsContext); ok {
			tst[i] = t.(IStatementsContext)
			i++
		}
	}

	return tst
}

func (s *TryExceptStatementContext) Statements(i int) IStatementsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *TryExceptStatementContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(pascalParserEXCEPT, 0)
}

func (s *TryExceptStatementContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *TryExceptStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryExceptStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryExceptStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTryExceptStatement(s)
	}
}

func (s *TryExceptStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTryExceptStatement(s)
	}
}

func (s *TryExceptStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTryExceptStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TryExceptStatement() (localctx ITryExceptStatementContext) {
	localctx = NewTryExceptStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, pascalParserRULE_tryExceptStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1282)
		p.Match(pascalParserTRY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1283)
		p.Statements()
	}
	{
		p.SetState(1284)
		p.Match(pascalParserEXCEPT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1285)
		p.Statements()
	}
	{
		p.SetState(1286)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryFinallyStatementContext is an interface to support dynamic dispatch.
type ITryFinallyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRY() antlr.TerminalNode
	AllStatements() []IStatementsContext
	Statements(i int) IStatementsContext
	FINALLY() antlr.TerminalNode
	END() antlr.TerminalNode

	// IsTryFinallyStatementContext differentiates from other interfaces.
	IsTryFinallyStatementContext()
}

type TryFinallyStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryFinallyStatementContext() *TryFinallyStatementContext {
	var p = new(TryFinallyStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tryFinallyStatement
	return p
}

func InitEmptyTryFinallyStatementContext(p *TryFinallyStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tryFinallyStatement
}

func (*TryFinallyStatementContext) IsTryFinallyStatementContext() {}

func NewTryFinallyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryFinallyStatementContext {
	var p = new(TryFinallyStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_tryFinallyStatement

	return p
}

func (s *TryFinallyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryFinallyStatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(pascalParserTRY, 0)
}

func (s *TryFinallyStatementContext) AllStatements() []IStatementsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementsContext); ok {
			len++
		}
	}

	tst := make([]IStatementsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementsContext); ok {
			tst[i] = t.(IStatementsContext)
			i++
		}
	}

	return tst
}

func (s *TryFinallyStatementContext) Statements(i int) IStatementsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *TryFinallyStatementContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(pascalParserFINALLY, 0)
}

func (s *TryFinallyStatementContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *TryFinallyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryFinallyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryFinallyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTryFinallyStatement(s)
	}
}

func (s *TryFinallyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTryFinallyStatement(s)
	}
}

func (s *TryFinallyStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTryFinallyStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TryFinallyStatement() (localctx ITryFinallyStatementContext) {
	localctx = NewTryFinallyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, pascalParserRULE_tryFinallyStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1288)
		p.Match(pascalParserTRY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1289)
		p.Statements()
	}
	{
		p.SetState(1290)
		p.Match(pascalParserFINALLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1291)
		p.Statements()
	}
	{
		p.SetState(1292)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordVariableListContext is an interface to support dynamic dispatch.
type IRecordVariableListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariable() []IVariableContext
	Variable(i int) IVariableContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRecordVariableListContext differentiates from other interfaces.
	IsRecordVariableListContext()
}

type RecordVariableListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordVariableListContext() *RecordVariableListContext {
	var p = new(RecordVariableListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordVariableList
	return p
}

func InitEmptyRecordVariableListContext(p *RecordVariableListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordVariableList
}

func (*RecordVariableListContext) IsRecordVariableListContext() {}

func NewRecordVariableListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordVariableListContext {
	var p = new(RecordVariableListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordVariableList

	return p
}

func (s *RecordVariableListContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordVariableListContext) AllVariable() []IVariableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableContext); ok {
			len++
		}
	}

	tst := make([]IVariableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableContext); ok {
			tst[i] = t.(IVariableContext)
			i++
		}
	}

	return tst
}

func (s *RecordVariableListContext) Variable(i int) IVariableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *RecordVariableListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *RecordVariableListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *RecordVariableListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordVariableListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordVariableListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordVariableList(s)
	}
}

func (s *RecordVariableListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordVariableList(s)
	}
}

func (s *RecordVariableListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordVariableList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordVariableList() (localctx IRecordVariableListContext) {
	localctx = NewRecordVariableListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, pascalParserRULE_recordVariableList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1294)
		p.Variable()
	}
	p.SetState(1299)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(1295)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1296)
			p.Variable()
		}

		p.SetState(1301)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *pascalParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 104:
		var t *FactorContext = nil
		if localctx != nil {
			t = localctx.(*FactorContext)
		}
		return p.Factor_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *pascalParser) Factor_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
