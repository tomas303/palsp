// Code generated from /home/tomas/development/tomas303/projects/pascallsp/palsp/internal/pascal.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // pascal

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type pascalParser struct {
	*antlr.BaseParser
}

var PascalParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func pascalParserInit() {
	staticData := &PascalParserStaticData
	staticData.LiteralNames = []string{
		"", "", "'AND'", "'ARRAY'", "'BEGIN'", "'BOOLEAN'", "'CASE'", "'CHAR'",
		"'CHR'", "'CONST'", "'DIV'", "'DO'", "'DOWNTO'", "'ELSE'", "'END'",
		"'FILE'", "'FOR'", "'FUNCTION'", "'GOTO'", "'HELPER'", "'IF'", "'IN'",
		"'INTEGER'", "'LABEL'", "'MOD'", "'NIL'", "'NOT'", "'OF'", "'OR'", "'PACKED'",
		"'PROCEDURE'", "'PROGRAM'", "'REAL'", "'RECORD'", "'REFERENCE'", "'REPEAT'",
		"'SET'", "'THEN'", "'TO'", "'TYPE'", "'UNTIL'", "'VAR'", "'WHILE'",
		"'WITH'", "'+'", "'-'", "'*'", "'/'", "':='", "','", "';'", "':'", "'='",
		"'<>'", "'<'", "'<='", "'>='", "'>'", "'('", "')'", "'['", "'(.'", "']'",
		"'.)'", "'^'", "'@'", "'.'", "'..'", "'{'", "'}'", "'UNIT'", "'INTERFACE'",
		"'USES'", "'STRING'", "'IMPLEMENTATION'", "'TRUE'", "'FALSE'", "'CLASS'",
		"'PRIVATE'", "'PROTECTED'", "'PUBLIC'", "'PUBLISHED'", "'STRICT'", "'OUT'",
		"'PROPERTY'", "'READ'", "'WRITE'", "'DEFAULT'", "'INDEX'", "'AS'", "'TRY'",
		"'FINALLY'", "'EXCEPT'", "'INITIALIZATION'", "'FINALIZATION'", "'OBJECT'",
		"'INHERITED'", "'ABSTRACT'", "'REINTRODUCE'", "'VIRTUAL'", "'OVERRIDE'",
		"'OVERLOAD'", "'INLINE'", "'CDECL'", "'stdcall'", "'STATIC'", "'CONSTRUCTOR'",
		"'DESTRUCTOR'", "'resourcestring'", "'FORWARD'", "'RAISE'", "'SHR'",
		"'SHL'", "'XOR'", "'Cardinal'", "'LONGBOOL'", "'LONGINT'", "'operator'",
		"", "", "", "", "", "", "", "", "", "", "'\\uFEFF'",
	}
	staticData.SymbolicNames = []string{
		"", "GUID_LITERAL", "AND", "ARRAY", "BEGIN", "BOOLEAN", "CASE", "CHAR",
		"CHR", "CONST", "DIV", "DO", "DOWNTO", "ELSE", "END", "FILE", "FOR",
		"FUNCTION", "GOTO", "HELPER", "IF", "IN", "INTEGER", "LABEL", "MOD",
		"NIL", "NOT", "OF", "OR", "PACKED", "PROCEDURE", "PROGRAM", "REAL",
		"RECORD", "REFERENCE", "REPEAT", "SET", "THEN", "TO", "TYPE", "UNTIL",
		"VAR", "WHILE", "WITH", "PLUS", "MINUS", "STAR", "SLASH", "ASSIGN",
		"COMMA", "SEMI", "COLON", "EQUAL", "NOT_EQUAL", "LT", "LE", "GE", "GT",
		"LPAREN", "RPAREN", "LBRACK", "LBRACK2", "RBRACK", "RBRACK2", "DEREFERENCE",
		"AT", "DOT", "DOTDOT", "LCURLY", "RCURLY", "UNIT", "INTERFACE", "USES",
		"STRING", "IMPLEMENTATION", "TRUE", "FALSE", "CLASS", "PRIVATE", "PROTECTED",
		"PUBLIC", "PUBLISHED", "STRICT", "OUT", "PROPERTY", "READ", "WRITE",
		"DEFAULT", "INDEX", "AS", "TRY", "FINALLY", "EXCEPT", "INITIALIZATION",
		"FINALIZATION", "OBJECT", "INHERITED", "ABSTRACT", "REINTRODUCE", "VIRTUAL",
		"OVERRIDE", "OVERLOAD", "INLINE", "CDECL", "STDCALL", "STATIC", "CONSTRUCTOR",
		"DESTRUCTOR", "RESOURCESTRING", "FORWARD", "RAISE", "SHR", "SHL", "XOR",
		"CARDINAL", "LONGBOOL", "LONGINT", "OPERATOR", "WS", "COMMENT_1", "COMMENT_2",
		"COMMENT_3", "IDENT", "HEX_LITERAL", "STRING_LITERAL", "STRING_CROSSHATCH_LITERAL",
		"NUM_INT", "NUM_REAL", "UTF8BOM",
	}
	staticData.RuleNames = []string{
		"source", "program", "unit", "interfaceSection", "implementationSection",
		"initializationSection", "finalizationSection", "identifier", "identifierPart",
		"interfaceBlock", "implementationBlock", "block", "usesUnits", "labelDeclarationPart",
		"label", "constantDefinitionPart", "constantDefinition", "constantChr",
		"hexConstant", "constant", "arrayConstant", "unsignedNumber", "unsignedInteger",
		"unsignedReal", "sign", "bool_", "string", "stringExpression", "resourceDefinitionPart",
		"resourceDefinition", "typeDefinitionPart", "typeDefinition", "functionType",
		"procedureType", "forwardClassType", "forwardInterfaceType", "classType",
		"classImplementsInterfaces", "accessSpecifier", "classDeclaration",
		"classImplicitPublishedDeclaration", "classDeclarationPart", "interfaceGuidConst",
		"interfaceType", "interfaceDeclaration", "interfaceDeclarationPart",
		"errorInterfaceDeclarationPart", "errorClassDeclarationPart", "propertyDeclaration",
		"propertyReadDeclaration", "propertyWriteDeclaration", "propertyDefaultValueDeclaration",
		"propertyIndexDeclaration", "propertyIndexParameters", "propertyIndexParametersList",
		"genericTemplate", "genericTemplateList", "genericTypeParameter", "genericConstraints",
		"genericConstraint", "type_", "simpleType", "scalarType", "scalerList",
		"scalerMember", "subrangeType", "typeIdentifier", "structuredType",
		"unpackedStructuredType", "stringtype", "arrayType", "typeList", "indexType",
		"recordType", "recordDeclaration", "recordImplicitPublishedDeclaration",
		"recordDeclarationPart", "errorRecordDeclarationPart", "recordParts",
		"recordFixedPart", "recordVariantPart", "tag", "recordVariant", "helperType",
		"helperDeclaration", "helperImplicitPublishedDeclaration", "helperDeclarationPart",
		"errorHelperDeclarationPart", "setType", "fileType", "pointerType",
		"variableDeclarationPart", "variableDeclaration", "procedureHeader",
		"functionHeader", "procedureOrFunctionHeader", "procedureOrFunctionHeaderModifiers",
		"procedureOrFunctionDeclaration", "procedureDeclaration", "functionDeclaration",
		"procedureLambdaDeclaration", "functionLambdaDeclaration", "resultType",
		"procedureOrFunctionBody", "classOperatorHeader", "classOperatorDeclaration",
		"formalParameterList", "formalParameterSection", "parameterGroup", "identifierList",
		"constList", "defaultValue", "typedIdentifierList", "statement", "errorStatement",
		"unlabelledStatement", "simpleStatement", "assignmentStatement", "raiseExceptionStatement",
		"variableDeclarationStatement", "variableDesignator", "typeCast", "propertyDesignator",
		"expression", "relationaloperator", "simpleExpression", "additiveoperator",
		"term", "multiplicativeoperator", "signedFactor", "factor", "unsignedConstant",
		"functionDesignator", "defaultDesignator", "parameterList", "set_",
		"elementList", "element", "procedureStatement", "methodCallStatement",
		"actualParameter", "parameterwidth", "gotoStatement", "inheritedStatement",
		"emptyStatement_", "empty_", "structuredStatement", "compoundStatement",
		"statements", "conditionalStatement", "ifStatement", "caseStatement",
		"caseListElement", "repetetiveStatement", "whileStatement", "repeatStatement",
		"forStatement", "forList", "initialValue", "finalValue", "withStatement",
		"tryExceptStatement", "tryFinallyStatement", "withStatementVariableList",
		"attributeSection", "attributeList", "attributeItem",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 128, 1745, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 1,
		0, 1, 0, 3, 0, 337, 8, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 345,
		8, 1, 1, 1, 1, 1, 3, 1, 349, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 363, 8, 2, 1, 2, 3, 2, 366, 8,
		2, 1, 2, 3, 2, 369, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 3, 1, 3, 3, 3, 377,
		8, 3, 1, 3, 1, 3, 1, 4, 1, 4, 3, 4, 383, 8, 4, 1, 4, 1, 4, 1, 5, 1, 5,
		1, 5, 1, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 5, 7, 396, 8, 7, 10, 7, 12, 7,
		399, 9, 7, 1, 8, 1, 8, 3, 8, 403, 8, 8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1,
		9, 5, 9, 411, 8, 9, 10, 9, 12, 9, 414, 9, 9, 1, 10, 1, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 5, 10, 427, 8, 10, 10,
		10, 12, 10, 430, 9, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 5, 11, 437,
		8, 11, 10, 11, 12, 11, 440, 9, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13, 1,
		13, 1, 13, 1, 13, 5, 13, 450, 8, 13, 10, 13, 12, 13, 453, 9, 13, 1, 13,
		1, 13, 1, 14, 1, 14, 1, 15, 1, 15, 1, 15, 1, 15, 4, 15, 463, 8, 15, 11,
		15, 12, 15, 464, 1, 16, 1, 16, 1, 16, 3, 16, 470, 8, 16, 1, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 481, 8, 16, 1,
		17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 19, 1, 19, 1, 19, 1, 19,
		1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1,
		19, 3, 19, 505, 8, 19, 5, 19, 507, 8, 19, 10, 19, 12, 19, 510, 9, 19, 3,
		19, 512, 8, 19, 1, 20, 1, 20, 1, 20, 1, 20, 5, 20, 518, 8, 20, 10, 20,
		12, 20, 521, 9, 20, 1, 20, 1, 20, 1, 21, 1, 21, 3, 21, 527, 8, 21, 1, 22,
		1, 22, 1, 23, 1, 23, 1, 24, 1, 24, 1, 25, 1, 25, 1, 26, 4, 26, 538, 8,
		26, 11, 26, 12, 26, 539, 1, 27, 1, 27, 1, 27, 5, 27, 545, 8, 27, 10, 27,
		12, 27, 548, 9, 27, 1, 28, 1, 28, 4, 28, 552, 8, 28, 11, 28, 12, 28, 553,
		1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 30, 4, 30, 565,
		8, 30, 11, 30, 12, 30, 566, 1, 31, 3, 31, 570, 8, 31, 1, 31, 1, 31, 1,
		31, 1, 31, 1, 31, 1, 31, 1, 31, 3, 31, 579, 8, 31, 1, 32, 1, 32, 3, 32,
		583, 8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 589, 8, 32, 1, 32, 1, 32,
		1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 597, 8, 32, 1, 32, 1, 32, 1, 32, 1,
		32, 3, 32, 603, 8, 32, 1, 33, 1, 33, 3, 33, 607, 8, 33, 1, 33, 1, 33, 3,
		33, 611, 8, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 618, 8, 33, 1,
		33, 3, 33, 621, 8, 33, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35, 1, 35, 1, 36,
		1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 3, 36, 635, 8, 36, 1, 36, 3, 36, 638,
		8, 36, 1, 36, 1, 36, 5, 36, 642, 8, 36, 10, 36, 12, 36, 645, 9, 36, 1,
		36, 1, 36, 1, 37, 1, 37, 5, 37, 651, 8, 37, 10, 37, 12, 37, 654, 9, 37,
		1, 38, 3, 38, 657, 8, 38, 1, 38, 1, 38, 3, 38, 661, 8, 38, 1, 38, 1, 38,
		1, 38, 3, 38, 666, 8, 38, 1, 39, 1, 39, 5, 39, 670, 8, 39, 10, 39, 12,
		39, 673, 9, 39, 1, 40, 5, 40, 676, 8, 40, 10, 40, 12, 40, 679, 9, 40, 1,
		41, 3, 41, 682, 8, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41,
		1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 695, 8, 41, 1, 41, 1, 41, 1, 41, 3,
		41, 700, 8, 41, 1, 42, 1, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43,
		709, 8, 43, 1, 43, 3, 43, 712, 8, 43, 1, 43, 1, 43, 1, 43, 1, 44, 5, 44,
		718, 8, 44, 10, 44, 12, 44, 721, 9, 44, 1, 45, 1, 45, 1, 45, 1, 45, 1,
		45, 1, 45, 1, 45, 1, 45, 3, 45, 731, 8, 45, 1, 46, 4, 46, 734, 8, 46, 11,
		46, 12, 46, 735, 1, 47, 4, 47, 739, 8, 47, 11, 47, 12, 47, 740, 1, 48,
		1, 48, 1, 48, 3, 48, 746, 8, 48, 1, 48, 1, 48, 1, 48, 3, 48, 751, 8, 48,
		1, 48, 3, 48, 754, 8, 48, 1, 48, 3, 48, 757, 8, 48, 1, 48, 3, 48, 760,
		8, 48, 1, 48, 1, 48, 3, 48, 764, 8, 48, 1, 48, 1, 48, 1, 48, 3, 48, 769,
		8, 48, 3, 48, 771, 8, 48, 1, 49, 1, 49, 1, 49, 1, 50, 1, 50, 1, 50, 1,
		51, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 1, 53, 5, 53,
		789, 8, 53, 10, 53, 12, 53, 792, 9, 53, 1, 53, 1, 53, 1, 54, 1, 54, 1,
		54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 5, 54, 804, 8, 54, 10, 54, 12, 54,
		807, 9, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 56, 1, 56, 1, 56, 5, 56, 816,
		8, 56, 10, 56, 12, 56, 819, 9, 56, 1, 57, 1, 57, 1, 57, 3, 57, 824, 8,
		57, 1, 58, 1, 58, 1, 58, 5, 58, 829, 8, 58, 10, 58, 12, 58, 832, 9, 58,
		1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 841, 8, 59, 1,
		60, 1, 60, 1, 60, 3, 60, 846, 8, 60, 1, 61, 1, 61, 1, 61, 1, 61, 3, 61,
		852, 8, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1, 63, 1, 63, 1, 63, 5, 63, 861,
		8, 63, 10, 63, 12, 63, 864, 9, 63, 1, 64, 1, 64, 1, 64, 3, 64, 869, 8,
		64, 1, 65, 1, 65, 1, 65, 1, 65, 1, 66, 1, 66, 1, 66, 3, 66, 878, 8, 66,
		1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 3, 67, 887, 8, 67, 1,
		68, 1, 68, 1, 68, 3, 68, 892, 8, 68, 1, 69, 1, 69, 1, 69, 1, 69, 3, 69,
		898, 8, 69, 1, 69, 1, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1,
		70, 1, 70, 3, 70, 910, 8, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70,
		1, 70, 1, 70, 3, 70, 920, 8, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1,
		70, 3, 70, 928, 8, 70, 1, 71, 1, 71, 1, 71, 5, 71, 933, 8, 71, 10, 71,
		12, 71, 936, 9, 71, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73, 5, 73, 943, 8, 73,
		10, 73, 12, 73, 946, 9, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 952, 8,
		73, 1, 73, 3, 73, 955, 8, 73, 1, 74, 1, 74, 5, 74, 959, 8, 74, 10, 74,
		12, 74, 962, 9, 74, 1, 75, 5, 75, 965, 8, 75, 10, 75, 12, 75, 968, 9, 75,
		1, 76, 3, 76, 971, 8, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1,
		76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 3, 76, 985, 8, 76, 1, 76, 1, 76,
		1, 76, 3, 76, 990, 8, 76, 1, 77, 4, 77, 993, 8, 77, 11, 77, 12, 77, 994,
		1, 78, 1, 78, 1, 78, 3, 78, 1000, 8, 78, 1, 78, 3, 78, 1003, 8, 78, 1,
		79, 1, 79, 1, 79, 5, 79, 1008, 8, 79, 10, 79, 12, 79, 1011, 9, 79, 1, 79,
		3, 79, 1014, 8, 79, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 5, 80, 1022,
		8, 80, 10, 80, 12, 80, 1025, 9, 80, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81,
		3, 81, 1032, 8, 81, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 83, 1,
		83, 1, 83, 1, 83, 1, 83, 1, 83, 5, 83, 1046, 8, 83, 10, 83, 12, 83, 1049,
		9, 83, 1, 83, 1, 83, 1, 84, 1, 84, 5, 84, 1055, 8, 84, 10, 84, 12, 84,
		1058, 9, 84, 1, 85, 5, 85, 1061, 8, 85, 10, 85, 12, 85, 1064, 9, 85, 1,
		86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 3, 86, 1074, 8, 86,
		1, 86, 1, 86, 1, 86, 3, 86, 1079, 8, 86, 1, 87, 4, 87, 1082, 8, 87, 11,
		87, 12, 87, 1083, 1, 88, 1, 88, 1, 88, 1, 88, 1, 89, 1, 89, 1, 89, 1, 89,
		3, 89, 1094, 8, 89, 1, 90, 1, 90, 1, 90, 1, 91, 1, 91, 1, 91, 1, 91, 5,
		91, 1103, 8, 91, 10, 91, 12, 91, 1106, 9, 91, 1, 91, 1, 91, 1, 92, 3, 92,
		1111, 8, 92, 1, 92, 1, 92, 1, 92, 3, 92, 1116, 8, 92, 1, 93, 3, 93, 1119,
		8, 93, 1, 93, 3, 93, 1122, 8, 93, 1, 93, 1, 93, 1, 93, 3, 93, 1127, 8,
		93, 1, 93, 1, 93, 1, 93, 1, 94, 3, 94, 1133, 8, 94, 1, 94, 3, 94, 1136,
		8, 94, 1, 94, 1, 94, 1, 94, 3, 94, 1141, 8, 94, 1, 94, 1, 94, 1, 94, 1,
		94, 1, 94, 1, 95, 1, 95, 3, 95, 1150, 8, 95, 1, 96, 1, 96, 5, 96, 1154,
		8, 96, 10, 96, 12, 96, 1157, 9, 96, 1, 97, 1, 97, 3, 97, 1161, 8, 97, 1,
		98, 1, 98, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 1, 99, 1, 100, 1, 100, 3,
		100, 1173, 8, 100, 1, 100, 1, 100, 1, 101, 1, 101, 3, 101, 1179, 8, 101,
		1, 101, 1, 101, 1, 101, 1, 101, 1, 102, 1, 102, 1, 103, 1, 103, 1, 103,
		1, 104, 1, 104, 1, 104, 1, 104, 3, 104, 1194, 8, 104, 1, 104, 1, 104, 1,
		104, 1, 104, 1, 104, 1, 105, 1, 105, 1, 105, 1, 105, 1, 106, 1, 106, 1,
		106, 1, 106, 5, 106, 1209, 8, 106, 10, 106, 12, 106, 1212, 9, 106, 1, 106,
		1, 106, 1, 107, 3, 107, 1217, 8, 107, 1, 107, 1, 107, 3, 107, 1221, 8,
		107, 1, 107, 1, 107, 1, 107, 3, 107, 1226, 8, 107, 1, 107, 1, 107, 1, 107,
		3, 107, 1231, 8, 107, 1, 107, 1, 107, 1, 107, 3, 107, 1236, 8, 107, 1,
		107, 1, 107, 1, 107, 3, 107, 1241, 8, 107, 1, 107, 1, 107, 3, 107, 1245,
		8, 107, 1, 108, 1, 108, 1, 108, 3, 108, 1250, 8, 108, 1, 108, 3, 108, 1253,
		8, 108, 1, 109, 1, 109, 1, 109, 5, 109, 1258, 8, 109, 10, 109, 12, 109,
		1261, 9, 109, 1, 110, 1, 110, 1, 110, 5, 110, 1266, 8, 110, 10, 110, 12,
		110, 1269, 9, 110, 1, 111, 1, 111, 1, 111, 1, 112, 1, 112, 1, 112, 1, 112,
		1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 3, 113, 1284, 8, 113, 1,
		114, 4, 114, 1287, 8, 114, 11, 114, 12, 114, 1288, 1, 115, 1, 115, 3, 115,
		1293, 8, 115, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1,
		116, 1, 116, 3, 116, 1304, 8, 116, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117,
		1, 117, 1, 117, 1, 117, 3, 117, 1314, 8, 117, 1, 118, 1, 118, 3, 118, 1318,
		8, 118, 1, 119, 1, 119, 1, 119, 1, 119, 3, 119, 1324, 8, 119, 1, 119, 1,
		119, 3, 119, 1328, 8, 119, 1, 120, 1, 120, 1, 120, 1, 120, 3, 120, 1334,
		8, 120, 1, 120, 1, 120, 1, 120, 1, 120, 5, 120, 1340, 8, 120, 10, 120,
		12, 120, 1343, 9, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120,
		5, 120, 1351, 8, 120, 10, 120, 12, 120, 1354, 9, 120, 1, 120, 1, 120, 1,
		120, 1, 120, 1, 120, 4, 120, 1361, 8, 120, 11, 120, 12, 120, 1362, 5, 120,
		1365, 8, 120, 10, 120, 12, 120, 1368, 9, 120, 1, 121, 1, 121, 1, 121, 1,
		121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 3, 121, 1381,
		8, 121, 1, 122, 1, 122, 1, 122, 5, 122, 1386, 8, 122, 10, 122, 12, 122,
		1389, 9, 122, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 5, 122, 1397,
		8, 122, 10, 122, 12, 122, 1400, 9, 122, 1, 122, 1, 122, 3, 122, 1404, 8,
		122, 1, 123, 1, 123, 1, 123, 1, 123, 3, 123, 1410, 8, 123, 1, 124, 1, 124,
		1, 125, 1, 125, 1, 125, 1, 125, 3, 125, 1418, 8, 125, 1, 126, 1, 126, 1,
		127, 1, 127, 1, 127, 1, 127, 3, 127, 1426, 8, 127, 1, 128, 1, 128, 1, 129,
		3, 129, 1431, 8, 129, 1, 129, 1, 129, 1, 130, 1, 130, 3, 130, 1437, 8,
		130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 3, 130, 1444, 8, 130, 1, 130,
		1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130,
		3, 130, 1456, 8, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 3, 130, 1463,
		8, 130, 1, 130, 5, 130, 1466, 8, 130, 10, 130, 12, 130, 1469, 9, 130, 3,
		130, 1471, 8, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 5, 130, 1478,
		8, 130, 10, 130, 12, 130, 1481, 9, 130, 1, 130, 1, 130, 1, 130, 1, 130,
		1, 130, 4, 130, 1488, 8, 130, 11, 130, 12, 130, 1489, 5, 130, 1492, 8,
		130, 10, 130, 12, 130, 1495, 9, 130, 1, 131, 1, 131, 1, 131, 1, 131, 1,
		131, 3, 131, 1502, 8, 131, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 3, 132,
		1509, 8, 132, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 134, 1, 134, 1,
		134, 5, 134, 1519, 8, 134, 10, 134, 12, 134, 1522, 9, 134, 1, 135, 1, 135,
		1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 3, 135, 1532, 8, 135, 1,
		136, 1, 136, 1, 136, 5, 136, 1537, 8, 136, 10, 136, 12, 136, 1540, 9, 136,
		1, 136, 3, 136, 1543, 8, 136, 1, 137, 1, 137, 1, 137, 3, 137, 1548, 8,
		137, 1, 138, 1, 138, 1, 138, 1, 138, 1, 138, 3, 138, 1555, 8, 138, 1, 139,
		1, 139, 1, 139, 5, 139, 1560, 8, 139, 10, 139, 12, 139, 1563, 9, 139, 1,
		139, 1, 139, 1, 139, 1, 139, 1, 139, 1, 139, 3, 139, 1571, 8, 139, 1, 140,
		1, 140, 5, 140, 1575, 8, 140, 10, 140, 12, 140, 1578, 9, 140, 1, 140, 1,
		140, 3, 140, 1582, 8, 140, 1, 141, 1, 141, 1, 141, 1, 142, 1, 142, 1, 142,
		1, 143, 1, 143, 1, 143, 1, 143, 1, 143, 1, 143, 3, 143, 1596, 8, 143, 3,
		143, 1598, 8, 143, 1, 144, 1, 144, 1, 145, 1, 145, 1, 146, 1, 146, 1, 146,
		1, 146, 1, 146, 1, 146, 3, 146, 1610, 8, 146, 1, 147, 1, 147, 1, 147, 1,
		147, 1, 148, 1, 148, 1, 148, 5, 148, 1619, 8, 148, 10, 148, 12, 148, 1622,
		9, 148, 1, 149, 1, 149, 3, 149, 1626, 8, 149, 1, 150, 1, 150, 1, 150, 1,
		150, 1, 150, 1, 150, 3, 150, 1634, 8, 150, 1, 150, 3, 150, 1637, 8, 150,
		1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 5, 151, 1645, 8, 151, 10,
		151, 12, 151, 1648, 9, 151, 1, 151, 1, 151, 1, 151, 3, 151, 1653, 8, 151,
		1, 151, 3, 151, 1656, 8, 151, 1, 151, 1, 151, 1, 152, 1, 152, 1, 152, 1,
		152, 1, 153, 1, 153, 1, 153, 3, 153, 1667, 8, 153, 1, 154, 1, 154, 1, 154,
		1, 154, 1, 154, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 156, 1, 156,
		1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 157, 1, 157, 1, 157, 1, 157,
		1, 158, 1, 158, 1, 159, 1, 159, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160,
		1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 3, 160, 1704, 8, 160, 1, 161, 1,
		161, 1, 161, 1, 161, 1, 161, 1, 161, 1, 162, 1, 162, 1, 162, 1, 162, 1,
		162, 1, 162, 1, 163, 1, 163, 1, 163, 5, 163, 1721, 8, 163, 10, 163, 12,
		163, 1724, 9, 163, 1, 164, 1, 164, 1, 164, 1, 164, 1, 165, 1, 165, 1, 165,
		5, 165, 1733, 8, 165, 10, 165, 12, 165, 1736, 9, 165, 1, 166, 1, 166, 1,
		166, 1, 166, 1, 166, 3, 166, 1743, 8, 166, 1, 166, 0, 1, 260, 167, 0, 2,
		4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40,
		42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76,
		78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110,
		112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140,
		142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170,
		172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200,
		202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230,
		232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260,
		262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290,
		292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320,
		322, 324, 326, 328, 330, 332, 0, 14, 3, 0, 85, 86, 88, 88, 122, 122, 1,
		0, 44, 45, 1, 0, 75, 76, 1, 0, 124, 125, 1, 0, 14, 14, 2, 0, 14, 14, 78,
		82, 6, 0, 5, 5, 7, 7, 22, 22, 32, 32, 73, 73, 114, 116, 2, 0, 30, 30, 106,
		107, 1, 0, 97, 105, 2, 0, 14, 14, 50, 50, 2, 0, 21, 21, 52, 57, 2, 0, 28,
		28, 44, 45, 5, 0, 2, 2, 10, 10, 24, 24, 46, 47, 111, 113, 2, 0, 12, 12,
		38, 38, 1854, 0, 336, 1, 0, 0, 0, 2, 338, 1, 0, 0, 0, 4, 357, 1, 0, 0,
		0, 6, 374, 1, 0, 0, 0, 8, 380, 1, 0, 0, 0, 10, 386, 1, 0, 0, 0, 12, 389,
		1, 0, 0, 0, 14, 392, 1, 0, 0, 0, 16, 400, 1, 0, 0, 0, 18, 412, 1, 0, 0,
		0, 20, 428, 1, 0, 0, 0, 22, 438, 1, 0, 0, 0, 24, 441, 1, 0, 0, 0, 26, 445,
		1, 0, 0, 0, 28, 456, 1, 0, 0, 0, 30, 458, 1, 0, 0, 0, 32, 480, 1, 0, 0,
		0, 34, 482, 1, 0, 0, 0, 36, 487, 1, 0, 0, 0, 38, 511, 1, 0, 0, 0, 40, 513,
		1, 0, 0, 0, 42, 526, 1, 0, 0, 0, 44, 528, 1, 0, 0, 0, 46, 530, 1, 0, 0,
		0, 48, 532, 1, 0, 0, 0, 50, 534, 1, 0, 0, 0, 52, 537, 1, 0, 0, 0, 54, 541,
		1, 0, 0, 0, 56, 549, 1, 0, 0, 0, 58, 555, 1, 0, 0, 0, 60, 560, 1, 0, 0,
		0, 62, 569, 1, 0, 0, 0, 64, 602, 1, 0, 0, 0, 66, 620, 1, 0, 0, 0, 68, 622,
		1, 0, 0, 0, 70, 625, 1, 0, 0, 0, 72, 628, 1, 0, 0, 0, 74, 652, 1, 0, 0,
		0, 76, 665, 1, 0, 0, 0, 78, 667, 1, 0, 0, 0, 80, 677, 1, 0, 0, 0, 82, 699,
		1, 0, 0, 0, 84, 701, 1, 0, 0, 0, 86, 703, 1, 0, 0, 0, 88, 719, 1, 0, 0,
		0, 90, 730, 1, 0, 0, 0, 92, 733, 1, 0, 0, 0, 94, 738, 1, 0, 0, 0, 96, 770,
		1, 0, 0, 0, 98, 772, 1, 0, 0, 0, 100, 775, 1, 0, 0, 0, 102, 778, 1, 0,
		0, 0, 104, 781, 1, 0, 0, 0, 106, 784, 1, 0, 0, 0, 108, 795, 1, 0, 0, 0,
		110, 808, 1, 0, 0, 0, 112, 812, 1, 0, 0, 0, 114, 820, 1, 0, 0, 0, 116,
		825, 1, 0, 0, 0, 118, 840, 1, 0, 0, 0, 120, 845, 1, 0, 0, 0, 122, 851,
		1, 0, 0, 0, 124, 853, 1, 0, 0, 0, 126, 857, 1, 0, 0, 0, 128, 865, 1, 0,
		0, 0, 130, 870, 1, 0, 0, 0, 132, 877, 1, 0, 0, 0, 134, 886, 1, 0, 0, 0,
		136, 891, 1, 0, 0, 0, 138, 893, 1, 0, 0, 0, 140, 927, 1, 0, 0, 0, 142,
		929, 1, 0, 0, 0, 144, 937, 1, 0, 0, 0, 146, 954, 1, 0, 0, 0, 148, 956,
		1, 0, 0, 0, 150, 966, 1, 0, 0, 0, 152, 989, 1, 0, 0, 0, 154, 992, 1, 0,
		0, 0, 156, 1002, 1, 0, 0, 0, 158, 1004, 1, 0, 0, 0, 160, 1015, 1, 0, 0,
		0, 162, 1031, 1, 0, 0, 0, 164, 1033, 1, 0, 0, 0, 166, 1039, 1, 0, 0, 0,
		168, 1052, 1, 0, 0, 0, 170, 1062, 1, 0, 0, 0, 172, 1078, 1, 0, 0, 0, 174,
		1081, 1, 0, 0, 0, 176, 1085, 1, 0, 0, 0, 178, 1093, 1, 0, 0, 0, 180, 1095,
		1, 0, 0, 0, 182, 1098, 1, 0, 0, 0, 184, 1110, 1, 0, 0, 0, 186, 1118, 1,
		0, 0, 0, 188, 1132, 1, 0, 0, 0, 190, 1149, 1, 0, 0, 0, 192, 1155, 1, 0,
		0, 0, 194, 1160, 1, 0, 0, 0, 196, 1162, 1, 0, 0, 0, 198, 1166, 1, 0, 0,
		0, 200, 1170, 1, 0, 0, 0, 202, 1176, 1, 0, 0, 0, 204, 1184, 1, 0, 0, 0,
		206, 1186, 1, 0, 0, 0, 208, 1189, 1, 0, 0, 0, 210, 1200, 1, 0, 0, 0, 212,
		1204, 1, 0, 0, 0, 214, 1244, 1, 0, 0, 0, 216, 1246, 1, 0, 0, 0, 218, 1254,
		1, 0, 0, 0, 220, 1262, 1, 0, 0, 0, 222, 1270, 1, 0, 0, 0, 224, 1273, 1,
		0, 0, 0, 226, 1283, 1, 0, 0, 0, 228, 1286, 1, 0, 0, 0, 230, 1292, 1, 0,
		0, 0, 232, 1303, 1, 0, 0, 0, 234, 1313, 1, 0, 0, 0, 236, 1315, 1, 0, 0,
		0, 238, 1319, 1, 0, 0, 0, 240, 1333, 1, 0, 0, 0, 242, 1380, 1, 0, 0, 0,
		244, 1382, 1, 0, 0, 0, 246, 1405, 1, 0, 0, 0, 248, 1411, 1, 0, 0, 0, 250,
		1413, 1, 0, 0, 0, 252, 1419, 1, 0, 0, 0, 254, 1421, 1, 0, 0, 0, 256, 1427,
		1, 0, 0, 0, 258, 1430, 1, 0, 0, 0, 260, 1470, 1, 0, 0, 0, 262, 1501, 1,
		0, 0, 0, 264, 1503, 1, 0, 0, 0, 266, 1510, 1, 0, 0, 0, 268, 1515, 1, 0,
		0, 0, 270, 1531, 1, 0, 0, 0, 272, 1542, 1, 0, 0, 0, 274, 1544, 1, 0, 0,
		0, 276, 1549, 1, 0, 0, 0, 278, 1556, 1, 0, 0, 0, 280, 1581, 1, 0, 0, 0,
		282, 1583, 1, 0, 0, 0, 284, 1586, 1, 0, 0, 0, 286, 1589, 1, 0, 0, 0, 288,
		1599, 1, 0, 0, 0, 290, 1601, 1, 0, 0, 0, 292, 1609, 1, 0, 0, 0, 294, 1611,
		1, 0, 0, 0, 296, 1615, 1, 0, 0, 0, 298, 1625, 1, 0, 0, 0, 300, 1627, 1,
		0, 0, 0, 302, 1638, 1, 0, 0, 0, 304, 1659, 1, 0, 0, 0, 306, 1666, 1, 0,
		0, 0, 308, 1668, 1, 0, 0, 0, 310, 1673, 1, 0, 0, 0, 312, 1678, 1, 0, 0,
		0, 314, 1685, 1, 0, 0, 0, 316, 1689, 1, 0, 0, 0, 318, 1691, 1, 0, 0, 0,
		320, 1703, 1, 0, 0, 0, 322, 1705, 1, 0, 0, 0, 324, 1711, 1, 0, 0, 0, 326,
		1717, 1, 0, 0, 0, 328, 1725, 1, 0, 0, 0, 330, 1729, 1, 0, 0, 0, 332, 1737,
		1, 0, 0, 0, 334, 337, 3, 2, 1, 0, 335, 337, 3, 4, 2, 0, 336, 334, 1, 0,
		0, 0, 336, 335, 1, 0, 0, 0, 337, 1, 1, 0, 0, 0, 338, 339, 5, 31, 0, 0,
		339, 344, 3, 14, 7, 0, 340, 341, 5, 58, 0, 0, 341, 342, 3, 218, 109, 0,
		342, 343, 5, 59, 0, 0, 343, 345, 1, 0, 0, 0, 344, 340, 1, 0, 0, 0, 344,
		345, 1, 0, 0, 0, 345, 346, 1, 0, 0, 0, 346, 348, 5, 50, 0, 0, 347, 349,
		3, 24, 12, 0, 348, 347, 1, 0, 0, 0, 348, 349, 1, 0, 0, 0, 349, 350, 1,
		0, 0, 0, 350, 351, 3, 20, 10, 0, 351, 352, 5, 4, 0, 0, 352, 353, 3, 296,
		148, 0, 353, 354, 5, 14, 0, 0, 354, 355, 5, 66, 0, 0, 355, 356, 5, 0, 0,
		1, 356, 3, 1, 0, 0, 0, 357, 358, 5, 70, 0, 0, 358, 359, 3, 14, 7, 0, 359,
		360, 5, 50, 0, 0, 360, 362, 3, 6, 3, 0, 361, 363, 3, 8, 4, 0, 362, 361,
		1, 0, 0, 0, 362, 363, 1, 0, 0, 0, 363, 365, 1, 0, 0, 0, 364, 366, 3, 10,
		5, 0, 365, 364, 1, 0, 0, 0, 365, 366, 1, 0, 0, 0, 366, 368, 1, 0, 0, 0,
		367, 369, 3, 12, 6, 0, 368, 367, 1, 0, 0, 0, 368, 369, 1, 0, 0, 0, 369,
		370, 1, 0, 0, 0, 370, 371, 5, 14, 0, 0, 371, 372, 5, 66, 0, 0, 372, 373,
		5, 0, 0, 1, 373, 5, 1, 0, 0, 0, 374, 376, 5, 71, 0, 0, 375, 377, 3, 24,
		12, 0, 376, 375, 1, 0, 0, 0, 376, 377, 1, 0, 0, 0, 377, 378, 1, 0, 0, 0,
		378, 379, 3, 18, 9, 0, 379, 7, 1, 0, 0, 0, 380, 382, 5, 74, 0, 0, 381,
		383, 3, 24, 12, 0, 382, 381, 1, 0, 0, 0, 382, 383, 1, 0, 0, 0, 383, 384,
		1, 0, 0, 0, 384, 385, 3, 20, 10, 0, 385, 9, 1, 0, 0, 0, 386, 387, 5, 93,
		0, 0, 387, 388, 3, 296, 148, 0, 388, 11, 1, 0, 0, 0, 389, 390, 5, 94, 0,
		0, 390, 391, 3, 296, 148, 0, 391, 13, 1, 0, 0, 0, 392, 397, 3, 16, 8, 0,
		393, 394, 5, 66, 0, 0, 394, 396, 3, 16, 8, 0, 395, 393, 1, 0, 0, 0, 396,
		399, 1, 0, 0, 0, 397, 395, 1, 0, 0, 0, 397, 398, 1, 0, 0, 0, 398, 15, 1,
		0, 0, 0, 399, 397, 1, 0, 0, 0, 400, 402, 7, 0, 0, 0, 401, 403, 3, 110,
		55, 0, 402, 401, 1, 0, 0, 0, 402, 403, 1, 0, 0, 0, 403, 17, 1, 0, 0, 0,
		404, 411, 3, 26, 13, 0, 405, 411, 3, 30, 15, 0, 406, 411, 3, 56, 28, 0,
		407, 411, 3, 60, 30, 0, 408, 411, 3, 182, 91, 0, 409, 411, 3, 190, 95,
		0, 410, 404, 1, 0, 0, 0, 410, 405, 1, 0, 0, 0, 410, 406, 1, 0, 0, 0, 410,
		407, 1, 0, 0, 0, 410, 408, 1, 0, 0, 0, 410, 409, 1, 0, 0, 0, 411, 414,
		1, 0, 0, 0, 412, 410, 1, 0, 0, 0, 412, 413, 1, 0, 0, 0, 413, 19, 1, 0,
		0, 0, 414, 412, 1, 0, 0, 0, 415, 427, 3, 26, 13, 0, 416, 427, 3, 30, 15,
		0, 417, 427, 3, 56, 28, 0, 418, 427, 3, 60, 30, 0, 419, 427, 3, 182, 91,
		0, 420, 427, 3, 194, 97, 0, 421, 422, 3, 190, 95, 0, 422, 423, 5, 109,
		0, 0, 423, 424, 5, 50, 0, 0, 424, 427, 1, 0, 0, 0, 425, 427, 3, 210, 105,
		0, 426, 415, 1, 0, 0, 0, 426, 416, 1, 0, 0, 0, 426, 417, 1, 0, 0, 0, 426,
		418, 1, 0, 0, 0, 426, 419, 1, 0, 0, 0, 426, 420, 1, 0, 0, 0, 426, 421,
		1, 0, 0, 0, 426, 425, 1, 0, 0, 0, 427, 430, 1, 0, 0, 0, 428, 426, 1, 0,
		0, 0, 428, 429, 1, 0, 0, 0, 429, 21, 1, 0, 0, 0, 430, 428, 1, 0, 0, 0,
		431, 437, 3, 26, 13, 0, 432, 437, 3, 30, 15, 0, 433, 437, 3, 182, 91, 0,
		434, 437, 3, 194, 97, 0, 435, 437, 3, 210, 105, 0, 436, 431, 1, 0, 0, 0,
		436, 432, 1, 0, 0, 0, 436, 433, 1, 0, 0, 0, 436, 434, 1, 0, 0, 0, 436,
		435, 1, 0, 0, 0, 437, 440, 1, 0, 0, 0, 438, 436, 1, 0, 0, 0, 438, 439,
		1, 0, 0, 0, 439, 23, 1, 0, 0, 0, 440, 438, 1, 0, 0, 0, 441, 442, 5, 72,
		0, 0, 442, 443, 3, 218, 109, 0, 443, 444, 5, 50, 0, 0, 444, 25, 1, 0, 0,
		0, 445, 446, 5, 23, 0, 0, 446, 451, 3, 28, 14, 0, 447, 448, 5, 49, 0, 0,
		448, 450, 3, 28, 14, 0, 449, 447, 1, 0, 0, 0, 450, 453, 1, 0, 0, 0, 451,
		449, 1, 0, 0, 0, 451, 452, 1, 0, 0, 0, 452, 454, 1, 0, 0, 0, 453, 451,
		1, 0, 0, 0, 454, 455, 5, 50, 0, 0, 455, 27, 1, 0, 0, 0, 456, 457, 3, 44,
		22, 0, 457, 29, 1, 0, 0, 0, 458, 462, 5, 9, 0, 0, 459, 460, 3, 32, 16,
		0, 460, 461, 5, 50, 0, 0, 461, 463, 1, 0, 0, 0, 462, 459, 1, 0, 0, 0, 463,
		464, 1, 0, 0, 0, 464, 462, 1, 0, 0, 0, 464, 465, 1, 0, 0, 0, 465, 31, 1,
		0, 0, 0, 466, 469, 3, 14, 7, 0, 467, 468, 5, 51, 0, 0, 468, 470, 3, 132,
		66, 0, 469, 467, 1, 0, 0, 0, 469, 470, 1, 0, 0, 0, 470, 471, 1, 0, 0, 0,
		471, 472, 5, 52, 0, 0, 472, 473, 3, 38, 19, 0, 473, 481, 1, 0, 0, 0, 474,
		475, 3, 14, 7, 0, 475, 476, 5, 51, 0, 0, 476, 477, 3, 140, 70, 0, 477,
		478, 5, 52, 0, 0, 478, 479, 3, 38, 19, 0, 479, 481, 1, 0, 0, 0, 480, 466,
		1, 0, 0, 0, 480, 474, 1, 0, 0, 0, 481, 33, 1, 0, 0, 0, 482, 483, 5, 8,
		0, 0, 483, 484, 5, 58, 0, 0, 484, 485, 3, 44, 22, 0, 485, 486, 5, 59, 0,
		0, 486, 35, 1, 0, 0, 0, 487, 488, 5, 123, 0, 0, 488, 37, 1, 0, 0, 0, 489,
		512, 3, 42, 21, 0, 490, 491, 3, 48, 24, 0, 491, 492, 3, 42, 21, 0, 492,
		512, 1, 0, 0, 0, 493, 512, 3, 14, 7, 0, 494, 495, 3, 48, 24, 0, 495, 496,
		3, 14, 7, 0, 496, 512, 1, 0, 0, 0, 497, 512, 3, 52, 26, 0, 498, 512, 3,
		34, 17, 0, 499, 512, 3, 124, 62, 0, 500, 508, 3, 40, 20, 0, 501, 504, 5,
		44, 0, 0, 502, 505, 3, 40, 20, 0, 503, 505, 3, 14, 7, 0, 504, 502, 1, 0,
		0, 0, 504, 503, 1, 0, 0, 0, 505, 507, 1, 0, 0, 0, 506, 501, 1, 0, 0, 0,
		507, 510, 1, 0, 0, 0, 508, 506, 1, 0, 0, 0, 508, 509, 1, 0, 0, 0, 509,
		512, 1, 0, 0, 0, 510, 508, 1, 0, 0, 0, 511, 489, 1, 0, 0, 0, 511, 490,
		1, 0, 0, 0, 511, 493, 1, 0, 0, 0, 511, 494, 1, 0, 0, 0, 511, 497, 1, 0,
		0, 0, 511, 498, 1, 0, 0, 0, 511, 499, 1, 0, 0, 0, 511, 500, 1, 0, 0, 0,
		512, 39, 1, 0, 0, 0, 513, 514, 5, 60, 0, 0, 514, 519, 3, 38, 19, 0, 515,
		516, 5, 49, 0, 0, 516, 518, 3, 38, 19, 0, 517, 515, 1, 0, 0, 0, 518, 521,
		1, 0, 0, 0, 519, 517, 1, 0, 0, 0, 519, 520, 1, 0, 0, 0, 520, 522, 1, 0,
		0, 0, 521, 519, 1, 0, 0, 0, 522, 523, 5, 62, 0, 0, 523, 41, 1, 0, 0, 0,
		524, 527, 3, 44, 22, 0, 525, 527, 3, 46, 23, 0, 526, 524, 1, 0, 0, 0, 526,
		525, 1, 0, 0, 0, 527, 43, 1, 0, 0, 0, 528, 529, 5, 126, 0, 0, 529, 45,
		1, 0, 0, 0, 530, 531, 5, 127, 0, 0, 531, 47, 1, 0, 0, 0, 532, 533, 7, 1,
		0, 0, 533, 49, 1, 0, 0, 0, 534, 535, 7, 2, 0, 0, 535, 51, 1, 0, 0, 0, 536,
		538, 7, 3, 0, 0, 537, 536, 1, 0, 0, 0, 538, 539, 1, 0, 0, 0, 539, 537,
		1, 0, 0, 0, 539, 540, 1, 0, 0, 0, 540, 53, 1, 0, 0, 0, 541, 546, 3, 52,
		26, 0, 542, 543, 5, 44, 0, 0, 543, 545, 3, 52, 26, 0, 544, 542, 1, 0, 0,
		0, 545, 548, 1, 0, 0, 0, 546, 544, 1, 0, 0, 0, 546, 547, 1, 0, 0, 0, 547,
		55, 1, 0, 0, 0, 548, 546, 1, 0, 0, 0, 549, 551, 5, 108, 0, 0, 550, 552,
		3, 58, 29, 0, 551, 550, 1, 0, 0, 0, 552, 553, 1, 0, 0, 0, 553, 551, 1,
		0, 0, 0, 553, 554, 1, 0, 0, 0, 554, 57, 1, 0, 0, 0, 555, 556, 3, 14, 7,
		0, 556, 557, 5, 52, 0, 0, 557, 558, 3, 54, 27, 0, 558, 559, 5, 50, 0, 0,
		559, 59, 1, 0, 0, 0, 560, 564, 5, 39, 0, 0, 561, 562, 3, 62, 31, 0, 562,
		563, 5, 50, 0, 0, 563, 565, 1, 0, 0, 0, 564, 561, 1, 0, 0, 0, 565, 566,
		1, 0, 0, 0, 566, 564, 1, 0, 0, 0, 566, 567, 1, 0, 0, 0, 567, 61, 1, 0,
		0, 0, 568, 570, 3, 328, 164, 0, 569, 568, 1, 0, 0, 0, 569, 570, 1, 0, 0,
		0, 570, 571, 1, 0, 0, 0, 571, 572, 3, 14, 7, 0, 572, 578, 5, 52, 0, 0,
		573, 579, 3, 120, 60, 0, 574, 579, 3, 64, 32, 0, 575, 579, 3, 66, 33, 0,
		576, 579, 3, 68, 34, 0, 577, 579, 3, 70, 35, 0, 578, 573, 1, 0, 0, 0, 578,
		574, 1, 0, 0, 0, 578, 575, 1, 0, 0, 0, 578, 576, 1, 0, 0, 0, 578, 577,
		1, 0, 0, 0, 579, 63, 1, 0, 0, 0, 580, 582, 5, 17, 0, 0, 581, 583, 3, 212,
		106, 0, 582, 581, 1, 0, 0, 0, 582, 583, 1, 0, 0, 0, 583, 584, 1, 0, 0,
		0, 584, 585, 5, 51, 0, 0, 585, 588, 3, 204, 102, 0, 586, 587, 5, 27, 0,
		0, 587, 589, 5, 95, 0, 0, 588, 586, 1, 0, 0, 0, 588, 589, 1, 0, 0, 0, 589,
		590, 1, 0, 0, 0, 590, 591, 3, 192, 96, 0, 591, 603, 1, 0, 0, 0, 592, 593,
		5, 34, 0, 0, 593, 594, 5, 38, 0, 0, 594, 596, 5, 17, 0, 0, 595, 597, 3,
		212, 106, 0, 596, 595, 1, 0, 0, 0, 596, 597, 1, 0, 0, 0, 597, 598, 1, 0,
		0, 0, 598, 599, 5, 51, 0, 0, 599, 600, 3, 204, 102, 0, 600, 601, 3, 192,
		96, 0, 601, 603, 1, 0, 0, 0, 602, 580, 1, 0, 0, 0, 602, 592, 1, 0, 0, 0,
		603, 65, 1, 0, 0, 0, 604, 606, 5, 30, 0, 0, 605, 607, 3, 212, 106, 0, 606,
		605, 1, 0, 0, 0, 606, 607, 1, 0, 0, 0, 607, 610, 1, 0, 0, 0, 608, 609,
		5, 27, 0, 0, 609, 611, 5, 95, 0, 0, 610, 608, 1, 0, 0, 0, 610, 611, 1,
		0, 0, 0, 611, 612, 1, 0, 0, 0, 612, 621, 3, 192, 96, 0, 613, 614, 5, 34,
		0, 0, 614, 615, 5, 38, 0, 0, 615, 617, 5, 30, 0, 0, 616, 618, 3, 212, 106,
		0, 617, 616, 1, 0, 0, 0, 617, 618, 1, 0, 0, 0, 618, 619, 1, 0, 0, 0, 619,
		621, 3, 192, 96, 0, 620, 604, 1, 0, 0, 0, 620, 613, 1, 0, 0, 0, 621, 67,
		1, 0, 0, 0, 622, 623, 5, 77, 0, 0, 623, 624, 5, 50, 0, 0, 624, 69, 1, 0,
		0, 0, 625, 626, 5, 71, 0, 0, 626, 627, 5, 50, 0, 0, 627, 71, 1, 0, 0, 0,
		628, 634, 5, 77, 0, 0, 629, 630, 5, 58, 0, 0, 630, 631, 3, 14, 7, 0, 631,
		632, 3, 74, 37, 0, 632, 633, 5, 59, 0, 0, 633, 635, 1, 0, 0, 0, 634, 629,
		1, 0, 0, 0, 634, 635, 1, 0, 0, 0, 635, 637, 1, 0, 0, 0, 636, 638, 5, 97,
		0, 0, 637, 636, 1, 0, 0, 0, 637, 638, 1, 0, 0, 0, 638, 639, 1, 0, 0, 0,
		639, 643, 3, 80, 40, 0, 640, 642, 3, 78, 39, 0, 641, 640, 1, 0, 0, 0, 642,
		645, 1, 0, 0, 0, 643, 641, 1, 0, 0, 0, 643, 644, 1, 0, 0, 0, 644, 646,
		1, 0, 0, 0, 645, 643, 1, 0, 0, 0, 646, 647, 5, 14, 0, 0, 647, 73, 1, 0,
		0, 0, 648, 649, 5, 49, 0, 0, 649, 651, 3, 132, 66, 0, 650, 648, 1, 0, 0,
		0, 651, 654, 1, 0, 0, 0, 652, 650, 1, 0, 0, 0, 652, 653, 1, 0, 0, 0, 653,
		75, 1, 0, 0, 0, 654, 652, 1, 0, 0, 0, 655, 657, 5, 82, 0, 0, 656, 655,
		1, 0, 0, 0, 656, 657, 1, 0, 0, 0, 657, 658, 1, 0, 0, 0, 658, 666, 5, 78,
		0, 0, 659, 661, 5, 82, 0, 0, 660, 659, 1, 0, 0, 0, 660, 661, 1, 0, 0, 0,
		661, 662, 1, 0, 0, 0, 662, 666, 5, 79, 0, 0, 663, 666, 5, 80, 0, 0, 664,
		666, 5, 81, 0, 0, 665, 656, 1, 0, 0, 0, 665, 660, 1, 0, 0, 0, 665, 663,
		1, 0, 0, 0, 665, 664, 1, 0, 0, 0, 666, 77, 1, 0, 0, 0, 667, 671, 3, 76,
		38, 0, 668, 670, 3, 82, 41, 0, 669, 668, 1, 0, 0, 0, 670, 673, 1, 0, 0,
		0, 671, 669, 1, 0, 0, 0, 671, 672, 1, 0, 0, 0, 672, 79, 1, 0, 0, 0, 673,
		671, 1, 0, 0, 0, 674, 676, 3, 82, 41, 0, 675, 674, 1, 0, 0, 0, 676, 679,
		1, 0, 0, 0, 677, 675, 1, 0, 0, 0, 677, 678, 1, 0, 0, 0, 678, 81, 1, 0,
		0, 0, 679, 677, 1, 0, 0, 0, 680, 682, 3, 328, 164, 0, 681, 680, 1, 0, 0,
		0, 681, 682, 1, 0, 0, 0, 682, 683, 1, 0, 0, 0, 683, 684, 3, 224, 112, 0,
		684, 685, 5, 50, 0, 0, 685, 700, 1, 0, 0, 0, 686, 700, 3, 60, 30, 0, 687,
		700, 3, 30, 15, 0, 688, 700, 3, 188, 94, 0, 689, 700, 3, 186, 93, 0, 690,
		691, 3, 96, 48, 0, 691, 694, 5, 50, 0, 0, 692, 693, 5, 87, 0, 0, 693, 695,
		5, 50, 0, 0, 694, 692, 1, 0, 0, 0, 694, 695, 1, 0, 0, 0, 695, 700, 1, 0,
		0, 0, 696, 697, 3, 94, 47, 0, 697, 698, 5, 50, 0, 0, 698, 700, 1, 0, 0,
		0, 699, 681, 1, 0, 0, 0, 699, 686, 1, 0, 0, 0, 699, 687, 1, 0, 0, 0, 699,
		688, 1, 0, 0, 0, 699, 689, 1, 0, 0, 0, 699, 690, 1, 0, 0, 0, 699, 696,
		1, 0, 0, 0, 700, 83, 1, 0, 0, 0, 701, 702, 5, 1, 0, 0, 702, 85, 1, 0, 0,
		0, 703, 708, 5, 71, 0, 0, 704, 705, 5, 58, 0, 0, 705, 706, 3, 14, 7, 0,
		706, 707, 5, 59, 0, 0, 707, 709, 1, 0, 0, 0, 708, 704, 1, 0, 0, 0, 708,
		709, 1, 0, 0, 0, 709, 711, 1, 0, 0, 0, 710, 712, 5, 1, 0, 0, 711, 710,
		1, 0, 0, 0, 711, 712, 1, 0, 0, 0, 712, 713, 1, 0, 0, 0, 713, 714, 3, 88,
		44, 0, 714, 715, 5, 14, 0, 0, 715, 87, 1, 0, 0, 0, 716, 718, 3, 90, 45,
		0, 717, 716, 1, 0, 0, 0, 718, 721, 1, 0, 0, 0, 719, 717, 1, 0, 0, 0, 719,
		720, 1, 0, 0, 0, 720, 89, 1, 0, 0, 0, 721, 719, 1, 0, 0, 0, 722, 731, 3,
		188, 94, 0, 723, 731, 3, 186, 93, 0, 724, 725, 3, 96, 48, 0, 725, 726,
		5, 50, 0, 0, 726, 731, 1, 0, 0, 0, 727, 728, 3, 92, 46, 0, 728, 729, 5,
		50, 0, 0, 729, 731, 1, 0, 0, 0, 730, 722, 1, 0, 0, 0, 730, 723, 1, 0, 0,
		0, 730, 724, 1, 0, 0, 0, 730, 727, 1, 0, 0, 0, 731, 91, 1, 0, 0, 0, 732,
		734, 8, 4, 0, 0, 733, 732, 1, 0, 0, 0, 734, 735, 1, 0, 0, 0, 735, 733,
		1, 0, 0, 0, 735, 736, 1, 0, 0, 0, 736, 93, 1, 0, 0, 0, 737, 739, 8, 5,
		0, 0, 738, 737, 1, 0, 0, 0, 739, 740, 1, 0, 0, 0, 740, 738, 1, 0, 0, 0,
		740, 741, 1, 0, 0, 0, 741, 95, 1, 0, 0, 0, 742, 743, 5, 84, 0, 0, 743,
		745, 3, 14, 7, 0, 744, 746, 3, 106, 53, 0, 745, 744, 1, 0, 0, 0, 745, 746,
		1, 0, 0, 0, 746, 747, 1, 0, 0, 0, 747, 748, 5, 51, 0, 0, 748, 750, 3, 132,
		66, 0, 749, 751, 3, 98, 49, 0, 750, 749, 1, 0, 0, 0, 750, 751, 1, 0, 0,
		0, 751, 753, 1, 0, 0, 0, 752, 754, 3, 100, 50, 0, 753, 752, 1, 0, 0, 0,
		753, 754, 1, 0, 0, 0, 754, 756, 1, 0, 0, 0, 755, 757, 3, 102, 51, 0, 756,
		755, 1, 0, 0, 0, 756, 757, 1, 0, 0, 0, 757, 759, 1, 0, 0, 0, 758, 760,
		3, 104, 52, 0, 759, 758, 1, 0, 0, 0, 759, 760, 1, 0, 0, 0, 760, 763, 1,
		0, 0, 0, 761, 762, 5, 50, 0, 0, 762, 764, 5, 87, 0, 0, 763, 761, 1, 0,
		0, 0, 763, 764, 1, 0, 0, 0, 764, 771, 1, 0, 0, 0, 765, 766, 5, 84, 0, 0,
		766, 768, 3, 14, 7, 0, 767, 769, 3, 102, 51, 0, 768, 767, 1, 0, 0, 0, 768,
		769, 1, 0, 0, 0, 769, 771, 1, 0, 0, 0, 770, 742, 1, 0, 0, 0, 770, 765,
		1, 0, 0, 0, 771, 97, 1, 0, 0, 0, 772, 773, 5, 85, 0, 0, 773, 774, 3, 14,
		7, 0, 774, 99, 1, 0, 0, 0, 775, 776, 5, 86, 0, 0, 776, 777, 3, 14, 7, 0,
		777, 101, 1, 0, 0, 0, 778, 779, 5, 87, 0, 0, 779, 780, 3, 246, 123, 0,
		780, 103, 1, 0, 0, 0, 781, 782, 5, 88, 0, 0, 782, 783, 3, 42, 21, 0, 783,
		105, 1, 0, 0, 0, 784, 785, 5, 60, 0, 0, 785, 790, 3, 214, 107, 0, 786,
		787, 5, 49, 0, 0, 787, 789, 3, 214, 107, 0, 788, 786, 1, 0, 0, 0, 789,
		792, 1, 0, 0, 0, 790, 788, 1, 0, 0, 0, 790, 791, 1, 0, 0, 0, 791, 793,
		1, 0, 0, 0, 792, 790, 1, 0, 0, 0, 793, 794, 5, 62, 0, 0, 794, 107, 1, 0,
		0, 0, 795, 796, 3, 218, 109, 0, 796, 797, 5, 51, 0, 0, 797, 805, 3, 144,
		72, 0, 798, 799, 5, 50, 0, 0, 799, 800, 3, 218, 109, 0, 800, 801, 5, 51,
		0, 0, 801, 802, 3, 144, 72, 0, 802, 804, 1, 0, 0, 0, 803, 798, 1, 0, 0,
		0, 804, 807, 1, 0, 0, 0, 805, 803, 1, 0, 0, 0, 805, 806, 1, 0, 0, 0, 806,
		109, 1, 0, 0, 0, 807, 805, 1, 0, 0, 0, 808, 809, 5, 54, 0, 0, 809, 810,
		3, 112, 56, 0, 810, 811, 5, 57, 0, 0, 811, 111, 1, 0, 0, 0, 812, 817, 3,
		114, 57, 0, 813, 814, 5, 49, 0, 0, 814, 816, 3, 114, 57, 0, 815, 813, 1,
		0, 0, 0, 816, 819, 1, 0, 0, 0, 817, 815, 1, 0, 0, 0, 817, 818, 1, 0, 0,
		0, 818, 113, 1, 0, 0, 0, 819, 817, 1, 0, 0, 0, 820, 823, 3, 132, 66, 0,
		821, 822, 5, 51, 0, 0, 822, 824, 3, 116, 58, 0, 823, 821, 1, 0, 0, 0, 823,
		824, 1, 0, 0, 0, 824, 115, 1, 0, 0, 0, 825, 830, 3, 118, 59, 0, 826, 827,
		5, 49, 0, 0, 827, 829, 3, 118, 59, 0, 828, 826, 1, 0, 0, 0, 829, 832, 1,
		0, 0, 0, 830, 828, 1, 0, 0, 0, 830, 831, 1, 0, 0, 0, 831, 117, 1, 0, 0,
		0, 832, 830, 1, 0, 0, 0, 833, 841, 5, 106, 0, 0, 834, 841, 5, 77, 0, 0,
		835, 841, 5, 33, 0, 0, 836, 837, 5, 77, 0, 0, 837, 838, 5, 27, 0, 0, 838,
		841, 3, 132, 66, 0, 839, 841, 3, 132, 66, 0, 840, 833, 1, 0, 0, 0, 840,
		834, 1, 0, 0, 0, 840, 835, 1, 0, 0, 0, 840, 836, 1, 0, 0, 0, 840, 839,
		1, 0, 0, 0, 841, 119, 1, 0, 0, 0, 842, 846, 3, 122, 61, 0, 843, 846, 3,
		134, 67, 0, 844, 846, 3, 180, 90, 0, 845, 842, 1, 0, 0, 0, 845, 843, 1,
		0, 0, 0, 845, 844, 1, 0, 0, 0, 846, 121, 1, 0, 0, 0, 847, 852, 3, 124,
		62, 0, 848, 852, 3, 130, 65, 0, 849, 852, 3, 132, 66, 0, 850, 852, 3, 138,
		69, 0, 851, 847, 1, 0, 0, 0, 851, 848, 1, 0, 0, 0, 851, 849, 1, 0, 0, 0,
		851, 850, 1, 0, 0, 0, 852, 123, 1, 0, 0, 0, 853, 854, 5, 58, 0, 0, 854,
		855, 3, 126, 63, 0, 855, 856, 5, 59, 0, 0, 856, 125, 1, 0, 0, 0, 857, 862,
		3, 128, 64, 0, 858, 859, 5, 49, 0, 0, 859, 861, 3, 128, 64, 0, 860, 858,
		1, 0, 0, 0, 861, 864, 1, 0, 0, 0, 862, 860, 1, 0, 0, 0, 862, 863, 1, 0,
		0, 0, 863, 127, 1, 0, 0, 0, 864, 862, 1, 0, 0, 0, 865, 868, 3, 14, 7, 0,
		866, 867, 5, 52, 0, 0, 867, 869, 3, 246, 123, 0, 868, 866, 1, 0, 0, 0,
		868, 869, 1, 0, 0, 0, 869, 129, 1, 0, 0, 0, 870, 871, 3, 250, 125, 0, 871,
		872, 5, 67, 0, 0, 872, 873, 3, 250, 125, 0, 873, 131, 1, 0, 0, 0, 874,
		878, 3, 14, 7, 0, 875, 878, 7, 6, 0, 0, 876, 878, 3, 140, 70, 0, 877, 874,
		1, 0, 0, 0, 877, 875, 1, 0, 0, 0, 877, 876, 1, 0, 0, 0, 878, 133, 1, 0,
		0, 0, 879, 880, 5, 29, 0, 0, 880, 887, 3, 136, 68, 0, 881, 887, 3, 136,
		68, 0, 882, 887, 3, 166, 83, 0, 883, 887, 3, 72, 36, 0, 884, 887, 3, 146,
		73, 0, 885, 887, 3, 86, 43, 0, 886, 879, 1, 0, 0, 0, 886, 881, 1, 0, 0,
		0, 886, 882, 1, 0, 0, 0, 886, 883, 1, 0, 0, 0, 886, 884, 1, 0, 0, 0, 886,
		885, 1, 0, 0, 0, 887, 135, 1, 0, 0, 0, 888, 892, 3, 140, 70, 0, 889, 892,
		3, 176, 88, 0, 890, 892, 3, 178, 89, 0, 891, 888, 1, 0, 0, 0, 891, 889,
		1, 0, 0, 0, 891, 890, 1, 0, 0, 0, 892, 137, 1, 0, 0, 0, 893, 894, 5, 73,
		0, 0, 894, 897, 5, 60, 0, 0, 895, 898, 3, 14, 7, 0, 896, 898, 3, 42, 21,
		0, 897, 895, 1, 0, 0, 0, 897, 896, 1, 0, 0, 0, 898, 899, 1, 0, 0, 0, 899,
		900, 5, 62, 0, 0, 900, 139, 1, 0, 0, 0, 901, 902, 5, 3, 0, 0, 902, 903,
		5, 60, 0, 0, 903, 904, 3, 142, 71, 0, 904, 905, 5, 62, 0, 0, 905, 906,
		5, 27, 0, 0, 906, 909, 3, 120, 60, 0, 907, 908, 5, 52, 0, 0, 908, 910,
		3, 124, 62, 0, 909, 907, 1, 0, 0, 0, 909, 910, 1, 0, 0, 0, 910, 928, 1,
		0, 0, 0, 911, 912, 5, 3, 0, 0, 912, 913, 5, 61, 0, 0, 913, 914, 3, 142,
		71, 0, 914, 915, 5, 63, 0, 0, 915, 916, 5, 27, 0, 0, 916, 919, 3, 120,
		60, 0, 917, 918, 5, 52, 0, 0, 918, 920, 3, 124, 62, 0, 919, 917, 1, 0,
		0, 0, 919, 920, 1, 0, 0, 0, 920, 928, 1, 0, 0, 0, 921, 922, 5, 3, 0, 0,
		922, 923, 5, 27, 0, 0, 923, 928, 5, 9, 0, 0, 924, 925, 5, 3, 0, 0, 925,
		926, 5, 27, 0, 0, 926, 928, 3, 120, 60, 0, 927, 901, 1, 0, 0, 0, 927, 911,
		1, 0, 0, 0, 927, 921, 1, 0, 0, 0, 927, 924, 1, 0, 0, 0, 928, 141, 1, 0,
		0, 0, 929, 934, 3, 144, 72, 0, 930, 931, 5, 49, 0, 0, 931, 933, 3, 144,
		72, 0, 932, 930, 1, 0, 0, 0, 933, 936, 1, 0, 0, 0, 934, 932, 1, 0, 0, 0,
		934, 935, 1, 0, 0, 0, 935, 143, 1, 0, 0, 0, 936, 934, 1, 0, 0, 0, 937,
		938, 3, 122, 61, 0, 938, 145, 1, 0, 0, 0, 939, 940, 5, 33, 0, 0, 940, 944,
		3, 150, 75, 0, 941, 943, 3, 148, 74, 0, 942, 941, 1, 0, 0, 0, 943, 946,
		1, 0, 0, 0, 944, 942, 1, 0, 0, 0, 944, 945, 1, 0, 0, 0, 945, 947, 1, 0,
		0, 0, 946, 944, 1, 0, 0, 0, 947, 948, 5, 14, 0, 0, 948, 955, 1, 0, 0, 0,
		949, 951, 5, 33, 0, 0, 950, 952, 3, 156, 78, 0, 951, 950, 1, 0, 0, 0, 951,
		952, 1, 0, 0, 0, 952, 953, 1, 0, 0, 0, 953, 955, 5, 14, 0, 0, 954, 939,
		1, 0, 0, 0, 954, 949, 1, 0, 0, 0, 955, 147, 1, 0, 0, 0, 956, 960, 3, 76,
		38, 0, 957, 959, 3, 152, 76, 0, 958, 957, 1, 0, 0, 0, 959, 962, 1, 0, 0,
		0, 960, 958, 1, 0, 0, 0, 960, 961, 1, 0, 0, 0, 961, 149, 1, 0, 0, 0, 962,
		960, 1, 0, 0, 0, 963, 965, 3, 152, 76, 0, 964, 963, 1, 0, 0, 0, 965, 968,
		1, 0, 0, 0, 966, 964, 1, 0, 0, 0, 966, 967, 1, 0, 0, 0, 967, 151, 1, 0,
		0, 0, 968, 966, 1, 0, 0, 0, 969, 971, 3, 328, 164, 0, 970, 969, 1, 0, 0,
		0, 970, 971, 1, 0, 0, 0, 971, 972, 1, 0, 0, 0, 972, 973, 3, 224, 112, 0,
		973, 974, 5, 50, 0, 0, 974, 990, 1, 0, 0, 0, 975, 990, 3, 60, 30, 0, 976,
		990, 3, 30, 15, 0, 977, 990, 3, 188, 94, 0, 978, 990, 3, 186, 93, 0, 979,
		990, 3, 208, 104, 0, 980, 981, 3, 96, 48, 0, 981, 984, 5, 50, 0, 0, 982,
		983, 5, 87, 0, 0, 983, 985, 5, 50, 0, 0, 984, 982, 1, 0, 0, 0, 984, 985,
		1, 0, 0, 0, 985, 990, 1, 0, 0, 0, 986, 987, 3, 154, 77, 0, 987, 988, 5,
		50, 0, 0, 988, 990, 1, 0, 0, 0, 989, 970, 1, 0, 0, 0, 989, 975, 1, 0, 0,
		0, 989, 976, 1, 0, 0, 0, 989, 977, 1, 0, 0, 0, 989, 978, 1, 0, 0, 0, 989,
		979, 1, 0, 0, 0, 989, 980, 1, 0, 0, 0, 989, 986, 1, 0, 0, 0, 990, 153,
		1, 0, 0, 0, 991, 993, 8, 5, 0, 0, 992, 991, 1, 0, 0, 0, 993, 994, 1, 0,
		0, 0, 994, 992, 1, 0, 0, 0, 994, 995, 1, 0, 0, 0, 995, 155, 1, 0, 0, 0,
		996, 999, 3, 158, 79, 0, 997, 998, 5, 50, 0, 0, 998, 1000, 3, 160, 80,
		0, 999, 997, 1, 0, 0, 0, 999, 1000, 1, 0, 0, 0, 1000, 1003, 1, 0, 0, 0,
		1001, 1003, 3, 160, 80, 0, 1002, 996, 1, 0, 0, 0, 1002, 1001, 1, 0, 0,
		0, 1003, 157, 1, 0, 0, 0, 1004, 1009, 3, 224, 112, 0, 1005, 1006, 5, 50,
		0, 0, 1006, 1008, 3, 224, 112, 0, 1007, 1005, 1, 0, 0, 0, 1008, 1011, 1,
		0, 0, 0, 1009, 1007, 1, 0, 0, 0, 1009, 1010, 1, 0, 0, 0, 1010, 1013, 1,
		0, 0, 0, 1011, 1009, 1, 0, 0, 0, 1012, 1014, 5, 50, 0, 0, 1013, 1012, 1,
		0, 0, 0, 1013, 1014, 1, 0, 0, 0, 1014, 159, 1, 0, 0, 0, 1015, 1016, 5,
		6, 0, 0, 1016, 1017, 3, 162, 81, 0, 1017, 1018, 5, 27, 0, 0, 1018, 1023,
		3, 164, 82, 0, 1019, 1020, 5, 50, 0, 0, 1020, 1022, 3, 164, 82, 0, 1021,
		1019, 1, 0, 0, 0, 1022, 1025, 1, 0, 0, 0, 1023, 1021, 1, 0, 0, 0, 1023,
		1024, 1, 0, 0, 0, 1024, 161, 1, 0, 0, 0, 1025, 1023, 1, 0, 0, 0, 1026,
		1027, 3, 14, 7, 0, 1027, 1028, 5, 51, 0, 0, 1028, 1029, 3, 132, 66, 0,
		1029, 1032, 1, 0, 0, 0, 1030, 1032, 3, 132, 66, 0, 1031, 1026, 1, 0, 0,
		0, 1031, 1030, 1, 0, 0, 0, 1032, 163, 1, 0, 0, 0, 1033, 1034, 3, 220, 110,
		0, 1034, 1035, 5, 51, 0, 0, 1035, 1036, 5, 58, 0, 0, 1036, 1037, 3, 156,
		78, 0, 1037, 1038, 5, 59, 0, 0, 1038, 165, 1, 0, 0, 0, 1039, 1040, 5, 77,
		0, 0, 1040, 1041, 5, 19, 0, 0, 1041, 1042, 5, 16, 0, 0, 1042, 1043, 3,
		132, 66, 0, 1043, 1047, 3, 170, 85, 0, 1044, 1046, 3, 168, 84, 0, 1045,
		1044, 1, 0, 0, 0, 1046, 1049, 1, 0, 0, 0, 1047, 1045, 1, 0, 0, 0, 1047,
		1048, 1, 0, 0, 0, 1048, 1050, 1, 0, 0, 0, 1049, 1047, 1, 0, 0, 0, 1050,
		1051, 5, 14, 0, 0, 1051, 167, 1, 0, 0, 0, 1052, 1056, 3, 76, 38, 0, 1053,
		1055, 3, 172, 86, 0, 1054, 1053, 1, 0, 0, 0, 1055, 1058, 1, 0, 0, 0, 1056,
		1054, 1, 0, 0, 0, 1056, 1057, 1, 0, 0, 0, 1057, 169, 1, 0, 0, 0, 1058,
		1056, 1, 0, 0, 0, 1059, 1061, 3, 172, 86, 0, 1060, 1059, 1, 0, 0, 0, 1061,
		1064, 1, 0, 0, 0, 1062, 1060, 1, 0, 0, 0, 1062, 1063, 1, 0, 0, 0, 1063,
		171, 1, 0, 0, 0, 1064, 1062, 1, 0, 0, 0, 1065, 1079, 3, 60, 30, 0, 1066,
		1079, 3, 30, 15, 0, 1067, 1079, 3, 188, 94, 0, 1068, 1079, 3, 186, 93,
		0, 1069, 1070, 3, 96, 48, 0, 1070, 1073, 5, 50, 0, 0, 1071, 1072, 5, 87,
		0, 0, 1072, 1074, 5, 50, 0, 0, 1073, 1071, 1, 0, 0, 0, 1073, 1074, 1, 0,
		0, 0, 1074, 1079, 1, 0, 0, 0, 1075, 1076, 3, 174, 87, 0, 1076, 1077, 5,
		50, 0, 0, 1077, 1079, 1, 0, 0, 0, 1078, 1065, 1, 0, 0, 0, 1078, 1066, 1,
		0, 0, 0, 1078, 1067, 1, 0, 0, 0, 1078, 1068, 1, 0, 0, 0, 1078, 1069, 1,
		0, 0, 0, 1078, 1075, 1, 0, 0, 0, 1079, 173, 1, 0, 0, 0, 1080, 1082, 8,
		5, 0, 0, 1081, 1080, 1, 0, 0, 0, 1082, 1083, 1, 0, 0, 0, 1083, 1081, 1,
		0, 0, 0, 1083, 1084, 1, 0, 0, 0, 1084, 175, 1, 0, 0, 0, 1085, 1086, 5,
		36, 0, 0, 1086, 1087, 5, 27, 0, 0, 1087, 1088, 3, 122, 61, 0, 1088, 177,
		1, 0, 0, 0, 1089, 1090, 5, 15, 0, 0, 1090, 1091, 5, 27, 0, 0, 1091, 1094,
		3, 120, 60, 0, 1092, 1094, 5, 15, 0, 0, 1093, 1089, 1, 0, 0, 0, 1093, 1092,
		1, 0, 0, 0, 1094, 179, 1, 0, 0, 0, 1095, 1096, 5, 64, 0, 0, 1096, 1097,
		3, 132, 66, 0, 1097, 181, 1, 0, 0, 0, 1098, 1099, 5, 41, 0, 0, 1099, 1104,
		3, 184, 92, 0, 1100, 1101, 5, 50, 0, 0, 1101, 1103, 3, 184, 92, 0, 1102,
		1100, 1, 0, 0, 0, 1103, 1106, 1, 0, 0, 0, 1104, 1102, 1, 0, 0, 0, 1104,
		1105, 1, 0, 0, 0, 1105, 1107, 1, 0, 0, 0, 1106, 1104, 1, 0, 0, 0, 1107,
		1108, 5, 50, 0, 0, 1108, 183, 1, 0, 0, 0, 1109, 1111, 3, 328, 164, 0, 1110,
		1109, 1, 0, 0, 0, 1110, 1111, 1, 0, 0, 0, 1111, 1112, 1, 0, 0, 0, 1112,
		1115, 3, 224, 112, 0, 1113, 1114, 5, 52, 0, 0, 1114, 1116, 3, 250, 125,
		0, 1115, 1113, 1, 0, 0, 0, 1115, 1116, 1, 0, 0, 0, 1116, 185, 1, 0, 0,
		0, 1117, 1119, 3, 328, 164, 0, 1118, 1117, 1, 0, 0, 0, 1118, 1119, 1, 0,
		0, 0, 1119, 1121, 1, 0, 0, 0, 1120, 1122, 5, 77, 0, 0, 1121, 1120, 1, 0,
		0, 0, 1121, 1122, 1, 0, 0, 0, 1122, 1123, 1, 0, 0, 0, 1123, 1124, 7, 7,
		0, 0, 1124, 1126, 3, 14, 7, 0, 1125, 1127, 3, 212, 106, 0, 1126, 1125,
		1, 0, 0, 0, 1126, 1127, 1, 0, 0, 0, 1127, 1128, 1, 0, 0, 0, 1128, 1129,
		3, 192, 96, 0, 1129, 1130, 5, 50, 0, 0, 1130, 187, 1, 0, 0, 0, 1131, 1133,
		3, 328, 164, 0, 1132, 1131, 1, 0, 0, 0, 1132, 1133, 1, 0, 0, 0, 1133, 1135,
		1, 0, 0, 0, 1134, 1136, 5, 77, 0, 0, 1135, 1134, 1, 0, 0, 0, 1135, 1136,
		1, 0, 0, 0, 1136, 1137, 1, 0, 0, 0, 1137, 1138, 5, 17, 0, 0, 1138, 1140,
		3, 14, 7, 0, 1139, 1141, 3, 212, 106, 0, 1140, 1139, 1, 0, 0, 0, 1140,
		1141, 1, 0, 0, 0, 1141, 1142, 1, 0, 0, 0, 1142, 1143, 5, 51, 0, 0, 1143,
		1144, 3, 204, 102, 0, 1144, 1145, 3, 192, 96, 0, 1145, 1146, 5, 50, 0,
		0, 1146, 189, 1, 0, 0, 0, 1147, 1150, 3, 186, 93, 0, 1148, 1150, 3, 188,
		94, 0, 1149, 1147, 1, 0, 0, 0, 1149, 1148, 1, 0, 0, 0, 1150, 191, 1, 0,
		0, 0, 1151, 1152, 5, 50, 0, 0, 1152, 1154, 7, 8, 0, 0, 1153, 1151, 1, 0,
		0, 0, 1154, 1157, 1, 0, 0, 0, 1155, 1153, 1, 0, 0, 0, 1155, 1156, 1, 0,
		0, 0, 1156, 193, 1, 0, 0, 0, 1157, 1155, 1, 0, 0, 0, 1158, 1161, 3, 196,
		98, 0, 1159, 1161, 3, 198, 99, 0, 1160, 1158, 1, 0, 0, 0, 1160, 1159, 1,
		0, 0, 0, 1161, 195, 1, 0, 0, 0, 1162, 1163, 3, 186, 93, 0, 1163, 1164,
		3, 206, 103, 0, 1164, 1165, 5, 50, 0, 0, 1165, 197, 1, 0, 0, 0, 1166, 1167,
		3, 188, 94, 0, 1167, 1168, 3, 206, 103, 0, 1168, 1169, 5, 50, 0, 0, 1169,
		199, 1, 0, 0, 0, 1170, 1172, 5, 30, 0, 0, 1171, 1173, 3, 212, 106, 0, 1172,
		1171, 1, 0, 0, 0, 1172, 1173, 1, 0, 0, 0, 1173, 1174, 1, 0, 0, 0, 1174,
		1175, 3, 206, 103, 0, 1175, 201, 1, 0, 0, 0, 1176, 1178, 5, 17, 0, 0, 1177,
		1179, 3, 212, 106, 0, 1178, 1177, 1, 0, 0, 0, 1178, 1179, 1, 0, 0, 0, 1179,
		1180, 1, 0, 0, 0, 1180, 1181, 3, 206, 103, 0, 1181, 1182, 5, 51, 0, 0,
		1182, 1183, 3, 204, 102, 0, 1183, 203, 1, 0, 0, 0, 1184, 1185, 3, 132,
		66, 0, 1185, 205, 1, 0, 0, 0, 1186, 1187, 3, 22, 11, 0, 1187, 1188, 3,
		294, 147, 0, 1188, 207, 1, 0, 0, 0, 1189, 1190, 5, 77, 0, 0, 1190, 1191,
		5, 117, 0, 0, 1191, 1193, 3, 14, 7, 0, 1192, 1194, 3, 212, 106, 0, 1193,
		1192, 1, 0, 0, 0, 1193, 1194, 1, 0, 0, 0, 1194, 1195, 1, 0, 0, 0, 1195,
		1196, 5, 51, 0, 0, 1196, 1197, 3, 204, 102, 0, 1197, 1198, 3, 192, 96,
		0, 1198, 1199, 5, 50, 0, 0, 1199, 209, 1, 0, 0, 0, 1200, 1201, 3, 208,
		104, 0, 1201, 1202, 3, 206, 103, 0, 1202, 1203, 5, 50, 0, 0, 1203, 211,
		1, 0, 0, 0, 1204, 1205, 5, 58, 0, 0, 1205, 1210, 3, 214, 107, 0, 1206,
		1207, 5, 50, 0, 0, 1207, 1209, 3, 214, 107, 0, 1208, 1206, 1, 0, 0, 0,
		1209, 1212, 1, 0, 0, 0, 1210, 1208, 1, 0, 0, 0, 1210, 1211, 1, 0, 0, 0,
		1211, 1213, 1, 0, 0, 0, 1212, 1210, 1, 0, 0, 0, 1213, 1214, 5, 59, 0, 0,
		1214, 213, 1, 0, 0, 0, 1215, 1217, 3, 328, 164, 0, 1216, 1215, 1, 0, 0,
		0, 1216, 1217, 1, 0, 0, 0, 1217, 1218, 1, 0, 0, 0, 1218, 1245, 3, 216,
		108, 0, 1219, 1221, 3, 328, 164, 0, 1220, 1219, 1, 0, 0, 0, 1220, 1221,
		1, 0, 0, 0, 1221, 1222, 1, 0, 0, 0, 1222, 1223, 5, 41, 0, 0, 1223, 1245,
		3, 216, 108, 0, 1224, 1226, 3, 328, 164, 0, 1225, 1224, 1, 0, 0, 0, 1225,
		1226, 1, 0, 0, 0, 1226, 1227, 1, 0, 0, 0, 1227, 1228, 5, 9, 0, 0, 1228,
		1245, 3, 216, 108, 0, 1229, 1231, 3, 328, 164, 0, 1230, 1229, 1, 0, 0,
		0, 1230, 1231, 1, 0, 0, 0, 1231, 1232, 1, 0, 0, 0, 1232, 1233, 5, 83, 0,
		0, 1233, 1245, 3, 216, 108, 0, 1234, 1236, 3, 328, 164, 0, 1235, 1234,
		1, 0, 0, 0, 1235, 1236, 1, 0, 0, 0, 1236, 1237, 1, 0, 0, 0, 1237, 1238,
		5, 17, 0, 0, 1238, 1245, 3, 216, 108, 0, 1239, 1241, 3, 328, 164, 0, 1240,
		1239, 1, 0, 0, 0, 1240, 1241, 1, 0, 0, 0, 1241, 1242, 1, 0, 0, 0, 1242,
		1243, 5, 30, 0, 0, 1243, 1245, 3, 216, 108, 0, 1244, 1216, 1, 0, 0, 0,
		1244, 1220, 1, 0, 0, 0, 1244, 1225, 1, 0, 0, 0, 1244, 1230, 1, 0, 0, 0,
		1244, 1235, 1, 0, 0, 0, 1244, 1240, 1, 0, 0, 0, 1245, 215, 1, 0, 0, 0,
		1246, 1249, 3, 218, 109, 0, 1247, 1248, 5, 51, 0, 0, 1248, 1250, 3, 132,
		66, 0, 1249, 1247, 1, 0, 0, 0, 1249, 1250, 1, 0, 0, 0, 1250, 1252, 1, 0,
		0, 0, 1251, 1253, 3, 222, 111, 0, 1252, 1251, 1, 0, 0, 0, 1252, 1253, 1,
		0, 0, 0, 1253, 217, 1, 0, 0, 0, 1254, 1259, 3, 14, 7, 0, 1255, 1256, 5,
		49, 0, 0, 1256, 1258, 3, 14, 7, 0, 1257, 1255, 1, 0, 0, 0, 1258, 1261,
		1, 0, 0, 0, 1259, 1257, 1, 0, 0, 0, 1259, 1260, 1, 0, 0, 0, 1260, 219,
		1, 0, 0, 0, 1261, 1259, 1, 0, 0, 0, 1262, 1267, 3, 38, 19, 0, 1263, 1264,
		5, 49, 0, 0, 1264, 1266, 3, 38, 19, 0, 1265, 1263, 1, 0, 0, 0, 1266, 1269,
		1, 0, 0, 0, 1267, 1265, 1, 0, 0, 0, 1267, 1268, 1, 0, 0, 0, 1268, 221,
		1, 0, 0, 0, 1269, 1267, 1, 0, 0, 0, 1270, 1271, 5, 52, 0, 0, 1271, 1272,
		3, 246, 123, 0, 1272, 223, 1, 0, 0, 0, 1273, 1274, 3, 218, 109, 0, 1274,
		1275, 5, 51, 0, 0, 1275, 1276, 3, 120, 60, 0, 1276, 225, 1, 0, 0, 0, 1277,
		1278, 3, 28, 14, 0, 1278, 1279, 5, 51, 0, 0, 1279, 1280, 3, 230, 115, 0,
		1280, 1284, 1, 0, 0, 0, 1281, 1284, 3, 230, 115, 0, 1282, 1284, 3, 228,
		114, 0, 1283, 1277, 1, 0, 0, 0, 1283, 1281, 1, 0, 0, 0, 1283, 1282, 1,
		0, 0, 0, 1284, 227, 1, 0, 0, 0, 1285, 1287, 8, 9, 0, 0, 1286, 1285, 1,
		0, 0, 0, 1287, 1288, 1, 0, 0, 0, 1288, 1286, 1, 0, 0, 0, 1288, 1289, 1,
		0, 0, 0, 1289, 229, 1, 0, 0, 0, 1290, 1293, 3, 232, 116, 0, 1291, 1293,
		3, 292, 146, 0, 1292, 1290, 1, 0, 0, 0, 1292, 1291, 1, 0, 0, 0, 1293, 231,
		1, 0, 0, 0, 1294, 1304, 3, 234, 117, 0, 1295, 1304, 3, 278, 139, 0, 1296,
		1304, 3, 276, 138, 0, 1297, 1304, 3, 284, 142, 0, 1298, 1304, 3, 286, 143,
		0, 1299, 1304, 3, 242, 121, 0, 1300, 1304, 3, 288, 144, 0, 1301, 1304,
		3, 236, 118, 0, 1302, 1304, 3, 238, 119, 0, 1303, 1294, 1, 0, 0, 0, 1303,
		1295, 1, 0, 0, 0, 1303, 1296, 1, 0, 0, 0, 1303, 1297, 1, 0, 0, 0, 1303,
		1298, 1, 0, 0, 0, 1303, 1299, 1, 0, 0, 0, 1303, 1300, 1, 0, 0, 0, 1303,
		1301, 1, 0, 0, 0, 1303, 1302, 1, 0, 0, 0, 1304, 233, 1, 0, 0, 0, 1305,
		1306, 3, 240, 120, 0, 1306, 1307, 5, 48, 0, 0, 1307, 1308, 3, 246, 123,
		0, 1308, 1314, 1, 0, 0, 0, 1309, 1310, 3, 244, 122, 0, 1310, 1311, 5, 48,
		0, 0, 1311, 1312, 3, 246, 123, 0, 1312, 1314, 1, 0, 0, 0, 1313, 1305, 1,
		0, 0, 0, 1313, 1309, 1, 0, 0, 0, 1314, 235, 1, 0, 0, 0, 1315, 1317, 5,
		110, 0, 0, 1316, 1318, 3, 246, 123, 0, 1317, 1316, 1, 0, 0, 0, 1317, 1318,
		1, 0, 0, 0, 1318, 237, 1, 0, 0, 0, 1319, 1320, 5, 41, 0, 0, 1320, 1323,
		3, 218, 109, 0, 1321, 1322, 5, 51, 0, 0, 1322, 1324, 3, 62, 31, 0, 1323,
		1321, 1, 0, 0, 0, 1323, 1324, 1, 0, 0, 0, 1324, 1327, 1, 0, 0, 0, 1325,
		1326, 5, 48, 0, 0, 1326, 1328, 3, 246, 123, 0, 1327, 1325, 1, 0, 0, 0,
		1327, 1328, 1, 0, 0, 0, 1328, 239, 1, 0, 0, 0, 1329, 1334, 3, 242, 121,
		0, 1330, 1331, 5, 65, 0, 0, 1331, 1334, 3, 14, 7, 0, 1332, 1334, 3, 264,
		132, 0, 1333, 1329, 1, 0, 0, 0, 1333, 1330, 1, 0, 0, 0, 1333, 1332, 1,
		0, 0, 0, 1334, 1366, 1, 0, 0, 0, 1335, 1336, 5, 60, 0, 0, 1336, 1341, 3,
		246, 123, 0, 1337, 1338, 5, 49, 0, 0, 1338, 1340, 3, 246, 123, 0, 1339,
		1337, 1, 0, 0, 0, 1340, 1343, 1, 0, 0, 0, 1341, 1339, 1, 0, 0, 0, 1341,
		1342, 1, 0, 0, 0, 1342, 1344, 1, 0, 0, 0, 1343, 1341, 1, 0, 0, 0, 1344,
		1345, 5, 62, 0, 0, 1345, 1365, 1, 0, 0, 0, 1346, 1347, 5, 61, 0, 0, 1347,
		1352, 3, 246, 123, 0, 1348, 1349, 5, 49, 0, 0, 1349, 1351, 3, 246, 123,
		0, 1350, 1348, 1, 0, 0, 0, 1351, 1354, 1, 0, 0, 0, 1352, 1350, 1, 0, 0,
		0, 1352, 1353, 1, 0, 0, 0, 1353, 1355, 1, 0, 0, 0, 1354, 1352, 1, 0, 0,
		0, 1355, 1356, 5, 63, 0, 0, 1356, 1365, 1, 0, 0, 0, 1357, 1358, 5, 66,
		0, 0, 1358, 1365, 3, 264, 132, 0, 1359, 1361, 5, 64, 0, 0, 1360, 1359,
		1, 0, 0, 0, 1361, 1362, 1, 0, 0, 0, 1362, 1360, 1, 0, 0, 0, 1362, 1363,
		1, 0, 0, 0, 1363, 1365, 1, 0, 0, 0, 1364, 1335, 1, 0, 0, 0, 1364, 1346,
		1, 0, 0, 0, 1364, 1357, 1, 0, 0, 0, 1364, 1360, 1, 0, 0, 0, 1365, 1368,
		1, 0, 0, 0, 1366, 1364, 1, 0, 0, 0, 1366, 1367, 1, 0, 0, 0, 1367, 241,
		1, 0, 0, 0, 1368, 1366, 1, 0, 0, 0, 1369, 1370, 3, 132, 66, 0, 1370, 1371,
		5, 58, 0, 0, 1371, 1372, 3, 246, 123, 0, 1372, 1373, 5, 59, 0, 0, 1373,
		1381, 1, 0, 0, 0, 1374, 1375, 5, 58, 0, 0, 1375, 1376, 3, 246, 123, 0,
		1376, 1377, 5, 89, 0, 0, 1377, 1378, 3, 132, 66, 0, 1378, 1379, 5, 59,
		0, 0, 1379, 1381, 1, 0, 0, 0, 1380, 1369, 1, 0, 0, 0, 1380, 1374, 1, 0,
		0, 0, 1381, 243, 1, 0, 0, 0, 1382, 1387, 3, 264, 132, 0, 1383, 1384, 5,
		66, 0, 0, 1384, 1386, 3, 264, 132, 0, 1385, 1383, 1, 0, 0, 0, 1386, 1389,
		1, 0, 0, 0, 1387, 1385, 1, 0, 0, 0, 1387, 1388, 1, 0, 0, 0, 1388, 1390,
		1, 0, 0, 0, 1389, 1387, 1, 0, 0, 0, 1390, 1391, 5, 66, 0, 0, 1391, 1403,
		3, 14, 7, 0, 1392, 1393, 5, 60, 0, 0, 1393, 1398, 3, 246, 123, 0, 1394,
		1395, 5, 49, 0, 0, 1395, 1397, 3, 246, 123, 0, 1396, 1394, 1, 0, 0, 0,
		1397, 1400, 1, 0, 0, 0, 1398, 1396, 1, 0, 0, 0, 1398, 1399, 1, 0, 0, 0,
		1399, 1401, 1, 0, 0, 0, 1400, 1398, 1, 0, 0, 0, 1401, 1402, 5, 62, 0, 0,
		1402, 1404, 1, 0, 0, 0, 1403, 1392, 1, 0, 0, 0, 1403, 1404, 1, 0, 0, 0,
		1404, 245, 1, 0, 0, 0, 1405, 1409, 3, 250, 125, 0, 1406, 1407, 3, 248,
		124, 0, 1407, 1408, 3, 246, 123, 0, 1408, 1410, 1, 0, 0, 0, 1409, 1406,
		1, 0, 0, 0, 1409, 1410, 1, 0, 0, 0, 1410, 247, 1, 0, 0, 0, 1411, 1412,
		7, 10, 0, 0, 1412, 249, 1, 0, 0, 0, 1413, 1417, 3, 254, 127, 0, 1414, 1415,
		3, 252, 126, 0, 1415, 1416, 3, 250, 125, 0, 1416, 1418, 1, 0, 0, 0, 1417,
		1414, 1, 0, 0, 0, 1417, 1418, 1, 0, 0, 0, 1418, 251, 1, 0, 0, 0, 1419,
		1420, 7, 11, 0, 0, 1420, 253, 1, 0, 0, 0, 1421, 1425, 3, 258, 129, 0, 1422,
		1423, 3, 256, 128, 0, 1423, 1424, 3, 254, 127, 0, 1424, 1426, 1, 0, 0,
		0, 1425, 1422, 1, 0, 0, 0, 1425, 1426, 1, 0, 0, 0, 1426, 255, 1, 0, 0,
		0, 1427, 1428, 7, 12, 0, 0, 1428, 257, 1, 0, 0, 0, 1429, 1431, 7, 1, 0,
		0, 1430, 1429, 1, 0, 0, 0, 1430, 1431, 1, 0, 0, 0, 1431, 1432, 1, 0, 0,
		0, 1432, 1433, 3, 260, 130, 0, 1433, 259, 1, 0, 0, 0, 1434, 1436, 6, 130,
		-1, 0, 1435, 1437, 5, 96, 0, 0, 1436, 1435, 1, 0, 0, 0, 1436, 1437, 1,
		0, 0, 0, 1437, 1438, 1, 0, 0, 0, 1438, 1471, 3, 264, 132, 0, 1439, 1471,
		3, 266, 133, 0, 1440, 1443, 3, 240, 120, 0, 1441, 1442, 5, 89, 0, 0, 1442,
		1444, 3, 14, 7, 0, 1443, 1441, 1, 0, 0, 0, 1443, 1444, 1, 0, 0, 0, 1444,
		1471, 1, 0, 0, 0, 1445, 1446, 5, 58, 0, 0, 1446, 1447, 3, 246, 123, 0,
		1447, 1448, 5, 59, 0, 0, 1448, 1471, 1, 0, 0, 0, 1449, 1471, 3, 262, 131,
		0, 1450, 1471, 3, 270, 135, 0, 1451, 1452, 5, 26, 0, 0, 1452, 1471, 3,
		260, 130, 5, 1453, 1471, 3, 50, 25, 0, 1454, 1456, 5, 65, 0, 0, 1455, 1454,
		1, 0, 0, 0, 1455, 1456, 1, 0, 0, 0, 1456, 1457, 1, 0, 0, 0, 1457, 1462,
		3, 132, 66, 0, 1458, 1459, 5, 58, 0, 0, 1459, 1460, 3, 246, 123, 0, 1460,
		1461, 5, 59, 0, 0, 1461, 1463, 1, 0, 0, 0, 1462, 1458, 1, 0, 0, 0, 1462,
		1463, 1, 0, 0, 0, 1463, 1467, 1, 0, 0, 0, 1464, 1466, 5, 64, 0, 0, 1465,
		1464, 1, 0, 0, 0, 1466, 1469, 1, 0, 0, 0, 1467, 1465, 1, 0, 0, 0, 1467,
		1468, 1, 0, 0, 0, 1468, 1471, 1, 0, 0, 0, 1469, 1467, 1, 0, 0, 0, 1470,
		1434, 1, 0, 0, 0, 1470, 1439, 1, 0, 0, 0, 1470, 1440, 1, 0, 0, 0, 1470,
		1445, 1, 0, 0, 0, 1470, 1449, 1, 0, 0, 0, 1470, 1450, 1, 0, 0, 0, 1470,
		1451, 1, 0, 0, 0, 1470, 1453, 1, 0, 0, 0, 1470, 1455, 1, 0, 0, 0, 1471,
		1493, 1, 0, 0, 0, 1472, 1473, 10, 3, 0, 0, 1473, 1474, 5, 60, 0, 0, 1474,
		1479, 3, 246, 123, 0, 1475, 1476, 5, 49, 0, 0, 1476, 1478, 3, 246, 123,
		0, 1477, 1475, 1, 0, 0, 0, 1478, 1481, 1, 0, 0, 0, 1479, 1477, 1, 0, 0,
		0, 1479, 1480, 1, 0, 0, 0, 1480, 1482, 1, 0, 0, 0, 1481, 1479, 1, 0, 0,
		0, 1482, 1483, 5, 62, 0, 0, 1483, 1492, 1, 0, 0, 0, 1484, 1487, 10, 1,
		0, 0, 1485, 1486, 5, 66, 0, 0, 1486, 1488, 3, 246, 123, 0, 1487, 1485,
		1, 0, 0, 0, 1488, 1489, 1, 0, 0, 0, 1489, 1487, 1, 0, 0, 0, 1489, 1490,
		1, 0, 0, 0, 1490, 1492, 1, 0, 0, 0, 1491, 1472, 1, 0, 0, 0, 1491, 1484,
		1, 0, 0, 0, 1492, 1495, 1, 0, 0, 0, 1493, 1491, 1, 0, 0, 0, 1493, 1494,
		1, 0, 0, 0, 1494, 261, 1, 0, 0, 0, 1495, 1493, 1, 0, 0, 0, 1496, 1502,
		3, 42, 21, 0, 1497, 1502, 3, 34, 17, 0, 1498, 1502, 3, 36, 18, 0, 1499,
		1502, 3, 52, 26, 0, 1500, 1502, 5, 25, 0, 0, 1501, 1496, 1, 0, 0, 0, 1501,
		1497, 1, 0, 0, 0, 1501, 1498, 1, 0, 0, 0, 1501, 1499, 1, 0, 0, 0, 1501,
		1500, 1, 0, 0, 0, 1502, 263, 1, 0, 0, 0, 1503, 1508, 3, 14, 7, 0, 1504,
		1505, 5, 58, 0, 0, 1505, 1506, 3, 268, 134, 0, 1506, 1507, 5, 59, 0, 0,
		1507, 1509, 1, 0, 0, 0, 1508, 1504, 1, 0, 0, 0, 1508, 1509, 1, 0, 0, 0,
		1509, 265, 1, 0, 0, 0, 1510, 1511, 5, 87, 0, 0, 1511, 1512, 5, 58, 0, 0,
		1512, 1513, 3, 268, 134, 0, 1513, 1514, 5, 59, 0, 0, 1514, 267, 1, 0, 0,
		0, 1515, 1520, 3, 280, 140, 0, 1516, 1517, 5, 49, 0, 0, 1517, 1519, 3,
		280, 140, 0, 1518, 1516, 1, 0, 0, 0, 1519, 1522, 1, 0, 0, 0, 1520, 1518,
		1, 0, 0, 0, 1520, 1521, 1, 0, 0, 0, 1521, 269, 1, 0, 0, 0, 1522, 1520,
		1, 0, 0, 0, 1523, 1524, 5, 60, 0, 0, 1524, 1525, 3, 272, 136, 0, 1525,
		1526, 5, 62, 0, 0, 1526, 1532, 1, 0, 0, 0, 1527, 1528, 5, 61, 0, 0, 1528,
		1529, 3, 272, 136, 0, 1529, 1530, 5, 63, 0, 0, 1530, 1532, 1, 0, 0, 0,
		1531, 1523, 1, 0, 0, 0, 1531, 1527, 1, 0, 0, 0, 1532, 271, 1, 0, 0, 0,
		1533, 1538, 3, 274, 137, 0, 1534, 1535, 5, 49, 0, 0, 1535, 1537, 3, 274,
		137, 0, 1536, 1534, 1, 0, 0, 0, 1537, 1540, 1, 0, 0, 0, 1538, 1536, 1,
		0, 0, 0, 1538, 1539, 1, 0, 0, 0, 1539, 1543, 1, 0, 0, 0, 1540, 1538, 1,
		0, 0, 0, 1541, 1543, 1, 0, 0, 0, 1542, 1533, 1, 0, 0, 0, 1542, 1541, 1,
		0, 0, 0, 1543, 273, 1, 0, 0, 0, 1544, 1547, 3, 246, 123, 0, 1545, 1546,
		5, 67, 0, 0, 1546, 1548, 3, 246, 123, 0, 1547, 1545, 1, 0, 0, 0, 1547,
		1548, 1, 0, 0, 0, 1548, 275, 1, 0, 0, 0, 1549, 1554, 3, 14, 7, 0, 1550,
		1551, 5, 58, 0, 0, 1551, 1552, 3, 268, 134, 0, 1552, 1553, 5, 59, 0, 0,
		1553, 1555, 1, 0, 0, 0, 1554, 1550, 1, 0, 0, 0, 1554, 1555, 1, 0, 0, 0,
		1555, 277, 1, 0, 0, 0, 1556, 1561, 3, 240, 120, 0, 1557, 1558, 5, 66, 0,
		0, 1558, 1560, 3, 240, 120, 0, 1559, 1557, 1, 0, 0, 0, 1560, 1563, 1, 0,
		0, 0, 1561, 1559, 1, 0, 0, 0, 1561, 1562, 1, 0, 0, 0, 1562, 1564, 1, 0,
		0, 0, 1563, 1561, 1, 0, 0, 0, 1564, 1565, 5, 66, 0, 0, 1565, 1570, 3, 14,
		7, 0, 1566, 1567, 5, 58, 0, 0, 1567, 1568, 3, 268, 134, 0, 1568, 1569,
		5, 59, 0, 0, 1569, 1571, 1, 0, 0, 0, 1570, 1566, 1, 0, 0, 0, 1570, 1571,
		1, 0, 0, 0, 1571, 279, 1, 0, 0, 0, 1572, 1576, 3, 246, 123, 0, 1573, 1575,
		3, 282, 141, 0, 1574, 1573, 1, 0, 0, 0, 1575, 1578, 1, 0, 0, 0, 1576, 1574,
		1, 0, 0, 0, 1576, 1577, 1, 0, 0, 0, 1577, 1582, 1, 0, 0, 0, 1578, 1576,
		1, 0, 0, 0, 1579, 1582, 3, 200, 100, 0, 1580, 1582, 3, 202, 101, 0, 1581,
		1572, 1, 0, 0, 0, 1581, 1579, 1, 0, 0, 0, 1581, 1580, 1, 0, 0, 0, 1582,
		281, 1, 0, 0, 0, 1583, 1584, 5, 51, 0, 0, 1584, 1585, 3, 246, 123, 0, 1585,
		283, 1, 0, 0, 0, 1586, 1587, 5, 18, 0, 0, 1587, 1588, 3, 28, 14, 0, 1588,
		285, 1, 0, 0, 0, 1589, 1597, 5, 96, 0, 0, 1590, 1595, 3, 14, 7, 0, 1591,
		1592, 5, 58, 0, 0, 1592, 1593, 3, 268, 134, 0, 1593, 1594, 5, 59, 0, 0,
		1594, 1596, 1, 0, 0, 0, 1595, 1591, 1, 0, 0, 0, 1595, 1596, 1, 0, 0, 0,
		1596, 1598, 1, 0, 0, 0, 1597, 1590, 1, 0, 0, 0, 1597, 1598, 1, 0, 0, 0,
		1598, 287, 1, 0, 0, 0, 1599, 1600, 1, 0, 0, 0, 1600, 289, 1, 0, 0, 0, 1601,
		1602, 1, 0, 0, 0, 1602, 291, 1, 0, 0, 0, 1603, 1610, 3, 294, 147, 0, 1604,
		1610, 3, 298, 149, 0, 1605, 1610, 3, 306, 153, 0, 1606, 1610, 3, 320, 160,
		0, 1607, 1610, 3, 322, 161, 0, 1608, 1610, 3, 324, 162, 0, 1609, 1603,
		1, 0, 0, 0, 1609, 1604, 1, 0, 0, 0, 1609, 1605, 1, 0, 0, 0, 1609, 1606,
		1, 0, 0, 0, 1609, 1607, 1, 0, 0, 0, 1609, 1608, 1, 0, 0, 0, 1610, 293,
		1, 0, 0, 0, 1611, 1612, 5, 4, 0, 0, 1612, 1613, 3, 296, 148, 0, 1613, 1614,
		5, 14, 0, 0, 1614, 295, 1, 0, 0, 0, 1615, 1620, 3, 226, 113, 0, 1616, 1617,
		5, 50, 0, 0, 1617, 1619, 3, 226, 113, 0, 1618, 1616, 1, 0, 0, 0, 1619,
		1622, 1, 0, 0, 0, 1620, 1618, 1, 0, 0, 0, 1620, 1621, 1, 0, 0, 0, 1621,
		297, 1, 0, 0, 0, 1622, 1620, 1, 0, 0, 0, 1623, 1626, 3, 300, 150, 0, 1624,
		1626, 3, 302, 151, 0, 1625, 1623, 1, 0, 0, 0, 1625, 1624, 1, 0, 0, 0, 1626,
		299, 1, 0, 0, 0, 1627, 1628, 5, 20, 0, 0, 1628, 1629, 3, 246, 123, 0, 1629,
		1630, 5, 37, 0, 0, 1630, 1633, 3, 226, 113, 0, 1631, 1632, 5, 13, 0, 0,
		1632, 1634, 3, 226, 113, 0, 1633, 1631, 1, 0, 0, 0, 1633, 1634, 1, 0, 0,
		0, 1634, 1636, 1, 0, 0, 0, 1635, 1637, 5, 50, 0, 0, 1636, 1635, 1, 0, 0,
		0, 1636, 1637, 1, 0, 0, 0, 1637, 301, 1, 0, 0, 0, 1638, 1639, 5, 6, 0,
		0, 1639, 1640, 3, 246, 123, 0, 1640, 1641, 5, 27, 0, 0, 1641, 1646, 3,
		304, 152, 0, 1642, 1643, 5, 50, 0, 0, 1643, 1645, 3, 304, 152, 0, 1644,
		1642, 1, 0, 0, 0, 1645, 1648, 1, 0, 0, 0, 1646, 1644, 1, 0, 0, 0, 1646,
		1647, 1, 0, 0, 0, 1647, 1652, 1, 0, 0, 0, 1648, 1646, 1, 0, 0, 0, 1649,
		1650, 5, 50, 0, 0, 1650, 1651, 5, 13, 0, 0, 1651, 1653, 3, 296, 148, 0,
		1652, 1649, 1, 0, 0, 0, 1652, 1653, 1, 0, 0, 0, 1653, 1655, 1, 0, 0, 0,
		1654, 1656, 5, 50, 0, 0, 1655, 1654, 1, 0, 0, 0, 1655, 1656, 1, 0, 0, 0,
		1656, 1657, 1, 0, 0, 0, 1657, 1658, 5, 14, 0, 0, 1658, 303, 1, 0, 0, 0,
		1659, 1660, 3, 220, 110, 0, 1660, 1661, 5, 51, 0, 0, 1661, 1662, 3, 226,
		113, 0, 1662, 305, 1, 0, 0, 0, 1663, 1667, 3, 308, 154, 0, 1664, 1667,
		3, 310, 155, 0, 1665, 1667, 3, 312, 156, 0, 1666, 1663, 1, 0, 0, 0, 1666,
		1664, 1, 0, 0, 0, 1666, 1665, 1, 0, 0, 0, 1667, 307, 1, 0, 0, 0, 1668,
		1669, 5, 42, 0, 0, 1669, 1670, 3, 246, 123, 0, 1670, 1671, 5, 11, 0, 0,
		1671, 1672, 3, 226, 113, 0, 1672, 309, 1, 0, 0, 0, 1673, 1674, 5, 35, 0,
		0, 1674, 1675, 3, 296, 148, 0, 1675, 1676, 5, 40, 0, 0, 1676, 1677, 3,
		246, 123, 0, 1677, 311, 1, 0, 0, 0, 1678, 1679, 5, 16, 0, 0, 1679, 1680,
		3, 14, 7, 0, 1680, 1681, 5, 48, 0, 0, 1681, 1682, 3, 314, 157, 0, 1682,
		1683, 5, 11, 0, 0, 1683, 1684, 3, 226, 113, 0, 1684, 313, 1, 0, 0, 0, 1685,
		1686, 3, 316, 158, 0, 1686, 1687, 7, 13, 0, 0, 1687, 1688, 3, 318, 159,
		0, 1688, 315, 1, 0, 0, 0, 1689, 1690, 3, 246, 123, 0, 1690, 317, 1, 0,
		0, 0, 1691, 1692, 3, 246, 123, 0, 1692, 319, 1, 0, 0, 0, 1693, 1694, 5,
		43, 0, 0, 1694, 1695, 3, 326, 163, 0, 1695, 1696, 5, 11, 0, 0, 1696, 1697,
		3, 226, 113, 0, 1697, 1704, 1, 0, 0, 0, 1698, 1699, 5, 43, 0, 0, 1699,
		1700, 3, 246, 123, 0, 1700, 1701, 5, 11, 0, 0, 1701, 1702, 3, 226, 113,
		0, 1702, 1704, 1, 0, 0, 0, 1703, 1693, 1, 0, 0, 0, 1703, 1698, 1, 0, 0,
		0, 1704, 321, 1, 0, 0, 0, 1705, 1706, 5, 90, 0, 0, 1706, 1707, 3, 296,
		148, 0, 1707, 1708, 5, 92, 0, 0, 1708, 1709, 3, 296, 148, 0, 1709, 1710,
		5, 14, 0, 0, 1710, 323, 1, 0, 0, 0, 1711, 1712, 5, 90, 0, 0, 1712, 1713,
		3, 296, 148, 0, 1713, 1714, 5, 91, 0, 0, 1714, 1715, 3, 296, 148, 0, 1715,
		1716, 5, 14, 0, 0, 1716, 325, 1, 0, 0, 0, 1717, 1722, 3, 240, 120, 0, 1718,
		1719, 5, 49, 0, 0, 1719, 1721, 3, 240, 120, 0, 1720, 1718, 1, 0, 0, 0,
		1721, 1724, 1, 0, 0, 0, 1722, 1720, 1, 0, 0, 0, 1722, 1723, 1, 0, 0, 0,
		1723, 327, 1, 0, 0, 0, 1724, 1722, 1, 0, 0, 0, 1725, 1726, 5, 60, 0, 0,
		1726, 1727, 3, 330, 165, 0, 1727, 1728, 5, 62, 0, 0, 1728, 329, 1, 0, 0,
		0, 1729, 1734, 3, 332, 166, 0, 1730, 1731, 5, 49, 0, 0, 1731, 1733, 3,
		332, 166, 0, 1732, 1730, 1, 0, 0, 0, 1733, 1736, 1, 0, 0, 0, 1734, 1732,
		1, 0, 0, 0, 1734, 1735, 1, 0, 0, 0, 1735, 331, 1, 0, 0, 0, 1736, 1734,
		1, 0, 0, 0, 1737, 1742, 3, 14, 7, 0, 1738, 1739, 5, 58, 0, 0, 1739, 1740,
		3, 268, 134, 0, 1740, 1741, 5, 59, 0, 0, 1741, 1743, 1, 0, 0, 0, 1742,
		1738, 1, 0, 0, 0, 1742, 1743, 1, 0, 0, 0, 1743, 333, 1, 0, 0, 0, 191, 336,
		344, 348, 362, 365, 368, 376, 382, 397, 402, 410, 412, 426, 428, 436, 438,
		451, 464, 469, 480, 504, 508, 511, 519, 526, 539, 546, 553, 566, 569, 578,
		582, 588, 596, 602, 606, 610, 617, 620, 634, 637, 643, 652, 656, 660, 665,
		671, 677, 681, 694, 699, 708, 711, 719, 730, 735, 740, 745, 750, 753, 756,
		759, 763, 768, 770, 790, 805, 817, 823, 830, 840, 845, 851, 862, 868, 877,
		886, 891, 897, 909, 919, 927, 934, 944, 951, 954, 960, 966, 970, 984, 989,
		994, 999, 1002, 1009, 1013, 1023, 1031, 1047, 1056, 1062, 1073, 1078, 1083,
		1093, 1104, 1110, 1115, 1118, 1121, 1126, 1132, 1135, 1140, 1149, 1155,
		1160, 1172, 1178, 1193, 1210, 1216, 1220, 1225, 1230, 1235, 1240, 1244,
		1249, 1252, 1259, 1267, 1283, 1288, 1292, 1303, 1313, 1317, 1323, 1327,
		1333, 1341, 1352, 1362, 1364, 1366, 1380, 1387, 1398, 1403, 1409, 1417,
		1425, 1430, 1436, 1443, 1455, 1462, 1467, 1470, 1479, 1489, 1491, 1493,
		1501, 1508, 1520, 1531, 1538, 1542, 1547, 1554, 1561, 1570, 1576, 1581,
		1595, 1597, 1609, 1620, 1625, 1633, 1636, 1646, 1652, 1655, 1666, 1703,
		1722, 1734, 1742,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// pascalParserInit initializes any static state used to implement pascalParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewpascalParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func PascalParserInit() {
	staticData := &PascalParserStaticData
	staticData.once.Do(pascalParserInit)
}

// NewpascalParser produces a new parser instance for the optional input antlr.TokenStream.
func NewpascalParser(input antlr.TokenStream) *pascalParser {
	PascalParserInit()
	this := new(pascalParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &PascalParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "pascal.g4"

	return this
}

// pascalParser tokens.
const (
	pascalParserEOF                       = antlr.TokenEOF
	pascalParserGUID_LITERAL              = 1
	pascalParserAND                       = 2
	pascalParserARRAY                     = 3
	pascalParserBEGIN                     = 4
	pascalParserBOOLEAN                   = 5
	pascalParserCASE                      = 6
	pascalParserCHAR                      = 7
	pascalParserCHR                       = 8
	pascalParserCONST                     = 9
	pascalParserDIV                       = 10
	pascalParserDO                        = 11
	pascalParserDOWNTO                    = 12
	pascalParserELSE                      = 13
	pascalParserEND                       = 14
	pascalParserFILE                      = 15
	pascalParserFOR                       = 16
	pascalParserFUNCTION                  = 17
	pascalParserGOTO                      = 18
	pascalParserHELPER                    = 19
	pascalParserIF                        = 20
	pascalParserIN                        = 21
	pascalParserINTEGER                   = 22
	pascalParserLABEL                     = 23
	pascalParserMOD                       = 24
	pascalParserNIL                       = 25
	pascalParserNOT                       = 26
	pascalParserOF                        = 27
	pascalParserOR                        = 28
	pascalParserPACKED                    = 29
	pascalParserPROCEDURE                 = 30
	pascalParserPROGRAM                   = 31
	pascalParserREAL                      = 32
	pascalParserRECORD                    = 33
	pascalParserREFERENCE                 = 34
	pascalParserREPEAT                    = 35
	pascalParserSET                       = 36
	pascalParserTHEN                      = 37
	pascalParserTO                        = 38
	pascalParserTYPE                      = 39
	pascalParserUNTIL                     = 40
	pascalParserVAR                       = 41
	pascalParserWHILE                     = 42
	pascalParserWITH                      = 43
	pascalParserPLUS                      = 44
	pascalParserMINUS                     = 45
	pascalParserSTAR                      = 46
	pascalParserSLASH                     = 47
	pascalParserASSIGN                    = 48
	pascalParserCOMMA                     = 49
	pascalParserSEMI                      = 50
	pascalParserCOLON                     = 51
	pascalParserEQUAL                     = 52
	pascalParserNOT_EQUAL                 = 53
	pascalParserLT                        = 54
	pascalParserLE                        = 55
	pascalParserGE                        = 56
	pascalParserGT                        = 57
	pascalParserLPAREN                    = 58
	pascalParserRPAREN                    = 59
	pascalParserLBRACK                    = 60
	pascalParserLBRACK2                   = 61
	pascalParserRBRACK                    = 62
	pascalParserRBRACK2                   = 63
	pascalParserDEREFERENCE               = 64
	pascalParserAT                        = 65
	pascalParserDOT                       = 66
	pascalParserDOTDOT                    = 67
	pascalParserLCURLY                    = 68
	pascalParserRCURLY                    = 69
	pascalParserUNIT                      = 70
	pascalParserINTERFACE                 = 71
	pascalParserUSES                      = 72
	pascalParserSTRING                    = 73
	pascalParserIMPLEMENTATION            = 74
	pascalParserTRUE                      = 75
	pascalParserFALSE                     = 76
	pascalParserCLASS                     = 77
	pascalParserPRIVATE                   = 78
	pascalParserPROTECTED                 = 79
	pascalParserPUBLIC                    = 80
	pascalParserPUBLISHED                 = 81
	pascalParserSTRICT                    = 82
	pascalParserOUT                       = 83
	pascalParserPROPERTY                  = 84
	pascalParserREAD                      = 85
	pascalParserWRITE                     = 86
	pascalParserDEFAULT                   = 87
	pascalParserINDEX                     = 88
	pascalParserAS                        = 89
	pascalParserTRY                       = 90
	pascalParserFINALLY                   = 91
	pascalParserEXCEPT                    = 92
	pascalParserINITIALIZATION            = 93
	pascalParserFINALIZATION              = 94
	pascalParserOBJECT                    = 95
	pascalParserINHERITED                 = 96
	pascalParserABSTRACT                  = 97
	pascalParserREINTRODUCE               = 98
	pascalParserVIRTUAL                   = 99
	pascalParserOVERRIDE                  = 100
	pascalParserOVERLOAD                  = 101
	pascalParserINLINE                    = 102
	pascalParserCDECL                     = 103
	pascalParserSTDCALL                   = 104
	pascalParserSTATIC                    = 105
	pascalParserCONSTRUCTOR               = 106
	pascalParserDESTRUCTOR                = 107
	pascalParserRESOURCESTRING            = 108
	pascalParserFORWARD                   = 109
	pascalParserRAISE                     = 110
	pascalParserSHR                       = 111
	pascalParserSHL                       = 112
	pascalParserXOR                       = 113
	pascalParserCARDINAL                  = 114
	pascalParserLONGBOOL                  = 115
	pascalParserLONGINT                   = 116
	pascalParserOPERATOR                  = 117
	pascalParserWS                        = 118
	pascalParserCOMMENT_1                 = 119
	pascalParserCOMMENT_2                 = 120
	pascalParserCOMMENT_3                 = 121
	pascalParserIDENT                     = 122
	pascalParserHEX_LITERAL               = 123
	pascalParserSTRING_LITERAL            = 124
	pascalParserSTRING_CROSSHATCH_LITERAL = 125
	pascalParserNUM_INT                   = 126
	pascalParserNUM_REAL                  = 127
	pascalParserUTF8BOM                   = 128
)

// pascalParser rules.
const (
	pascalParserRULE_source                             = 0
	pascalParserRULE_program                            = 1
	pascalParserRULE_unit                               = 2
	pascalParserRULE_interfaceSection                   = 3
	pascalParserRULE_implementationSection              = 4
	pascalParserRULE_initializationSection              = 5
	pascalParserRULE_finalizationSection                = 6
	pascalParserRULE_identifier                         = 7
	pascalParserRULE_identifierPart                     = 8
	pascalParserRULE_interfaceBlock                     = 9
	pascalParserRULE_implementationBlock                = 10
	pascalParserRULE_block                              = 11
	pascalParserRULE_usesUnits                          = 12
	pascalParserRULE_labelDeclarationPart               = 13
	pascalParserRULE_label                              = 14
	pascalParserRULE_constantDefinitionPart             = 15
	pascalParserRULE_constantDefinition                 = 16
	pascalParserRULE_constantChr                        = 17
	pascalParserRULE_hexConstant                        = 18
	pascalParserRULE_constant                           = 19
	pascalParserRULE_arrayConstant                      = 20
	pascalParserRULE_unsignedNumber                     = 21
	pascalParserRULE_unsignedInteger                    = 22
	pascalParserRULE_unsignedReal                       = 23
	pascalParserRULE_sign                               = 24
	pascalParserRULE_bool_                              = 25
	pascalParserRULE_string                             = 26
	pascalParserRULE_stringExpression                   = 27
	pascalParserRULE_resourceDefinitionPart             = 28
	pascalParserRULE_resourceDefinition                 = 29
	pascalParserRULE_typeDefinitionPart                 = 30
	pascalParserRULE_typeDefinition                     = 31
	pascalParserRULE_functionType                       = 32
	pascalParserRULE_procedureType                      = 33
	pascalParserRULE_forwardClassType                   = 34
	pascalParserRULE_forwardInterfaceType               = 35
	pascalParserRULE_classType                          = 36
	pascalParserRULE_classImplementsInterfaces          = 37
	pascalParserRULE_accessSpecifier                    = 38
	pascalParserRULE_classDeclaration                   = 39
	pascalParserRULE_classImplicitPublishedDeclaration  = 40
	pascalParserRULE_classDeclarationPart               = 41
	pascalParserRULE_interfaceGuidConst                 = 42
	pascalParserRULE_interfaceType                      = 43
	pascalParserRULE_interfaceDeclaration               = 44
	pascalParserRULE_interfaceDeclarationPart           = 45
	pascalParserRULE_errorInterfaceDeclarationPart      = 46
	pascalParserRULE_errorClassDeclarationPart          = 47
	pascalParserRULE_propertyDeclaration                = 48
	pascalParserRULE_propertyReadDeclaration            = 49
	pascalParserRULE_propertyWriteDeclaration           = 50
	pascalParserRULE_propertyDefaultValueDeclaration    = 51
	pascalParserRULE_propertyIndexDeclaration           = 52
	pascalParserRULE_propertyIndexParameters            = 53
	pascalParserRULE_propertyIndexParametersList        = 54
	pascalParserRULE_genericTemplate                    = 55
	pascalParserRULE_genericTemplateList                = 56
	pascalParserRULE_genericTypeParameter               = 57
	pascalParserRULE_genericConstraints                 = 58
	pascalParserRULE_genericConstraint                  = 59
	pascalParserRULE_type_                              = 60
	pascalParserRULE_simpleType                         = 61
	pascalParserRULE_scalarType                         = 62
	pascalParserRULE_scalerList                         = 63
	pascalParserRULE_scalerMember                       = 64
	pascalParserRULE_subrangeType                       = 65
	pascalParserRULE_typeIdentifier                     = 66
	pascalParserRULE_structuredType                     = 67
	pascalParserRULE_unpackedStructuredType             = 68
	pascalParserRULE_stringtype                         = 69
	pascalParserRULE_arrayType                          = 70
	pascalParserRULE_typeList                           = 71
	pascalParserRULE_indexType                          = 72
	pascalParserRULE_recordType                         = 73
	pascalParserRULE_recordDeclaration                  = 74
	pascalParserRULE_recordImplicitPublishedDeclaration = 75
	pascalParserRULE_recordDeclarationPart              = 76
	pascalParserRULE_errorRecordDeclarationPart         = 77
	pascalParserRULE_recordParts                        = 78
	pascalParserRULE_recordFixedPart                    = 79
	pascalParserRULE_recordVariantPart                  = 80
	pascalParserRULE_tag                                = 81
	pascalParserRULE_recordVariant                      = 82
	pascalParserRULE_helperType                         = 83
	pascalParserRULE_helperDeclaration                  = 84
	pascalParserRULE_helperImplicitPublishedDeclaration = 85
	pascalParserRULE_helperDeclarationPart              = 86
	pascalParserRULE_errorHelperDeclarationPart         = 87
	pascalParserRULE_setType                            = 88
	pascalParserRULE_fileType                           = 89
	pascalParserRULE_pointerType                        = 90
	pascalParserRULE_variableDeclarationPart            = 91
	pascalParserRULE_variableDeclaration                = 92
	pascalParserRULE_procedureHeader                    = 93
	pascalParserRULE_functionHeader                     = 94
	pascalParserRULE_procedureOrFunctionHeader          = 95
	pascalParserRULE_procedureOrFunctionHeaderModifiers = 96
	pascalParserRULE_procedureOrFunctionDeclaration     = 97
	pascalParserRULE_procedureDeclaration               = 98
	pascalParserRULE_functionDeclaration                = 99
	pascalParserRULE_procedureLambdaDeclaration         = 100
	pascalParserRULE_functionLambdaDeclaration          = 101
	pascalParserRULE_resultType                         = 102
	pascalParserRULE_procedureOrFunctionBody            = 103
	pascalParserRULE_classOperatorHeader                = 104
	pascalParserRULE_classOperatorDeclaration           = 105
	pascalParserRULE_formalParameterList                = 106
	pascalParserRULE_formalParameterSection             = 107
	pascalParserRULE_parameterGroup                     = 108
	pascalParserRULE_identifierList                     = 109
	pascalParserRULE_constList                          = 110
	pascalParserRULE_defaultValue                       = 111
	pascalParserRULE_typedIdentifierList                = 112
	pascalParserRULE_statement                          = 113
	pascalParserRULE_errorStatement                     = 114
	pascalParserRULE_unlabelledStatement                = 115
	pascalParserRULE_simpleStatement                    = 116
	pascalParserRULE_assignmentStatement                = 117
	pascalParserRULE_raiseExceptionStatement            = 118
	pascalParserRULE_variableDeclarationStatement       = 119
	pascalParserRULE_variableDesignator                 = 120
	pascalParserRULE_typeCast                           = 121
	pascalParserRULE_propertyDesignator                 = 122
	pascalParserRULE_expression                         = 123
	pascalParserRULE_relationaloperator                 = 124
	pascalParserRULE_simpleExpression                   = 125
	pascalParserRULE_additiveoperator                   = 126
	pascalParserRULE_term                               = 127
	pascalParserRULE_multiplicativeoperator             = 128
	pascalParserRULE_signedFactor                       = 129
	pascalParserRULE_factor                             = 130
	pascalParserRULE_unsignedConstant                   = 131
	pascalParserRULE_functionDesignator                 = 132
	pascalParserRULE_defaultDesignator                  = 133
	pascalParserRULE_parameterList                      = 134
	pascalParserRULE_set_                               = 135
	pascalParserRULE_elementList                        = 136
	pascalParserRULE_element                            = 137
	pascalParserRULE_procedureStatement                 = 138
	pascalParserRULE_methodCallStatement                = 139
	pascalParserRULE_actualParameter                    = 140
	pascalParserRULE_parameterwidth                     = 141
	pascalParserRULE_gotoStatement                      = 142
	pascalParserRULE_inheritedStatement                 = 143
	pascalParserRULE_emptyStatement_                    = 144
	pascalParserRULE_empty_                             = 145
	pascalParserRULE_structuredStatement                = 146
	pascalParserRULE_compoundStatement                  = 147
	pascalParserRULE_statements                         = 148
	pascalParserRULE_conditionalStatement               = 149
	pascalParserRULE_ifStatement                        = 150
	pascalParserRULE_caseStatement                      = 151
	pascalParserRULE_caseListElement                    = 152
	pascalParserRULE_repetetiveStatement                = 153
	pascalParserRULE_whileStatement                     = 154
	pascalParserRULE_repeatStatement                    = 155
	pascalParserRULE_forStatement                       = 156
	pascalParserRULE_forList                            = 157
	pascalParserRULE_initialValue                       = 158
	pascalParserRULE_finalValue                         = 159
	pascalParserRULE_withStatement                      = 160
	pascalParserRULE_tryExceptStatement                 = 161
	pascalParserRULE_tryFinallyStatement                = 162
	pascalParserRULE_withStatementVariableList          = 163
	pascalParserRULE_attributeSection                   = 164
	pascalParserRULE_attributeList                      = 165
	pascalParserRULE_attributeItem                      = 166
)

// ISourceContext is an interface to support dynamic dispatch.
type ISourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Program() IProgramContext
	Unit() IUnitContext

	// IsSourceContext differentiates from other interfaces.
	IsSourceContext()
}

type SourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceContext() *SourceContext {
	var p = new(SourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_source
	return p
}

func InitEmptySourceContext(p *SourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_source
}

func (*SourceContext) IsSourceContext() {}

func NewSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceContext {
	var p = new(SourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_source

	return p
}

func (s *SourceContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceContext) Program() IProgramContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProgramContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProgramContext)
}

func (s *SourceContext) Unit() IUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitContext)
}

func (s *SourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSource(s)
	}
}

func (s *SourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSource(s)
	}
}

func (s *SourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSource(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Source() (localctx ISourceContext) {
	localctx = NewSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, pascalParserRULE_source)
	p.SetState(336)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserPROGRAM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(334)
			p.Program()
		}

	case pascalParserUNIT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(335)
			p.Unit()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROGRAM() antlr.TerminalNode
	Identifier() IIdentifierContext
	SEMI() antlr.TerminalNode
	ImplementationBlock() IImplementationBlockContext
	BEGIN() antlr.TerminalNode
	Statements() IStatementsContext
	END() antlr.TerminalNode
	DOT() antlr.TerminalNode
	EOF() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	RPAREN() antlr.TerminalNode
	UsesUnits() IUsesUnitsContext

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) PROGRAM() antlr.TerminalNode {
	return s.GetToken(pascalParserPROGRAM, 0)
}

func (s *ProgramContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ProgramContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ProgramContext) ImplementationBlock() IImplementationBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplementationBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplementationBlockContext)
}

func (s *ProgramContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(pascalParserBEGIN, 0)
}

func (s *ProgramContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *ProgramContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *ProgramContext) DOT() antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, 0)
}

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(pascalParserEOF, 0)
}

func (s *ProgramContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ProgramContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ProgramContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ProgramContext) UsesUnits() IUsesUnitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsesUnitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsesUnitsContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProgram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, pascalParserRULE_program)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(338)
		p.Match(pascalParserPROGRAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(339)
		p.Identifier()
	}
	p.SetState(344)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(340)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(341)
			p.IdentifierList()
		}
		{
			p.SetState(342)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(346)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(348)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserUSES {
		{
			p.SetState(347)
			p.UsesUnits()
		}

	}
	{
		p.SetState(350)
		p.ImplementationBlock()
	}
	{
		p.SetState(351)
		p.Match(pascalParserBEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(352)
		p.Statements()
	}
	{
		p.SetState(353)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(354)
		p.Match(pascalParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(355)
		p.Match(pascalParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitContext is an interface to support dynamic dispatch.
type IUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNIT() antlr.TerminalNode
	Identifier() IIdentifierContext
	SEMI() antlr.TerminalNode
	InterfaceSection() IInterfaceSectionContext
	END() antlr.TerminalNode
	DOT() antlr.TerminalNode
	EOF() antlr.TerminalNode
	ImplementationSection() IImplementationSectionContext
	InitializationSection() IInitializationSectionContext
	FinalizationSection() IFinalizationSectionContext

	// IsUnitContext differentiates from other interfaces.
	IsUnitContext()
}

type UnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitContext() *UnitContext {
	var p = new(UnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unit
	return p
}

func InitEmptyUnitContext(p *UnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unit
}

func (*UnitContext) IsUnitContext() {}

func NewUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitContext {
	var p = new(UnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unit

	return p
}

func (s *UnitContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitContext) UNIT() antlr.TerminalNode {
	return s.GetToken(pascalParserUNIT, 0)
}

func (s *UnitContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnitContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *UnitContext) InterfaceSection() IInterfaceSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceSectionContext)
}

func (s *UnitContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *UnitContext) DOT() antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, 0)
}

func (s *UnitContext) EOF() antlr.TerminalNode {
	return s.GetToken(pascalParserEOF, 0)
}

func (s *UnitContext) ImplementationSection() IImplementationSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplementationSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplementationSectionContext)
}

func (s *UnitContext) InitializationSection() IInitializationSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializationSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializationSectionContext)
}

func (s *UnitContext) FinalizationSection() IFinalizationSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinalizationSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinalizationSectionContext)
}

func (s *UnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnit(s)
	}
}

func (s *UnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnit(s)
	}
}

func (s *UnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Unit() (localctx IUnitContext) {
	localctx = NewUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, pascalParserRULE_unit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(357)
		p.Match(pascalParserUNIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(358)
		p.Identifier()
	}
	{
		p.SetState(359)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(360)
		p.InterfaceSection()
	}
	p.SetState(362)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserIMPLEMENTATION {
		{
			p.SetState(361)
			p.ImplementationSection()
		}

	}
	p.SetState(365)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserINITIALIZATION {
		{
			p.SetState(364)
			p.InitializationSection()
		}

	}
	p.SetState(368)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserFINALIZATION {
		{
			p.SetState(367)
			p.FinalizationSection()
		}

	}
	{
		p.SetState(370)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(371)
		p.Match(pascalParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(372)
		p.Match(pascalParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceSectionContext is an interface to support dynamic dispatch.
type IInterfaceSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	InterfaceBlock() IInterfaceBlockContext
	UsesUnits() IUsesUnitsContext

	// IsInterfaceSectionContext differentiates from other interfaces.
	IsInterfaceSectionContext()
}

type InterfaceSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceSectionContext() *InterfaceSectionContext {
	var p = new(InterfaceSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceSection
	return p
}

func InitEmptyInterfaceSectionContext(p *InterfaceSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceSection
}

func (*InterfaceSectionContext) IsInterfaceSectionContext() {}

func NewInterfaceSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceSectionContext {
	var p = new(InterfaceSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceSection

	return p
}

func (s *InterfaceSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceSectionContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(pascalParserINTERFACE, 0)
}

func (s *InterfaceSectionContext) InterfaceBlock() IInterfaceBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceBlockContext)
}

func (s *InterfaceSectionContext) UsesUnits() IUsesUnitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsesUnitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsesUnitsContext)
}

func (s *InterfaceSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceSection(s)
	}
}

func (s *InterfaceSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceSection(s)
	}
}

func (s *InterfaceSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceSection() (localctx IInterfaceSectionContext) {
	localctx = NewInterfaceSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, pascalParserRULE_interfaceSection)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(374)
		p.Match(pascalParserINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserUSES {
		{
			p.SetState(375)
			p.UsesUnits()
		}

	}
	{
		p.SetState(378)
		p.InterfaceBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImplementationSectionContext is an interface to support dynamic dispatch.
type IImplementationSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPLEMENTATION() antlr.TerminalNode
	ImplementationBlock() IImplementationBlockContext
	UsesUnits() IUsesUnitsContext

	// IsImplementationSectionContext differentiates from other interfaces.
	IsImplementationSectionContext()
}

type ImplementationSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplementationSectionContext() *ImplementationSectionContext {
	var p = new(ImplementationSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_implementationSection
	return p
}

func InitEmptyImplementationSectionContext(p *ImplementationSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_implementationSection
}

func (*ImplementationSectionContext) IsImplementationSectionContext() {}

func NewImplementationSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplementationSectionContext {
	var p = new(ImplementationSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_implementationSection

	return p
}

func (s *ImplementationSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplementationSectionContext) IMPLEMENTATION() antlr.TerminalNode {
	return s.GetToken(pascalParserIMPLEMENTATION, 0)
}

func (s *ImplementationSectionContext) ImplementationBlock() IImplementationBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplementationBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplementationBlockContext)
}

func (s *ImplementationSectionContext) UsesUnits() IUsesUnitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsesUnitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsesUnitsContext)
}

func (s *ImplementationSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplementationSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplementationSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterImplementationSection(s)
	}
}

func (s *ImplementationSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitImplementationSection(s)
	}
}

func (s *ImplementationSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitImplementationSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ImplementationSection() (localctx IImplementationSectionContext) {
	localctx = NewImplementationSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, pascalParserRULE_implementationSection)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(380)
		p.Match(pascalParserIMPLEMENTATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(382)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserUSES {
		{
			p.SetState(381)
			p.UsesUnits()
		}

	}
	{
		p.SetState(384)
		p.ImplementationBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitializationSectionContext is an interface to support dynamic dispatch.
type IInitializationSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INITIALIZATION() antlr.TerminalNode
	Statements() IStatementsContext

	// IsInitializationSectionContext differentiates from other interfaces.
	IsInitializationSectionContext()
}

type InitializationSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializationSectionContext() *InitializationSectionContext {
	var p = new(InitializationSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_initializationSection
	return p
}

func InitEmptyInitializationSectionContext(p *InitializationSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_initializationSection
}

func (*InitializationSectionContext) IsInitializationSectionContext() {}

func NewInitializationSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializationSectionContext {
	var p = new(InitializationSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_initializationSection

	return p
}

func (s *InitializationSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializationSectionContext) INITIALIZATION() antlr.TerminalNode {
	return s.GetToken(pascalParserINITIALIZATION, 0)
}

func (s *InitializationSectionContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *InitializationSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializationSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializationSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInitializationSection(s)
	}
}

func (s *InitializationSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInitializationSection(s)
	}
}

func (s *InitializationSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInitializationSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InitializationSection() (localctx IInitializationSectionContext) {
	localctx = NewInitializationSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, pascalParserRULE_initializationSection)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(386)
		p.Match(pascalParserINITIALIZATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(387)
		p.Statements()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFinalizationSectionContext is an interface to support dynamic dispatch.
type IFinalizationSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FINALIZATION() antlr.TerminalNode
	Statements() IStatementsContext

	// IsFinalizationSectionContext differentiates from other interfaces.
	IsFinalizationSectionContext()
}

type FinalizationSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinalizationSectionContext() *FinalizationSectionContext {
	var p = new(FinalizationSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_finalizationSection
	return p
}

func InitEmptyFinalizationSectionContext(p *FinalizationSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_finalizationSection
}

func (*FinalizationSectionContext) IsFinalizationSectionContext() {}

func NewFinalizationSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinalizationSectionContext {
	var p = new(FinalizationSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_finalizationSection

	return p
}

func (s *FinalizationSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *FinalizationSectionContext) FINALIZATION() antlr.TerminalNode {
	return s.GetToken(pascalParserFINALIZATION, 0)
}

func (s *FinalizationSectionContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *FinalizationSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinalizationSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinalizationSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFinalizationSection(s)
	}
}

func (s *FinalizationSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFinalizationSection(s)
	}
}

func (s *FinalizationSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFinalizationSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FinalizationSection() (localctx IFinalizationSectionContext) {
	localctx = NewFinalizationSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, pascalParserRULE_finalizationSection)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(389)
		p.Match(pascalParserFINALIZATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(390)
		p.Statements()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierPart() []IIdentifierPartContext
	IdentifierPart(i int) IIdentifierPartContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) AllIdentifierPart() []IIdentifierPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierPartContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierPartContext); ok {
			tst[i] = t.(IIdentifierPartContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierContext) IdentifierPart(i int) IIdentifierPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierPartContext)
}

func (s *IdentifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDOT)
}

func (s *IdentifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, i)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, pascalParserRULE_identifier)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(392)
		p.IdentifierPart()
	}
	p.SetState(397)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(393)
				p.Match(pascalParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(394)
				p.IdentifierPart()
			}

		}
		p.SetState(399)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierPartContext is an interface to support dynamic dispatch.
type IIdentifierPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENT() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	READ() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	GenericTemplate() IGenericTemplateContext

	// IsIdentifierPartContext differentiates from other interfaces.
	IsIdentifierPartContext()
}

type IdentifierPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierPartContext() *IdentifierPartContext {
	var p = new(IdentifierPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifierPart
	return p
}

func InitEmptyIdentifierPartContext(p *IdentifierPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifierPart
}

func (*IdentifierPartContext) IsIdentifierPartContext() {}

func NewIdentifierPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierPartContext {
	var p = new(IdentifierPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_identifierPart

	return p
}

func (s *IdentifierPartContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierPartContext) IDENT() antlr.TerminalNode {
	return s.GetToken(pascalParserIDENT, 0)
}

func (s *IdentifierPartContext) INDEX() antlr.TerminalNode {
	return s.GetToken(pascalParserINDEX, 0)
}

func (s *IdentifierPartContext) READ() antlr.TerminalNode {
	return s.GetToken(pascalParserREAD, 0)
}

func (s *IdentifierPartContext) WRITE() antlr.TerminalNode {
	return s.GetToken(pascalParserWRITE, 0)
}

func (s *IdentifierPartContext) GenericTemplate() IGenericTemplateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericTemplateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericTemplateContext)
}

func (s *IdentifierPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterIdentifierPart(s)
	}
}

func (s *IdentifierPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitIdentifierPart(s)
	}
}

func (s *IdentifierPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitIdentifierPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) IdentifierPart() (localctx IIdentifierPartContext) {
	localctx = NewIdentifierPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, pascalParserRULE_identifierPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(400)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-85)) & ^0x3f) == 0 && ((int64(1)<<(_la-85))&137438953483) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(402)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(401)
			p.GenericTemplate()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceBlockContext is an interface to support dynamic dispatch.
type IInterfaceBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLabelDeclarationPart() []ILabelDeclarationPartContext
	LabelDeclarationPart(i int) ILabelDeclarationPartContext
	AllConstantDefinitionPart() []IConstantDefinitionPartContext
	ConstantDefinitionPart(i int) IConstantDefinitionPartContext
	AllResourceDefinitionPart() []IResourceDefinitionPartContext
	ResourceDefinitionPart(i int) IResourceDefinitionPartContext
	AllTypeDefinitionPart() []ITypeDefinitionPartContext
	TypeDefinitionPart(i int) ITypeDefinitionPartContext
	AllVariableDeclarationPart() []IVariableDeclarationPartContext
	VariableDeclarationPart(i int) IVariableDeclarationPartContext
	AllProcedureOrFunctionHeader() []IProcedureOrFunctionHeaderContext
	ProcedureOrFunctionHeader(i int) IProcedureOrFunctionHeaderContext

	// IsInterfaceBlockContext differentiates from other interfaces.
	IsInterfaceBlockContext()
}

type InterfaceBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceBlockContext() *InterfaceBlockContext {
	var p = new(InterfaceBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceBlock
	return p
}

func InitEmptyInterfaceBlockContext(p *InterfaceBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceBlock
}

func (*InterfaceBlockContext) IsInterfaceBlockContext() {}

func NewInterfaceBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceBlockContext {
	var p = new(InterfaceBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceBlock

	return p
}

func (s *InterfaceBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceBlockContext) AllLabelDeclarationPart() []ILabelDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]ILabelDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelDeclarationPartContext); ok {
			tst[i] = t.(ILabelDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) LabelDeclarationPart(i int) ILabelDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelDeclarationPartContext)
}

func (s *InterfaceBlockContext) AllConstantDefinitionPart() []IConstantDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IConstantDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantDefinitionPartContext); ok {
			tst[i] = t.(IConstantDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) ConstantDefinitionPart(i int) IConstantDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *InterfaceBlockContext) AllResourceDefinitionPart() []IResourceDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResourceDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IResourceDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResourceDefinitionPartContext); ok {
			tst[i] = t.(IResourceDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) ResourceDefinitionPart(i int) IResourceDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceDefinitionPartContext)
}

func (s *InterfaceBlockContext) AllTypeDefinitionPart() []ITypeDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]ITypeDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeDefinitionPartContext); ok {
			tst[i] = t.(ITypeDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) TypeDefinitionPart(i int) ITypeDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionPartContext)
}

func (s *InterfaceBlockContext) AllVariableDeclarationPart() []IVariableDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationPartContext); ok {
			tst[i] = t.(IVariableDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) VariableDeclarationPart(i int) IVariableDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationPartContext)
}

func (s *InterfaceBlockContext) AllProcedureOrFunctionHeader() []IProcedureOrFunctionHeaderContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			len++
		}
	}

	tst := make([]IProcedureOrFunctionHeaderContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			tst[i] = t.(IProcedureOrFunctionHeaderContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) ProcedureOrFunctionHeader(i int) IProcedureOrFunctionHeaderContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderContext)
}

func (s *InterfaceBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceBlock(s)
	}
}

func (s *InterfaceBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceBlock(s)
	}
}

func (s *InterfaceBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceBlock() (localctx IInterfaceBlockContext) {
	localctx = NewInterfaceBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, pascalParserRULE_interfaceBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(412)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1152924254468178432) != 0) || ((int64((_la-77)) & ^0x3f) == 0 && ((int64(1)<<(_la-77))&3758096385) != 0) {
		p.SetState(410)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case pascalParserLABEL:
			{
				p.SetState(404)
				p.LabelDeclarationPart()
			}

		case pascalParserCONST:
			{
				p.SetState(405)
				p.ConstantDefinitionPart()
			}

		case pascalParserRESOURCESTRING:
			{
				p.SetState(406)
				p.ResourceDefinitionPart()
			}

		case pascalParserTYPE:
			{
				p.SetState(407)
				p.TypeDefinitionPart()
			}

		case pascalParserVAR:
			{
				p.SetState(408)
				p.VariableDeclarationPart()
			}

		case pascalParserFUNCTION, pascalParserPROCEDURE, pascalParserLBRACK, pascalParserCLASS, pascalParserCONSTRUCTOR, pascalParserDESTRUCTOR:
			{
				p.SetState(409)
				p.ProcedureOrFunctionHeader()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(414)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImplementationBlockContext is an interface to support dynamic dispatch.
type IImplementationBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLabelDeclarationPart() []ILabelDeclarationPartContext
	LabelDeclarationPart(i int) ILabelDeclarationPartContext
	AllConstantDefinitionPart() []IConstantDefinitionPartContext
	ConstantDefinitionPart(i int) IConstantDefinitionPartContext
	AllResourceDefinitionPart() []IResourceDefinitionPartContext
	ResourceDefinitionPart(i int) IResourceDefinitionPartContext
	AllTypeDefinitionPart() []ITypeDefinitionPartContext
	TypeDefinitionPart(i int) ITypeDefinitionPartContext
	AllVariableDeclarationPart() []IVariableDeclarationPartContext
	VariableDeclarationPart(i int) IVariableDeclarationPartContext
	AllProcedureOrFunctionDeclaration() []IProcedureOrFunctionDeclarationContext
	ProcedureOrFunctionDeclaration(i int) IProcedureOrFunctionDeclarationContext
	AllProcedureOrFunctionHeader() []IProcedureOrFunctionHeaderContext
	ProcedureOrFunctionHeader(i int) IProcedureOrFunctionHeaderContext
	AllFORWARD() []antlr.TerminalNode
	FORWARD(i int) antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AllClassOperatorDeclaration() []IClassOperatorDeclarationContext
	ClassOperatorDeclaration(i int) IClassOperatorDeclarationContext

	// IsImplementationBlockContext differentiates from other interfaces.
	IsImplementationBlockContext()
}

type ImplementationBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplementationBlockContext() *ImplementationBlockContext {
	var p = new(ImplementationBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_implementationBlock
	return p
}

func InitEmptyImplementationBlockContext(p *ImplementationBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_implementationBlock
}

func (*ImplementationBlockContext) IsImplementationBlockContext() {}

func NewImplementationBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplementationBlockContext {
	var p = new(ImplementationBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_implementationBlock

	return p
}

func (s *ImplementationBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplementationBlockContext) AllLabelDeclarationPart() []ILabelDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]ILabelDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelDeclarationPartContext); ok {
			tst[i] = t.(ILabelDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) LabelDeclarationPart(i int) ILabelDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelDeclarationPartContext)
}

func (s *ImplementationBlockContext) AllConstantDefinitionPart() []IConstantDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IConstantDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantDefinitionPartContext); ok {
			tst[i] = t.(IConstantDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) ConstantDefinitionPart(i int) IConstantDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *ImplementationBlockContext) AllResourceDefinitionPart() []IResourceDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResourceDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IResourceDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResourceDefinitionPartContext); ok {
			tst[i] = t.(IResourceDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) ResourceDefinitionPart(i int) IResourceDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceDefinitionPartContext)
}

func (s *ImplementationBlockContext) AllTypeDefinitionPart() []ITypeDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]ITypeDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeDefinitionPartContext); ok {
			tst[i] = t.(ITypeDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) TypeDefinitionPart(i int) ITypeDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionPartContext)
}

func (s *ImplementationBlockContext) AllVariableDeclarationPart() []IVariableDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationPartContext); ok {
			tst[i] = t.(IVariableDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) VariableDeclarationPart(i int) IVariableDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationPartContext)
}

func (s *ImplementationBlockContext) AllProcedureOrFunctionDeclaration() []IProcedureOrFunctionDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IProcedureOrFunctionDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			tst[i] = t.(IProcedureOrFunctionDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) ProcedureOrFunctionDeclaration(i int) IProcedureOrFunctionDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionDeclarationContext)
}

func (s *ImplementationBlockContext) AllProcedureOrFunctionHeader() []IProcedureOrFunctionHeaderContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			len++
		}
	}

	tst := make([]IProcedureOrFunctionHeaderContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			tst[i] = t.(IProcedureOrFunctionHeaderContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) ProcedureOrFunctionHeader(i int) IProcedureOrFunctionHeaderContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderContext)
}

func (s *ImplementationBlockContext) AllFORWARD() []antlr.TerminalNode {
	return s.GetTokens(pascalParserFORWARD)
}

func (s *ImplementationBlockContext) FORWARD(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserFORWARD, i)
}

func (s *ImplementationBlockContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ImplementationBlockContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ImplementationBlockContext) AllClassOperatorDeclaration() []IClassOperatorDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassOperatorDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassOperatorDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassOperatorDeclarationContext); ok {
			tst[i] = t.(IClassOperatorDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) ClassOperatorDeclaration(i int) IClassOperatorDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOperatorDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOperatorDeclarationContext)
}

func (s *ImplementationBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplementationBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplementationBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterImplementationBlock(s)
	}
}

func (s *ImplementationBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitImplementationBlock(s)
	}
}

func (s *ImplementationBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitImplementationBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ImplementationBlock() (localctx IImplementationBlockContext) {
	localctx = NewImplementationBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, pascalParserRULE_implementationBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(428)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1152924254468178432) != 0) || ((int64((_la-77)) & ^0x3f) == 0 && ((int64(1)<<(_la-77))&3758096385) != 0) {
		p.SetState(426)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(415)
				p.LabelDeclarationPart()
			}

		case 2:
			{
				p.SetState(416)
				p.ConstantDefinitionPart()
			}

		case 3:
			{
				p.SetState(417)
				p.ResourceDefinitionPart()
			}

		case 4:
			{
				p.SetState(418)
				p.TypeDefinitionPart()
			}

		case 5:
			{
				p.SetState(419)
				p.VariableDeclarationPart()
			}

		case 6:
			{
				p.SetState(420)
				p.ProcedureOrFunctionDeclaration()
			}

		case 7:
			{
				p.SetState(421)
				p.ProcedureOrFunctionHeader()
			}
			{
				p.SetState(422)
				p.Match(pascalParserFORWARD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(423)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 8:
			{
				p.SetState(425)
				p.ClassOperatorDeclaration()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(430)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLabelDeclarationPart() []ILabelDeclarationPartContext
	LabelDeclarationPart(i int) ILabelDeclarationPartContext
	AllConstantDefinitionPart() []IConstantDefinitionPartContext
	ConstantDefinitionPart(i int) IConstantDefinitionPartContext
	AllVariableDeclarationPart() []IVariableDeclarationPartContext
	VariableDeclarationPart(i int) IVariableDeclarationPartContext
	AllProcedureOrFunctionDeclaration() []IProcedureOrFunctionDeclarationContext
	ProcedureOrFunctionDeclaration(i int) IProcedureOrFunctionDeclarationContext
	AllClassOperatorDeclaration() []IClassOperatorDeclarationContext
	ClassOperatorDeclaration(i int) IClassOperatorDeclarationContext

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) AllLabelDeclarationPart() []ILabelDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]ILabelDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelDeclarationPartContext); ok {
			tst[i] = t.(ILabelDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) LabelDeclarationPart(i int) ILabelDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelDeclarationPartContext)
}

func (s *BlockContext) AllConstantDefinitionPart() []IConstantDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IConstantDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantDefinitionPartContext); ok {
			tst[i] = t.(IConstantDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) ConstantDefinitionPart(i int) IConstantDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *BlockContext) AllVariableDeclarationPart() []IVariableDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationPartContext); ok {
			tst[i] = t.(IVariableDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) VariableDeclarationPart(i int) IVariableDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationPartContext)
}

func (s *BlockContext) AllProcedureOrFunctionDeclaration() []IProcedureOrFunctionDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IProcedureOrFunctionDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			tst[i] = t.(IProcedureOrFunctionDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) ProcedureOrFunctionDeclaration(i int) IProcedureOrFunctionDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionDeclarationContext)
}

func (s *BlockContext) AllClassOperatorDeclaration() []IClassOperatorDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassOperatorDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassOperatorDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassOperatorDeclarationContext); ok {
			tst[i] = t.(IClassOperatorDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) ClassOperatorDeclaration(i int) IClassOperatorDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOperatorDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOperatorDeclarationContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (s *BlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, pascalParserRULE_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(438)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1152923704712364544) != 0) || ((int64((_la-77)) & ^0x3f) == 0 && ((int64(1)<<(_la-77))&1610612737) != 0) {
		p.SetState(436)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(431)
				p.LabelDeclarationPart()
			}

		case 2:
			{
				p.SetState(432)
				p.ConstantDefinitionPart()
			}

		case 3:
			{
				p.SetState(433)
				p.VariableDeclarationPart()
			}

		case 4:
			{
				p.SetState(434)
				p.ProcedureOrFunctionDeclaration()
			}

		case 5:
			{
				p.SetState(435)
				p.ClassOperatorDeclaration()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(440)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsesUnitsContext is an interface to support dynamic dispatch.
type IUsesUnitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USES() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	SEMI() antlr.TerminalNode

	// IsUsesUnitsContext differentiates from other interfaces.
	IsUsesUnitsContext()
}

type UsesUnitsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsesUnitsContext() *UsesUnitsContext {
	var p = new(UsesUnitsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_usesUnits
	return p
}

func InitEmptyUsesUnitsContext(p *UsesUnitsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_usesUnits
}

func (*UsesUnitsContext) IsUsesUnitsContext() {}

func NewUsesUnitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsesUnitsContext {
	var p = new(UsesUnitsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_usesUnits

	return p
}

func (s *UsesUnitsContext) GetParser() antlr.Parser { return s.parser }

func (s *UsesUnitsContext) USES() antlr.TerminalNode {
	return s.GetToken(pascalParserUSES, 0)
}

func (s *UsesUnitsContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *UsesUnitsContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *UsesUnitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsesUnitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsesUnitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUsesUnits(s)
	}
}

func (s *UsesUnitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUsesUnits(s)
	}
}

func (s *UsesUnitsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUsesUnits(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UsesUnits() (localctx IUsesUnitsContext) {
	localctx = NewUsesUnitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, pascalParserRULE_usesUnits)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(441)
		p.Match(pascalParserUSES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(442)
		p.IdentifierList()
	}
	{
		p.SetState(443)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelDeclarationPartContext is an interface to support dynamic dispatch.
type ILabelDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LABEL() antlr.TerminalNode
	AllLabel() []ILabelContext
	Label(i int) ILabelContext
	SEMI() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLabelDeclarationPartContext differentiates from other interfaces.
	IsLabelDeclarationPartContext()
}

type LabelDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelDeclarationPartContext() *LabelDeclarationPartContext {
	var p = new(LabelDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_labelDeclarationPart
	return p
}

func InitEmptyLabelDeclarationPartContext(p *LabelDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_labelDeclarationPart
}

func (*LabelDeclarationPartContext) IsLabelDeclarationPartContext() {}

func NewLabelDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelDeclarationPartContext {
	var p = new(LabelDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_labelDeclarationPart

	return p
}

func (s *LabelDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelDeclarationPartContext) LABEL() antlr.TerminalNode {
	return s.GetToken(pascalParserLABEL, 0)
}

func (s *LabelDeclarationPartContext) AllLabel() []ILabelContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelContext); ok {
			len++
		}
	}

	tst := make([]ILabelContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelContext); ok {
			tst[i] = t.(ILabelContext)
			i++
		}
	}

	return tst
}

func (s *LabelDeclarationPartContext) Label(i int) ILabelContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *LabelDeclarationPartContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *LabelDeclarationPartContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *LabelDeclarationPartContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *LabelDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterLabelDeclarationPart(s)
	}
}

func (s *LabelDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitLabelDeclarationPart(s)
	}
}

func (s *LabelDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitLabelDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) LabelDeclarationPart() (localctx ILabelDeclarationPartContext) {
	localctx = NewLabelDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, pascalParserRULE_labelDeclarationPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(445)
		p.Match(pascalParserLABEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(446)
		p.Label()
	}
	p.SetState(451)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(447)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(448)
			p.Label()
		}

		p.SetState(453)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(454)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelContext is an interface to support dynamic dispatch.
type ILabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedInteger() IUnsignedIntegerContext

	// IsLabelContext differentiates from other interfaces.
	IsLabelContext()
}

type LabelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelContext() *LabelContext {
	var p = new(LabelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_label
	return p
}

func InitEmptyLabelContext(p *LabelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_label
}

func (*LabelContext) IsLabelContext() {}

func NewLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelContext {
	var p = new(LabelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_label

	return p
}

func (s *LabelContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelContext) UnsignedInteger() IUnsignedIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerContext)
}

func (s *LabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterLabel(s)
	}
}

func (s *LabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitLabel(s)
	}
}

func (s *LabelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitLabel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Label() (localctx ILabelContext) {
	localctx = NewLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, pascalParserRULE_label)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(456)
		p.UnsignedInteger()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantDefinitionPartContext is an interface to support dynamic dispatch.
type IConstantDefinitionPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONST() antlr.TerminalNode
	AllConstantDefinition() []IConstantDefinitionContext
	ConstantDefinition(i int) IConstantDefinitionContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsConstantDefinitionPartContext differentiates from other interfaces.
	IsConstantDefinitionPartContext()
}

type ConstantDefinitionPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantDefinitionPartContext() *ConstantDefinitionPartContext {
	var p = new(ConstantDefinitionPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantDefinitionPart
	return p
}

func InitEmptyConstantDefinitionPartContext(p *ConstantDefinitionPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantDefinitionPart
}

func (*ConstantDefinitionPartContext) IsConstantDefinitionPartContext() {}

func NewConstantDefinitionPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantDefinitionPartContext {
	var p = new(ConstantDefinitionPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constantDefinitionPart

	return p
}

func (s *ConstantDefinitionPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantDefinitionPartContext) CONST() antlr.TerminalNode {
	return s.GetToken(pascalParserCONST, 0)
}

func (s *ConstantDefinitionPartContext) AllConstantDefinition() []IConstantDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IConstantDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantDefinitionContext); ok {
			tst[i] = t.(IConstantDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *ConstantDefinitionPartContext) ConstantDefinition(i int) IConstantDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionContext)
}

func (s *ConstantDefinitionPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ConstantDefinitionPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ConstantDefinitionPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantDefinitionPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantDefinitionPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstantDefinitionPart(s)
	}
}

func (s *ConstantDefinitionPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstantDefinitionPart(s)
	}
}

func (s *ConstantDefinitionPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstantDefinitionPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConstantDefinitionPart() (localctx IConstantDefinitionPartContext) {
	localctx = NewConstantDefinitionPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, pascalParserRULE_constantDefinitionPart)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(458)
		p.Match(pascalParserCONST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(462)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(459)
				p.ConstantDefinition()
			}
			{
				p.SetState(460)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(464)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantDefinitionContext is an interface to support dynamic dispatch.
type IConstantDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQUAL() antlr.TerminalNode
	Constant() IConstantContext
	COLON() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	ArrayType() IArrayTypeContext

	// IsConstantDefinitionContext differentiates from other interfaces.
	IsConstantDefinitionContext()
}

type ConstantDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantDefinitionContext() *ConstantDefinitionContext {
	var p = new(ConstantDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantDefinition
	return p
}

func InitEmptyConstantDefinitionContext(p *ConstantDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantDefinition
}

func (*ConstantDefinitionContext) IsConstantDefinitionContext() {}

func NewConstantDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantDefinitionContext {
	var p = new(ConstantDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constantDefinition

	return p
}

func (s *ConstantDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConstantDefinitionContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *ConstantDefinitionContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantDefinitionContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *ConstantDefinitionContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ConstantDefinitionContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *ConstantDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstantDefinition(s)
	}
}

func (s *ConstantDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstantDefinition(s)
	}
}

func (s *ConstantDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstantDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConstantDefinition() (localctx IConstantDefinitionContext) {
	localctx = NewConstantDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, pascalParserRULE_constantDefinition)
	var _la int

	p.SetState(480)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(466)
			p.Identifier()
		}
		p.SetState(469)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserCOLON {
			{
				p.SetState(467)
				p.Match(pascalParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(468)
				p.TypeIdentifier()
			}

		}
		{
			p.SetState(471)
			p.Match(pascalParserEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(472)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(474)
			p.Identifier()
		}
		{
			p.SetState(475)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(476)
			p.ArrayType()
		}
		{
			p.SetState(477)
			p.Match(pascalParserEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(478)
			p.Constant()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantChrContext is an interface to support dynamic dispatch.
type IConstantChrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHR() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	UnsignedInteger() IUnsignedIntegerContext
	RPAREN() antlr.TerminalNode

	// IsConstantChrContext differentiates from other interfaces.
	IsConstantChrContext()
}

type ConstantChrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantChrContext() *ConstantChrContext {
	var p = new(ConstantChrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantChr
	return p
}

func InitEmptyConstantChrContext(p *ConstantChrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantChr
}

func (*ConstantChrContext) IsConstantChrContext() {}

func NewConstantChrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantChrContext {
	var p = new(ConstantChrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constantChr

	return p
}

func (s *ConstantChrContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantChrContext) CHR() antlr.TerminalNode {
	return s.GetToken(pascalParserCHR, 0)
}

func (s *ConstantChrContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ConstantChrContext) UnsignedInteger() IUnsignedIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerContext)
}

func (s *ConstantChrContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ConstantChrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantChrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantChrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstantChr(s)
	}
}

func (s *ConstantChrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstantChr(s)
	}
}

func (s *ConstantChrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstantChr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConstantChr() (localctx IConstantChrContext) {
	localctx = NewConstantChrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, pascalParserRULE_constantChr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(482)
		p.Match(pascalParserCHR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(483)
		p.Match(pascalParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(484)
		p.UnsignedInteger()
	}
	{
		p.SetState(485)
		p.Match(pascalParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHexConstantContext is an interface to support dynamic dispatch.
type IHexConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HEX_LITERAL() antlr.TerminalNode

	// IsHexConstantContext differentiates from other interfaces.
	IsHexConstantContext()
}

type HexConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexConstantContext() *HexConstantContext {
	var p = new(HexConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_hexConstant
	return p
}

func InitEmptyHexConstantContext(p *HexConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_hexConstant
}

func (*HexConstantContext) IsHexConstantContext() {}

func NewHexConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexConstantContext {
	var p = new(HexConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_hexConstant

	return p
}

func (s *HexConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *HexConstantContext) HEX_LITERAL() antlr.TerminalNode {
	return s.GetToken(pascalParserHEX_LITERAL, 0)
}

func (s *HexConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterHexConstant(s)
	}
}

func (s *HexConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitHexConstant(s)
	}
}

func (s *HexConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitHexConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) HexConstant() (localctx IHexConstantContext) {
	localctx = NewHexConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, pascalParserRULE_hexConstant)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(487)
		p.Match(pascalParserHEX_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedNumber() IUnsignedNumberContext
	Sign() ISignContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	String_() IStringContext
	ConstantChr() IConstantChrContext
	ScalarType() IScalarTypeContext
	AllArrayConstant() []IArrayConstantContext
	ArrayConstant(i int) IArrayConstantContext
	AllPLUS() []antlr.TerminalNode
	PLUS(i int) antlr.TerminalNode

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constant
	return p
}

func InitEmptyConstantContext(p *ConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constant
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) UnsignedNumber() IUnsignedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedNumberContext)
}

func (s *ConstantContext) Sign() ISignContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignContext)
}

func (s *ConstantContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ConstantContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConstantContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ConstantContext) ConstantChr() IConstantChrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantChrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantChrContext)
}

func (s *ConstantContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ConstantContext) AllArrayConstant() []IArrayConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayConstantContext); ok {
			len++
		}
	}

	tst := make([]IArrayConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayConstantContext); ok {
			tst[i] = t.(IArrayConstantContext)
			i++
		}
	}

	return tst
}

func (s *ConstantContext) ArrayConstant(i int) IArrayConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayConstantContext)
}

func (s *ConstantContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPLUS)
}

func (s *ConstantContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPLUS, i)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstant(s)
	}
}

func (s *ConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, pascalParserRULE_constant)
	var _la int

	p.SetState(511)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(489)
			p.UnsignedNumber()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(490)
			p.Sign()
		}
		{
			p.SetState(491)
			p.UnsignedNumber()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(493)
			p.Identifier()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(494)
			p.Sign()
		}
		{
			p.SetState(495)
			p.Identifier()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(497)
			p.String_()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(498)
			p.ConstantChr()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(499)
			p.ScalarType()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(500)
			p.ArrayConstant()
		}
		p.SetState(508)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == pascalParserPLUS {
			{
				p.SetState(501)
				p.Match(pascalParserPLUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(504)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case pascalParserLBRACK:
				{
					p.SetState(502)
					p.ArrayConstant()
				}

			case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
				{
					p.SetState(503)
					p.Identifier()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(510)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayConstantContext is an interface to support dynamic dispatch.
type IArrayConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	RBRACK() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsArrayConstantContext differentiates from other interfaces.
	IsArrayConstantContext()
}

type ArrayConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayConstantContext() *ArrayConstantContext {
	var p = new(ArrayConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_arrayConstant
	return p
}

func InitEmptyArrayConstantContext(p *ArrayConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_arrayConstant
}

func (*ArrayConstantContext) IsArrayConstantContext() {}

func NewArrayConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayConstantContext {
	var p = new(ArrayConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_arrayConstant

	return p
}

func (s *ArrayConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayConstantContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *ArrayConstantContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *ArrayConstantContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ArrayConstantContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *ArrayConstantContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ArrayConstantContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ArrayConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterArrayConstant(s)
	}
}

func (s *ArrayConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitArrayConstant(s)
	}
}

func (s *ArrayConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitArrayConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ArrayConstant() (localctx IArrayConstantContext) {
	localctx = NewArrayConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, pascalParserRULE_arrayConstant)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(513)
		p.Match(pascalParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(514)
		p.Constant()
	}
	p.SetState(519)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(515)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(516)
			p.Constant()
		}

		p.SetState(521)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(522)
		p.Match(pascalParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedNumberContext is an interface to support dynamic dispatch.
type IUnsignedNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedInteger() IUnsignedIntegerContext
	UnsignedReal() IUnsignedRealContext

	// IsUnsignedNumberContext differentiates from other interfaces.
	IsUnsignedNumberContext()
}

type UnsignedNumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedNumberContext() *UnsignedNumberContext {
	var p = new(UnsignedNumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedNumber
	return p
}

func InitEmptyUnsignedNumberContext(p *UnsignedNumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedNumber
}

func (*UnsignedNumberContext) IsUnsignedNumberContext() {}

func NewUnsignedNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedNumberContext {
	var p = new(UnsignedNumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unsignedNumber

	return p
}

func (s *UnsignedNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedNumberContext) UnsignedInteger() IUnsignedIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerContext)
}

func (s *UnsignedNumberContext) UnsignedReal() IUnsignedRealContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedRealContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedRealContext)
}

func (s *UnsignedNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnsignedNumber(s)
	}
}

func (s *UnsignedNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnsignedNumber(s)
	}
}

func (s *UnsignedNumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnsignedNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnsignedNumber() (localctx IUnsignedNumberContext) {
	localctx = NewUnsignedNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, pascalParserRULE_unsignedNumber)
	p.SetState(526)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserNUM_INT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(524)
			p.UnsignedInteger()
		}

	case pascalParserNUM_REAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(525)
			p.UnsignedReal()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedIntegerContext is an interface to support dynamic dispatch.
type IUnsignedIntegerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUM_INT() antlr.TerminalNode

	// IsUnsignedIntegerContext differentiates from other interfaces.
	IsUnsignedIntegerContext()
}

type UnsignedIntegerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedIntegerContext() *UnsignedIntegerContext {
	var p = new(UnsignedIntegerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedInteger
	return p
}

func InitEmptyUnsignedIntegerContext(p *UnsignedIntegerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedInteger
}

func (*UnsignedIntegerContext) IsUnsignedIntegerContext() {}

func NewUnsignedIntegerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedIntegerContext {
	var p = new(UnsignedIntegerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unsignedInteger

	return p
}

func (s *UnsignedIntegerContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedIntegerContext) NUM_INT() antlr.TerminalNode {
	return s.GetToken(pascalParserNUM_INT, 0)
}

func (s *UnsignedIntegerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedIntegerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedIntegerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnsignedInteger(s)
	}
}

func (s *UnsignedIntegerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnsignedInteger(s)
	}
}

func (s *UnsignedIntegerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnsignedInteger(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnsignedInteger() (localctx IUnsignedIntegerContext) {
	localctx = NewUnsignedIntegerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, pascalParserRULE_unsignedInteger)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(528)
		p.Match(pascalParserNUM_INT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedRealContext is an interface to support dynamic dispatch.
type IUnsignedRealContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUM_REAL() antlr.TerminalNode

	// IsUnsignedRealContext differentiates from other interfaces.
	IsUnsignedRealContext()
}

type UnsignedRealContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedRealContext() *UnsignedRealContext {
	var p = new(UnsignedRealContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedReal
	return p
}

func InitEmptyUnsignedRealContext(p *UnsignedRealContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedReal
}

func (*UnsignedRealContext) IsUnsignedRealContext() {}

func NewUnsignedRealContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedRealContext {
	var p = new(UnsignedRealContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unsignedReal

	return p
}

func (s *UnsignedRealContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedRealContext) NUM_REAL() antlr.TerminalNode {
	return s.GetToken(pascalParserNUM_REAL, 0)
}

func (s *UnsignedRealContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedRealContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedRealContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnsignedReal(s)
	}
}

func (s *UnsignedRealContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnsignedReal(s)
	}
}

func (s *UnsignedRealContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnsignedReal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnsignedReal() (localctx IUnsignedRealContext) {
	localctx = NewUnsignedRealContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, pascalParserRULE_unsignedReal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(530)
		p.Match(pascalParserNUM_REAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignContext is an interface to support dynamic dispatch.
type ISignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsSignContext differentiates from other interfaces.
	IsSignContext()
}

type SignContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignContext() *SignContext {
	var p = new(SignContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_sign
	return p
}

func InitEmptySignContext(p *SignContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_sign
}

func (*SignContext) IsSignContext() {}

func NewSignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignContext {
	var p = new(SignContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_sign

	return p
}

func (s *SignContext) GetParser() antlr.Parser { return s.parser }

func (s *SignContext) PLUS() antlr.TerminalNode {
	return s.GetToken(pascalParserPLUS, 0)
}

func (s *SignContext) MINUS() antlr.TerminalNode {
	return s.GetToken(pascalParserMINUS, 0)
}

func (s *SignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSign(s)
	}
}

func (s *SignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSign(s)
	}
}

func (s *SignContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSign(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Sign() (localctx ISignContext) {
	localctx = NewSignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, pascalParserRULE_sign)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(532)
		_la = p.GetTokenStream().LA(1)

		if !(_la == pascalParserPLUS || _la == pascalParserMINUS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_Context is an interface to support dynamic dispatch.
type IBool_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBool_Context differentiates from other interfaces.
	IsBool_Context()
}

type Bool_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_Context() *Bool_Context {
	var p = new(Bool_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_bool_
	return p
}

func InitEmptyBool_Context(p *Bool_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_bool_
}

func (*Bool_Context) IsBool_Context() {}

func NewBool_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_Context {
	var p = new(Bool_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_bool_

	return p
}

func (s *Bool_Context) GetParser() antlr.Parser { return s.parser }

func (s *Bool_Context) TRUE() antlr.TerminalNode {
	return s.GetToken(pascalParserTRUE, 0)
}

func (s *Bool_Context) FALSE() antlr.TerminalNode {
	return s.GetToken(pascalParserFALSE, 0)
}

func (s *Bool_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterBool_(s)
	}
}

func (s *Bool_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitBool_(s)
	}
}

func (s *Bool_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitBool_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Bool_() (localctx IBool_Context) {
	localctx = NewBool_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, pascalParserRULE_bool_)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(534)
		_la = p.GetTokenStream().LA(1)

		if !(_la == pascalParserTRUE || _la == pascalParserFALSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringContext is an interface to support dynamic dispatch.
type IStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	AllSTRING_CROSSHATCH_LITERAL() []antlr.TerminalNode
	STRING_CROSSHATCH_LITERAL(i int) antlr.TerminalNode

	// IsStringContext differentiates from other interfaces.
	IsStringContext()
}

type StringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringContext() *StringContext {
	var p = new(StringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_string
	return p
}

func InitEmptyStringContext(p *StringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_string
}

func (*StringContext) IsStringContext() {}

func NewStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringContext {
	var p = new(StringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_string

	return p
}

func (s *StringContext) GetParser() antlr.Parser { return s.parser }

func (s *StringContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTRING_LITERAL)
}

func (s *StringContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTRING_LITERAL, i)
}

func (s *StringContext) AllSTRING_CROSSHATCH_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTRING_CROSSHATCH_LITERAL)
}

func (s *StringContext) STRING_CROSSHATCH_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTRING_CROSSHATCH_LITERAL, i)
}

func (s *StringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterString(s)
	}
}

func (s *StringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitString(s)
	}
}

func (s *StringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) String_() (localctx IStringContext) {
	localctx = NewStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, pascalParserRULE_string)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(537)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(536)
				_la = p.GetTokenStream().LA(1)

				if !(_la == pascalParserSTRING_LITERAL || _la == pascalParserSTRING_CROSSHATCH_LITERAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(539)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringExpressionContext is an interface to support dynamic dispatch.
type IStringExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllString_() []IStringContext
	String_(i int) IStringContext
	AllPLUS() []antlr.TerminalNode
	PLUS(i int) antlr.TerminalNode

	// IsStringExpressionContext differentiates from other interfaces.
	IsStringExpressionContext()
}

type StringExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringExpressionContext() *StringExpressionContext {
	var p = new(StringExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_stringExpression
	return p
}

func InitEmptyStringExpressionContext(p *StringExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_stringExpression
}

func (*StringExpressionContext) IsStringExpressionContext() {}

func NewStringExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringExpressionContext {
	var p = new(StringExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_stringExpression

	return p
}

func (s *StringExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *StringExpressionContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *StringExpressionContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *StringExpressionContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPLUS)
}

func (s *StringExpressionContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPLUS, i)
}

func (s *StringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStringExpression(s)
	}
}

func (s *StringExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStringExpression(s)
	}
}

func (s *StringExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStringExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) StringExpression() (localctx IStringExpressionContext) {
	localctx = NewStringExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, pascalParserRULE_stringExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(541)
		p.String_()
	}
	p.SetState(546)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserPLUS {
		{
			p.SetState(542)
			p.Match(pascalParserPLUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(543)
			p.String_()
		}

		p.SetState(548)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceDefinitionPartContext is an interface to support dynamic dispatch.
type IResourceDefinitionPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESOURCESTRING() antlr.TerminalNode
	AllResourceDefinition() []IResourceDefinitionContext
	ResourceDefinition(i int) IResourceDefinitionContext

	// IsResourceDefinitionPartContext differentiates from other interfaces.
	IsResourceDefinitionPartContext()
}

type ResourceDefinitionPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceDefinitionPartContext() *ResourceDefinitionPartContext {
	var p = new(ResourceDefinitionPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resourceDefinitionPart
	return p
}

func InitEmptyResourceDefinitionPartContext(p *ResourceDefinitionPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resourceDefinitionPart
}

func (*ResourceDefinitionPartContext) IsResourceDefinitionPartContext() {}

func NewResourceDefinitionPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceDefinitionPartContext {
	var p = new(ResourceDefinitionPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_resourceDefinitionPart

	return p
}

func (s *ResourceDefinitionPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceDefinitionPartContext) RESOURCESTRING() antlr.TerminalNode {
	return s.GetToken(pascalParserRESOURCESTRING, 0)
}

func (s *ResourceDefinitionPartContext) AllResourceDefinition() []IResourceDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResourceDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IResourceDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResourceDefinitionContext); ok {
			tst[i] = t.(IResourceDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *ResourceDefinitionPartContext) ResourceDefinition(i int) IResourceDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceDefinitionContext)
}

func (s *ResourceDefinitionPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceDefinitionPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceDefinitionPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterResourceDefinitionPart(s)
	}
}

func (s *ResourceDefinitionPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitResourceDefinitionPart(s)
	}
}

func (s *ResourceDefinitionPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitResourceDefinitionPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ResourceDefinitionPart() (localctx IResourceDefinitionPartContext) {
	localctx = NewResourceDefinitionPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, pascalParserRULE_resourceDefinitionPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(549)
		p.Match(pascalParserRESOURCESTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(551)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64((_la-85)) & ^0x3f) == 0 && ((int64(1)<<(_la-85))&137438953483) != 0) {
		{
			p.SetState(550)
			p.ResourceDefinition()
		}

		p.SetState(553)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceDefinitionContext is an interface to support dynamic dispatch.
type IResourceDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQUAL() antlr.TerminalNode
	StringExpression() IStringExpressionContext
	SEMI() antlr.TerminalNode

	// IsResourceDefinitionContext differentiates from other interfaces.
	IsResourceDefinitionContext()
}

type ResourceDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceDefinitionContext() *ResourceDefinitionContext {
	var p = new(ResourceDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resourceDefinition
	return p
}

func InitEmptyResourceDefinitionContext(p *ResourceDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resourceDefinition
}

func (*ResourceDefinitionContext) IsResourceDefinitionContext() {}

func NewResourceDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceDefinitionContext {
	var p = new(ResourceDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_resourceDefinition

	return p
}

func (s *ResourceDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ResourceDefinitionContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *ResourceDefinitionContext) StringExpression() IStringExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringExpressionContext)
}

func (s *ResourceDefinitionContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ResourceDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterResourceDefinition(s)
	}
}

func (s *ResourceDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitResourceDefinition(s)
	}
}

func (s *ResourceDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitResourceDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ResourceDefinition() (localctx IResourceDefinitionContext) {
	localctx = NewResourceDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, pascalParserRULE_resourceDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(555)
		p.Identifier()
	}
	{
		p.SetState(556)
		p.Match(pascalParserEQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(557)
		p.StringExpression()
	}
	{
		p.SetState(558)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDefinitionPartContext is an interface to support dynamic dispatch.
type ITypeDefinitionPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE() antlr.TerminalNode
	AllTypeDefinition() []ITypeDefinitionContext
	TypeDefinition(i int) ITypeDefinitionContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsTypeDefinitionPartContext differentiates from other interfaces.
	IsTypeDefinitionPartContext()
}

type TypeDefinitionPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDefinitionPartContext() *TypeDefinitionPartContext {
	var p = new(TypeDefinitionPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeDefinitionPart
	return p
}

func InitEmptyTypeDefinitionPartContext(p *TypeDefinitionPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeDefinitionPart
}

func (*TypeDefinitionPartContext) IsTypeDefinitionPartContext() {}

func NewTypeDefinitionPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDefinitionPartContext {
	var p = new(TypeDefinitionPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typeDefinitionPart

	return p
}

func (s *TypeDefinitionPartContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDefinitionPartContext) TYPE() antlr.TerminalNode {
	return s.GetToken(pascalParserTYPE, 0)
}

func (s *TypeDefinitionPartContext) AllTypeDefinition() []ITypeDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ITypeDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeDefinitionContext); ok {
			tst[i] = t.(ITypeDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *TypeDefinitionPartContext) TypeDefinition(i int) ITypeDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionContext)
}

func (s *TypeDefinitionPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *TypeDefinitionPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *TypeDefinitionPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDefinitionPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDefinitionPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypeDefinitionPart(s)
	}
}

func (s *TypeDefinitionPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypeDefinitionPart(s)
	}
}

func (s *TypeDefinitionPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypeDefinitionPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypeDefinitionPart() (localctx ITypeDefinitionPartContext) {
	localctx = NewTypeDefinitionPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, pascalParserRULE_typeDefinitionPart)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(560)
		p.Match(pascalParserTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(564)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(561)
				p.TypeDefinition()
			}
			{
				p.SetState(562)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(566)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDefinitionContext is an interface to support dynamic dispatch.
type ITypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQUAL() antlr.TerminalNode
	Type_() IType_Context
	FunctionType() IFunctionTypeContext
	ProcedureType() IProcedureTypeContext
	ForwardClassType() IForwardClassTypeContext
	ForwardInterfaceType() IForwardInterfaceTypeContext
	AttributeSection() IAttributeSectionContext

	// IsTypeDefinitionContext differentiates from other interfaces.
	IsTypeDefinitionContext()
}

type TypeDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDefinitionContext() *TypeDefinitionContext {
	var p = new(TypeDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeDefinition
	return p
}

func InitEmptyTypeDefinitionContext(p *TypeDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeDefinition
}

func (*TypeDefinitionContext) IsTypeDefinitionContext() {}

func NewTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDefinitionContext {
	var p = new(TypeDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typeDefinition

	return p
}

func (s *TypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeDefinitionContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *TypeDefinitionContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeDefinitionContext) FunctionType() IFunctionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *TypeDefinitionContext) ProcedureType() IProcedureTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureTypeContext)
}

func (s *TypeDefinitionContext) ForwardClassType() IForwardClassTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForwardClassTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForwardClassTypeContext)
}

func (s *TypeDefinitionContext) ForwardInterfaceType() IForwardInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForwardInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForwardInterfaceTypeContext)
}

func (s *TypeDefinitionContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *TypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypeDefinition(s)
	}
}

func (s *TypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypeDefinition(s)
	}
}

func (s *TypeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypeDefinition() (localctx ITypeDefinitionContext) {
	localctx = NewTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, pascalParserRULE_typeDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(569)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLBRACK {
		{
			p.SetState(568)
			p.AttributeSection()
		}

	}
	{
		p.SetState(571)
		p.Identifier()
	}
	{
		p.SetState(572)
		p.Match(pascalParserEQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(578)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(573)
			p.Type_()
		}

	case 2:
		{
			p.SetState(574)
			p.FunctionType()
		}

	case 3:
		{
			p.SetState(575)
			p.ProcedureType()
		}

	case 4:
		{
			p.SetState(576)
			p.ForwardClassType()
		}

	case 5:
		{
			p.SetState(577)
			p.ForwardInterfaceType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTypeContext is an interface to support dynamic dispatch.
type IFunctionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNCTION() antlr.TerminalNode
	COLON() antlr.TerminalNode
	ResultType() IResultTypeContext
	ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext
	FormalParameterList() IFormalParameterListContext
	OF() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	REFERENCE() antlr.TerminalNode
	TO() antlr.TerminalNode

	// IsFunctionTypeContext differentiates from other interfaces.
	IsFunctionTypeContext()
}

type FunctionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeContext() *FunctionTypeContext {
	var p = new(FunctionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionType
	return p
}

func InitEmptyFunctionTypeContext(p *FunctionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionType
}

func (*FunctionTypeContext) IsFunctionTypeContext() {}

func NewFunctionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeContext {
	var p = new(FunctionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_functionType

	return p
}

func (s *FunctionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(pascalParserFUNCTION, 0)
}

func (s *FunctionTypeContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *FunctionTypeContext) ResultType() IResultTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultTypeContext)
}

func (s *FunctionTypeContext) ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderModifiersContext)
}

func (s *FunctionTypeContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *FunctionTypeContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(pascalParserOBJECT, 0)
}

func (s *FunctionTypeContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(pascalParserREFERENCE, 0)
}

func (s *FunctionTypeContext) TO() antlr.TerminalNode {
	return s.GetToken(pascalParserTO, 0)
}

func (s *FunctionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFunctionType(s)
	}
}

func (s *FunctionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFunctionType(s)
	}
}

func (s *FunctionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFunctionType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FunctionType() (localctx IFunctionTypeContext) {
	localctx = NewFunctionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, pascalParserRULE_functionType)
	var _la int

	p.SetState(602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserFUNCTION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(580)
			p.Match(pascalParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(582)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLPAREN {
			{
				p.SetState(581)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(584)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(585)
			p.ResultType()
		}
		p.SetState(588)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserOF {
			{
				p.SetState(586)
				p.Match(pascalParserOF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(587)
				p.Match(pascalParserOBJECT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(590)
			p.ProcedureOrFunctionHeaderModifiers()
		}

	case pascalParserREFERENCE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(592)
			p.Match(pascalParserREFERENCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(593)
			p.Match(pascalParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(594)
			p.Match(pascalParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(596)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLPAREN {
			{
				p.SetState(595)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(598)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(599)
			p.ResultType()
		}
		{
			p.SetState(600)
			p.ProcedureOrFunctionHeaderModifiers()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureTypeContext is an interface to support dynamic dispatch.
type IProcedureTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROCEDURE() antlr.TerminalNode
	ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext
	FormalParameterList() IFormalParameterListContext
	OF() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	REFERENCE() antlr.TerminalNode
	TO() antlr.TerminalNode

	// IsProcedureTypeContext differentiates from other interfaces.
	IsProcedureTypeContext()
}

type ProcedureTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureTypeContext() *ProcedureTypeContext {
	var p = new(ProcedureTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureType
	return p
}

func InitEmptyProcedureTypeContext(p *ProcedureTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureType
}

func (*ProcedureTypeContext) IsProcedureTypeContext() {}

func NewProcedureTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureTypeContext {
	var p = new(ProcedureTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureType

	return p
}

func (s *ProcedureTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureTypeContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(pascalParserPROCEDURE, 0)
}

func (s *ProcedureTypeContext) ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderModifiersContext)
}

func (s *ProcedureTypeContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ProcedureTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *ProcedureTypeContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(pascalParserOBJECT, 0)
}

func (s *ProcedureTypeContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(pascalParserREFERENCE, 0)
}

func (s *ProcedureTypeContext) TO() antlr.TerminalNode {
	return s.GetToken(pascalParserTO, 0)
}

func (s *ProcedureTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureType(s)
	}
}

func (s *ProcedureTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureType(s)
	}
}

func (s *ProcedureTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureType() (localctx IProcedureTypeContext) {
	localctx = NewProcedureTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, pascalParserRULE_procedureType)
	var _la int

	p.SetState(620)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserPROCEDURE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(604)
			p.Match(pascalParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(606)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLPAREN {
			{
				p.SetState(605)
				p.FormalParameterList()
			}

		}
		p.SetState(610)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserOF {
			{
				p.SetState(608)
				p.Match(pascalParserOF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(609)
				p.Match(pascalParserOBJECT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(612)
			p.ProcedureOrFunctionHeaderModifiers()
		}

	case pascalParserREFERENCE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(613)
			p.Match(pascalParserREFERENCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(614)
			p.Match(pascalParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(615)
			p.Match(pascalParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(617)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLPAREN {
			{
				p.SetState(616)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(619)
			p.ProcedureOrFunctionHeaderModifiers()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForwardClassTypeContext is an interface to support dynamic dispatch.
type IForwardClassTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsForwardClassTypeContext differentiates from other interfaces.
	IsForwardClassTypeContext()
}

type ForwardClassTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForwardClassTypeContext() *ForwardClassTypeContext {
	var p = new(ForwardClassTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forwardClassType
	return p
}

func InitEmptyForwardClassTypeContext(p *ForwardClassTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forwardClassType
}

func (*ForwardClassTypeContext) IsForwardClassTypeContext() {}

func NewForwardClassTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForwardClassTypeContext {
	var p = new(ForwardClassTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_forwardClassType

	return p
}

func (s *ForwardClassTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ForwardClassTypeContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *ForwardClassTypeContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ForwardClassTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForwardClassTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForwardClassTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterForwardClassType(s)
	}
}

func (s *ForwardClassTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitForwardClassType(s)
	}
}

func (s *ForwardClassTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitForwardClassType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ForwardClassType() (localctx IForwardClassTypeContext) {
	localctx = NewForwardClassTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, pascalParserRULE_forwardClassType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(622)
		p.Match(pascalParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(623)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForwardInterfaceTypeContext is an interface to support dynamic dispatch.
type IForwardInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsForwardInterfaceTypeContext differentiates from other interfaces.
	IsForwardInterfaceTypeContext()
}

type ForwardInterfaceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForwardInterfaceTypeContext() *ForwardInterfaceTypeContext {
	var p = new(ForwardInterfaceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forwardInterfaceType
	return p
}

func InitEmptyForwardInterfaceTypeContext(p *ForwardInterfaceTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forwardInterfaceType
}

func (*ForwardInterfaceTypeContext) IsForwardInterfaceTypeContext() {}

func NewForwardInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForwardInterfaceTypeContext {
	var p = new(ForwardInterfaceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_forwardInterfaceType

	return p
}

func (s *ForwardInterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ForwardInterfaceTypeContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(pascalParserINTERFACE, 0)
}

func (s *ForwardInterfaceTypeContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ForwardInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForwardInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForwardInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterForwardInterfaceType(s)
	}
}

func (s *ForwardInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitForwardInterfaceType(s)
	}
}

func (s *ForwardInterfaceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitForwardInterfaceType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ForwardInterfaceType() (localctx IForwardInterfaceTypeContext) {
	localctx = NewForwardInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, pascalParserRULE_forwardInterfaceType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(625)
		p.Match(pascalParserINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(626)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassTypeContext is an interface to support dynamic dispatch.
type IClassTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	ClassImplicitPublishedDeclaration() IClassImplicitPublishedDeclarationContext
	END() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	ClassImplementsInterfaces() IClassImplementsInterfacesContext
	RPAREN() antlr.TerminalNode
	ABSTRACT() antlr.TerminalNode
	AllClassDeclaration() []IClassDeclarationContext
	ClassDeclaration(i int) IClassDeclarationContext

	// IsClassTypeContext differentiates from other interfaces.
	IsClassTypeContext()
}

type ClassTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassTypeContext() *ClassTypeContext {
	var p = new(ClassTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classType
	return p
}

func InitEmptyClassTypeContext(p *ClassTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classType
}

func (*ClassTypeContext) IsClassTypeContext() {}

func NewClassTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassTypeContext {
	var p = new(ClassTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classType

	return p
}

func (s *ClassTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassTypeContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *ClassTypeContext) ClassImplicitPublishedDeclaration() IClassImplicitPublishedDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassImplicitPublishedDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassImplicitPublishedDeclarationContext)
}

func (s *ClassTypeContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *ClassTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ClassTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassTypeContext) ClassImplementsInterfaces() IClassImplementsInterfacesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassImplementsInterfacesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassImplementsInterfacesContext)
}

func (s *ClassTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ClassTypeContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(pascalParserABSTRACT, 0)
}

func (s *ClassTypeContext) AllClassDeclaration() []IClassDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassDeclarationContext); ok {
			tst[i] = t.(IClassDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ClassTypeContext) ClassDeclaration(i int) IClassDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *ClassTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassType(s)
	}
}

func (s *ClassTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassType(s)
	}
}

func (s *ClassTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassType() (localctx IClassTypeContext) {
	localctx = NewClassTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, pascalParserRULE_classType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(628)
		p.Match(pascalParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(634)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(629)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(630)
			p.Identifier()
		}
		{
			p.SetState(631)
			p.ClassImplementsInterfaces()
		}
		{
			p.SetState(632)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(637)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(636)
			p.Match(pascalParserABSTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(639)
		p.ClassImplicitPublishedDeclaration()
	}
	p.SetState(643)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&31) != 0 {
		{
			p.SetState(640)
			p.ClassDeclaration()
		}

		p.SetState(645)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(646)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassImplementsInterfacesContext is an interface to support dynamic dispatch.
type IClassImplementsInterfacesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllTypeIdentifier() []ITypeIdentifierContext
	TypeIdentifier(i int) ITypeIdentifierContext

	// IsClassImplementsInterfacesContext differentiates from other interfaces.
	IsClassImplementsInterfacesContext()
}

type ClassImplementsInterfacesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassImplementsInterfacesContext() *ClassImplementsInterfacesContext {
	var p = new(ClassImplementsInterfacesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classImplementsInterfaces
	return p
}

func InitEmptyClassImplementsInterfacesContext(p *ClassImplementsInterfacesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classImplementsInterfaces
}

func (*ClassImplementsInterfacesContext) IsClassImplementsInterfacesContext() {}

func NewClassImplementsInterfacesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassImplementsInterfacesContext {
	var p = new(ClassImplementsInterfacesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classImplementsInterfaces

	return p
}

func (s *ClassImplementsInterfacesContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassImplementsInterfacesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ClassImplementsInterfacesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ClassImplementsInterfacesContext) AllTypeIdentifier() []ITypeIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			len++
		}
	}

	tst := make([]ITypeIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeIdentifierContext); ok {
			tst[i] = t.(ITypeIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ClassImplementsInterfacesContext) TypeIdentifier(i int) ITypeIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ClassImplementsInterfacesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassImplementsInterfacesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassImplementsInterfacesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassImplementsInterfaces(s)
	}
}

func (s *ClassImplementsInterfacesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassImplementsInterfaces(s)
	}
}

func (s *ClassImplementsInterfacesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassImplementsInterfaces(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassImplementsInterfaces() (localctx IClassImplementsInterfacesContext) {
	localctx = NewClassImplementsInterfacesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, pascalParserRULE_classImplementsInterfaces)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(652)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(648)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(649)
			p.TypeIdentifier()
		}

		p.SetState(654)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAccessSpecifierContext is an interface to support dynamic dispatch.
type IAccessSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRIVATE() antlr.TerminalNode
	STRICT() antlr.TerminalNode
	PROTECTED() antlr.TerminalNode
	PUBLIC() antlr.TerminalNode
	PUBLISHED() antlr.TerminalNode

	// IsAccessSpecifierContext differentiates from other interfaces.
	IsAccessSpecifierContext()
}

type AccessSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccessSpecifierContext() *AccessSpecifierContext {
	var p = new(AccessSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_accessSpecifier
	return p
}

func InitEmptyAccessSpecifierContext(p *AccessSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_accessSpecifier
}

func (*AccessSpecifierContext) IsAccessSpecifierContext() {}

func NewAccessSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccessSpecifierContext {
	var p = new(AccessSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_accessSpecifier

	return p
}

func (s *AccessSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AccessSpecifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(pascalParserPRIVATE, 0)
}

func (s *AccessSpecifierContext) STRICT() antlr.TerminalNode {
	return s.GetToken(pascalParserSTRICT, 0)
}

func (s *AccessSpecifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(pascalParserPROTECTED, 0)
}

func (s *AccessSpecifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLIC, 0)
}

func (s *AccessSpecifierContext) PUBLISHED() antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLISHED, 0)
}

func (s *AccessSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccessSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AccessSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAccessSpecifier(s)
	}
}

func (s *AccessSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAccessSpecifier(s)
	}
}

func (s *AccessSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAccessSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) AccessSpecifier() (localctx IAccessSpecifierContext) {
	localctx = NewAccessSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, pascalParserRULE_accessSpecifier)
	var _la int

	p.SetState(665)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(656)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserSTRICT {
			{
				p.SetState(655)
				p.Match(pascalParserSTRICT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(658)
			p.Match(pascalParserPRIVATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(660)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserSTRICT {
			{
				p.SetState(659)
				p.Match(pascalParserSTRICT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(662)
			p.Match(pascalParserPROTECTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(663)
			p.Match(pascalParserPUBLIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(664)
			p.Match(pascalParserPUBLISHED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AccessSpecifier() IAccessSpecifierContext
	AllClassDeclarationPart() []IClassDeclarationPartContext
	ClassDeclarationPart(i int) IClassDeclarationPartContext

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classDeclaration
	return p
}

func InitEmptyClassDeclarationContext(p *ClassDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classDeclaration
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) AccessSpecifier() IAccessSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessSpecifierContext)
}

func (s *ClassDeclarationContext) AllClassDeclarationPart() []IClassDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IClassDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassDeclarationPartContext); ok {
			tst[i] = t.(IClassDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ClassDeclarationContext) ClassDeclarationPart(i int) IClassDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationPartContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, pascalParserRULE_classDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(667)
		p.AccessSpecifier()
	}
	p.SetState(671)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-8193) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-253953) != 0) {
		{
			p.SetState(668)
			p.ClassDeclarationPart()
		}

		p.SetState(673)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassImplicitPublishedDeclarationContext is an interface to support dynamic dispatch.
type IClassImplicitPublishedDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllClassDeclarationPart() []IClassDeclarationPartContext
	ClassDeclarationPart(i int) IClassDeclarationPartContext

	// IsClassImplicitPublishedDeclarationContext differentiates from other interfaces.
	IsClassImplicitPublishedDeclarationContext()
}

type ClassImplicitPublishedDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassImplicitPublishedDeclarationContext() *ClassImplicitPublishedDeclarationContext {
	var p = new(ClassImplicitPublishedDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classImplicitPublishedDeclaration
	return p
}

func InitEmptyClassImplicitPublishedDeclarationContext(p *ClassImplicitPublishedDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classImplicitPublishedDeclaration
}

func (*ClassImplicitPublishedDeclarationContext) IsClassImplicitPublishedDeclarationContext() {}

func NewClassImplicitPublishedDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassImplicitPublishedDeclarationContext {
	var p = new(ClassImplicitPublishedDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classImplicitPublishedDeclaration

	return p
}

func (s *ClassImplicitPublishedDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassImplicitPublishedDeclarationContext) AllClassDeclarationPart() []IClassDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IClassDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassDeclarationPartContext); ok {
			tst[i] = t.(IClassDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ClassImplicitPublishedDeclarationContext) ClassDeclarationPart(i int) IClassDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationPartContext)
}

func (s *ClassImplicitPublishedDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassImplicitPublishedDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassImplicitPublishedDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassImplicitPublishedDeclaration(s)
	}
}

func (s *ClassImplicitPublishedDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassImplicitPublishedDeclaration(s)
	}
}

func (s *ClassImplicitPublishedDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassImplicitPublishedDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassImplicitPublishedDeclaration() (localctx IClassImplicitPublishedDeclarationContext) {
	localctx = NewClassImplicitPublishedDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, pascalParserRULE_classImplicitPublishedDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(677)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-8193) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-253953) != 0) {
		{
			p.SetState(674)
			p.ClassDeclarationPart()
		}

		p.SetState(679)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassDeclarationPartContext is an interface to support dynamic dispatch.
type IClassDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypedIdentifierList() ITypedIdentifierListContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AttributeSection() IAttributeSectionContext
	TypeDefinitionPart() ITypeDefinitionPartContext
	ConstantDefinitionPart() IConstantDefinitionPartContext
	FunctionHeader() IFunctionHeaderContext
	ProcedureHeader() IProcedureHeaderContext
	PropertyDeclaration() IPropertyDeclarationContext
	DEFAULT() antlr.TerminalNode
	ErrorClassDeclarationPart() IErrorClassDeclarationPartContext

	// IsClassDeclarationPartContext differentiates from other interfaces.
	IsClassDeclarationPartContext()
}

type ClassDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationPartContext() *ClassDeclarationPartContext {
	var p = new(ClassDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classDeclarationPart
	return p
}

func InitEmptyClassDeclarationPartContext(p *ClassDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classDeclarationPart
}

func (*ClassDeclarationPartContext) IsClassDeclarationPartContext() {}

func NewClassDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationPartContext {
	var p = new(ClassDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classDeclarationPart

	return p
}

func (s *ClassDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationPartContext) TypedIdentifierList() ITypedIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIdentifierListContext)
}

func (s *ClassDeclarationPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ClassDeclarationPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ClassDeclarationPartContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *ClassDeclarationPartContext) TypeDefinitionPart() ITypeDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionPartContext)
}

func (s *ClassDeclarationPartContext) ConstantDefinitionPart() IConstantDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *ClassDeclarationPartContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *ClassDeclarationPartContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *ClassDeclarationPartContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *ClassDeclarationPartContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *ClassDeclarationPartContext) ErrorClassDeclarationPart() IErrorClassDeclarationPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorClassDeclarationPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorClassDeclarationPartContext)
}

func (s *ClassDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassDeclarationPart(s)
	}
}

func (s *ClassDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassDeclarationPart(s)
	}
}

func (s *ClassDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassDeclarationPart() (localctx IClassDeclarationPartContext) {
	localctx = NewClassDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, pascalParserRULE_classDeclarationPart)
	var _la int

	p.SetState(699)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(681)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(680)
				p.AttributeSection()
			}

		}
		{
			p.SetState(683)
			p.TypedIdentifierList()
		}
		{
			p.SetState(684)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(686)
			p.TypeDefinitionPart()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(687)
			p.ConstantDefinitionPart()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(688)
			p.FunctionHeader()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(689)
			p.ProcedureHeader()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(690)
			p.PropertyDeclaration()
		}
		{
			p.SetState(691)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(694)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(692)
				p.Match(pascalParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(693)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(696)
			p.ErrorClassDeclarationPart()
		}
		{
			p.SetState(697)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceGuidConstContext is an interface to support dynamic dispatch.
type IInterfaceGuidConstContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GUID_LITERAL() antlr.TerminalNode

	// IsInterfaceGuidConstContext differentiates from other interfaces.
	IsInterfaceGuidConstContext()
}

type InterfaceGuidConstContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceGuidConstContext() *InterfaceGuidConstContext {
	var p = new(InterfaceGuidConstContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceGuidConst
	return p
}

func InitEmptyInterfaceGuidConstContext(p *InterfaceGuidConstContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceGuidConst
}

func (*InterfaceGuidConstContext) IsInterfaceGuidConstContext() {}

func NewInterfaceGuidConstContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceGuidConstContext {
	var p = new(InterfaceGuidConstContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceGuidConst

	return p
}

func (s *InterfaceGuidConstContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceGuidConstContext) GUID_LITERAL() antlr.TerminalNode {
	return s.GetToken(pascalParserGUID_LITERAL, 0)
}

func (s *InterfaceGuidConstContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceGuidConstContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceGuidConstContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceGuidConst(s)
	}
}

func (s *InterfaceGuidConstContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceGuidConst(s)
	}
}

func (s *InterfaceGuidConstContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceGuidConst(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceGuidConst() (localctx IInterfaceGuidConstContext) {
	localctx = NewInterfaceGuidConstContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, pascalParserRULE_interfaceGuidConst)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(701)
		p.Match(pascalParserGUID_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceTypeContext is an interface to support dynamic dispatch.
type IInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	InterfaceDeclaration() IInterfaceDeclarationContext
	END() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	RPAREN() antlr.TerminalNode
	GUID_LITERAL() antlr.TerminalNode

	// IsInterfaceTypeContext differentiates from other interfaces.
	IsInterfaceTypeContext()
}

type InterfaceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceTypeContext() *InterfaceTypeContext {
	var p = new(InterfaceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceType
	return p
}

func InitEmptyInterfaceTypeContext(p *InterfaceTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceType
}

func (*InterfaceTypeContext) IsInterfaceTypeContext() {}

func NewInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceTypeContext {
	var p = new(InterfaceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceType

	return p
}

func (s *InterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceTypeContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(pascalParserINTERFACE, 0)
}

func (s *InterfaceTypeContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *InterfaceTypeContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *InterfaceTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *InterfaceTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InterfaceTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *InterfaceTypeContext) GUID_LITERAL() antlr.TerminalNode {
	return s.GetToken(pascalParserGUID_LITERAL, 0)
}

func (s *InterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceType(s)
	}
}

func (s *InterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceType(s)
	}
}

func (s *InterfaceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceType() (localctx IInterfaceTypeContext) {
	localctx = NewInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, pascalParserRULE_interfaceType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(703)
		p.Match(pascalParserINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(708)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(704)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(705)
			p.Identifier()
		}
		{
			p.SetState(706)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(711)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(710)
			p.Match(pascalParserGUID_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(713)
		p.InterfaceDeclaration()
	}
	{
		p.SetState(714)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInterfaceDeclarationPart() []IInterfaceDeclarationPartContext
	InterfaceDeclarationPart(i int) IInterfaceDeclarationPartContext

	// IsInterfaceDeclarationContext differentiates from other interfaces.
	IsInterfaceDeclarationContext()
}

type InterfaceDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclarationContext() *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceDeclaration
	return p
}

func InitEmptyInterfaceDeclarationContext(p *InterfaceDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceDeclaration
}

func (*InterfaceDeclarationContext) IsInterfaceDeclarationContext() {}

func NewInterfaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceDeclaration

	return p
}

func (s *InterfaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclarationContext) AllInterfaceDeclarationPart() []IInterfaceDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceDeclarationPartContext); ok {
			tst[i] = t.(IInterfaceDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceDeclarationContext) InterfaceDeclarationPart(i int) IInterfaceDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationPartContext)
}

func (s *InterfaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceDeclaration(s)
	}
}

func (s *InterfaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceDeclaration(s)
	}
}

func (s *InterfaceDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceDeclaration() (localctx IInterfaceDeclarationContext) {
	localctx = NewInterfaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, pascalParserRULE_interfaceDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(719)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-8193) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-1) != 0) {
		{
			p.SetState(716)
			p.InterfaceDeclarationPart()
		}

		p.SetState(721)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceDeclarationPartContext is an interface to support dynamic dispatch.
type IInterfaceDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionHeader() IFunctionHeaderContext
	ProcedureHeader() IProcedureHeaderContext
	PropertyDeclaration() IPropertyDeclarationContext
	SEMI() antlr.TerminalNode
	ErrorInterfaceDeclarationPart() IErrorInterfaceDeclarationPartContext

	// IsInterfaceDeclarationPartContext differentiates from other interfaces.
	IsInterfaceDeclarationPartContext()
}

type InterfaceDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclarationPartContext() *InterfaceDeclarationPartContext {
	var p = new(InterfaceDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceDeclarationPart
	return p
}

func InitEmptyInterfaceDeclarationPartContext(p *InterfaceDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceDeclarationPart
}

func (*InterfaceDeclarationPartContext) IsInterfaceDeclarationPartContext() {}

func NewInterfaceDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclarationPartContext {
	var p = new(InterfaceDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceDeclarationPart

	return p
}

func (s *InterfaceDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclarationPartContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *InterfaceDeclarationPartContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *InterfaceDeclarationPartContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *InterfaceDeclarationPartContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *InterfaceDeclarationPartContext) ErrorInterfaceDeclarationPart() IErrorInterfaceDeclarationPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorInterfaceDeclarationPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorInterfaceDeclarationPartContext)
}

func (s *InterfaceDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceDeclarationPart(s)
	}
}

func (s *InterfaceDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceDeclarationPart(s)
	}
}

func (s *InterfaceDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceDeclarationPart() (localctx IInterfaceDeclarationPartContext) {
	localctx = NewInterfaceDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, pascalParserRULE_interfaceDeclarationPart)
	p.SetState(730)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(722)
			p.FunctionHeader()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(723)
			p.ProcedureHeader()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(724)
			p.PropertyDeclaration()
		}
		{
			p.SetState(725)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(727)
			p.ErrorInterfaceDeclarationPart()
		}
		{
			p.SetState(728)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorInterfaceDeclarationPartContext is an interface to support dynamic dispatch.
type IErrorInterfaceDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEND() []antlr.TerminalNode
	END(i int) antlr.TerminalNode

	// IsErrorInterfaceDeclarationPartContext differentiates from other interfaces.
	IsErrorInterfaceDeclarationPartContext()
}

type ErrorInterfaceDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorInterfaceDeclarationPartContext() *ErrorInterfaceDeclarationPartContext {
	var p = new(ErrorInterfaceDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorInterfaceDeclarationPart
	return p
}

func InitEmptyErrorInterfaceDeclarationPartContext(p *ErrorInterfaceDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorInterfaceDeclarationPart
}

func (*ErrorInterfaceDeclarationPartContext) IsErrorInterfaceDeclarationPartContext() {}

func NewErrorInterfaceDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorInterfaceDeclarationPartContext {
	var p = new(ErrorInterfaceDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_errorInterfaceDeclarationPart

	return p
}

func (s *ErrorInterfaceDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorInterfaceDeclarationPartContext) AllEND() []antlr.TerminalNode {
	return s.GetTokens(pascalParserEND)
}

func (s *ErrorInterfaceDeclarationPartContext) END(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserEND, i)
}

func (s *ErrorInterfaceDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorInterfaceDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorInterfaceDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterErrorInterfaceDeclarationPart(s)
	}
}

func (s *ErrorInterfaceDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitErrorInterfaceDeclarationPart(s)
	}
}

func (s *ErrorInterfaceDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitErrorInterfaceDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ErrorInterfaceDeclarationPart() (localctx IErrorInterfaceDeclarationPartContext) {
	localctx = NewErrorInterfaceDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, pascalParserRULE_errorInterfaceDeclarationPart)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(733)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(732)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || _la == pascalParserEND {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(735)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorClassDeclarationPartContext is an interface to support dynamic dispatch.
type IErrorClassDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRICT() []antlr.TerminalNode
	STRICT(i int) antlr.TerminalNode
	AllPRIVATE() []antlr.TerminalNode
	PRIVATE(i int) antlr.TerminalNode
	AllPROTECTED() []antlr.TerminalNode
	PROTECTED(i int) antlr.TerminalNode
	AllPUBLIC() []antlr.TerminalNode
	PUBLIC(i int) antlr.TerminalNode
	AllPUBLISHED() []antlr.TerminalNode
	PUBLISHED(i int) antlr.TerminalNode
	AllEND() []antlr.TerminalNode
	END(i int) antlr.TerminalNode

	// IsErrorClassDeclarationPartContext differentiates from other interfaces.
	IsErrorClassDeclarationPartContext()
}

type ErrorClassDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorClassDeclarationPartContext() *ErrorClassDeclarationPartContext {
	var p = new(ErrorClassDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorClassDeclarationPart
	return p
}

func InitEmptyErrorClassDeclarationPartContext(p *ErrorClassDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorClassDeclarationPart
}

func (*ErrorClassDeclarationPartContext) IsErrorClassDeclarationPartContext() {}

func NewErrorClassDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorClassDeclarationPartContext {
	var p = new(ErrorClassDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_errorClassDeclarationPart

	return p
}

func (s *ErrorClassDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorClassDeclarationPartContext) AllSTRICT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTRICT)
}

func (s *ErrorClassDeclarationPartContext) STRICT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTRICT, i)
}

func (s *ErrorClassDeclarationPartContext) AllPRIVATE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPRIVATE)
}

func (s *ErrorClassDeclarationPartContext) PRIVATE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPRIVATE, i)
}

func (s *ErrorClassDeclarationPartContext) AllPROTECTED() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPROTECTED)
}

func (s *ErrorClassDeclarationPartContext) PROTECTED(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPROTECTED, i)
}

func (s *ErrorClassDeclarationPartContext) AllPUBLIC() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPUBLIC)
}

func (s *ErrorClassDeclarationPartContext) PUBLIC(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLIC, i)
}

func (s *ErrorClassDeclarationPartContext) AllPUBLISHED() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPUBLISHED)
}

func (s *ErrorClassDeclarationPartContext) PUBLISHED(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLISHED, i)
}

func (s *ErrorClassDeclarationPartContext) AllEND() []antlr.TerminalNode {
	return s.GetTokens(pascalParserEND)
}

func (s *ErrorClassDeclarationPartContext) END(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserEND, i)
}

func (s *ErrorClassDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorClassDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorClassDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterErrorClassDeclarationPart(s)
	}
}

func (s *ErrorClassDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitErrorClassDeclarationPart(s)
	}
}

func (s *ErrorClassDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitErrorClassDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ErrorClassDeclarationPart() (localctx IErrorClassDeclarationPartContext) {
	localctx = NewErrorClassDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, pascalParserRULE_errorClassDeclarationPart)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(738)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(737)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || _la == pascalParserEND || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&31) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(740)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyDeclarationContext is an interface to support dynamic dispatch.
type IPropertyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROPERTY() antlr.TerminalNode
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	PropertyIndexParameters() IPropertyIndexParametersContext
	PropertyReadDeclaration() IPropertyReadDeclarationContext
	PropertyWriteDeclaration() IPropertyWriteDeclarationContext
	PropertyDefaultValueDeclaration() IPropertyDefaultValueDeclarationContext
	PropertyIndexDeclaration() IPropertyIndexDeclarationContext
	SEMI() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode

	// IsPropertyDeclarationContext differentiates from other interfaces.
	IsPropertyDeclarationContext()
}

type PropertyDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDeclarationContext() *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDeclaration
	return p
}

func InitEmptyPropertyDeclarationContext(p *PropertyDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDeclaration
}

func (*PropertyDeclarationContext) IsPropertyDeclarationContext() {}

func NewPropertyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyDeclaration

	return p
}

func (s *PropertyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDeclarationContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(pascalParserPROPERTY, 0)
}

func (s *PropertyDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *PropertyDeclarationContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *PropertyDeclarationContext) PropertyIndexParameters() IPropertyIndexParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyIndexParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyIndexParametersContext)
}

func (s *PropertyDeclarationContext) PropertyReadDeclaration() IPropertyReadDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyReadDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyReadDeclarationContext)
}

func (s *PropertyDeclarationContext) PropertyWriteDeclaration() IPropertyWriteDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyWriteDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyWriteDeclarationContext)
}

func (s *PropertyDeclarationContext) PropertyDefaultValueDeclaration() IPropertyDefaultValueDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDefaultValueDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDefaultValueDeclarationContext)
}

func (s *PropertyDeclarationContext) PropertyIndexDeclaration() IPropertyIndexDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyIndexDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyIndexDeclarationContext)
}

func (s *PropertyDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *PropertyDeclarationContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *PropertyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyDeclaration(s)
	}
}

func (s *PropertyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyDeclaration(s)
	}
}

func (s *PropertyDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyDeclaration() (localctx IPropertyDeclarationContext) {
	localctx = NewPropertyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, pascalParserRULE_propertyDeclaration)
	var _la int

	p.SetState(770)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(742)
			p.Match(pascalParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(743)
			p.Identifier()
		}
		p.SetState(745)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(744)
				p.PropertyIndexParameters()
			}

		}
		{
			p.SetState(747)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(748)
			p.TypeIdentifier()
		}
		p.SetState(750)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserREAD {
			{
				p.SetState(749)
				p.PropertyReadDeclaration()
			}

		}
		p.SetState(753)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserWRITE {
			{
				p.SetState(752)
				p.PropertyWriteDeclaration()
			}

		}
		p.SetState(756)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserDEFAULT {
			{
				p.SetState(755)
				p.PropertyDefaultValueDeclaration()
			}

		}
		p.SetState(759)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserINDEX {
			{
				p.SetState(758)
				p.PropertyIndexDeclaration()
			}

		}
		p.SetState(763)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(761)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(762)
				p.Match(pascalParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(765)
			p.Match(pascalParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(766)
			p.Identifier()
		}
		p.SetState(768)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserDEFAULT {
			{
				p.SetState(767)
				p.PropertyDefaultValueDeclaration()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyReadDeclarationContext is an interface to support dynamic dispatch.
type IPropertyReadDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsPropertyReadDeclarationContext differentiates from other interfaces.
	IsPropertyReadDeclarationContext()
}

type PropertyReadDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyReadDeclarationContext() *PropertyReadDeclarationContext {
	var p = new(PropertyReadDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyReadDeclaration
	return p
}

func InitEmptyPropertyReadDeclarationContext(p *PropertyReadDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyReadDeclaration
}

func (*PropertyReadDeclarationContext) IsPropertyReadDeclarationContext() {}

func NewPropertyReadDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyReadDeclarationContext {
	var p = new(PropertyReadDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyReadDeclaration

	return p
}

func (s *PropertyReadDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyReadDeclarationContext) READ() antlr.TerminalNode {
	return s.GetToken(pascalParserREAD, 0)
}

func (s *PropertyReadDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyReadDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyReadDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyReadDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyReadDeclaration(s)
	}
}

func (s *PropertyReadDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyReadDeclaration(s)
	}
}

func (s *PropertyReadDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyReadDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyReadDeclaration() (localctx IPropertyReadDeclarationContext) {
	localctx = NewPropertyReadDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, pascalParserRULE_propertyReadDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(772)
		p.Match(pascalParserREAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(773)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyWriteDeclarationContext is an interface to support dynamic dispatch.
type IPropertyWriteDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WRITE() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsPropertyWriteDeclarationContext differentiates from other interfaces.
	IsPropertyWriteDeclarationContext()
}

type PropertyWriteDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyWriteDeclarationContext() *PropertyWriteDeclarationContext {
	var p = new(PropertyWriteDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyWriteDeclaration
	return p
}

func InitEmptyPropertyWriteDeclarationContext(p *PropertyWriteDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyWriteDeclaration
}

func (*PropertyWriteDeclarationContext) IsPropertyWriteDeclarationContext() {}

func NewPropertyWriteDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyWriteDeclarationContext {
	var p = new(PropertyWriteDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyWriteDeclaration

	return p
}

func (s *PropertyWriteDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyWriteDeclarationContext) WRITE() antlr.TerminalNode {
	return s.GetToken(pascalParserWRITE, 0)
}

func (s *PropertyWriteDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyWriteDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyWriteDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyWriteDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyWriteDeclaration(s)
	}
}

func (s *PropertyWriteDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyWriteDeclaration(s)
	}
}

func (s *PropertyWriteDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyWriteDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyWriteDeclaration() (localctx IPropertyWriteDeclarationContext) {
	localctx = NewPropertyWriteDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, pascalParserRULE_propertyWriteDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(775)
		p.Match(pascalParserWRITE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(776)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyDefaultValueDeclarationContext is an interface to support dynamic dispatch.
type IPropertyDefaultValueDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	Expression() IExpressionContext

	// IsPropertyDefaultValueDeclarationContext differentiates from other interfaces.
	IsPropertyDefaultValueDeclarationContext()
}

type PropertyDefaultValueDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDefaultValueDeclarationContext() *PropertyDefaultValueDeclarationContext {
	var p = new(PropertyDefaultValueDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDefaultValueDeclaration
	return p
}

func InitEmptyPropertyDefaultValueDeclarationContext(p *PropertyDefaultValueDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDefaultValueDeclaration
}

func (*PropertyDefaultValueDeclarationContext) IsPropertyDefaultValueDeclarationContext() {}

func NewPropertyDefaultValueDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDefaultValueDeclarationContext {
	var p = new(PropertyDefaultValueDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyDefaultValueDeclaration

	return p
}

func (s *PropertyDefaultValueDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDefaultValueDeclarationContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *PropertyDefaultValueDeclarationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PropertyDefaultValueDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDefaultValueDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyDefaultValueDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyDefaultValueDeclaration(s)
	}
}

func (s *PropertyDefaultValueDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyDefaultValueDeclaration(s)
	}
}

func (s *PropertyDefaultValueDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyDefaultValueDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyDefaultValueDeclaration() (localctx IPropertyDefaultValueDeclarationContext) {
	localctx = NewPropertyDefaultValueDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, pascalParserRULE_propertyDefaultValueDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(778)
		p.Match(pascalParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(779)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyIndexDeclarationContext is an interface to support dynamic dispatch.
type IPropertyIndexDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INDEX() antlr.TerminalNode
	UnsignedNumber() IUnsignedNumberContext

	// IsPropertyIndexDeclarationContext differentiates from other interfaces.
	IsPropertyIndexDeclarationContext()
}

type PropertyIndexDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyIndexDeclarationContext() *PropertyIndexDeclarationContext {
	var p = new(PropertyIndexDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexDeclaration
	return p
}

func InitEmptyPropertyIndexDeclarationContext(p *PropertyIndexDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexDeclaration
}

func (*PropertyIndexDeclarationContext) IsPropertyIndexDeclarationContext() {}

func NewPropertyIndexDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyIndexDeclarationContext {
	var p = new(PropertyIndexDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyIndexDeclaration

	return p
}

func (s *PropertyIndexDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyIndexDeclarationContext) INDEX() antlr.TerminalNode {
	return s.GetToken(pascalParserINDEX, 0)
}

func (s *PropertyIndexDeclarationContext) UnsignedNumber() IUnsignedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedNumberContext)
}

func (s *PropertyIndexDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyIndexDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyIndexDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyIndexDeclaration(s)
	}
}

func (s *PropertyIndexDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyIndexDeclaration(s)
	}
}

func (s *PropertyIndexDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyIndexDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyIndexDeclaration() (localctx IPropertyIndexDeclarationContext) {
	localctx = NewPropertyIndexDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, pascalParserRULE_propertyIndexDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(781)
		p.Match(pascalParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(782)
		p.UnsignedNumber()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyIndexParametersContext is an interface to support dynamic dispatch.
type IPropertyIndexParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	AllFormalParameterSection() []IFormalParameterSectionContext
	FormalParameterSection(i int) IFormalParameterSectionContext
	RBRACK() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPropertyIndexParametersContext differentiates from other interfaces.
	IsPropertyIndexParametersContext()
}

type PropertyIndexParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyIndexParametersContext() *PropertyIndexParametersContext {
	var p = new(PropertyIndexParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexParameters
	return p
}

func InitEmptyPropertyIndexParametersContext(p *PropertyIndexParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexParameters
}

func (*PropertyIndexParametersContext) IsPropertyIndexParametersContext() {}

func NewPropertyIndexParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyIndexParametersContext {
	var p = new(PropertyIndexParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyIndexParameters

	return p
}

func (s *PropertyIndexParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyIndexParametersContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *PropertyIndexParametersContext) AllFormalParameterSection() []IFormalParameterSectionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormalParameterSectionContext); ok {
			len++
		}
	}

	tst := make([]IFormalParameterSectionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormalParameterSectionContext); ok {
			tst[i] = t.(IFormalParameterSectionContext)
			i++
		}
	}

	return tst
}

func (s *PropertyIndexParametersContext) FormalParameterSection(i int) IFormalParameterSectionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterSectionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterSectionContext)
}

func (s *PropertyIndexParametersContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *PropertyIndexParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *PropertyIndexParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *PropertyIndexParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyIndexParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyIndexParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyIndexParameters(s)
	}
}

func (s *PropertyIndexParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyIndexParameters(s)
	}
}

func (s *PropertyIndexParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyIndexParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyIndexParameters() (localctx IPropertyIndexParametersContext) {
	localctx = NewPropertyIndexParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, pascalParserRULE_propertyIndexParameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(784)
		p.Match(pascalParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(785)
		p.FormalParameterSection()
	}
	p.SetState(790)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(786)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(787)
			p.FormalParameterSection()
		}

		p.SetState(792)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(793)
		p.Match(pascalParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyIndexParametersListContext is an interface to support dynamic dispatch.
type IPropertyIndexParametersListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierList() []IIdentifierListContext
	IdentifierList(i int) IIdentifierListContext
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllIndexType() []IIndexTypeContext
	IndexType(i int) IIndexTypeContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsPropertyIndexParametersListContext differentiates from other interfaces.
	IsPropertyIndexParametersListContext()
}

type PropertyIndexParametersListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyIndexParametersListContext() *PropertyIndexParametersListContext {
	var p = new(PropertyIndexParametersListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexParametersList
	return p
}

func InitEmptyPropertyIndexParametersListContext(p *PropertyIndexParametersListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexParametersList
}

func (*PropertyIndexParametersListContext) IsPropertyIndexParametersListContext() {}

func NewPropertyIndexParametersListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyIndexParametersListContext {
	var p = new(PropertyIndexParametersListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyIndexParametersList

	return p
}

func (s *PropertyIndexParametersListContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyIndexParametersListContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *PropertyIndexParametersListContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PropertyIndexParametersListContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOLON)
}

func (s *PropertyIndexParametersListContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, i)
}

func (s *PropertyIndexParametersListContext) AllIndexType() []IIndexTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexTypeContext); ok {
			len++
		}
	}

	tst := make([]IIndexTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexTypeContext); ok {
			tst[i] = t.(IIndexTypeContext)
			i++
		}
	}

	return tst
}

func (s *PropertyIndexParametersListContext) IndexType(i int) IIndexTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *PropertyIndexParametersListContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *PropertyIndexParametersListContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *PropertyIndexParametersListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyIndexParametersListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyIndexParametersListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyIndexParametersList(s)
	}
}

func (s *PropertyIndexParametersListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyIndexParametersList(s)
	}
}

func (s *PropertyIndexParametersListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyIndexParametersList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyIndexParametersList() (localctx IPropertyIndexParametersListContext) {
	localctx = NewPropertyIndexParametersListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, pascalParserRULE_propertyIndexParametersList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(795)
		p.IdentifierList()
	}
	{
		p.SetState(796)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(797)
		p.IndexType()
	}
	p.SetState(805)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserSEMI {
		{
			p.SetState(798)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(799)
			p.IdentifierList()
		}
		{
			p.SetState(800)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(801)
			p.IndexType()
		}

		p.SetState(807)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericTemplateContext is an interface to support dynamic dispatch.
type IGenericTemplateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	GenericTemplateList() IGenericTemplateListContext
	GT() antlr.TerminalNode

	// IsGenericTemplateContext differentiates from other interfaces.
	IsGenericTemplateContext()
}

type GenericTemplateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericTemplateContext() *GenericTemplateContext {
	var p = new(GenericTemplateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericTemplate
	return p
}

func InitEmptyGenericTemplateContext(p *GenericTemplateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericTemplate
}

func (*GenericTemplateContext) IsGenericTemplateContext() {}

func NewGenericTemplateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericTemplateContext {
	var p = new(GenericTemplateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_genericTemplate

	return p
}

func (s *GenericTemplateContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericTemplateContext) LT() antlr.TerminalNode {
	return s.GetToken(pascalParserLT, 0)
}

func (s *GenericTemplateContext) GenericTemplateList() IGenericTemplateListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericTemplateListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericTemplateListContext)
}

func (s *GenericTemplateContext) GT() antlr.TerminalNode {
	return s.GetToken(pascalParserGT, 0)
}

func (s *GenericTemplateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericTemplateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericTemplateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterGenericTemplate(s)
	}
}

func (s *GenericTemplateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitGenericTemplate(s)
	}
}

func (s *GenericTemplateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitGenericTemplate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) GenericTemplate() (localctx IGenericTemplateContext) {
	localctx = NewGenericTemplateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, pascalParserRULE_genericTemplate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(808)
		p.Match(pascalParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(809)
		p.GenericTemplateList()
	}
	{
		p.SetState(810)
		p.Match(pascalParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericTemplateListContext is an interface to support dynamic dispatch.
type IGenericTemplateListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGenericTypeParameter() []IGenericTypeParameterContext
	GenericTypeParameter(i int) IGenericTypeParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGenericTemplateListContext differentiates from other interfaces.
	IsGenericTemplateListContext()
}

type GenericTemplateListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericTemplateListContext() *GenericTemplateListContext {
	var p = new(GenericTemplateListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericTemplateList
	return p
}

func InitEmptyGenericTemplateListContext(p *GenericTemplateListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericTemplateList
}

func (*GenericTemplateListContext) IsGenericTemplateListContext() {}

func NewGenericTemplateListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericTemplateListContext {
	var p = new(GenericTemplateListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_genericTemplateList

	return p
}

func (s *GenericTemplateListContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericTemplateListContext) AllGenericTypeParameter() []IGenericTypeParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGenericTypeParameterContext); ok {
			len++
		}
	}

	tst := make([]IGenericTypeParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGenericTypeParameterContext); ok {
			tst[i] = t.(IGenericTypeParameterContext)
			i++
		}
	}

	return tst
}

func (s *GenericTemplateListContext) GenericTypeParameter(i int) IGenericTypeParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericTypeParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericTypeParameterContext)
}

func (s *GenericTemplateListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *GenericTemplateListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *GenericTemplateListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericTemplateListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericTemplateListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterGenericTemplateList(s)
	}
}

func (s *GenericTemplateListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitGenericTemplateList(s)
	}
}

func (s *GenericTemplateListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitGenericTemplateList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) GenericTemplateList() (localctx IGenericTemplateListContext) {
	localctx = NewGenericTemplateListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, pascalParserRULE_genericTemplateList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(812)
		p.GenericTypeParameter()
	}
	p.SetState(817)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(813)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(814)
			p.GenericTypeParameter()
		}

		p.SetState(819)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericTypeParameterContext is an interface to support dynamic dispatch.
type IGenericTypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIdentifier() ITypeIdentifierContext
	COLON() antlr.TerminalNode
	GenericConstraints() IGenericConstraintsContext

	// IsGenericTypeParameterContext differentiates from other interfaces.
	IsGenericTypeParameterContext()
}

type GenericTypeParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericTypeParameterContext() *GenericTypeParameterContext {
	var p = new(GenericTypeParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericTypeParameter
	return p
}

func InitEmptyGenericTypeParameterContext(p *GenericTypeParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericTypeParameter
}

func (*GenericTypeParameterContext) IsGenericTypeParameterContext() {}

func NewGenericTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericTypeParameterContext {
	var p = new(GenericTypeParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_genericTypeParameter

	return p
}

func (s *GenericTypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericTypeParameterContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *GenericTypeParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *GenericTypeParameterContext) GenericConstraints() IGenericConstraintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericConstraintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericConstraintsContext)
}

func (s *GenericTypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericTypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericTypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterGenericTypeParameter(s)
	}
}

func (s *GenericTypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitGenericTypeParameter(s)
	}
}

func (s *GenericTypeParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitGenericTypeParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) GenericTypeParameter() (localctx IGenericTypeParameterContext) {
	localctx = NewGenericTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, pascalParserRULE_genericTypeParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(820)
		p.TypeIdentifier()
	}
	p.SetState(823)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserCOLON {
		{
			p.SetState(821)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(822)
			p.GenericConstraints()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericConstraintsContext is an interface to support dynamic dispatch.
type IGenericConstraintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGenericConstraint() []IGenericConstraintContext
	GenericConstraint(i int) IGenericConstraintContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGenericConstraintsContext differentiates from other interfaces.
	IsGenericConstraintsContext()
}

type GenericConstraintsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericConstraintsContext() *GenericConstraintsContext {
	var p = new(GenericConstraintsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericConstraints
	return p
}

func InitEmptyGenericConstraintsContext(p *GenericConstraintsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericConstraints
}

func (*GenericConstraintsContext) IsGenericConstraintsContext() {}

func NewGenericConstraintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericConstraintsContext {
	var p = new(GenericConstraintsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_genericConstraints

	return p
}

func (s *GenericConstraintsContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericConstraintsContext) AllGenericConstraint() []IGenericConstraintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGenericConstraintContext); ok {
			len++
		}
	}

	tst := make([]IGenericConstraintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGenericConstraintContext); ok {
			tst[i] = t.(IGenericConstraintContext)
			i++
		}
	}

	return tst
}

func (s *GenericConstraintsContext) GenericConstraint(i int) IGenericConstraintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericConstraintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericConstraintContext)
}

func (s *GenericConstraintsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *GenericConstraintsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *GenericConstraintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericConstraintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericConstraintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterGenericConstraints(s)
	}
}

func (s *GenericConstraintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitGenericConstraints(s)
	}
}

func (s *GenericConstraintsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitGenericConstraints(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) GenericConstraints() (localctx IGenericConstraintsContext) {
	localctx = NewGenericConstraintsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, pascalParserRULE_genericConstraints)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(825)
		p.GenericConstraint()
	}
	p.SetState(830)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(826)
				p.Match(pascalParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(827)
				p.GenericConstraint()
			}

		}
		p.SetState(832)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericConstraintContext is an interface to support dynamic dispatch.
type IGenericConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONSTRUCTOR() antlr.TerminalNode
	CLASS() antlr.TerminalNode
	RECORD() antlr.TerminalNode
	OF() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext

	// IsGenericConstraintContext differentiates from other interfaces.
	IsGenericConstraintContext()
}

type GenericConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericConstraintContext() *GenericConstraintContext {
	var p = new(GenericConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericConstraint
	return p
}

func InitEmptyGenericConstraintContext(p *GenericConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericConstraint
}

func (*GenericConstraintContext) IsGenericConstraintContext() {}

func NewGenericConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericConstraintContext {
	var p = new(GenericConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_genericConstraint

	return p
}

func (s *GenericConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericConstraintContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(pascalParserCONSTRUCTOR, 0)
}

func (s *GenericConstraintContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *GenericConstraintContext) RECORD() antlr.TerminalNode {
	return s.GetToken(pascalParserRECORD, 0)
}

func (s *GenericConstraintContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *GenericConstraintContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *GenericConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterGenericConstraint(s)
	}
}

func (s *GenericConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitGenericConstraint(s)
	}
}

func (s *GenericConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitGenericConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) GenericConstraint() (localctx IGenericConstraintContext) {
	localctx = NewGenericConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, pascalParserRULE_genericConstraint)
	p.SetState(840)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(833)
			p.Match(pascalParserCONSTRUCTOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(834)
			p.Match(pascalParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(835)
			p.Match(pascalParserRECORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(836)
			p.Match(pascalParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(837)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(838)
			p.TypeIdentifier()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(839)
			p.TypeIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_Context is an interface to support dynamic dispatch.
type IType_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleType() ISimpleTypeContext
	StructuredType() IStructuredTypeContext
	PointerType() IPointerTypeContext

	// IsType_Context differentiates from other interfaces.
	IsType_Context()
}

type Type_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_Context() *Type_Context {
	var p = new(Type_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_type_
	return p
}

func InitEmptyType_Context(p *Type_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_type_
}

func (*Type_Context) IsType_Context() {}

func NewType_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_Context {
	var p = new(Type_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_type_

	return p
}

func (s *Type_Context) GetParser() antlr.Parser { return s.parser }

func (s *Type_Context) SimpleType() ISimpleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeContext)
}

func (s *Type_Context) StructuredType() IStructuredTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructuredTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructuredTypeContext)
}

func (s *Type_Context) PointerType() IPointerTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerTypeContext)
}

func (s *Type_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterType_(s)
	}
}

func (s *Type_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitType_(s)
	}
}

func (s *Type_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitType_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Type_() (localctx IType_Context) {
	localctx = NewType_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, pascalParserRULE_type_)
	p.SetState(845)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(842)
			p.SimpleType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(843)
			p.StructuredType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(844)
			p.PointerType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleTypeContext is an interface to support dynamic dispatch.
type ISimpleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ScalarType() IScalarTypeContext
	SubrangeType() ISubrangeTypeContext
	TypeIdentifier() ITypeIdentifierContext
	Stringtype() IStringtypeContext

	// IsSimpleTypeContext differentiates from other interfaces.
	IsSimpleTypeContext()
}

type SimpleTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleTypeContext() *SimpleTypeContext {
	var p = new(SimpleTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleType
	return p
}

func InitEmptySimpleTypeContext(p *SimpleTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleType
}

func (*SimpleTypeContext) IsSimpleTypeContext() {}

func NewSimpleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleTypeContext {
	var p = new(SimpleTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_simpleType

	return p
}

func (s *SimpleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleTypeContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *SimpleTypeContext) SubrangeType() ISubrangeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubrangeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubrangeTypeContext)
}

func (s *SimpleTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *SimpleTypeContext) Stringtype() IStringtypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringtypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringtypeContext)
}

func (s *SimpleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSimpleType(s)
	}
}

func (s *SimpleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSimpleType(s)
	}
}

func (s *SimpleTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSimpleType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SimpleType() (localctx ISimpleTypeContext) {
	localctx = NewSimpleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, pascalParserRULE_simpleType)
	p.SetState(851)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(847)
			p.ScalarType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(848)
			p.SubrangeType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(849)
			p.TypeIdentifier()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(850)
			p.Stringtype()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScalarTypeContext is an interface to support dynamic dispatch.
type IScalarTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	ScalerList() IScalerListContext
	RPAREN() antlr.TerminalNode

	// IsScalarTypeContext differentiates from other interfaces.
	IsScalarTypeContext()
}

type ScalarTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalarTypeContext() *ScalarTypeContext {
	var p = new(ScalarTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalarType
	return p
}

func InitEmptyScalarTypeContext(p *ScalarTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalarType
}

func (*ScalarTypeContext) IsScalarTypeContext() {}

func NewScalarTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalarTypeContext {
	var p = new(ScalarTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_scalarType

	return p
}

func (s *ScalarTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalarTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ScalarTypeContext) ScalerList() IScalerListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalerListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalerListContext)
}

func (s *ScalarTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ScalarTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalarTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterScalarType(s)
	}
}

func (s *ScalarTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitScalarType(s)
	}
}

func (s *ScalarTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitScalarType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ScalarType() (localctx IScalarTypeContext) {
	localctx = NewScalarTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, pascalParserRULE_scalarType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(853)
		p.Match(pascalParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(854)
		p.ScalerList()
	}
	{
		p.SetState(855)
		p.Match(pascalParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScalerListContext is an interface to support dynamic dispatch.
type IScalerListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllScalerMember() []IScalerMemberContext
	ScalerMember(i int) IScalerMemberContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsScalerListContext differentiates from other interfaces.
	IsScalerListContext()
}

type ScalerListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalerListContext() *ScalerListContext {
	var p = new(ScalerListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalerList
	return p
}

func InitEmptyScalerListContext(p *ScalerListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalerList
}

func (*ScalerListContext) IsScalerListContext() {}

func NewScalerListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalerListContext {
	var p = new(ScalerListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_scalerList

	return p
}

func (s *ScalerListContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalerListContext) AllScalerMember() []IScalerMemberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScalerMemberContext); ok {
			len++
		}
	}

	tst := make([]IScalerMemberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScalerMemberContext); ok {
			tst[i] = t.(IScalerMemberContext)
			i++
		}
	}

	return tst
}

func (s *ScalerListContext) ScalerMember(i int) IScalerMemberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalerMemberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalerMemberContext)
}

func (s *ScalerListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ScalerListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ScalerListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalerListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalerListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterScalerList(s)
	}
}

func (s *ScalerListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitScalerList(s)
	}
}

func (s *ScalerListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitScalerList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ScalerList() (localctx IScalerListContext) {
	localctx = NewScalerListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, pascalParserRULE_scalerList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(857)
		p.ScalerMember()
	}
	p.SetState(862)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(858)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(859)
			p.ScalerMember()
		}

		p.SetState(864)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScalerMemberContext is an interface to support dynamic dispatch.
type IScalerMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQUAL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsScalerMemberContext differentiates from other interfaces.
	IsScalerMemberContext()
}

type ScalerMemberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalerMemberContext() *ScalerMemberContext {
	var p = new(ScalerMemberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalerMember
	return p
}

func InitEmptyScalerMemberContext(p *ScalerMemberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalerMember
}

func (*ScalerMemberContext) IsScalerMemberContext() {}

func NewScalerMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalerMemberContext {
	var p = new(ScalerMemberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_scalerMember

	return p
}

func (s *ScalerMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalerMemberContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScalerMemberContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *ScalerMemberContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ScalerMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalerMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalerMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterScalerMember(s)
	}
}

func (s *ScalerMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitScalerMember(s)
	}
}

func (s *ScalerMemberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitScalerMember(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ScalerMember() (localctx IScalerMemberContext) {
	localctx = NewScalerMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, pascalParserRULE_scalerMember)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(865)
		p.Identifier()
	}
	p.SetState(868)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserEQUAL {
		{
			p.SetState(866)
			p.Match(pascalParserEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(867)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubrangeTypeContext is an interface to support dynamic dispatch.
type ISubrangeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSimpleExpression() []ISimpleExpressionContext
	SimpleExpression(i int) ISimpleExpressionContext
	DOTDOT() antlr.TerminalNode

	// IsSubrangeTypeContext differentiates from other interfaces.
	IsSubrangeTypeContext()
}

type SubrangeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubrangeTypeContext() *SubrangeTypeContext {
	var p = new(SubrangeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_subrangeType
	return p
}

func InitEmptySubrangeTypeContext(p *SubrangeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_subrangeType
}

func (*SubrangeTypeContext) IsSubrangeTypeContext() {}

func NewSubrangeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubrangeTypeContext {
	var p = new(SubrangeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_subrangeType

	return p
}

func (s *SubrangeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SubrangeTypeContext) AllSimpleExpression() []ISimpleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISimpleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleExpressionContext); ok {
			tst[i] = t.(ISimpleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SubrangeTypeContext) SimpleExpression(i int) ISimpleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExpressionContext)
}

func (s *SubrangeTypeContext) DOTDOT() antlr.TerminalNode {
	return s.GetToken(pascalParserDOTDOT, 0)
}

func (s *SubrangeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubrangeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubrangeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSubrangeType(s)
	}
}

func (s *SubrangeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSubrangeType(s)
	}
}

func (s *SubrangeTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSubrangeType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SubrangeType() (localctx ISubrangeTypeContext) {
	localctx = NewSubrangeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, pascalParserRULE_subrangeType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(870)
		p.SimpleExpression()
	}
	{
		p.SetState(871)
		p.Match(pascalParserDOTDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(872)
		p.SimpleExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeIdentifierContext is an interface to support dynamic dispatch.
type ITypeIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	CHAR() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	REAL() antlr.TerminalNode
	STRING() antlr.TerminalNode
	CARDINAL() antlr.TerminalNode
	LONGBOOL() antlr.TerminalNode
	LONGINT() antlr.TerminalNode
	ArrayType() IArrayTypeContext

	// IsTypeIdentifierContext differentiates from other interfaces.
	IsTypeIdentifierContext()
}

type TypeIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeIdentifierContext() *TypeIdentifierContext {
	var p = new(TypeIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeIdentifier
	return p
}

func InitEmptyTypeIdentifierContext(p *TypeIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeIdentifier
}

func (*TypeIdentifierContext) IsTypeIdentifierContext() {}

func NewTypeIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeIdentifierContext {
	var p = new(TypeIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typeIdentifier

	return p
}

func (s *TypeIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeIdentifierContext) CHAR() antlr.TerminalNode {
	return s.GetToken(pascalParserCHAR, 0)
}

func (s *TypeIdentifierContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(pascalParserBOOLEAN, 0)
}

func (s *TypeIdentifierContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(pascalParserINTEGER, 0)
}

func (s *TypeIdentifierContext) REAL() antlr.TerminalNode {
	return s.GetToken(pascalParserREAL, 0)
}

func (s *TypeIdentifierContext) STRING() antlr.TerminalNode {
	return s.GetToken(pascalParserSTRING, 0)
}

func (s *TypeIdentifierContext) CARDINAL() antlr.TerminalNode {
	return s.GetToken(pascalParserCARDINAL, 0)
}

func (s *TypeIdentifierContext) LONGBOOL() antlr.TerminalNode {
	return s.GetToken(pascalParserLONGBOOL, 0)
}

func (s *TypeIdentifierContext) LONGINT() antlr.TerminalNode {
	return s.GetToken(pascalParserLONGINT, 0)
}

func (s *TypeIdentifierContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *TypeIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypeIdentifier(s)
	}
}

func (s *TypeIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypeIdentifier(s)
	}
}

func (s *TypeIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypeIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypeIdentifier() (localctx ITypeIdentifierContext) {
	localctx = NewTypeIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, pascalParserRULE_typeIdentifier)
	var _la int

	p.SetState(877)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(874)
			p.Identifier()
		}

	case pascalParserBOOLEAN, pascalParserCHAR, pascalParserINTEGER, pascalParserREAL, pascalParserSTRING, pascalParserCARDINAL, pascalParserLONGBOOL, pascalParserLONGINT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(875)
			_la = p.GetTokenStream().LA(1)

			if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4299161760) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&15393162788865) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case pascalParserARRAY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(876)
			p.ArrayType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructuredTypeContext is an interface to support dynamic dispatch.
type IStructuredTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PACKED() antlr.TerminalNode
	UnpackedStructuredType() IUnpackedStructuredTypeContext
	HelperType() IHelperTypeContext
	ClassType() IClassTypeContext
	RecordType() IRecordTypeContext
	InterfaceType() IInterfaceTypeContext

	// IsStructuredTypeContext differentiates from other interfaces.
	IsStructuredTypeContext()
}

type StructuredTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructuredTypeContext() *StructuredTypeContext {
	var p = new(StructuredTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_structuredType
	return p
}

func InitEmptyStructuredTypeContext(p *StructuredTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_structuredType
}

func (*StructuredTypeContext) IsStructuredTypeContext() {}

func NewStructuredTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructuredTypeContext {
	var p = new(StructuredTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_structuredType

	return p
}

func (s *StructuredTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StructuredTypeContext) PACKED() antlr.TerminalNode {
	return s.GetToken(pascalParserPACKED, 0)
}

func (s *StructuredTypeContext) UnpackedStructuredType() IUnpackedStructuredTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpackedStructuredTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpackedStructuredTypeContext)
}

func (s *StructuredTypeContext) HelperType() IHelperTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelperTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelperTypeContext)
}

func (s *StructuredTypeContext) ClassType() IClassTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTypeContext)
}

func (s *StructuredTypeContext) RecordType() IRecordTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordTypeContext)
}

func (s *StructuredTypeContext) InterfaceType() IInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceTypeContext)
}

func (s *StructuredTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructuredTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructuredTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStructuredType(s)
	}
}

func (s *StructuredTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStructuredType(s)
	}
}

func (s *StructuredTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStructuredType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) StructuredType() (localctx IStructuredTypeContext) {
	localctx = NewStructuredTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, pascalParserRULE_structuredType)
	p.SetState(886)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(879)
			p.Match(pascalParserPACKED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(880)
			p.UnpackedStructuredType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(881)
			p.UnpackedStructuredType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(882)
			p.HelperType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(883)
			p.ClassType()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(884)
			p.RecordType()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(885)
			p.InterfaceType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpackedStructuredTypeContext is an interface to support dynamic dispatch.
type IUnpackedStructuredTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ArrayType() IArrayTypeContext
	SetType() ISetTypeContext
	FileType() IFileTypeContext

	// IsUnpackedStructuredTypeContext differentiates from other interfaces.
	IsUnpackedStructuredTypeContext()
}

type UnpackedStructuredTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpackedStructuredTypeContext() *UnpackedStructuredTypeContext {
	var p = new(UnpackedStructuredTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unpackedStructuredType
	return p
}

func InitEmptyUnpackedStructuredTypeContext(p *UnpackedStructuredTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unpackedStructuredType
}

func (*UnpackedStructuredTypeContext) IsUnpackedStructuredTypeContext() {}

func NewUnpackedStructuredTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpackedStructuredTypeContext {
	var p = new(UnpackedStructuredTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unpackedStructuredType

	return p
}

func (s *UnpackedStructuredTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpackedStructuredTypeContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *UnpackedStructuredTypeContext) SetType() ISetTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetTypeContext)
}

func (s *UnpackedStructuredTypeContext) FileType() IFileTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileTypeContext)
}

func (s *UnpackedStructuredTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpackedStructuredTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpackedStructuredTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnpackedStructuredType(s)
	}
}

func (s *UnpackedStructuredTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnpackedStructuredType(s)
	}
}

func (s *UnpackedStructuredTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnpackedStructuredType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnpackedStructuredType() (localctx IUnpackedStructuredTypeContext) {
	localctx = NewUnpackedStructuredTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, pascalParserRULE_unpackedStructuredType)
	p.SetState(891)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserARRAY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(888)
			p.ArrayType()
		}

	case pascalParserSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(889)
			p.SetType()
		}

	case pascalParserFILE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(890)
			p.FileType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringtypeContext is an interface to support dynamic dispatch.
type IStringtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	Identifier() IIdentifierContext
	UnsignedNumber() IUnsignedNumberContext

	// IsStringtypeContext differentiates from other interfaces.
	IsStringtypeContext()
}

type StringtypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringtypeContext() *StringtypeContext {
	var p = new(StringtypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_stringtype
	return p
}

func InitEmptyStringtypeContext(p *StringtypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_stringtype
}

func (*StringtypeContext) IsStringtypeContext() {}

func NewStringtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringtypeContext {
	var p = new(StringtypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_stringtype

	return p
}

func (s *StringtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StringtypeContext) STRING() antlr.TerminalNode {
	return s.GetToken(pascalParserSTRING, 0)
}

func (s *StringtypeContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *StringtypeContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *StringtypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StringtypeContext) UnsignedNumber() IUnsignedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedNumberContext)
}

func (s *StringtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStringtype(s)
	}
}

func (s *StringtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStringtype(s)
	}
}

func (s *StringtypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStringtype(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Stringtype() (localctx IStringtypeContext) {
	localctx = NewStringtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, pascalParserRULE_stringtype)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(893)
		p.Match(pascalParserSTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(894)
		p.Match(pascalParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(897)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
		{
			p.SetState(895)
			p.Identifier()
		}

	case pascalParserNUM_INT, pascalParserNUM_REAL:
		{
			p.SetState(896)
			p.UnsignedNumber()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(899)
		p.Match(pascalParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY() antlr.TerminalNode
	LBRACK() antlr.TerminalNode
	TypeList() ITypeListContext
	RBRACK() antlr.TerminalNode
	OF() antlr.TerminalNode
	Type_() IType_Context
	EQUAL() antlr.TerminalNode
	ScalarType() IScalarTypeContext
	LBRACK2() antlr.TerminalNode
	RBRACK2() antlr.TerminalNode
	CONST() antlr.TerminalNode

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_arrayType
	return p
}

func InitEmptyArrayTypeContext(p *ArrayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_arrayType
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(pascalParserARRAY, 0)
}

func (s *ArrayTypeContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *ArrayTypeContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *ArrayTypeContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *ArrayTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *ArrayTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ArrayTypeContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *ArrayTypeContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ArrayTypeContext) LBRACK2() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK2, 0)
}

func (s *ArrayTypeContext) RBRACK2() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK2, 0)
}

func (s *ArrayTypeContext) CONST() antlr.TerminalNode {
	return s.GetToken(pascalParserCONST, 0)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (s *ArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, pascalParserRULE_arrayType)
	p.SetState(927)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(901)
			p.Match(pascalParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(902)
			p.Match(pascalParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(903)
			p.TypeList()
		}
		{
			p.SetState(904)
			p.Match(pascalParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(905)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(906)
			p.Type_()
		}
		p.SetState(909)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(907)
				p.Match(pascalParserEQUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(908)
				p.ScalarType()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(911)
			p.Match(pascalParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(912)
			p.Match(pascalParserLBRACK2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(913)
			p.TypeList()
		}
		{
			p.SetState(914)
			p.Match(pascalParserRBRACK2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(915)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(916)
			p.Type_()
		}
		p.SetState(919)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(917)
				p.Match(pascalParserEQUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(918)
				p.ScalarType()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(921)
			p.Match(pascalParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(922)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(923)
			p.Match(pascalParserCONST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(924)
			p.Match(pascalParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(925)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(926)
			p.Type_()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIndexType() []IIndexTypeContext
	IndexType(i int) IIndexTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeList
	return p
}

func InitEmptyTypeListContext(p *TypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeList
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllIndexType() []IIndexTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexTypeContext); ok {
			len++
		}
	}

	tst := make([]IIndexTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexTypeContext); ok {
			tst[i] = t.(IIndexTypeContext)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) IndexType(i int) IIndexTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *TypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *TypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypeList(s)
	}
}

func (s *TypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypeList(s)
	}
}

func (s *TypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, pascalParserRULE_typeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(929)
		p.IndexType()
	}
	p.SetState(934)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(930)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(931)
			p.IndexType()
		}

		p.SetState(936)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexTypeContext is an interface to support dynamic dispatch.
type IIndexTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleType() ISimpleTypeContext

	// IsIndexTypeContext differentiates from other interfaces.
	IsIndexTypeContext()
}

type IndexTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexTypeContext() *IndexTypeContext {
	var p = new(IndexTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_indexType
	return p
}

func InitEmptyIndexTypeContext(p *IndexTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_indexType
}

func (*IndexTypeContext) IsIndexTypeContext() {}

func NewIndexTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexTypeContext {
	var p = new(IndexTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_indexType

	return p
}

func (s *IndexTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexTypeContext) SimpleType() ISimpleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeContext)
}

func (s *IndexTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterIndexType(s)
	}
}

func (s *IndexTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitIndexType(s)
	}
}

func (s *IndexTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitIndexType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) IndexType() (localctx IIndexTypeContext) {
	localctx = NewIndexTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, pascalParserRULE_indexType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(937)
		p.SimpleType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordTypeContext is an interface to support dynamic dispatch.
type IRecordTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RECORD() antlr.TerminalNode
	RecordImplicitPublishedDeclaration() IRecordImplicitPublishedDeclarationContext
	END() antlr.TerminalNode
	AllRecordDeclaration() []IRecordDeclarationContext
	RecordDeclaration(i int) IRecordDeclarationContext
	RecordParts() IRecordPartsContext

	// IsRecordTypeContext differentiates from other interfaces.
	IsRecordTypeContext()
}

type RecordTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordTypeContext() *RecordTypeContext {
	var p = new(RecordTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordType
	return p
}

func InitEmptyRecordTypeContext(p *RecordTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordType
}

func (*RecordTypeContext) IsRecordTypeContext() {}

func NewRecordTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordTypeContext {
	var p = new(RecordTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordType

	return p
}

func (s *RecordTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordTypeContext) RECORD() antlr.TerminalNode {
	return s.GetToken(pascalParserRECORD, 0)
}

func (s *RecordTypeContext) RecordImplicitPublishedDeclaration() IRecordImplicitPublishedDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordImplicitPublishedDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordImplicitPublishedDeclarationContext)
}

func (s *RecordTypeContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *RecordTypeContext) AllRecordDeclaration() []IRecordDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IRecordDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordDeclarationContext); ok {
			tst[i] = t.(IRecordDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *RecordTypeContext) RecordDeclaration(i int) IRecordDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDeclarationContext)
}

func (s *RecordTypeContext) RecordParts() IRecordPartsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordPartsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordPartsContext)
}

func (s *RecordTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordType(s)
	}
}

func (s *RecordTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordType(s)
	}
}

func (s *RecordTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordType() (localctx IRecordTypeContext) {
	localctx = NewRecordTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, pascalParserRULE_recordType)
	var _la int

	p.SetState(954)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(939)
			p.Match(pascalParserRECORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(940)
			p.RecordImplicitPublishedDeclaration()
		}
		p.SetState(944)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&31) != 0 {
			{
				p.SetState(941)
				p.RecordDeclaration()
			}

			p.SetState(946)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(947)
			p.Match(pascalParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(949)
			p.Match(pascalParserRECORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(951)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserCASE || ((int64((_la-85)) & ^0x3f) == 0 && ((int64(1)<<(_la-85))&137438953483) != 0) {
			{
				p.SetState(950)
				p.RecordParts()
			}

		}
		{
			p.SetState(953)
			p.Match(pascalParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordDeclarationContext is an interface to support dynamic dispatch.
type IRecordDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AccessSpecifier() IAccessSpecifierContext
	AllRecordDeclarationPart() []IRecordDeclarationPartContext
	RecordDeclarationPart(i int) IRecordDeclarationPartContext

	// IsRecordDeclarationContext differentiates from other interfaces.
	IsRecordDeclarationContext()
}

type RecordDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordDeclarationContext() *RecordDeclarationContext {
	var p = new(RecordDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordDeclaration
	return p
}

func InitEmptyRecordDeclarationContext(p *RecordDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordDeclaration
}

func (*RecordDeclarationContext) IsRecordDeclarationContext() {}

func NewRecordDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordDeclarationContext {
	var p = new(RecordDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordDeclaration

	return p
}

func (s *RecordDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordDeclarationContext) AccessSpecifier() IAccessSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessSpecifierContext)
}

func (s *RecordDeclarationContext) AllRecordDeclarationPart() []IRecordDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IRecordDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordDeclarationPartContext); ok {
			tst[i] = t.(IRecordDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *RecordDeclarationContext) RecordDeclarationPart(i int) IRecordDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDeclarationPartContext)
}

func (s *RecordDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordDeclaration(s)
	}
}

func (s *RecordDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordDeclaration(s)
	}
}

func (s *RecordDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordDeclaration() (localctx IRecordDeclarationContext) {
	localctx = NewRecordDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, pascalParserRULE_recordDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(956)
		p.AccessSpecifier()
	}
	p.SetState(960)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-8193) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-253953) != 0) {
		{
			p.SetState(957)
			p.RecordDeclarationPart()
		}

		p.SetState(962)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordImplicitPublishedDeclarationContext is an interface to support dynamic dispatch.
type IRecordImplicitPublishedDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRecordDeclarationPart() []IRecordDeclarationPartContext
	RecordDeclarationPart(i int) IRecordDeclarationPartContext

	// IsRecordImplicitPublishedDeclarationContext differentiates from other interfaces.
	IsRecordImplicitPublishedDeclarationContext()
}

type RecordImplicitPublishedDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordImplicitPublishedDeclarationContext() *RecordImplicitPublishedDeclarationContext {
	var p = new(RecordImplicitPublishedDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordImplicitPublishedDeclaration
	return p
}

func InitEmptyRecordImplicitPublishedDeclarationContext(p *RecordImplicitPublishedDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordImplicitPublishedDeclaration
}

func (*RecordImplicitPublishedDeclarationContext) IsRecordImplicitPublishedDeclarationContext() {}

func NewRecordImplicitPublishedDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordImplicitPublishedDeclarationContext {
	var p = new(RecordImplicitPublishedDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordImplicitPublishedDeclaration

	return p
}

func (s *RecordImplicitPublishedDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordImplicitPublishedDeclarationContext) AllRecordDeclarationPart() []IRecordDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IRecordDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordDeclarationPartContext); ok {
			tst[i] = t.(IRecordDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *RecordImplicitPublishedDeclarationContext) RecordDeclarationPart(i int) IRecordDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDeclarationPartContext)
}

func (s *RecordImplicitPublishedDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordImplicitPublishedDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordImplicitPublishedDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordImplicitPublishedDeclaration(s)
	}
}

func (s *RecordImplicitPublishedDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordImplicitPublishedDeclaration(s)
	}
}

func (s *RecordImplicitPublishedDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordImplicitPublishedDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordImplicitPublishedDeclaration() (localctx IRecordImplicitPublishedDeclarationContext) {
	localctx = NewRecordImplicitPublishedDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, pascalParserRULE_recordImplicitPublishedDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(966)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-8193) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-253953) != 0) {
		{
			p.SetState(963)
			p.RecordDeclarationPart()
		}

		p.SetState(968)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordDeclarationPartContext is an interface to support dynamic dispatch.
type IRecordDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypedIdentifierList() ITypedIdentifierListContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AttributeSection() IAttributeSectionContext
	TypeDefinitionPart() ITypeDefinitionPartContext
	ConstantDefinitionPart() IConstantDefinitionPartContext
	FunctionHeader() IFunctionHeaderContext
	ProcedureHeader() IProcedureHeaderContext
	ClassOperatorHeader() IClassOperatorHeaderContext
	PropertyDeclaration() IPropertyDeclarationContext
	DEFAULT() antlr.TerminalNode
	ErrorRecordDeclarationPart() IErrorRecordDeclarationPartContext

	// IsRecordDeclarationPartContext differentiates from other interfaces.
	IsRecordDeclarationPartContext()
}

type RecordDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordDeclarationPartContext() *RecordDeclarationPartContext {
	var p = new(RecordDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordDeclarationPart
	return p
}

func InitEmptyRecordDeclarationPartContext(p *RecordDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordDeclarationPart
}

func (*RecordDeclarationPartContext) IsRecordDeclarationPartContext() {}

func NewRecordDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordDeclarationPartContext {
	var p = new(RecordDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordDeclarationPart

	return p
}

func (s *RecordDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordDeclarationPartContext) TypedIdentifierList() ITypedIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIdentifierListContext)
}

func (s *RecordDeclarationPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *RecordDeclarationPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *RecordDeclarationPartContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *RecordDeclarationPartContext) TypeDefinitionPart() ITypeDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionPartContext)
}

func (s *RecordDeclarationPartContext) ConstantDefinitionPart() IConstantDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *RecordDeclarationPartContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *RecordDeclarationPartContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *RecordDeclarationPartContext) ClassOperatorHeader() IClassOperatorHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOperatorHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOperatorHeaderContext)
}

func (s *RecordDeclarationPartContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *RecordDeclarationPartContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *RecordDeclarationPartContext) ErrorRecordDeclarationPart() IErrorRecordDeclarationPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorRecordDeclarationPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorRecordDeclarationPartContext)
}

func (s *RecordDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordDeclarationPart(s)
	}
}

func (s *RecordDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordDeclarationPart(s)
	}
}

func (s *RecordDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordDeclarationPart() (localctx IRecordDeclarationPartContext) {
	localctx = NewRecordDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, pascalParserRULE_recordDeclarationPart)
	var _la int

	p.SetState(989)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(970)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(969)
				p.AttributeSection()
			}

		}
		{
			p.SetState(972)
			p.TypedIdentifierList()
		}
		{
			p.SetState(973)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(975)
			p.TypeDefinitionPart()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(976)
			p.ConstantDefinitionPart()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(977)
			p.FunctionHeader()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(978)
			p.ProcedureHeader()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(979)
			p.ClassOperatorHeader()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(980)
			p.PropertyDeclaration()
		}
		{
			p.SetState(981)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(984)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(982)
				p.Match(pascalParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(983)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(986)
			p.ErrorRecordDeclarationPart()
		}
		{
			p.SetState(987)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorRecordDeclarationPartContext is an interface to support dynamic dispatch.
type IErrorRecordDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRICT() []antlr.TerminalNode
	STRICT(i int) antlr.TerminalNode
	AllPRIVATE() []antlr.TerminalNode
	PRIVATE(i int) antlr.TerminalNode
	AllPROTECTED() []antlr.TerminalNode
	PROTECTED(i int) antlr.TerminalNode
	AllPUBLIC() []antlr.TerminalNode
	PUBLIC(i int) antlr.TerminalNode
	AllPUBLISHED() []antlr.TerminalNode
	PUBLISHED(i int) antlr.TerminalNode
	AllEND() []antlr.TerminalNode
	END(i int) antlr.TerminalNode

	// IsErrorRecordDeclarationPartContext differentiates from other interfaces.
	IsErrorRecordDeclarationPartContext()
}

type ErrorRecordDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorRecordDeclarationPartContext() *ErrorRecordDeclarationPartContext {
	var p = new(ErrorRecordDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorRecordDeclarationPart
	return p
}

func InitEmptyErrorRecordDeclarationPartContext(p *ErrorRecordDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorRecordDeclarationPart
}

func (*ErrorRecordDeclarationPartContext) IsErrorRecordDeclarationPartContext() {}

func NewErrorRecordDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorRecordDeclarationPartContext {
	var p = new(ErrorRecordDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_errorRecordDeclarationPart

	return p
}

func (s *ErrorRecordDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorRecordDeclarationPartContext) AllSTRICT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTRICT)
}

func (s *ErrorRecordDeclarationPartContext) STRICT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTRICT, i)
}

func (s *ErrorRecordDeclarationPartContext) AllPRIVATE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPRIVATE)
}

func (s *ErrorRecordDeclarationPartContext) PRIVATE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPRIVATE, i)
}

func (s *ErrorRecordDeclarationPartContext) AllPROTECTED() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPROTECTED)
}

func (s *ErrorRecordDeclarationPartContext) PROTECTED(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPROTECTED, i)
}

func (s *ErrorRecordDeclarationPartContext) AllPUBLIC() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPUBLIC)
}

func (s *ErrorRecordDeclarationPartContext) PUBLIC(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLIC, i)
}

func (s *ErrorRecordDeclarationPartContext) AllPUBLISHED() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPUBLISHED)
}

func (s *ErrorRecordDeclarationPartContext) PUBLISHED(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLISHED, i)
}

func (s *ErrorRecordDeclarationPartContext) AllEND() []antlr.TerminalNode {
	return s.GetTokens(pascalParserEND)
}

func (s *ErrorRecordDeclarationPartContext) END(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserEND, i)
}

func (s *ErrorRecordDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorRecordDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorRecordDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterErrorRecordDeclarationPart(s)
	}
}

func (s *ErrorRecordDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitErrorRecordDeclarationPart(s)
	}
}

func (s *ErrorRecordDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitErrorRecordDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ErrorRecordDeclarationPart() (localctx IErrorRecordDeclarationPartContext) {
	localctx = NewErrorRecordDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, pascalParserRULE_errorRecordDeclarationPart)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(992)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(991)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || _la == pascalParserEND || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&31) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(994)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordPartsContext is an interface to support dynamic dispatch.
type IRecordPartsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RecordFixedPart() IRecordFixedPartContext
	SEMI() antlr.TerminalNode
	RecordVariantPart() IRecordVariantPartContext

	// IsRecordPartsContext differentiates from other interfaces.
	IsRecordPartsContext()
}

type RecordPartsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordPartsContext() *RecordPartsContext {
	var p = new(RecordPartsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordParts
	return p
}

func InitEmptyRecordPartsContext(p *RecordPartsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordParts
}

func (*RecordPartsContext) IsRecordPartsContext() {}

func NewRecordPartsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordPartsContext {
	var p = new(RecordPartsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordParts

	return p
}

func (s *RecordPartsContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordPartsContext) RecordFixedPart() IRecordFixedPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordFixedPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordFixedPartContext)
}

func (s *RecordPartsContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *RecordPartsContext) RecordVariantPart() IRecordVariantPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordVariantPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordVariantPartContext)
}

func (s *RecordPartsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordPartsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordPartsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordParts(s)
	}
}

func (s *RecordPartsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordParts(s)
	}
}

func (s *RecordPartsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordParts(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordParts() (localctx IRecordPartsContext) {
	localctx = NewRecordPartsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, pascalParserRULE_recordParts)
	var _la int

	p.SetState(1002)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(996)
			p.RecordFixedPart()
		}
		p.SetState(999)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserSEMI {
			{
				p.SetState(997)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(998)
				p.RecordVariantPart()
			}

		}

	case pascalParserCASE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1001)
			p.RecordVariantPart()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordFixedPartContext is an interface to support dynamic dispatch.
type IRecordFixedPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypedIdentifierList() []ITypedIdentifierListContext
	TypedIdentifierList(i int) ITypedIdentifierListContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsRecordFixedPartContext differentiates from other interfaces.
	IsRecordFixedPartContext()
}

type RecordFixedPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordFixedPartContext() *RecordFixedPartContext {
	var p = new(RecordFixedPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordFixedPart
	return p
}

func InitEmptyRecordFixedPartContext(p *RecordFixedPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordFixedPart
}

func (*RecordFixedPartContext) IsRecordFixedPartContext() {}

func NewRecordFixedPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordFixedPartContext {
	var p = new(RecordFixedPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordFixedPart

	return p
}

func (s *RecordFixedPartContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordFixedPartContext) AllTypedIdentifierList() []ITypedIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypedIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]ITypedIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypedIdentifierListContext); ok {
			tst[i] = t.(ITypedIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *RecordFixedPartContext) TypedIdentifierList(i int) ITypedIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIdentifierListContext)
}

func (s *RecordFixedPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *RecordFixedPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *RecordFixedPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordFixedPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordFixedPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordFixedPart(s)
	}
}

func (s *RecordFixedPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordFixedPart(s)
	}
}

func (s *RecordFixedPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordFixedPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordFixedPart() (localctx IRecordFixedPartContext) {
	localctx = NewRecordFixedPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, pascalParserRULE_recordFixedPart)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1004)
		p.TypedIdentifierList()
	}
	p.SetState(1009)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1005)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1006)
				p.TypedIdentifierList()
			}

		}
		p.SetState(1011)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1013)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1012)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordVariantPartContext is an interface to support dynamic dispatch.
type IRecordVariantPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	Tag() ITagContext
	OF() antlr.TerminalNode
	AllRecordVariant() []IRecordVariantContext
	RecordVariant(i int) IRecordVariantContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsRecordVariantPartContext differentiates from other interfaces.
	IsRecordVariantPartContext()
}

type RecordVariantPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordVariantPartContext() *RecordVariantPartContext {
	var p = new(RecordVariantPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordVariantPart
	return p
}

func InitEmptyRecordVariantPartContext(p *RecordVariantPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordVariantPart
}

func (*RecordVariantPartContext) IsRecordVariantPartContext() {}

func NewRecordVariantPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordVariantPartContext {
	var p = new(RecordVariantPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordVariantPart

	return p
}

func (s *RecordVariantPartContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordVariantPartContext) CASE() antlr.TerminalNode {
	return s.GetToken(pascalParserCASE, 0)
}

func (s *RecordVariantPartContext) Tag() ITagContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITagContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITagContext)
}

func (s *RecordVariantPartContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *RecordVariantPartContext) AllRecordVariant() []IRecordVariantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordVariantContext); ok {
			len++
		}
	}

	tst := make([]IRecordVariantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordVariantContext); ok {
			tst[i] = t.(IRecordVariantContext)
			i++
		}
	}

	return tst
}

func (s *RecordVariantPartContext) RecordVariant(i int) IRecordVariantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordVariantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordVariantContext)
}

func (s *RecordVariantPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *RecordVariantPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *RecordVariantPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordVariantPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordVariantPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordVariantPart(s)
	}
}

func (s *RecordVariantPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordVariantPart(s)
	}
}

func (s *RecordVariantPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordVariantPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordVariantPart() (localctx IRecordVariantPartContext) {
	localctx = NewRecordVariantPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, pascalParserRULE_recordVariantPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1015)
		p.Match(pascalParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1016)
		p.Tag()
	}
	{
		p.SetState(1017)
		p.Match(pascalParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1018)
		p.RecordVariant()
	}
	p.SetState(1023)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserSEMI {
		{
			p.SetState(1019)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1020)
			p.RecordVariant()
		}

		p.SetState(1025)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITagContext is an interface to support dynamic dispatch.
type ITagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext

	// IsTagContext differentiates from other interfaces.
	IsTagContext()
}

type TagContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTagContext() *TagContext {
	var p = new(TagContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tag
	return p
}

func InitEmptyTagContext(p *TagContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tag
}

func (*TagContext) IsTagContext() {}

func NewTagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TagContext {
	var p = new(TagContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_tag

	return p
}

func (s *TagContext) GetParser() antlr.Parser { return s.parser }

func (s *TagContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TagContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *TagContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *TagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTag(s)
	}
}

func (s *TagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTag(s)
	}
}

func (s *TagContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTag(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Tag() (localctx ITagContext) {
	localctx = NewTagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, pascalParserRULE_tag)
	p.SetState(1031)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1026)
			p.Identifier()
		}
		{
			p.SetState(1027)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1028)
			p.TypeIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1030)
			p.TypeIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordVariantContext is an interface to support dynamic dispatch.
type IRecordVariantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConstList() IConstListContext
	COLON() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RecordParts() IRecordPartsContext
	RPAREN() antlr.TerminalNode

	// IsRecordVariantContext differentiates from other interfaces.
	IsRecordVariantContext()
}

type RecordVariantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordVariantContext() *RecordVariantContext {
	var p = new(RecordVariantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordVariant
	return p
}

func InitEmptyRecordVariantContext(p *RecordVariantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordVariant
}

func (*RecordVariantContext) IsRecordVariantContext() {}

func NewRecordVariantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordVariantContext {
	var p = new(RecordVariantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordVariant

	return p
}

func (s *RecordVariantContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordVariantContext) ConstList() IConstListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstListContext)
}

func (s *RecordVariantContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *RecordVariantContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *RecordVariantContext) RecordParts() IRecordPartsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordPartsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordPartsContext)
}

func (s *RecordVariantContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *RecordVariantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordVariantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordVariantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordVariant(s)
	}
}

func (s *RecordVariantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordVariant(s)
	}
}

func (s *RecordVariantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordVariant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordVariant() (localctx IRecordVariantContext) {
	localctx = NewRecordVariantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, pascalParserRULE_recordVariant)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1033)
		p.ConstList()
	}
	{
		p.SetState(1034)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1035)
		p.Match(pascalParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1036)
		p.RecordParts()
	}
	{
		p.SetState(1037)
		p.Match(pascalParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHelperTypeContext is an interface to support dynamic dispatch.
type IHelperTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	HELPER() antlr.TerminalNode
	FOR() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	HelperImplicitPublishedDeclaration() IHelperImplicitPublishedDeclarationContext
	END() antlr.TerminalNode
	AllHelperDeclaration() []IHelperDeclarationContext
	HelperDeclaration(i int) IHelperDeclarationContext

	// IsHelperTypeContext differentiates from other interfaces.
	IsHelperTypeContext()
}

type HelperTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelperTypeContext() *HelperTypeContext {
	var p = new(HelperTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperType
	return p
}

func InitEmptyHelperTypeContext(p *HelperTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperType
}

func (*HelperTypeContext) IsHelperTypeContext() {}

func NewHelperTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelperTypeContext {
	var p = new(HelperTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_helperType

	return p
}

func (s *HelperTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *HelperTypeContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *HelperTypeContext) HELPER() antlr.TerminalNode {
	return s.GetToken(pascalParserHELPER, 0)
}

func (s *HelperTypeContext) FOR() antlr.TerminalNode {
	return s.GetToken(pascalParserFOR, 0)
}

func (s *HelperTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *HelperTypeContext) HelperImplicitPublishedDeclaration() IHelperImplicitPublishedDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelperImplicitPublishedDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelperImplicitPublishedDeclarationContext)
}

func (s *HelperTypeContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *HelperTypeContext) AllHelperDeclaration() []IHelperDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHelperDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IHelperDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHelperDeclarationContext); ok {
			tst[i] = t.(IHelperDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *HelperTypeContext) HelperDeclaration(i int) IHelperDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelperDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelperDeclarationContext)
}

func (s *HelperTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelperTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelperTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterHelperType(s)
	}
}

func (s *HelperTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitHelperType(s)
	}
}

func (s *HelperTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitHelperType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) HelperType() (localctx IHelperTypeContext) {
	localctx = NewHelperTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, pascalParserRULE_helperType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1039)
		p.Match(pascalParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1040)
		p.Match(pascalParserHELPER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1041)
		p.Match(pascalParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1042)
		p.TypeIdentifier()
	}
	{
		p.SetState(1043)
		p.HelperImplicitPublishedDeclaration()
	}
	p.SetState(1047)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&31) != 0 {
		{
			p.SetState(1044)
			p.HelperDeclaration()
		}

		p.SetState(1049)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1050)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHelperDeclarationContext is an interface to support dynamic dispatch.
type IHelperDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AccessSpecifier() IAccessSpecifierContext
	AllHelperDeclarationPart() []IHelperDeclarationPartContext
	HelperDeclarationPart(i int) IHelperDeclarationPartContext

	// IsHelperDeclarationContext differentiates from other interfaces.
	IsHelperDeclarationContext()
}

type HelperDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelperDeclarationContext() *HelperDeclarationContext {
	var p = new(HelperDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperDeclaration
	return p
}

func InitEmptyHelperDeclarationContext(p *HelperDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperDeclaration
}

func (*HelperDeclarationContext) IsHelperDeclarationContext() {}

func NewHelperDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelperDeclarationContext {
	var p = new(HelperDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_helperDeclaration

	return p
}

func (s *HelperDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *HelperDeclarationContext) AccessSpecifier() IAccessSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessSpecifierContext)
}

func (s *HelperDeclarationContext) AllHelperDeclarationPart() []IHelperDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHelperDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IHelperDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHelperDeclarationPartContext); ok {
			tst[i] = t.(IHelperDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *HelperDeclarationContext) HelperDeclarationPart(i int) IHelperDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelperDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelperDeclarationPartContext)
}

func (s *HelperDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelperDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelperDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterHelperDeclaration(s)
	}
}

func (s *HelperDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitHelperDeclaration(s)
	}
}

func (s *HelperDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitHelperDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) HelperDeclaration() (localctx IHelperDeclarationContext) {
	localctx = NewHelperDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, pascalParserRULE_helperDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1052)
		p.AccessSpecifier()
	}
	p.SetState(1056)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-8193) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-253953) != 0) {
		{
			p.SetState(1053)
			p.HelperDeclarationPart()
		}

		p.SetState(1058)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHelperImplicitPublishedDeclarationContext is an interface to support dynamic dispatch.
type IHelperImplicitPublishedDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllHelperDeclarationPart() []IHelperDeclarationPartContext
	HelperDeclarationPart(i int) IHelperDeclarationPartContext

	// IsHelperImplicitPublishedDeclarationContext differentiates from other interfaces.
	IsHelperImplicitPublishedDeclarationContext()
}

type HelperImplicitPublishedDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelperImplicitPublishedDeclarationContext() *HelperImplicitPublishedDeclarationContext {
	var p = new(HelperImplicitPublishedDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperImplicitPublishedDeclaration
	return p
}

func InitEmptyHelperImplicitPublishedDeclarationContext(p *HelperImplicitPublishedDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperImplicitPublishedDeclaration
}

func (*HelperImplicitPublishedDeclarationContext) IsHelperImplicitPublishedDeclarationContext() {}

func NewHelperImplicitPublishedDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelperImplicitPublishedDeclarationContext {
	var p = new(HelperImplicitPublishedDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_helperImplicitPublishedDeclaration

	return p
}

func (s *HelperImplicitPublishedDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *HelperImplicitPublishedDeclarationContext) AllHelperDeclarationPart() []IHelperDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHelperDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IHelperDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHelperDeclarationPartContext); ok {
			tst[i] = t.(IHelperDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *HelperImplicitPublishedDeclarationContext) HelperDeclarationPart(i int) IHelperDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelperDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelperDeclarationPartContext)
}

func (s *HelperImplicitPublishedDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelperImplicitPublishedDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelperImplicitPublishedDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterHelperImplicitPublishedDeclaration(s)
	}
}

func (s *HelperImplicitPublishedDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitHelperImplicitPublishedDeclaration(s)
	}
}

func (s *HelperImplicitPublishedDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitHelperImplicitPublishedDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) HelperImplicitPublishedDeclaration() (localctx IHelperImplicitPublishedDeclarationContext) {
	localctx = NewHelperImplicitPublishedDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, pascalParserRULE_helperImplicitPublishedDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1062)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-8193) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-253953) != 0) {
		{
			p.SetState(1059)
			p.HelperDeclarationPart()
		}

		p.SetState(1064)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHelperDeclarationPartContext is an interface to support dynamic dispatch.
type IHelperDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeDefinitionPart() ITypeDefinitionPartContext
	ConstantDefinitionPart() IConstantDefinitionPartContext
	FunctionHeader() IFunctionHeaderContext
	ProcedureHeader() IProcedureHeaderContext
	PropertyDeclaration() IPropertyDeclarationContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	ErrorHelperDeclarationPart() IErrorHelperDeclarationPartContext

	// IsHelperDeclarationPartContext differentiates from other interfaces.
	IsHelperDeclarationPartContext()
}

type HelperDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelperDeclarationPartContext() *HelperDeclarationPartContext {
	var p = new(HelperDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperDeclarationPart
	return p
}

func InitEmptyHelperDeclarationPartContext(p *HelperDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperDeclarationPart
}

func (*HelperDeclarationPartContext) IsHelperDeclarationPartContext() {}

func NewHelperDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelperDeclarationPartContext {
	var p = new(HelperDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_helperDeclarationPart

	return p
}

func (s *HelperDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *HelperDeclarationPartContext) TypeDefinitionPart() ITypeDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionPartContext)
}

func (s *HelperDeclarationPartContext) ConstantDefinitionPart() IConstantDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *HelperDeclarationPartContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *HelperDeclarationPartContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *HelperDeclarationPartContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *HelperDeclarationPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *HelperDeclarationPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *HelperDeclarationPartContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *HelperDeclarationPartContext) ErrorHelperDeclarationPart() IErrorHelperDeclarationPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorHelperDeclarationPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorHelperDeclarationPartContext)
}

func (s *HelperDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelperDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelperDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterHelperDeclarationPart(s)
	}
}

func (s *HelperDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitHelperDeclarationPart(s)
	}
}

func (s *HelperDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitHelperDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) HelperDeclarationPart() (localctx IHelperDeclarationPartContext) {
	localctx = NewHelperDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, pascalParserRULE_helperDeclarationPart)
	p.SetState(1078)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1065)
			p.TypeDefinitionPart()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1066)
			p.ConstantDefinitionPart()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1067)
			p.FunctionHeader()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1068)
			p.ProcedureHeader()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1069)
			p.PropertyDeclaration()
		}
		{
			p.SetState(1070)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1073)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1071)
				p.Match(pascalParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1072)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1075)
			p.ErrorHelperDeclarationPart()
		}
		{
			p.SetState(1076)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorHelperDeclarationPartContext is an interface to support dynamic dispatch.
type IErrorHelperDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRICT() []antlr.TerminalNode
	STRICT(i int) antlr.TerminalNode
	AllPRIVATE() []antlr.TerminalNode
	PRIVATE(i int) antlr.TerminalNode
	AllPROTECTED() []antlr.TerminalNode
	PROTECTED(i int) antlr.TerminalNode
	AllPUBLIC() []antlr.TerminalNode
	PUBLIC(i int) antlr.TerminalNode
	AllPUBLISHED() []antlr.TerminalNode
	PUBLISHED(i int) antlr.TerminalNode
	AllEND() []antlr.TerminalNode
	END(i int) antlr.TerminalNode

	// IsErrorHelperDeclarationPartContext differentiates from other interfaces.
	IsErrorHelperDeclarationPartContext()
}

type ErrorHelperDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorHelperDeclarationPartContext() *ErrorHelperDeclarationPartContext {
	var p = new(ErrorHelperDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorHelperDeclarationPart
	return p
}

func InitEmptyErrorHelperDeclarationPartContext(p *ErrorHelperDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorHelperDeclarationPart
}

func (*ErrorHelperDeclarationPartContext) IsErrorHelperDeclarationPartContext() {}

func NewErrorHelperDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorHelperDeclarationPartContext {
	var p = new(ErrorHelperDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_errorHelperDeclarationPart

	return p
}

func (s *ErrorHelperDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorHelperDeclarationPartContext) AllSTRICT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTRICT)
}

func (s *ErrorHelperDeclarationPartContext) STRICT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTRICT, i)
}

func (s *ErrorHelperDeclarationPartContext) AllPRIVATE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPRIVATE)
}

func (s *ErrorHelperDeclarationPartContext) PRIVATE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPRIVATE, i)
}

func (s *ErrorHelperDeclarationPartContext) AllPROTECTED() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPROTECTED)
}

func (s *ErrorHelperDeclarationPartContext) PROTECTED(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPROTECTED, i)
}

func (s *ErrorHelperDeclarationPartContext) AllPUBLIC() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPUBLIC)
}

func (s *ErrorHelperDeclarationPartContext) PUBLIC(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLIC, i)
}

func (s *ErrorHelperDeclarationPartContext) AllPUBLISHED() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPUBLISHED)
}

func (s *ErrorHelperDeclarationPartContext) PUBLISHED(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLISHED, i)
}

func (s *ErrorHelperDeclarationPartContext) AllEND() []antlr.TerminalNode {
	return s.GetTokens(pascalParserEND)
}

func (s *ErrorHelperDeclarationPartContext) END(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserEND, i)
}

func (s *ErrorHelperDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorHelperDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorHelperDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterErrorHelperDeclarationPart(s)
	}
}

func (s *ErrorHelperDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitErrorHelperDeclarationPart(s)
	}
}

func (s *ErrorHelperDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitErrorHelperDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ErrorHelperDeclarationPart() (localctx IErrorHelperDeclarationPartContext) {
	localctx = NewErrorHelperDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, pascalParserRULE_errorHelperDeclarationPart)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1081)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1080)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || _la == pascalParserEND || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&31) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1083)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetTypeContext is an interface to support dynamic dispatch.
type ISetTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	OF() antlr.TerminalNode
	SimpleType() ISimpleTypeContext

	// IsSetTypeContext differentiates from other interfaces.
	IsSetTypeContext()
}

type SetTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetTypeContext() *SetTypeContext {
	var p = new(SetTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_setType
	return p
}

func InitEmptySetTypeContext(p *SetTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_setType
}

func (*SetTypeContext) IsSetTypeContext() {}

func NewSetTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetTypeContext {
	var p = new(SetTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_setType

	return p
}

func (s *SetTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SetTypeContext) SET() antlr.TerminalNode {
	return s.GetToken(pascalParserSET, 0)
}

func (s *SetTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *SetTypeContext) SimpleType() ISimpleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeContext)
}

func (s *SetTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSetType(s)
	}
}

func (s *SetTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSetType(s)
	}
}

func (s *SetTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSetType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SetType() (localctx ISetTypeContext) {
	localctx = NewSetTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, pascalParserRULE_setType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1085)
		p.Match(pascalParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1086)
		p.Match(pascalParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1087)
		p.SimpleType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFileTypeContext is an interface to support dynamic dispatch.
type IFileTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FILE() antlr.TerminalNode
	OF() antlr.TerminalNode
	Type_() IType_Context

	// IsFileTypeContext differentiates from other interfaces.
	IsFileTypeContext()
}

type FileTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileTypeContext() *FileTypeContext {
	var p = new(FileTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_fileType
	return p
}

func InitEmptyFileTypeContext(p *FileTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_fileType
}

func (*FileTypeContext) IsFileTypeContext() {}

func NewFileTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileTypeContext {
	var p = new(FileTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_fileType

	return p
}

func (s *FileTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FileTypeContext) FILE() antlr.TerminalNode {
	return s.GetToken(pascalParserFILE, 0)
}

func (s *FileTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *FileTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *FileTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFileType(s)
	}
}

func (s *FileTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFileType(s)
	}
}

func (s *FileTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFileType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FileType() (localctx IFileTypeContext) {
	localctx = NewFileTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, pascalParserRULE_fileType)
	p.SetState(1093)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1089)
			p.Match(pascalParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1090)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1091)
			p.Type_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1092)
			p.Match(pascalParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPointerTypeContext is an interface to support dynamic dispatch.
type IPointerTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEREFERENCE() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext

	// IsPointerTypeContext differentiates from other interfaces.
	IsPointerTypeContext()
}

type PointerTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPointerTypeContext() *PointerTypeContext {
	var p = new(PointerTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_pointerType
	return p
}

func InitEmptyPointerTypeContext(p *PointerTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_pointerType
}

func (*PointerTypeContext) IsPointerTypeContext() {}

func NewPointerTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PointerTypeContext {
	var p = new(PointerTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_pointerType

	return p
}

func (s *PointerTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PointerTypeContext) DEREFERENCE() antlr.TerminalNode {
	return s.GetToken(pascalParserDEREFERENCE, 0)
}

func (s *PointerTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *PointerTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PointerTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PointerTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPointerType(s)
	}
}

func (s *PointerTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPointerType(s)
	}
}

func (s *PointerTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPointerType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PointerType() (localctx IPointerTypeContext) {
	localctx = NewPointerTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, pascalParserRULE_pointerType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1095)
		p.Match(pascalParserDEREFERENCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1096)
		p.TypeIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationPartContext is an interface to support dynamic dispatch.
type IVariableDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VAR() antlr.TerminalNode
	AllVariableDeclaration() []IVariableDeclarationContext
	VariableDeclaration(i int) IVariableDeclarationContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsVariableDeclarationPartContext differentiates from other interfaces.
	IsVariableDeclarationPartContext()
}

type VariableDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationPartContext() *VariableDeclarationPartContext {
	var p = new(VariableDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclarationPart
	return p
}

func InitEmptyVariableDeclarationPartContext(p *VariableDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclarationPart
}

func (*VariableDeclarationPartContext) IsVariableDeclarationPartContext() {}

func NewVariableDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationPartContext {
	var p = new(VariableDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_variableDeclarationPart

	return p
}

func (s *VariableDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationPartContext) VAR() antlr.TerminalNode {
	return s.GetToken(pascalParserVAR, 0)
}

func (s *VariableDeclarationPartContext) AllVariableDeclaration() []IVariableDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationContext); ok {
			tst[i] = t.(IVariableDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclarationPartContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *VariableDeclarationPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *VariableDeclarationPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *VariableDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterVariableDeclarationPart(s)
	}
}

func (s *VariableDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitVariableDeclarationPart(s)
	}
}

func (s *VariableDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitVariableDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) VariableDeclarationPart() (localctx IVariableDeclarationPartContext) {
	localctx = NewVariableDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, pascalParserRULE_variableDeclarationPart)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1098)
		p.Match(pascalParserVAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1099)
		p.VariableDeclaration()
	}
	p.SetState(1104)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1100)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1101)
				p.VariableDeclaration()
			}

		}
		p.SetState(1106)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1107)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypedIdentifierList() ITypedIdentifierListContext
	AttributeSection() IAttributeSectionContext
	EQUAL() antlr.TerminalNode
	SimpleExpression() ISimpleExpressionContext

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclaration
	return p
}

func InitEmptyVariableDeclarationContext(p *VariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclaration
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) TypedIdentifierList() ITypedIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIdentifierListContext)
}

func (s *VariableDeclarationContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *VariableDeclarationContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *VariableDeclarationContext) SimpleExpression() ISimpleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExpressionContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitVariableDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, pascalParserRULE_variableDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1110)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLBRACK {
		{
			p.SetState(1109)
			p.AttributeSection()
		}

	}
	{
		p.SetState(1112)
		p.TypedIdentifierList()
	}
	p.SetState(1115)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserEQUAL {
		{
			p.SetState(1113)
			p.Match(pascalParserEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1114)
			p.SimpleExpression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureHeaderContext is an interface to support dynamic dispatch.
type IProcedureHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext
	SEMI() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	CONSTRUCTOR() antlr.TerminalNode
	DESTRUCTOR() antlr.TerminalNode
	AttributeSection() IAttributeSectionContext
	CLASS() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext

	// IsProcedureHeaderContext differentiates from other interfaces.
	IsProcedureHeaderContext()
}

type ProcedureHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureHeaderContext() *ProcedureHeaderContext {
	var p = new(ProcedureHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureHeader
	return p
}

func InitEmptyProcedureHeaderContext(p *ProcedureHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureHeader
}

func (*ProcedureHeaderContext) IsProcedureHeaderContext() {}

func NewProcedureHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureHeaderContext {
	var p = new(ProcedureHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureHeader

	return p
}

func (s *ProcedureHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureHeaderContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ProcedureHeaderContext) ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderModifiersContext)
}

func (s *ProcedureHeaderContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ProcedureHeaderContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(pascalParserPROCEDURE, 0)
}

func (s *ProcedureHeaderContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(pascalParserCONSTRUCTOR, 0)
}

func (s *ProcedureHeaderContext) DESTRUCTOR() antlr.TerminalNode {
	return s.GetToken(pascalParserDESTRUCTOR, 0)
}

func (s *ProcedureHeaderContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *ProcedureHeaderContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *ProcedureHeaderContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ProcedureHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureHeader(s)
	}
}

func (s *ProcedureHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureHeader(s)
	}
}

func (s *ProcedureHeaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureHeader(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureHeader() (localctx IProcedureHeaderContext) {
	localctx = NewProcedureHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, pascalParserRULE_procedureHeader)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1118)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLBRACK {
		{
			p.SetState(1117)
			p.AttributeSection()
		}

	}
	p.SetState(1121)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserCLASS {
		{
			p.SetState(1120)
			p.Match(pascalParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1123)
		_la = p.GetTokenStream().LA(1)

		if !(_la == pascalParserPROCEDURE || _la == pascalParserCONSTRUCTOR || _la == pascalParserDESTRUCTOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1124)
		p.Identifier()
	}
	p.SetState(1126)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1125)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1128)
		p.ProcedureOrFunctionHeaderModifiers()
	}
	{
		p.SetState(1129)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionHeaderContext is an interface to support dynamic dispatch.
type IFunctionHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNCTION() antlr.TerminalNode
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	ResultType() IResultTypeContext
	ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext
	SEMI() antlr.TerminalNode
	AttributeSection() IAttributeSectionContext
	CLASS() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext

	// IsFunctionHeaderContext differentiates from other interfaces.
	IsFunctionHeaderContext()
}

type FunctionHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionHeaderContext() *FunctionHeaderContext {
	var p = new(FunctionHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionHeader
	return p
}

func InitEmptyFunctionHeaderContext(p *FunctionHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionHeader
}

func (*FunctionHeaderContext) IsFunctionHeaderContext() {}

func NewFunctionHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionHeaderContext {
	var p = new(FunctionHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_functionHeader

	return p
}

func (s *FunctionHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionHeaderContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(pascalParserFUNCTION, 0)
}

func (s *FunctionHeaderContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionHeaderContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *FunctionHeaderContext) ResultType() IResultTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultTypeContext)
}

func (s *FunctionHeaderContext) ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderModifiersContext)
}

func (s *FunctionHeaderContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *FunctionHeaderContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *FunctionHeaderContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *FunctionHeaderContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFunctionHeader(s)
	}
}

func (s *FunctionHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFunctionHeader(s)
	}
}

func (s *FunctionHeaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFunctionHeader(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FunctionHeader() (localctx IFunctionHeaderContext) {
	localctx = NewFunctionHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, pascalParserRULE_functionHeader)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1132)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLBRACK {
		{
			p.SetState(1131)
			p.AttributeSection()
		}

	}
	p.SetState(1135)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserCLASS {
		{
			p.SetState(1134)
			p.Match(pascalParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1137)
		p.Match(pascalParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1138)
		p.Identifier()
	}
	p.SetState(1140)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1139)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1142)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1143)
		p.ResultType()
	}
	{
		p.SetState(1144)
		p.ProcedureOrFunctionHeaderModifiers()
	}
	{
		p.SetState(1145)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureOrFunctionHeaderContext is an interface to support dynamic dispatch.
type IProcedureOrFunctionHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ProcedureHeader() IProcedureHeaderContext
	FunctionHeader() IFunctionHeaderContext

	// IsProcedureOrFunctionHeaderContext differentiates from other interfaces.
	IsProcedureOrFunctionHeaderContext()
}

type ProcedureOrFunctionHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureOrFunctionHeaderContext() *ProcedureOrFunctionHeaderContext {
	var p = new(ProcedureOrFunctionHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeader
	return p
}

func InitEmptyProcedureOrFunctionHeaderContext(p *ProcedureOrFunctionHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeader
}

func (*ProcedureOrFunctionHeaderContext) IsProcedureOrFunctionHeaderContext() {}

func NewProcedureOrFunctionHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureOrFunctionHeaderContext {
	var p = new(ProcedureOrFunctionHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeader

	return p
}

func (s *ProcedureOrFunctionHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureOrFunctionHeaderContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *ProcedureOrFunctionHeaderContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *ProcedureOrFunctionHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureOrFunctionHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureOrFunctionHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureOrFunctionHeader(s)
	}
}

func (s *ProcedureOrFunctionHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureOrFunctionHeader(s)
	}
}

func (s *ProcedureOrFunctionHeaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureOrFunctionHeader(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureOrFunctionHeader() (localctx IProcedureOrFunctionHeaderContext) {
	localctx = NewProcedureOrFunctionHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, pascalParserRULE_procedureOrFunctionHeader)
	p.SetState(1149)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1147)
			p.ProcedureHeader()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1148)
			p.FunctionHeader()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureOrFunctionHeaderModifiersContext is an interface to support dynamic dispatch.
type IProcedureOrFunctionHeaderModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AllABSTRACT() []antlr.TerminalNode
	ABSTRACT(i int) antlr.TerminalNode
	AllVIRTUAL() []antlr.TerminalNode
	VIRTUAL(i int) antlr.TerminalNode
	AllOVERRIDE() []antlr.TerminalNode
	OVERRIDE(i int) antlr.TerminalNode
	AllREINTRODUCE() []antlr.TerminalNode
	REINTRODUCE(i int) antlr.TerminalNode
	AllOVERLOAD() []antlr.TerminalNode
	OVERLOAD(i int) antlr.TerminalNode
	AllINLINE() []antlr.TerminalNode
	INLINE(i int) antlr.TerminalNode
	AllSTDCALL() []antlr.TerminalNode
	STDCALL(i int) antlr.TerminalNode
	AllCDECL() []antlr.TerminalNode
	CDECL(i int) antlr.TerminalNode
	AllSTATIC() []antlr.TerminalNode
	STATIC(i int) antlr.TerminalNode

	// IsProcedureOrFunctionHeaderModifiersContext differentiates from other interfaces.
	IsProcedureOrFunctionHeaderModifiersContext()
}

type ProcedureOrFunctionHeaderModifiersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureOrFunctionHeaderModifiersContext() *ProcedureOrFunctionHeaderModifiersContext {
	var p = new(ProcedureOrFunctionHeaderModifiersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeaderModifiers
	return p
}

func InitEmptyProcedureOrFunctionHeaderModifiersContext(p *ProcedureOrFunctionHeaderModifiersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeaderModifiers
}

func (*ProcedureOrFunctionHeaderModifiersContext) IsProcedureOrFunctionHeaderModifiersContext() {}

func NewProcedureOrFunctionHeaderModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureOrFunctionHeaderModifiersContext {
	var p = new(ProcedureOrFunctionHeaderModifiersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeaderModifiers

	return p
}

func (s *ProcedureOrFunctionHeaderModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureOrFunctionHeaderModifiersContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllABSTRACT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserABSTRACT)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) ABSTRACT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserABSTRACT, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllVIRTUAL() []antlr.TerminalNode {
	return s.GetTokens(pascalParserVIRTUAL)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) VIRTUAL(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserVIRTUAL, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllOVERRIDE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserOVERRIDE)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) OVERRIDE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserOVERRIDE, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllREINTRODUCE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserREINTRODUCE)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) REINTRODUCE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserREINTRODUCE, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllOVERLOAD() []antlr.TerminalNode {
	return s.GetTokens(pascalParserOVERLOAD)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) OVERLOAD(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserOVERLOAD, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllINLINE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserINLINE)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) INLINE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserINLINE, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllSTDCALL() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTDCALL)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) STDCALL(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTDCALL, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllCDECL() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCDECL)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) CDECL(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCDECL, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllSTATIC() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTATIC)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) STATIC(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTATIC, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureOrFunctionHeaderModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureOrFunctionHeaderModifiers(s)
	}
}

func (s *ProcedureOrFunctionHeaderModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureOrFunctionHeaderModifiers(s)
	}
}

func (s *ProcedureOrFunctionHeaderModifiersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureOrFunctionHeaderModifiers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureOrFunctionHeaderModifiers() (localctx IProcedureOrFunctionHeaderModifiersContext) {
	localctx = NewProcedureOrFunctionHeaderModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, pascalParserRULE_procedureOrFunctionHeaderModifiers)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1155)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1151)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1152)
				_la = p.GetTokenStream().LA(1)

				if !((int64((_la-97)) & ^0x3f) == 0 && ((int64(1)<<(_la-97))&511) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1157)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureOrFunctionDeclarationContext is an interface to support dynamic dispatch.
type IProcedureOrFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ProcedureDeclaration() IProcedureDeclarationContext
	FunctionDeclaration() IFunctionDeclarationContext

	// IsProcedureOrFunctionDeclarationContext differentiates from other interfaces.
	IsProcedureOrFunctionDeclarationContext()
}

type ProcedureOrFunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureOrFunctionDeclarationContext() *ProcedureOrFunctionDeclarationContext {
	var p = new(ProcedureOrFunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionDeclaration
	return p
}

func InitEmptyProcedureOrFunctionDeclarationContext(p *ProcedureOrFunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionDeclaration
}

func (*ProcedureOrFunctionDeclarationContext) IsProcedureOrFunctionDeclarationContext() {}

func NewProcedureOrFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureOrFunctionDeclarationContext {
	var p = new(ProcedureOrFunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureOrFunctionDeclaration

	return p
}

func (s *ProcedureOrFunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureOrFunctionDeclarationContext) ProcedureDeclaration() IProcedureDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureDeclarationContext)
}

func (s *ProcedureOrFunctionDeclarationContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *ProcedureOrFunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureOrFunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureOrFunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureOrFunctionDeclaration(s)
	}
}

func (s *ProcedureOrFunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureOrFunctionDeclaration(s)
	}
}

func (s *ProcedureOrFunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureOrFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureOrFunctionDeclaration() (localctx IProcedureOrFunctionDeclarationContext) {
	localctx = NewProcedureOrFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, pascalParserRULE_procedureOrFunctionDeclaration)
	p.SetState(1160)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 116, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1158)
			p.ProcedureDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1159)
			p.FunctionDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureDeclarationContext is an interface to support dynamic dispatch.
type IProcedureDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ProcedureHeader() IProcedureHeaderContext
	ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext
	SEMI() antlr.TerminalNode

	// IsProcedureDeclarationContext differentiates from other interfaces.
	IsProcedureDeclarationContext()
}

type ProcedureDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDeclarationContext() *ProcedureDeclarationContext {
	var p = new(ProcedureDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureDeclaration
	return p
}

func InitEmptyProcedureDeclarationContext(p *ProcedureDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureDeclaration
}

func (*ProcedureDeclarationContext) IsProcedureDeclarationContext() {}

func NewProcedureDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDeclarationContext {
	var p = new(ProcedureDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureDeclaration

	return p
}

func (s *ProcedureDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDeclarationContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *ProcedureDeclarationContext) ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionBodyContext)
}

func (s *ProcedureDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ProcedureDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureDeclaration(s)
	}
}

func (s *ProcedureDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureDeclaration(s)
	}
}

func (s *ProcedureDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureDeclaration() (localctx IProcedureDeclarationContext) {
	localctx = NewProcedureDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, pascalParserRULE_procedureDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1162)
		p.ProcedureHeader()
	}
	{
		p.SetState(1163)
		p.ProcedureOrFunctionBody()
	}
	{
		p.SetState(1164)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionHeader() IFunctionHeaderContext
	ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext
	SEMI() antlr.TerminalNode

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionDeclaration
	return p
}

func InitEmptyFunctionDeclarationContext(p *FunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionDeclaration
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *FunctionDeclarationContext) ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionBodyContext)
}

func (s *FunctionDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, pascalParserRULE_functionDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1166)
		p.FunctionHeader()
	}
	{
		p.SetState(1167)
		p.ProcedureOrFunctionBody()
	}
	{
		p.SetState(1168)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureLambdaDeclarationContext is an interface to support dynamic dispatch.
type IProcedureLambdaDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROCEDURE() antlr.TerminalNode
	ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext
	FormalParameterList() IFormalParameterListContext

	// IsProcedureLambdaDeclarationContext differentiates from other interfaces.
	IsProcedureLambdaDeclarationContext()
}

type ProcedureLambdaDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureLambdaDeclarationContext() *ProcedureLambdaDeclarationContext {
	var p = new(ProcedureLambdaDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureLambdaDeclaration
	return p
}

func InitEmptyProcedureLambdaDeclarationContext(p *ProcedureLambdaDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureLambdaDeclaration
}

func (*ProcedureLambdaDeclarationContext) IsProcedureLambdaDeclarationContext() {}

func NewProcedureLambdaDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureLambdaDeclarationContext {
	var p = new(ProcedureLambdaDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureLambdaDeclaration

	return p
}

func (s *ProcedureLambdaDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureLambdaDeclarationContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(pascalParserPROCEDURE, 0)
}

func (s *ProcedureLambdaDeclarationContext) ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionBodyContext)
}

func (s *ProcedureLambdaDeclarationContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ProcedureLambdaDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureLambdaDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureLambdaDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureLambdaDeclaration(s)
	}
}

func (s *ProcedureLambdaDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureLambdaDeclaration(s)
	}
}

func (s *ProcedureLambdaDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureLambdaDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureLambdaDeclaration() (localctx IProcedureLambdaDeclarationContext) {
	localctx = NewProcedureLambdaDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, pascalParserRULE_procedureLambdaDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1170)
		p.Match(pascalParserPROCEDURE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1172)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1171)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1174)
		p.ProcedureOrFunctionBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionLambdaDeclarationContext is an interface to support dynamic dispatch.
type IFunctionLambdaDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNCTION() antlr.TerminalNode
	ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext
	COLON() antlr.TerminalNode
	ResultType() IResultTypeContext
	FormalParameterList() IFormalParameterListContext

	// IsFunctionLambdaDeclarationContext differentiates from other interfaces.
	IsFunctionLambdaDeclarationContext()
}

type FunctionLambdaDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionLambdaDeclarationContext() *FunctionLambdaDeclarationContext {
	var p = new(FunctionLambdaDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionLambdaDeclaration
	return p
}

func InitEmptyFunctionLambdaDeclarationContext(p *FunctionLambdaDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionLambdaDeclaration
}

func (*FunctionLambdaDeclarationContext) IsFunctionLambdaDeclarationContext() {}

func NewFunctionLambdaDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionLambdaDeclarationContext {
	var p = new(FunctionLambdaDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_functionLambdaDeclaration

	return p
}

func (s *FunctionLambdaDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionLambdaDeclarationContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(pascalParserFUNCTION, 0)
}

func (s *FunctionLambdaDeclarationContext) ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionBodyContext)
}

func (s *FunctionLambdaDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *FunctionLambdaDeclarationContext) ResultType() IResultTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultTypeContext)
}

func (s *FunctionLambdaDeclarationContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionLambdaDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionLambdaDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionLambdaDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFunctionLambdaDeclaration(s)
	}
}

func (s *FunctionLambdaDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFunctionLambdaDeclaration(s)
	}
}

func (s *FunctionLambdaDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFunctionLambdaDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FunctionLambdaDeclaration() (localctx IFunctionLambdaDeclarationContext) {
	localctx = NewFunctionLambdaDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, pascalParserRULE_functionLambdaDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1176)
		p.Match(pascalParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1178)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1177)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1180)
		p.ProcedureOrFunctionBody()
	}
	{
		p.SetState(1181)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1182)
		p.ResultType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResultTypeContext is an interface to support dynamic dispatch.
type IResultTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIdentifier() ITypeIdentifierContext

	// IsResultTypeContext differentiates from other interfaces.
	IsResultTypeContext()
}

type ResultTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResultTypeContext() *ResultTypeContext {
	var p = new(ResultTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resultType
	return p
}

func InitEmptyResultTypeContext(p *ResultTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resultType
}

func (*ResultTypeContext) IsResultTypeContext() {}

func NewResultTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResultTypeContext {
	var p = new(ResultTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_resultType

	return p
}

func (s *ResultTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ResultTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ResultTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResultTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResultTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterResultType(s)
	}
}

func (s *ResultTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitResultType(s)
	}
}

func (s *ResultTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitResultType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ResultType() (localctx IResultTypeContext) {
	localctx = NewResultTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, pascalParserRULE_resultType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1184)
		p.TypeIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureOrFunctionBodyContext is an interface to support dynamic dispatch.
type IProcedureOrFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	CompoundStatement() ICompoundStatementContext

	// IsProcedureOrFunctionBodyContext differentiates from other interfaces.
	IsProcedureOrFunctionBodyContext()
}

type ProcedureOrFunctionBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureOrFunctionBodyContext() *ProcedureOrFunctionBodyContext {
	var p = new(ProcedureOrFunctionBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionBody
	return p
}

func InitEmptyProcedureOrFunctionBodyContext(p *ProcedureOrFunctionBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionBody
}

func (*ProcedureOrFunctionBodyContext) IsProcedureOrFunctionBodyContext() {}

func NewProcedureOrFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureOrFunctionBodyContext {
	var p = new(ProcedureOrFunctionBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureOrFunctionBody

	return p
}

func (s *ProcedureOrFunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureOrFunctionBodyContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ProcedureOrFunctionBodyContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *ProcedureOrFunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureOrFunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureOrFunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureOrFunctionBody(s)
	}
}

func (s *ProcedureOrFunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureOrFunctionBody(s)
	}
}

func (s *ProcedureOrFunctionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureOrFunctionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureOrFunctionBody() (localctx IProcedureOrFunctionBodyContext) {
	localctx = NewProcedureOrFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, pascalParserRULE_procedureOrFunctionBody)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1186)
		p.Block()
	}
	{
		p.SetState(1187)
		p.CompoundStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassOperatorHeaderContext is an interface to support dynamic dispatch.
type IClassOperatorHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	OPERATOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	ResultType() IResultTypeContext
	ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext
	SEMI() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext

	// IsClassOperatorHeaderContext differentiates from other interfaces.
	IsClassOperatorHeaderContext()
}

type ClassOperatorHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOperatorHeaderContext() *ClassOperatorHeaderContext {
	var p = new(ClassOperatorHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classOperatorHeader
	return p
}

func InitEmptyClassOperatorHeaderContext(p *ClassOperatorHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classOperatorHeader
}

func (*ClassOperatorHeaderContext) IsClassOperatorHeaderContext() {}

func NewClassOperatorHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOperatorHeaderContext {
	var p = new(ClassOperatorHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classOperatorHeader

	return p
}

func (s *ClassOperatorHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOperatorHeaderContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *ClassOperatorHeaderContext) OPERATOR() antlr.TerminalNode {
	return s.GetToken(pascalParserOPERATOR, 0)
}

func (s *ClassOperatorHeaderContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassOperatorHeaderContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *ClassOperatorHeaderContext) ResultType() IResultTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultTypeContext)
}

func (s *ClassOperatorHeaderContext) ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderModifiersContext)
}

func (s *ClassOperatorHeaderContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ClassOperatorHeaderContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ClassOperatorHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOperatorHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOperatorHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassOperatorHeader(s)
	}
}

func (s *ClassOperatorHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassOperatorHeader(s)
	}
}

func (s *ClassOperatorHeaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassOperatorHeader(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassOperatorHeader() (localctx IClassOperatorHeaderContext) {
	localctx = NewClassOperatorHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, pascalParserRULE_classOperatorHeader)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1189)
		p.Match(pascalParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1190)
		p.Match(pascalParserOPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1191)
		p.Identifier()
	}
	p.SetState(1193)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1192)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1195)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1196)
		p.ResultType()
	}
	{
		p.SetState(1197)
		p.ProcedureOrFunctionHeaderModifiers()
	}
	{
		p.SetState(1198)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassOperatorDeclarationContext is an interface to support dynamic dispatch.
type IClassOperatorDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassOperatorHeader() IClassOperatorHeaderContext
	ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext
	SEMI() antlr.TerminalNode

	// IsClassOperatorDeclarationContext differentiates from other interfaces.
	IsClassOperatorDeclarationContext()
}

type ClassOperatorDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOperatorDeclarationContext() *ClassOperatorDeclarationContext {
	var p = new(ClassOperatorDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classOperatorDeclaration
	return p
}

func InitEmptyClassOperatorDeclarationContext(p *ClassOperatorDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classOperatorDeclaration
}

func (*ClassOperatorDeclarationContext) IsClassOperatorDeclarationContext() {}

func NewClassOperatorDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOperatorDeclarationContext {
	var p = new(ClassOperatorDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classOperatorDeclaration

	return p
}

func (s *ClassOperatorDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOperatorDeclarationContext) ClassOperatorHeader() IClassOperatorHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOperatorHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOperatorHeaderContext)
}

func (s *ClassOperatorDeclarationContext) ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionBodyContext)
}

func (s *ClassOperatorDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ClassOperatorDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOperatorDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOperatorDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassOperatorDeclaration(s)
	}
}

func (s *ClassOperatorDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassOperatorDeclaration(s)
	}
}

func (s *ClassOperatorDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassOperatorDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassOperatorDeclaration() (localctx IClassOperatorDeclarationContext) {
	localctx = NewClassOperatorDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, pascalParserRULE_classOperatorDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1200)
		p.ClassOperatorHeader()
	}
	{
		p.SetState(1201)
		p.ProcedureOrFunctionBody()
	}
	{
		p.SetState(1202)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllFormalParameterSection() []IFormalParameterSectionContext
	FormalParameterSection(i int) IFormalParameterSectionContext
	RPAREN() antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_formalParameterList
	return p
}

func InitEmptyFormalParameterListContext(p *FormalParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_formalParameterList
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *FormalParameterListContext) AllFormalParameterSection() []IFormalParameterSectionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormalParameterSectionContext); ok {
			len++
		}
	}

	tst := make([]IFormalParameterSectionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormalParameterSectionContext); ok {
			tst[i] = t.(IFormalParameterSectionContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameterSection(i int) IFormalParameterSectionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterSectionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterSectionContext)
}

func (s *FormalParameterListContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *FormalParameterListContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *FormalParameterListContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFormalParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FormalParameterList() (localctx IFormalParameterListContext) {
	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, pascalParserRULE_formalParameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1204)
		p.Match(pascalParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1205)
		p.FormalParameterSection()
	}
	p.SetState(1210)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserSEMI {
		{
			p.SetState(1206)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1207)
			p.FormalParameterSection()
		}

		p.SetState(1212)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1213)
		p.Match(pascalParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterSectionContext is an interface to support dynamic dispatch.
type IFormalParameterSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParameterGroup() IParameterGroupContext
	AttributeSection() IAttributeSectionContext
	VAR() antlr.TerminalNode
	CONST() antlr.TerminalNode
	OUT() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode

	// IsFormalParameterSectionContext differentiates from other interfaces.
	IsFormalParameterSectionContext()
}

type FormalParameterSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterSectionContext() *FormalParameterSectionContext {
	var p = new(FormalParameterSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_formalParameterSection
	return p
}

func InitEmptyFormalParameterSectionContext(p *FormalParameterSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_formalParameterSection
}

func (*FormalParameterSectionContext) IsFormalParameterSectionContext() {}

func NewFormalParameterSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterSectionContext {
	var p = new(FormalParameterSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_formalParameterSection

	return p
}

func (s *FormalParameterSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterSectionContext) ParameterGroup() IParameterGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterGroupContext)
}

func (s *FormalParameterSectionContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *FormalParameterSectionContext) VAR() antlr.TerminalNode {
	return s.GetToken(pascalParserVAR, 0)
}

func (s *FormalParameterSectionContext) CONST() antlr.TerminalNode {
	return s.GetToken(pascalParserCONST, 0)
}

func (s *FormalParameterSectionContext) OUT() antlr.TerminalNode {
	return s.GetToken(pascalParserOUT, 0)
}

func (s *FormalParameterSectionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(pascalParserFUNCTION, 0)
}

func (s *FormalParameterSectionContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(pascalParserPROCEDURE, 0)
}

func (s *FormalParameterSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFormalParameterSection(s)
	}
}

func (s *FormalParameterSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFormalParameterSection(s)
	}
}

func (s *FormalParameterSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFormalParameterSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FormalParameterSection() (localctx IFormalParameterSectionContext) {
	localctx = NewFormalParameterSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, pascalParserRULE_formalParameterSection)
	var _la int

	p.SetState(1244)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 127, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1216)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1215)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1218)
			p.ParameterGroup()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1220)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1219)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1222)
			p.Match(pascalParserVAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1223)
			p.ParameterGroup()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1225)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1224)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1227)
			p.Match(pascalParserCONST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1228)
			p.ParameterGroup()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1230)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1229)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1232)
			p.Match(pascalParserOUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1233)
			p.ParameterGroup()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1235)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1234)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1237)
			p.Match(pascalParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1238)
			p.ParameterGroup()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1240)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1239)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1242)
			p.Match(pascalParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1243)
			p.ParameterGroup()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterGroupContext is an interface to support dynamic dispatch.
type IParameterGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierList() IIdentifierListContext
	COLON() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	DefaultValue() IDefaultValueContext

	// IsParameterGroupContext differentiates from other interfaces.
	IsParameterGroupContext()
}

type ParameterGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterGroupContext() *ParameterGroupContext {
	var p = new(ParameterGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterGroup
	return p
}

func InitEmptyParameterGroupContext(p *ParameterGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterGroup
}

func (*ParameterGroupContext) IsParameterGroupContext() {}

func NewParameterGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterGroupContext {
	var p = new(ParameterGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_parameterGroup

	return p
}

func (s *ParameterGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterGroupContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ParameterGroupContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *ParameterGroupContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ParameterGroupContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *ParameterGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterParameterGroup(s)
	}
}

func (s *ParameterGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitParameterGroup(s)
	}
}

func (s *ParameterGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitParameterGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ParameterGroup() (localctx IParameterGroupContext) {
	localctx = NewParameterGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, pascalParserRULE_parameterGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1246)
		p.IdentifierList()
	}
	p.SetState(1249)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserCOLON {
		{
			p.SetState(1247)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1248)
			p.TypeIdentifier()
		}

	}
	p.SetState(1252)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserEQUAL {
		{
			p.SetState(1251)
			p.DefaultValue()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifierList
	return p
}

func InitEmptyIdentifierListContext(p *IdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifierList
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierListContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *IdentifierListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (s *IdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, pascalParserRULE_identifierList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1254)
		p.Identifier()
	}
	p.SetState(1259)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 130, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1255)
				p.Match(pascalParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1256)
				p.Identifier()
			}

		}
		p.SetState(1261)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 130, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstListContext is an interface to support dynamic dispatch.
type IConstListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsConstListContext differentiates from other interfaces.
	IsConstListContext()
}

type ConstListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstListContext() *ConstListContext {
	var p = new(ConstListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constList
	return p
}

func InitEmptyConstListContext(p *ConstListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constList
}

func (*ConstListContext) IsConstListContext() {}

func NewConstListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstListContext {
	var p = new(ConstListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constList

	return p
}

func (s *ConstListContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstListContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *ConstListContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ConstListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ConstListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstList(s)
	}
}

func (s *ConstListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstList(s)
	}
}

func (s *ConstListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConstList() (localctx IConstListContext) {
	localctx = NewConstListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, pascalParserRULE_constList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1262)
		p.Constant()
	}
	p.SetState(1267)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(1263)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1264)
			p.Constant()
		}

		p.SetState(1269)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultValueContext is an interface to support dynamic dispatch.
type IDefaultValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsDefaultValueContext differentiates from other interfaces.
	IsDefaultValueContext()
}

type DefaultValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultValueContext() *DefaultValueContext {
	var p = new(DefaultValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_defaultValue
	return p
}

func InitEmptyDefaultValueContext(p *DefaultValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_defaultValue
}

func (*DefaultValueContext) IsDefaultValueContext() {}

func NewDefaultValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultValueContext {
	var p = new(DefaultValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_defaultValue

	return p
}

func (s *DefaultValueContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultValueContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *DefaultValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DefaultValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterDefaultValue(s)
	}
}

func (s *DefaultValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitDefaultValue(s)
	}
}

func (s *DefaultValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitDefaultValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) DefaultValue() (localctx IDefaultValueContext) {
	localctx = NewDefaultValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, pascalParserRULE_defaultValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1270)
		p.Match(pascalParserEQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1271)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypedIdentifierListContext is an interface to support dynamic dispatch.
type ITypedIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierList() IIdentifierListContext
	COLON() antlr.TerminalNode
	Type_() IType_Context

	// IsTypedIdentifierListContext differentiates from other interfaces.
	IsTypedIdentifierListContext()
}

type TypedIdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedIdentifierListContext() *TypedIdentifierListContext {
	var p = new(TypedIdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typedIdentifierList
	return p
}

func InitEmptyTypedIdentifierListContext(p *TypedIdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typedIdentifierList
}

func (*TypedIdentifierListContext) IsTypedIdentifierListContext() {}

func NewTypedIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedIdentifierListContext {
	var p = new(TypedIdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typedIdentifierList

	return p
}

func (s *TypedIdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedIdentifierListContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *TypedIdentifierListContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *TypedIdentifierListContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypedIdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedIdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedIdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypedIdentifierList(s)
	}
}

func (s *TypedIdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypedIdentifierList(s)
	}
}

func (s *TypedIdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypedIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypedIdentifierList() (localctx ITypedIdentifierListContext) {
	localctx = NewTypedIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, pascalParserRULE_typedIdentifierList)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1273)
		p.IdentifierList()
	}
	{
		p.SetState(1274)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1275)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Label() ILabelContext
	COLON() antlr.TerminalNode
	UnlabelledStatement() IUnlabelledStatementContext
	ErrorStatement() IErrorStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Label() ILabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *StatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *StatementContext) UnlabelledStatement() IUnlabelledStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnlabelledStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnlabelledStatementContext)
}

func (s *StatementContext) ErrorStatement() IErrorStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, pascalParserRULE_statement)
	p.SetState(1283)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 132, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1277)
			p.Label()
		}
		{
			p.SetState(1278)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1279)
			p.UnlabelledStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1281)
			p.UnlabelledStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1282)
			p.ErrorStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorStatementContext is an interface to support dynamic dispatch.
type IErrorStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEND() []antlr.TerminalNode
	END(i int) antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsErrorStatementContext differentiates from other interfaces.
	IsErrorStatementContext()
}

type ErrorStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorStatementContext() *ErrorStatementContext {
	var p = new(ErrorStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorStatement
	return p
}

func InitEmptyErrorStatementContext(p *ErrorStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorStatement
}

func (*ErrorStatementContext) IsErrorStatementContext() {}

func NewErrorStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorStatementContext {
	var p = new(ErrorStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_errorStatement

	return p
}

func (s *ErrorStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorStatementContext) AllEND() []antlr.TerminalNode {
	return s.GetTokens(pascalParserEND)
}

func (s *ErrorStatementContext) END(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserEND, i)
}

func (s *ErrorStatementContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ErrorStatementContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ErrorStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterErrorStatement(s)
	}
}

func (s *ErrorStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitErrorStatement(s)
	}
}

func (s *ErrorStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitErrorStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ErrorStatement() (localctx IErrorStatementContext) {
	localctx = NewErrorStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, pascalParserRULE_errorStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1285)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || _la == pascalParserEND || _la == pascalParserSEMI {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1288)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnlabelledStatementContext is an interface to support dynamic dispatch.
type IUnlabelledStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleStatement() ISimpleStatementContext
	StructuredStatement() IStructuredStatementContext

	// IsUnlabelledStatementContext differentiates from other interfaces.
	IsUnlabelledStatementContext()
}

type UnlabelledStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnlabelledStatementContext() *UnlabelledStatementContext {
	var p = new(UnlabelledStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unlabelledStatement
	return p
}

func InitEmptyUnlabelledStatementContext(p *UnlabelledStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unlabelledStatement
}

func (*UnlabelledStatementContext) IsUnlabelledStatementContext() {}

func NewUnlabelledStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnlabelledStatementContext {
	var p = new(UnlabelledStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unlabelledStatement

	return p
}

func (s *UnlabelledStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnlabelledStatementContext) SimpleStatement() ISimpleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStatementContext)
}

func (s *UnlabelledStatementContext) StructuredStatement() IStructuredStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructuredStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructuredStatementContext)
}

func (s *UnlabelledStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnlabelledStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnlabelledStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnlabelledStatement(s)
	}
}

func (s *UnlabelledStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnlabelledStatement(s)
	}
}

func (s *UnlabelledStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnlabelledStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnlabelledStatement() (localctx IUnlabelledStatementContext) {
	localctx = NewUnlabelledStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, pascalParserRULE_unlabelledStatement)
	p.SetState(1292)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserARRAY, pascalParserBOOLEAN, pascalParserCHAR, pascalParserELSE, pascalParserEND, pascalParserGOTO, pascalParserINTEGER, pascalParserREAL, pascalParserUNTIL, pascalParserVAR, pascalParserSEMI, pascalParserLPAREN, pascalParserAT, pascalParserSTRING, pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserFINALLY, pascalParserEXCEPT, pascalParserFINALIZATION, pascalParserINHERITED, pascalParserRAISE, pascalParserCARDINAL, pascalParserLONGBOOL, pascalParserLONGINT, pascalParserIDENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1290)
			p.SimpleStatement()
		}

	case pascalParserBEGIN, pascalParserCASE, pascalParserFOR, pascalParserIF, pascalParserREPEAT, pascalParserWHILE, pascalParserWITH, pascalParserTRY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1291)
			p.StructuredStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleStatementContext is an interface to support dynamic dispatch.
type ISimpleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssignmentStatement() IAssignmentStatementContext
	MethodCallStatement() IMethodCallStatementContext
	ProcedureStatement() IProcedureStatementContext
	GotoStatement() IGotoStatementContext
	InheritedStatement() IInheritedStatementContext
	TypeCast() ITypeCastContext
	EmptyStatement_() IEmptyStatement_Context
	RaiseExceptionStatement() IRaiseExceptionStatementContext
	VariableDeclarationStatement() IVariableDeclarationStatementContext

	// IsSimpleStatementContext differentiates from other interfaces.
	IsSimpleStatementContext()
}

type SimpleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleStatementContext() *SimpleStatementContext {
	var p = new(SimpleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleStatement
	return p
}

func InitEmptySimpleStatementContext(p *SimpleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleStatement
}

func (*SimpleStatementContext) IsSimpleStatementContext() {}

func NewSimpleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleStatementContext {
	var p = new(SimpleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_simpleStatement

	return p
}

func (s *SimpleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleStatementContext) AssignmentStatement() IAssignmentStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentStatementContext)
}

func (s *SimpleStatementContext) MethodCallStatement() IMethodCallStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodCallStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodCallStatementContext)
}

func (s *SimpleStatementContext) ProcedureStatement() IProcedureStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureStatementContext)
}

func (s *SimpleStatementContext) GotoStatement() IGotoStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGotoStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGotoStatementContext)
}

func (s *SimpleStatementContext) InheritedStatement() IInheritedStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInheritedStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInheritedStatementContext)
}

func (s *SimpleStatementContext) TypeCast() ITypeCastContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeCastContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeCastContext)
}

func (s *SimpleStatementContext) EmptyStatement_() IEmptyStatement_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatement_Context)
}

func (s *SimpleStatementContext) RaiseExceptionStatement() IRaiseExceptionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRaiseExceptionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRaiseExceptionStatementContext)
}

func (s *SimpleStatementContext) VariableDeclarationStatement() IVariableDeclarationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationStatementContext)
}

func (s *SimpleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSimpleStatement(s)
	}
}

func (s *SimpleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSimpleStatement(s)
	}
}

func (s *SimpleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSimpleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SimpleStatement() (localctx ISimpleStatementContext) {
	localctx = NewSimpleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, pascalParserRULE_simpleStatement)
	p.SetState(1303)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1294)
			p.AssignmentStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1295)
			p.MethodCallStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1296)
			p.ProcedureStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1297)
			p.GotoStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1298)
			p.InheritedStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1299)
			p.TypeCast()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1300)
			p.EmptyStatement_()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1301)
			p.RaiseExceptionStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1302)
			p.VariableDeclarationStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentStatementContext is an interface to support dynamic dispatch.
type IAssignmentStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableDesignator() IVariableDesignatorContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext
	PropertyDesignator() IPropertyDesignatorContext

	// IsAssignmentStatementContext differentiates from other interfaces.
	IsAssignmentStatementContext()
}

type AssignmentStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentStatementContext() *AssignmentStatementContext {
	var p = new(AssignmentStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_assignmentStatement
	return p
}

func InitEmptyAssignmentStatementContext(p *AssignmentStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_assignmentStatement
}

func (*AssignmentStatementContext) IsAssignmentStatementContext() {}

func NewAssignmentStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentStatementContext {
	var p = new(AssignmentStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_assignmentStatement

	return p
}

func (s *AssignmentStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentStatementContext) VariableDesignator() IVariableDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDesignatorContext)
}

func (s *AssignmentStatementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(pascalParserASSIGN, 0)
}

func (s *AssignmentStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentStatementContext) PropertyDesignator() IPropertyDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDesignatorContext)
}

func (s *AssignmentStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAssignmentStatement(s)
	}
}

func (s *AssignmentStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAssignmentStatement(s)
	}
}

func (s *AssignmentStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAssignmentStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) AssignmentStatement() (localctx IAssignmentStatementContext) {
	localctx = NewAssignmentStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, pascalParserRULE_assignmentStatement)
	p.SetState(1313)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1305)
			p.VariableDesignator()
		}
		{
			p.SetState(1306)
			p.Match(pascalParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1307)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1309)
			p.PropertyDesignator()
		}
		{
			p.SetState(1310)
			p.Match(pascalParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1311)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRaiseExceptionStatementContext is an interface to support dynamic dispatch.
type IRaiseExceptionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RAISE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsRaiseExceptionStatementContext differentiates from other interfaces.
	IsRaiseExceptionStatementContext()
}

type RaiseExceptionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaiseExceptionStatementContext() *RaiseExceptionStatementContext {
	var p = new(RaiseExceptionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_raiseExceptionStatement
	return p
}

func InitEmptyRaiseExceptionStatementContext(p *RaiseExceptionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_raiseExceptionStatement
}

func (*RaiseExceptionStatementContext) IsRaiseExceptionStatementContext() {}

func NewRaiseExceptionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RaiseExceptionStatementContext {
	var p = new(RaiseExceptionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_raiseExceptionStatement

	return p
}

func (s *RaiseExceptionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RaiseExceptionStatementContext) RAISE() antlr.TerminalNode {
	return s.GetToken(pascalParserRAISE, 0)
}

func (s *RaiseExceptionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RaiseExceptionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RaiseExceptionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RaiseExceptionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRaiseExceptionStatement(s)
	}
}

func (s *RaiseExceptionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRaiseExceptionStatement(s)
	}
}

func (s *RaiseExceptionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRaiseExceptionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RaiseExceptionStatement() (localctx IRaiseExceptionStatementContext) {
	localctx = NewRaiseExceptionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, pascalParserRULE_raiseExceptionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1315)
		p.Match(pascalParserRAISE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1317)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3747047670930211240) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&9083197500616084737) != 0) {
		{
			p.SetState(1316)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationStatementContext is an interface to support dynamic dispatch.
type IVariableDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VAR() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	COLON() antlr.TerminalNode
	TypeDefinition() ITypeDefinitionContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsVariableDeclarationStatementContext differentiates from other interfaces.
	IsVariableDeclarationStatementContext()
}

type VariableDeclarationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationStatementContext() *VariableDeclarationStatementContext {
	var p = new(VariableDeclarationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclarationStatement
	return p
}

func InitEmptyVariableDeclarationStatementContext(p *VariableDeclarationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclarationStatement
}

func (*VariableDeclarationStatementContext) IsVariableDeclarationStatementContext() {}

func NewVariableDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationStatementContext {
	var p = new(VariableDeclarationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_variableDeclarationStatement

	return p
}

func (s *VariableDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationStatementContext) VAR() antlr.TerminalNode {
	return s.GetToken(pascalParserVAR, 0)
}

func (s *VariableDeclarationStatementContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *VariableDeclarationStatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *VariableDeclarationStatementContext) TypeDefinition() ITypeDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionContext)
}

func (s *VariableDeclarationStatementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(pascalParserASSIGN, 0)
}

func (s *VariableDeclarationStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterVariableDeclarationStatement(s)
	}
}

func (s *VariableDeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitVariableDeclarationStatement(s)
	}
}

func (s *VariableDeclarationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitVariableDeclarationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) VariableDeclarationStatement() (localctx IVariableDeclarationStatementContext) {
	localctx = NewVariableDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, pascalParserRULE_variableDeclarationStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1319)
		p.Match(pascalParserVAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1320)
		p.IdentifierList()
	}
	p.SetState(1323)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserCOLON {
		{
			p.SetState(1321)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1322)
			p.TypeDefinition()
		}

	}
	p.SetState(1327)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserASSIGN {
		{
			p.SetState(1325)
			p.Match(pascalParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1326)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDesignatorContext is an interface to support dynamic dispatch.
type IVariableDesignatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeCast() ITypeCastContext
	AT() antlr.TerminalNode
	Identifier() IIdentifierContext
	AllFunctionDesignator() []IFunctionDesignatorContext
	FunctionDesignator(i int) IFunctionDesignatorContext
	AllLBRACK() []antlr.TerminalNode
	LBRACK(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllRBRACK() []antlr.TerminalNode
	RBRACK(i int) antlr.TerminalNode
	AllLBRACK2() []antlr.TerminalNode
	LBRACK2(i int) antlr.TerminalNode
	AllRBRACK2() []antlr.TerminalNode
	RBRACK2(i int) antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllDEREFERENCE() []antlr.TerminalNode
	DEREFERENCE(i int) antlr.TerminalNode

	// IsVariableDesignatorContext differentiates from other interfaces.
	IsVariableDesignatorContext()
}

type VariableDesignatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDesignatorContext() *VariableDesignatorContext {
	var p = new(VariableDesignatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDesignator
	return p
}

func InitEmptyVariableDesignatorContext(p *VariableDesignatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDesignator
}

func (*VariableDesignatorContext) IsVariableDesignatorContext() {}

func NewVariableDesignatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDesignatorContext {
	var p = new(VariableDesignatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_variableDesignator

	return p
}

func (s *VariableDesignatorContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDesignatorContext) TypeCast() ITypeCastContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeCastContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeCastContext)
}

func (s *VariableDesignatorContext) AT() antlr.TerminalNode {
	return s.GetToken(pascalParserAT, 0)
}

func (s *VariableDesignatorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableDesignatorContext) AllFunctionDesignator() []IFunctionDesignatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionDesignatorContext); ok {
			len++
		}
	}

	tst := make([]IFunctionDesignatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionDesignatorContext); ok {
			tst[i] = t.(IFunctionDesignatorContext)
			i++
		}
	}

	return tst
}

func (s *VariableDesignatorContext) FunctionDesignator(i int) IFunctionDesignatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDesignatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDesignatorContext)
}

func (s *VariableDesignatorContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(pascalParserLBRACK)
}

func (s *VariableDesignatorContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, i)
}

func (s *VariableDesignatorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *VariableDesignatorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableDesignatorContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(pascalParserRBRACK)
}

func (s *VariableDesignatorContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, i)
}

func (s *VariableDesignatorContext) AllLBRACK2() []antlr.TerminalNode {
	return s.GetTokens(pascalParserLBRACK2)
}

func (s *VariableDesignatorContext) LBRACK2(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK2, i)
}

func (s *VariableDesignatorContext) AllRBRACK2() []antlr.TerminalNode {
	return s.GetTokens(pascalParserRBRACK2)
}

func (s *VariableDesignatorContext) RBRACK2(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK2, i)
}

func (s *VariableDesignatorContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDOT)
}

func (s *VariableDesignatorContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, i)
}

func (s *VariableDesignatorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *VariableDesignatorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *VariableDesignatorContext) AllDEREFERENCE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDEREFERENCE)
}

func (s *VariableDesignatorContext) DEREFERENCE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDEREFERENCE, i)
}

func (s *VariableDesignatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDesignatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDesignatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterVariableDesignator(s)
	}
}

func (s *VariableDesignatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitVariableDesignator(s)
	}
}

func (s *VariableDesignatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitVariableDesignator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) VariableDesignator() (localctx IVariableDesignatorContext) {
	localctx = NewVariableDesignatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, pascalParserRULE_variableDesignator)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1333)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 140, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1329)
			p.TypeCast()
		}

	case 2:
		{
			p.SetState(1330)
			p.Match(pascalParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1331)
			p.Identifier()
		}

	case 3:
		{
			p.SetState(1332)
			p.FunctionDesignator()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(1366)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1364)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case pascalParserLBRACK:
				{
					p.SetState(1335)
					p.Match(pascalParserLBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1336)
					p.Expression()
				}
				p.SetState(1341)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == pascalParserCOMMA {
					{
						p.SetState(1337)
						p.Match(pascalParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1338)
						p.Expression()
					}

					p.SetState(1343)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1344)
					p.Match(pascalParserRBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case pascalParserLBRACK2:
				{
					p.SetState(1346)
					p.Match(pascalParserLBRACK2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1347)
					p.Expression()
				}
				p.SetState(1352)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == pascalParserCOMMA {
					{
						p.SetState(1348)
						p.Match(pascalParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1349)
						p.Expression()
					}

					p.SetState(1354)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1355)
					p.Match(pascalParserRBRACK2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case pascalParserDOT:
				{
					p.SetState(1357)
					p.Match(pascalParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1358)
					p.FunctionDesignator()
				}

			case pascalParserDEREFERENCE:
				p.SetState(1360)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = 1
				for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					switch _alt {
					case 1:
						{
							p.SetState(1359)
							p.Match(pascalParserDEREFERENCE)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					default:
						p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
						goto errorExit
					}

					p.SetState(1362)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 143, p.GetParserRuleContext())
					if p.HasError() {
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(1368)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeCastContext is an interface to support dynamic dispatch.
type ITypeCastContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIdentifier() ITypeIdentifierContext
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsTypeCastContext differentiates from other interfaces.
	IsTypeCastContext()
}

type TypeCastContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeCastContext() *TypeCastContext {
	var p = new(TypeCastContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeCast
	return p
}

func InitEmptyTypeCastContext(p *TypeCastContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeCast
}

func (*TypeCastContext) IsTypeCastContext() {}

func NewTypeCastContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeCastContext {
	var p = new(TypeCastContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typeCast

	return p
}

func (s *TypeCastContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeCastContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *TypeCastContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *TypeCastContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TypeCastContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *TypeCastContext) AS() antlr.TerminalNode {
	return s.GetToken(pascalParserAS, 0)
}

func (s *TypeCastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeCastContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeCastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypeCast(s)
	}
}

func (s *TypeCastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypeCast(s)
	}
}

func (s *TypeCastContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypeCast(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypeCast() (localctx ITypeCastContext) {
	localctx = NewTypeCastContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, pascalParserRULE_typeCast)
	p.SetState(1380)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserARRAY, pascalParserBOOLEAN, pascalParserCHAR, pascalParserINTEGER, pascalParserREAL, pascalParserSTRING, pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserCARDINAL, pascalParserLONGBOOL, pascalParserLONGINT, pascalParserIDENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1369)
			p.TypeIdentifier()
		}
		{
			p.SetState(1370)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1371)
			p.Expression()
		}
		{
			p.SetState(1372)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case pascalParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1374)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1375)
			p.Expression()
		}
		{
			p.SetState(1376)
			p.Match(pascalParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1377)
			p.TypeIdentifier()
		}
		{
			p.SetState(1378)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyDesignatorContext is an interface to support dynamic dispatch.
type IPropertyDesignatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFunctionDesignator() []IFunctionDesignatorContext
	FunctionDesignator(i int) IFunctionDesignatorContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	Identifier() IIdentifierContext
	LBRACK() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	RBRACK() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPropertyDesignatorContext differentiates from other interfaces.
	IsPropertyDesignatorContext()
}

type PropertyDesignatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDesignatorContext() *PropertyDesignatorContext {
	var p = new(PropertyDesignatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDesignator
	return p
}

func InitEmptyPropertyDesignatorContext(p *PropertyDesignatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDesignator
}

func (*PropertyDesignatorContext) IsPropertyDesignatorContext() {}

func NewPropertyDesignatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDesignatorContext {
	var p = new(PropertyDesignatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyDesignator

	return p
}

func (s *PropertyDesignatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDesignatorContext) AllFunctionDesignator() []IFunctionDesignatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionDesignatorContext); ok {
			len++
		}
	}

	tst := make([]IFunctionDesignatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionDesignatorContext); ok {
			tst[i] = t.(IFunctionDesignatorContext)
			i++
		}
	}

	return tst
}

func (s *PropertyDesignatorContext) FunctionDesignator(i int) IFunctionDesignatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDesignatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDesignatorContext)
}

func (s *PropertyDesignatorContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDOT)
}

func (s *PropertyDesignatorContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, i)
}

func (s *PropertyDesignatorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyDesignatorContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *PropertyDesignatorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PropertyDesignatorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PropertyDesignatorContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *PropertyDesignatorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *PropertyDesignatorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *PropertyDesignatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDesignatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyDesignatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyDesignator(s)
	}
}

func (s *PropertyDesignatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyDesignator(s)
	}
}

func (s *PropertyDesignatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyDesignator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyDesignator() (localctx IPropertyDesignatorContext) {
	localctx = NewPropertyDesignatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, pascalParserRULE_propertyDesignator)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1382)
		p.FunctionDesignator()
	}
	p.SetState(1387)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1383)
				p.Match(pascalParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1384)
				p.FunctionDesignator()
			}

		}
		p.SetState(1389)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1390)
		p.Match(pascalParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1391)
		p.Identifier()
	}
	p.SetState(1403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLBRACK {
		{
			p.SetState(1392)
			p.Match(pascalParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1393)
			p.Expression()
		}
		p.SetState(1398)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == pascalParserCOMMA {
			{
				p.SetState(1394)
				p.Match(pascalParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1395)
				p.Expression()
			}

			p.SetState(1400)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1401)
			p.Match(pascalParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleExpression() ISimpleExpressionContext
	Relationaloperator() IRelationaloperatorContext
	Expression() IExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) SimpleExpression() ISimpleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExpressionContext)
}

func (s *ExpressionContext) Relationaloperator() IRelationaloperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationaloperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationaloperatorContext)
}

func (s *ExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, pascalParserRULE_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1405)
		p.SimpleExpression()
	}
	p.SetState(1409)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 150, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1406)
			p.Relationaloperator()
		}
		{
			p.SetState(1407)
			p.Expression()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationaloperatorContext is an interface to support dynamic dispatch.
type IRelationaloperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL() antlr.TerminalNode
	NOT_EQUAL() antlr.TerminalNode
	LT() antlr.TerminalNode
	LE() antlr.TerminalNode
	GE() antlr.TerminalNode
	GT() antlr.TerminalNode
	IN() antlr.TerminalNode

	// IsRelationaloperatorContext differentiates from other interfaces.
	IsRelationaloperatorContext()
}

type RelationaloperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationaloperatorContext() *RelationaloperatorContext {
	var p = new(RelationaloperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_relationaloperator
	return p
}

func InitEmptyRelationaloperatorContext(p *RelationaloperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_relationaloperator
}

func (*RelationaloperatorContext) IsRelationaloperatorContext() {}

func NewRelationaloperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationaloperatorContext {
	var p = new(RelationaloperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_relationaloperator

	return p
}

func (s *RelationaloperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationaloperatorContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *RelationaloperatorContext) NOT_EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserNOT_EQUAL, 0)
}

func (s *RelationaloperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(pascalParserLT, 0)
}

func (s *RelationaloperatorContext) LE() antlr.TerminalNode {
	return s.GetToken(pascalParserLE, 0)
}

func (s *RelationaloperatorContext) GE() antlr.TerminalNode {
	return s.GetToken(pascalParserGE, 0)
}

func (s *RelationaloperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(pascalParserGT, 0)
}

func (s *RelationaloperatorContext) IN() antlr.TerminalNode {
	return s.GetToken(pascalParserIN, 0)
}

func (s *RelationaloperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationaloperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationaloperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRelationaloperator(s)
	}
}

func (s *RelationaloperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRelationaloperator(s)
	}
}

func (s *RelationaloperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRelationaloperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Relationaloperator() (localctx IRelationaloperatorContext) {
	localctx = NewRelationaloperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, pascalParserRULE_relationaloperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1411)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&283726776526438400) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleExpressionContext is an interface to support dynamic dispatch.
type ISimpleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Term() ITermContext
	Additiveoperator() IAdditiveoperatorContext
	SimpleExpression() ISimpleExpressionContext

	// IsSimpleExpressionContext differentiates from other interfaces.
	IsSimpleExpressionContext()
}

type SimpleExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleExpressionContext() *SimpleExpressionContext {
	var p = new(SimpleExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleExpression
	return p
}

func InitEmptySimpleExpressionContext(p *SimpleExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleExpression
}

func (*SimpleExpressionContext) IsSimpleExpressionContext() {}

func NewSimpleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleExpressionContext {
	var p = new(SimpleExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_simpleExpression

	return p
}

func (s *SimpleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleExpressionContext) Term() ITermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *SimpleExpressionContext) Additiveoperator() IAdditiveoperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveoperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveoperatorContext)
}

func (s *SimpleExpressionContext) SimpleExpression() ISimpleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExpressionContext)
}

func (s *SimpleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSimpleExpression(s)
	}
}

func (s *SimpleExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSimpleExpression(s)
	}
}

func (s *SimpleExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSimpleExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SimpleExpression() (localctx ISimpleExpressionContext) {
	localctx = NewSimpleExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, pascalParserRULE_simpleExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1413)
		p.Term()
	}
	p.SetState(1417)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 151, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1414)
			p.Additiveoperator()
		}
		{
			p.SetState(1415)
			p.SimpleExpression()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdditiveoperatorContext is an interface to support dynamic dispatch.
type IAdditiveoperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	OR() antlr.TerminalNode

	// IsAdditiveoperatorContext differentiates from other interfaces.
	IsAdditiveoperatorContext()
}

type AdditiveoperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveoperatorContext() *AdditiveoperatorContext {
	var p = new(AdditiveoperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_additiveoperator
	return p
}

func InitEmptyAdditiveoperatorContext(p *AdditiveoperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_additiveoperator
}

func (*AdditiveoperatorContext) IsAdditiveoperatorContext() {}

func NewAdditiveoperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveoperatorContext {
	var p = new(AdditiveoperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_additiveoperator

	return p
}

func (s *AdditiveoperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveoperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(pascalParserPLUS, 0)
}

func (s *AdditiveoperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(pascalParserMINUS, 0)
}

func (s *AdditiveoperatorContext) OR() antlr.TerminalNode {
	return s.GetToken(pascalParserOR, 0)
}

func (s *AdditiveoperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveoperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveoperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAdditiveoperator(s)
	}
}

func (s *AdditiveoperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAdditiveoperator(s)
	}
}

func (s *AdditiveoperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAdditiveoperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Additiveoperator() (localctx IAdditiveoperatorContext) {
	localctx = NewAdditiveoperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, pascalParserRULE_additiveoperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1419)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&52776826568704) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SignedFactor() ISignedFactorContext
	Multiplicativeoperator() IMultiplicativeoperatorContext
	Term() ITermContext

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_term
	return p
}

func InitEmptyTermContext(p *TermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_term
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) SignedFactor() ISignedFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignedFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignedFactorContext)
}

func (s *TermContext) Multiplicativeoperator() IMultiplicativeoperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeoperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeoperatorContext)
}

func (s *TermContext) Term() ITermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTerm(s)
	}
}

func (s *TermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTerm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, pascalParserRULE_term)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1421)
		p.SignedFactor()
	}
	p.SetState(1425)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 152, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1422)
			p.Multiplicativeoperator()
		}
		{
			p.SetState(1423)
			p.Term()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplicativeoperatorContext is an interface to support dynamic dispatch.
type IMultiplicativeoperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	SLASH() antlr.TerminalNode
	DIV() antlr.TerminalNode
	MOD() antlr.TerminalNode
	AND() antlr.TerminalNode
	SHR() antlr.TerminalNode
	SHL() antlr.TerminalNode
	XOR() antlr.TerminalNode

	// IsMultiplicativeoperatorContext differentiates from other interfaces.
	IsMultiplicativeoperatorContext()
}

type MultiplicativeoperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeoperatorContext() *MultiplicativeoperatorContext {
	var p = new(MultiplicativeoperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_multiplicativeoperator
	return p
}

func InitEmptyMultiplicativeoperatorContext(p *MultiplicativeoperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_multiplicativeoperator
}

func (*MultiplicativeoperatorContext) IsMultiplicativeoperatorContext() {}

func NewMultiplicativeoperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeoperatorContext {
	var p = new(MultiplicativeoperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_multiplicativeoperator

	return p
}

func (s *MultiplicativeoperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeoperatorContext) STAR() antlr.TerminalNode {
	return s.GetToken(pascalParserSTAR, 0)
}

func (s *MultiplicativeoperatorContext) SLASH() antlr.TerminalNode {
	return s.GetToken(pascalParserSLASH, 0)
}

func (s *MultiplicativeoperatorContext) DIV() antlr.TerminalNode {
	return s.GetToken(pascalParserDIV, 0)
}

func (s *MultiplicativeoperatorContext) MOD() antlr.TerminalNode {
	return s.GetToken(pascalParserMOD, 0)
}

func (s *MultiplicativeoperatorContext) AND() antlr.TerminalNode {
	return s.GetToken(pascalParserAND, 0)
}

func (s *MultiplicativeoperatorContext) SHR() antlr.TerminalNode {
	return s.GetToken(pascalParserSHR, 0)
}

func (s *MultiplicativeoperatorContext) SHL() antlr.TerminalNode {
	return s.GetToken(pascalParserSHL, 0)
}

func (s *MultiplicativeoperatorContext) XOR() antlr.TerminalNode {
	return s.GetToken(pascalParserXOR, 0)
}

func (s *MultiplicativeoperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeoperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeoperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterMultiplicativeoperator(s)
	}
}

func (s *MultiplicativeoperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitMultiplicativeoperator(s)
	}
}

func (s *MultiplicativeoperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitMultiplicativeoperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Multiplicativeoperator() (localctx IMultiplicativeoperatorContext) {
	localctx = NewMultiplicativeoperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, pascalParserRULE_multiplicativeoperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1427)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&211106249311236) != 0) || ((int64((_la-111)) & ^0x3f) == 0 && ((int64(1)<<(_la-111))&7) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignedFactorContext is an interface to support dynamic dispatch.
type ISignedFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Factor() IFactorContext
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsSignedFactorContext differentiates from other interfaces.
	IsSignedFactorContext()
}

type SignedFactorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignedFactorContext() *SignedFactorContext {
	var p = new(SignedFactorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_signedFactor
	return p
}

func InitEmptySignedFactorContext(p *SignedFactorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_signedFactor
}

func (*SignedFactorContext) IsSignedFactorContext() {}

func NewSignedFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignedFactorContext {
	var p = new(SignedFactorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_signedFactor

	return p
}

func (s *SignedFactorContext) GetParser() antlr.Parser { return s.parser }

func (s *SignedFactorContext) Factor() IFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *SignedFactorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(pascalParserPLUS, 0)
}

func (s *SignedFactorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(pascalParserMINUS, 0)
}

func (s *SignedFactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignedFactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignedFactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSignedFactor(s)
	}
}

func (s *SignedFactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSignedFactor(s)
	}
}

func (s *SignedFactorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSignedFactor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SignedFactor() (localctx ISignedFactorContext) {
	localctx = NewSignedFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, pascalParserRULE_signedFactor)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1430)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserPLUS || _la == pascalParserMINUS {
		{
			p.SetState(1429)
			_la = p.GetTokenStream().LA(1)

			if !(_la == pascalParserPLUS || _la == pascalParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1432)
		p.factor(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFactorContext is an interface to support dynamic dispatch.
type IFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionDesignator() IFunctionDesignatorContext
	INHERITED() antlr.TerminalNode
	DefaultDesignator() IDefaultDesignatorContext
	VariableDesignator() IVariableDesignatorContext
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	RPAREN() antlr.TerminalNode
	UnsignedConstant() IUnsignedConstantContext
	Set_() ISet_Context
	NOT() antlr.TerminalNode
	Factor() IFactorContext
	Bool_() IBool_Context
	TypeIdentifier() ITypeIdentifierContext
	AT() antlr.TerminalNode
	AllDEREFERENCE() []antlr.TerminalNode
	DEREFERENCE(i int) antlr.TerminalNode
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsFactorContext differentiates from other interfaces.
	IsFactorContext()
}

type FactorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFactorContext() *FactorContext {
	var p = new(FactorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_factor
	return p
}

func InitEmptyFactorContext(p *FactorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_factor
}

func (*FactorContext) IsFactorContext() {}

func NewFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FactorContext {
	var p = new(FactorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_factor

	return p
}

func (s *FactorContext) GetParser() antlr.Parser { return s.parser }

func (s *FactorContext) FunctionDesignator() IFunctionDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDesignatorContext)
}

func (s *FactorContext) INHERITED() antlr.TerminalNode {
	return s.GetToken(pascalParserINHERITED, 0)
}

func (s *FactorContext) DefaultDesignator() IDefaultDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultDesignatorContext)
}

func (s *FactorContext) VariableDesignator() IVariableDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDesignatorContext)
}

func (s *FactorContext) AS() antlr.TerminalNode {
	return s.GetToken(pascalParserAS, 0)
}

func (s *FactorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FactorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *FactorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *FactorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FactorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *FactorContext) UnsignedConstant() IUnsignedConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedConstantContext)
}

func (s *FactorContext) Set_() ISet_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_Context)
}

func (s *FactorContext) NOT() antlr.TerminalNode {
	return s.GetToken(pascalParserNOT, 0)
}

func (s *FactorContext) Factor() IFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *FactorContext) Bool_() IBool_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_Context)
}

func (s *FactorContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *FactorContext) AT() antlr.TerminalNode {
	return s.GetToken(pascalParserAT, 0)
}

func (s *FactorContext) AllDEREFERENCE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDEREFERENCE)
}

func (s *FactorContext) DEREFERENCE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDEREFERENCE, i)
}

func (s *FactorContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *FactorContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *FactorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *FactorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *FactorContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDOT)
}

func (s *FactorContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, i)
}

func (s *FactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFactor(s)
	}
}

func (s *FactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFactor(s)
	}
}

func (s *FactorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFactor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Factor() (localctx IFactorContext) {
	return p.factor(0)
}

func (p *pascalParser) factor(_p int) (localctx IFactorContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewFactorContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IFactorContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 260
	p.EnterRecursionRule(localctx, 260, pascalParserRULE_factor, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1470)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1436)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserINHERITED {
			{
				p.SetState(1435)
				p.Match(pascalParserINHERITED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1438)
			p.FunctionDesignator()
		}

	case 2:
		{
			p.SetState(1439)
			p.DefaultDesignator()
		}

	case 3:
		{
			p.SetState(1440)
			p.VariableDesignator()
		}
		p.SetState(1443)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 155, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1441)
				p.Match(pascalParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1442)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		{
			p.SetState(1445)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1446)
			p.Expression()
		}
		{
			p.SetState(1447)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		{
			p.SetState(1449)
			p.UnsignedConstant()
		}

	case 6:
		{
			p.SetState(1450)
			p.Set_()
		}

	case 7:
		{
			p.SetState(1451)
			p.Match(pascalParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1452)
			p.factor(5)
		}

	case 8:
		{
			p.SetState(1453)
			p.Bool_()
		}

	case 9:
		p.SetState(1455)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserAT {
			{
				p.SetState(1454)
				p.Match(pascalParserAT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1457)
			p.TypeIdentifier()
		}
		p.SetState(1462)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 157, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1458)
				p.Match(pascalParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1459)
				p.Expression()
			}
			{
				p.SetState(1460)
				p.Match(pascalParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1467)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 158, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1464)
					p.Match(pascalParserDEREFERENCE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1469)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 158, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1493)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 163, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1491)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 162, p.GetParserRuleContext()) {
			case 1:
				localctx = NewFactorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, pascalParserRULE_factor)
				p.SetState(1472)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(1473)
					p.Match(pascalParserLBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1474)
					p.Expression()
				}
				p.SetState(1479)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == pascalParserCOMMA {
					{
						p.SetState(1475)
						p.Match(pascalParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1476)
						p.Expression()
					}

					p.SetState(1481)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1482)
					p.Match(pascalParserRBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				localctx = NewFactorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, pascalParserRULE_factor)
				p.SetState(1484)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				p.SetState(1487)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = 1
				for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					switch _alt {
					case 1:
						{
							p.SetState(1485)
							p.Match(pascalParserDOT)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(1486)
							p.Expression()
						}

					default:
						p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
						goto errorExit
					}

					p.SetState(1489)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 161, p.GetParserRuleContext())
					if p.HasError() {
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1495)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 163, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedConstantContext is an interface to support dynamic dispatch.
type IUnsignedConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedNumber() IUnsignedNumberContext
	ConstantChr() IConstantChrContext
	HexConstant() IHexConstantContext
	String_() IStringContext
	NIL() antlr.TerminalNode

	// IsUnsignedConstantContext differentiates from other interfaces.
	IsUnsignedConstantContext()
}

type UnsignedConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedConstantContext() *UnsignedConstantContext {
	var p = new(UnsignedConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedConstant
	return p
}

func InitEmptyUnsignedConstantContext(p *UnsignedConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedConstant
}

func (*UnsignedConstantContext) IsUnsignedConstantContext() {}

func NewUnsignedConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedConstantContext {
	var p = new(UnsignedConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unsignedConstant

	return p
}

func (s *UnsignedConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedConstantContext) UnsignedNumber() IUnsignedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedNumberContext)
}

func (s *UnsignedConstantContext) ConstantChr() IConstantChrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantChrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantChrContext)
}

func (s *UnsignedConstantContext) HexConstant() IHexConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexConstantContext)
}

func (s *UnsignedConstantContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *UnsignedConstantContext) NIL() antlr.TerminalNode {
	return s.GetToken(pascalParserNIL, 0)
}

func (s *UnsignedConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnsignedConstant(s)
	}
}

func (s *UnsignedConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnsignedConstant(s)
	}
}

func (s *UnsignedConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnsignedConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnsignedConstant() (localctx IUnsignedConstantContext) {
	localctx = NewUnsignedConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, pascalParserRULE_unsignedConstant)
	p.SetState(1501)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserNUM_INT, pascalParserNUM_REAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1496)
			p.UnsignedNumber()
		}

	case pascalParserCHR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1497)
			p.ConstantChr()
		}

	case pascalParserHEX_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1498)
			p.HexConstant()
		}

	case pascalParserSTRING_LITERAL, pascalParserSTRING_CROSSHATCH_LITERAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1499)
			p.String_()
		}

	case pascalParserNIL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1500)
			p.Match(pascalParserNIL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDesignatorContext is an interface to support dynamic dispatch.
type IFunctionDesignatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext
	RPAREN() antlr.TerminalNode

	// IsFunctionDesignatorContext differentiates from other interfaces.
	IsFunctionDesignatorContext()
}

type FunctionDesignatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDesignatorContext() *FunctionDesignatorContext {
	var p = new(FunctionDesignatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionDesignator
	return p
}

func InitEmptyFunctionDesignatorContext(p *FunctionDesignatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionDesignator
}

func (*FunctionDesignatorContext) IsFunctionDesignatorContext() {}

func NewFunctionDesignatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDesignatorContext {
	var p = new(FunctionDesignatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_functionDesignator

	return p
}

func (s *FunctionDesignatorContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDesignatorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionDesignatorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *FunctionDesignatorContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *FunctionDesignatorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *FunctionDesignatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDesignatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDesignatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFunctionDesignator(s)
	}
}

func (s *FunctionDesignatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFunctionDesignator(s)
	}
}

func (s *FunctionDesignatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFunctionDesignator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FunctionDesignator() (localctx IFunctionDesignatorContext) {
	localctx = NewFunctionDesignatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, pascalParserRULE_functionDesignator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1503)
		p.Identifier()
	}

	p.SetState(1508)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 165, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1504)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1505)
			p.ParameterList()
		}
		{
			p.SetState(1506)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultDesignatorContext is an interface to support dynamic dispatch.
type IDefaultDesignatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext
	RPAREN() antlr.TerminalNode

	// IsDefaultDesignatorContext differentiates from other interfaces.
	IsDefaultDesignatorContext()
}

type DefaultDesignatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultDesignatorContext() *DefaultDesignatorContext {
	var p = new(DefaultDesignatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_defaultDesignator
	return p
}

func InitEmptyDefaultDesignatorContext(p *DefaultDesignatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_defaultDesignator
}

func (*DefaultDesignatorContext) IsDefaultDesignatorContext() {}

func NewDefaultDesignatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultDesignatorContext {
	var p = new(DefaultDesignatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_defaultDesignator

	return p
}

func (s *DefaultDesignatorContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultDesignatorContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *DefaultDesignatorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *DefaultDesignatorContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *DefaultDesignatorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *DefaultDesignatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultDesignatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultDesignatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterDefaultDesignator(s)
	}
}

func (s *DefaultDesignatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitDefaultDesignator(s)
	}
}

func (s *DefaultDesignatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitDefaultDesignator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) DefaultDesignator() (localctx IDefaultDesignatorContext) {
	localctx = NewDefaultDesignatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, pascalParserRULE_defaultDesignator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1510)
		p.Match(pascalParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1511)
		p.Match(pascalParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1512)
		p.ParameterList()
	}
	{
		p.SetState(1513)
		p.Match(pascalParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterListContext is an interface to support dynamic dispatch.
type IParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllActualParameter() []IActualParameterContext
	ActualParameter(i int) IActualParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsParameterListContext differentiates from other interfaces.
	IsParameterListContext()
}

type ParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterListContext() *ParameterListContext {
	var p = new(ParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterList
	return p
}

func InitEmptyParameterListContext(p *ParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterList
}

func (*ParameterListContext) IsParameterListContext() {}

func NewParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterListContext {
	var p = new(ParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_parameterList

	return p
}

func (s *ParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterListContext) AllActualParameter() []IActualParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IActualParameterContext); ok {
			len++
		}
	}

	tst := make([]IActualParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IActualParameterContext); ok {
			tst[i] = t.(IActualParameterContext)
			i++
		}
	}

	return tst
}

func (s *ParameterListContext) ActualParameter(i int) IActualParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IActualParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IActualParameterContext)
}

func (s *ParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterParameterList(s)
	}
}

func (s *ParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitParameterList(s)
	}
}

func (s *ParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ParameterList() (localctx IParameterListContext) {
	localctx = NewParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, pascalParserRULE_parameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1515)
		p.ActualParameter()
	}
	p.SetState(1520)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(1516)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1517)
			p.ActualParameter()
		}

		p.SetState(1522)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_Context is an interface to support dynamic dispatch.
type ISet_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	ElementList() IElementListContext
	RBRACK() antlr.TerminalNode
	LBRACK2() antlr.TerminalNode
	RBRACK2() antlr.TerminalNode

	// IsSet_Context differentiates from other interfaces.
	IsSet_Context()
}

type Set_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_Context() *Set_Context {
	var p = new(Set_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_set_
	return p
}

func InitEmptySet_Context(p *Set_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_set_
}

func (*Set_Context) IsSet_Context() {}

func NewSet_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_Context {
	var p = new(Set_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_set_

	return p
}

func (s *Set_Context) GetParser() antlr.Parser { return s.parser }

func (s *Set_Context) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *Set_Context) ElementList() IElementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementListContext)
}

func (s *Set_Context) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *Set_Context) LBRACK2() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK2, 0)
}

func (s *Set_Context) RBRACK2() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK2, 0)
}

func (s *Set_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSet_(s)
	}
}

func (s *Set_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSet_(s)
	}
}

func (s *Set_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSet_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Set_() (localctx ISet_Context) {
	localctx = NewSet_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, pascalParserRULE_set_)
	p.SetState(1531)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserLBRACK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1523)
			p.Match(pascalParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1524)
			p.ElementList()
		}
		{
			p.SetState(1525)
			p.Match(pascalParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case pascalParserLBRACK2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1527)
			p.Match(pascalParserLBRACK2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1528)
			p.ElementList()
		}
		{
			p.SetState(1529)
			p.Match(pascalParserRBRACK2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementListContext is an interface to support dynamic dispatch.
type IElementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllElement() []IElementContext
	Element(i int) IElementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsElementListContext differentiates from other interfaces.
	IsElementListContext()
}

type ElementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementListContext() *ElementListContext {
	var p = new(ElementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_elementList
	return p
}

func InitEmptyElementListContext(p *ElementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_elementList
}

func (*ElementListContext) IsElementListContext() {}

func NewElementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementListContext {
	var p = new(ElementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_elementList

	return p
}

func (s *ElementListContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementListContext) AllElement() []IElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElementContext); ok {
			len++
		}
	}

	tst := make([]IElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElementContext); ok {
			tst[i] = t.(IElementContext)
			i++
		}
	}

	return tst
}

func (s *ElementListContext) Element(i int) IElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementContext)
}

func (s *ElementListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ElementListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ElementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterElementList(s)
	}
}

func (s *ElementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitElementList(s)
	}
}

func (s *ElementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitElementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ElementList() (localctx IElementListContext) {
	localctx = NewElementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, pascalParserRULE_elementList)
	var _la int

	p.SetState(1542)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserARRAY, pascalParserBOOLEAN, pascalParserCHAR, pascalParserCHR, pascalParserINTEGER, pascalParserNIL, pascalParserNOT, pascalParserREAL, pascalParserPLUS, pascalParserMINUS, pascalParserLPAREN, pascalParserLBRACK, pascalParserLBRACK2, pascalParserAT, pascalParserSTRING, pascalParserTRUE, pascalParserFALSE, pascalParserREAD, pascalParserWRITE, pascalParserDEFAULT, pascalParserINDEX, pascalParserINHERITED, pascalParserCARDINAL, pascalParserLONGBOOL, pascalParserLONGINT, pascalParserIDENT, pascalParserHEX_LITERAL, pascalParserSTRING_LITERAL, pascalParserSTRING_CROSSHATCH_LITERAL, pascalParserNUM_INT, pascalParserNUM_REAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1533)
			p.Element()
		}
		p.SetState(1538)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == pascalParserCOMMA {
			{
				p.SetState(1534)
				p.Match(pascalParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1535)
				p.Element()
			}

			p.SetState(1540)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case pascalParserRBRACK, pascalParserRBRACK2:
		p.EnterOuterAlt(localctx, 2)

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementContext is an interface to support dynamic dispatch.
type IElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	DOTDOT() antlr.TerminalNode

	// IsElementContext differentiates from other interfaces.
	IsElementContext()
}

type ElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementContext() *ElementContext {
	var p = new(ElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_element
	return p
}

func InitEmptyElementContext(p *ElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_element
}

func (*ElementContext) IsElementContext() {}

func NewElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementContext {
	var p = new(ElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_element

	return p
}

func (s *ElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ElementContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ElementContext) DOTDOT() antlr.TerminalNode {
	return s.GetToken(pascalParserDOTDOT, 0)
}

func (s *ElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterElement(s)
	}
}

func (s *ElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitElement(s)
	}
}

func (s *ElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Element() (localctx IElementContext) {
	localctx = NewElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, pascalParserRULE_element)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1544)
		p.Expression()
	}
	p.SetState(1547)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserDOTDOT {
		{
			p.SetState(1545)
			p.Match(pascalParserDOTDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1546)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureStatementContext is an interface to support dynamic dispatch.
type IProcedureStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext
	RPAREN() antlr.TerminalNode

	// IsProcedureStatementContext differentiates from other interfaces.
	IsProcedureStatementContext()
}

type ProcedureStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureStatementContext() *ProcedureStatementContext {
	var p = new(ProcedureStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureStatement
	return p
}

func InitEmptyProcedureStatementContext(p *ProcedureStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureStatement
}

func (*ProcedureStatementContext) IsProcedureStatementContext() {}

func NewProcedureStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureStatementContext {
	var p = new(ProcedureStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureStatement

	return p
}

func (s *ProcedureStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ProcedureStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ProcedureStatementContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *ProcedureStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ProcedureStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureStatement(s)
	}
}

func (s *ProcedureStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureStatement(s)
	}
}

func (s *ProcedureStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureStatement() (localctx IProcedureStatementContext) {
	localctx = NewProcedureStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, pascalParserRULE_procedureStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1549)
		p.Identifier()
	}
	p.SetState(1554)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1550)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1551)
			p.ParameterList()
		}
		{
			p.SetState(1552)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodCallStatementContext is an interface to support dynamic dispatch.
type IMethodCallStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariableDesignator() []IVariableDesignatorContext
	VariableDesignator(i int) IVariableDesignatorContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext
	RPAREN() antlr.TerminalNode

	// IsMethodCallStatementContext differentiates from other interfaces.
	IsMethodCallStatementContext()
}

type MethodCallStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodCallStatementContext() *MethodCallStatementContext {
	var p = new(MethodCallStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_methodCallStatement
	return p
}

func InitEmptyMethodCallStatementContext(p *MethodCallStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_methodCallStatement
}

func (*MethodCallStatementContext) IsMethodCallStatementContext() {}

func NewMethodCallStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodCallStatementContext {
	var p = new(MethodCallStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_methodCallStatement

	return p
}

func (s *MethodCallStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodCallStatementContext) AllVariableDesignator() []IVariableDesignatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDesignatorContext); ok {
			len++
		}
	}

	tst := make([]IVariableDesignatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDesignatorContext); ok {
			tst[i] = t.(IVariableDesignatorContext)
			i++
		}
	}

	return tst
}

func (s *MethodCallStatementContext) VariableDesignator(i int) IVariableDesignatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDesignatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDesignatorContext)
}

func (s *MethodCallStatementContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDOT)
}

func (s *MethodCallStatementContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, i)
}

func (s *MethodCallStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MethodCallStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *MethodCallStatementContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *MethodCallStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *MethodCallStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodCallStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodCallStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterMethodCallStatement(s)
	}
}

func (s *MethodCallStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitMethodCallStatement(s)
	}
}

func (s *MethodCallStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitMethodCallStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) MethodCallStatement() (localctx IMethodCallStatementContext) {
	localctx = NewMethodCallStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, pascalParserRULE_methodCallStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1556)
		p.VariableDesignator()
	}
	p.SetState(1561)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 172, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1557)
				p.Match(pascalParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1558)
				p.VariableDesignator()
			}

		}
		p.SetState(1563)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 172, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1564)
		p.Match(pascalParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1565)
		p.Identifier()
	}
	p.SetState(1570)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1566)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1567)
			p.ParameterList()
		}
		{
			p.SetState(1568)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IActualParameterContext is an interface to support dynamic dispatch.
type IActualParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	AllParameterwidth() []IParameterwidthContext
	Parameterwidth(i int) IParameterwidthContext
	ProcedureLambdaDeclaration() IProcedureLambdaDeclarationContext
	FunctionLambdaDeclaration() IFunctionLambdaDeclarationContext

	// IsActualParameterContext differentiates from other interfaces.
	IsActualParameterContext()
}

type ActualParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActualParameterContext() *ActualParameterContext {
	var p = new(ActualParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_actualParameter
	return p
}

func InitEmptyActualParameterContext(p *ActualParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_actualParameter
}

func (*ActualParameterContext) IsActualParameterContext() {}

func NewActualParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ActualParameterContext {
	var p = new(ActualParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_actualParameter

	return p
}

func (s *ActualParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ActualParameterContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ActualParameterContext) AllParameterwidth() []IParameterwidthContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterwidthContext); ok {
			len++
		}
	}

	tst := make([]IParameterwidthContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterwidthContext); ok {
			tst[i] = t.(IParameterwidthContext)
			i++
		}
	}

	return tst
}

func (s *ActualParameterContext) Parameterwidth(i int) IParameterwidthContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterwidthContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterwidthContext)
}

func (s *ActualParameterContext) ProcedureLambdaDeclaration() IProcedureLambdaDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureLambdaDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureLambdaDeclarationContext)
}

func (s *ActualParameterContext) FunctionLambdaDeclaration() IFunctionLambdaDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionLambdaDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionLambdaDeclarationContext)
}

func (s *ActualParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ActualParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ActualParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterActualParameter(s)
	}
}

func (s *ActualParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitActualParameter(s)
	}
}

func (s *ActualParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitActualParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ActualParameter() (localctx IActualParameterContext) {
	localctx = NewActualParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, pascalParserRULE_actualParameter)
	var _la int

	p.SetState(1581)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserARRAY, pascalParserBOOLEAN, pascalParserCHAR, pascalParserCHR, pascalParserINTEGER, pascalParserNIL, pascalParserNOT, pascalParserREAL, pascalParserPLUS, pascalParserMINUS, pascalParserLPAREN, pascalParserLBRACK, pascalParserLBRACK2, pascalParserAT, pascalParserSTRING, pascalParserTRUE, pascalParserFALSE, pascalParserREAD, pascalParserWRITE, pascalParserDEFAULT, pascalParserINDEX, pascalParserINHERITED, pascalParserCARDINAL, pascalParserLONGBOOL, pascalParserLONGINT, pascalParserIDENT, pascalParserHEX_LITERAL, pascalParserSTRING_LITERAL, pascalParserSTRING_CROSSHATCH_LITERAL, pascalParserNUM_INT, pascalParserNUM_REAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1572)
			p.Expression()
		}
		p.SetState(1576)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == pascalParserCOLON {
			{
				p.SetState(1573)
				p.Parameterwidth()
			}

			p.SetState(1578)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case pascalParserPROCEDURE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1579)
			p.ProcedureLambdaDeclaration()
		}

	case pascalParserFUNCTION:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1580)
			p.FunctionLambdaDeclaration()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterwidthContext is an interface to support dynamic dispatch.
type IParameterwidthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode
	Expression() IExpressionContext

	// IsParameterwidthContext differentiates from other interfaces.
	IsParameterwidthContext()
}

type ParameterwidthContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterwidthContext() *ParameterwidthContext {
	var p = new(ParameterwidthContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterwidth
	return p
}

func InitEmptyParameterwidthContext(p *ParameterwidthContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterwidth
}

func (*ParameterwidthContext) IsParameterwidthContext() {}

func NewParameterwidthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterwidthContext {
	var p = new(ParameterwidthContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_parameterwidth

	return p
}

func (s *ParameterwidthContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterwidthContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *ParameterwidthContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParameterwidthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterwidthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterwidthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterParameterwidth(s)
	}
}

func (s *ParameterwidthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitParameterwidth(s)
	}
}

func (s *ParameterwidthContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitParameterwidth(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Parameterwidth() (localctx IParameterwidthContext) {
	localctx = NewParameterwidthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, pascalParserRULE_parameterwidth)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1583)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1584)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGotoStatementContext is an interface to support dynamic dispatch.
type IGotoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GOTO() antlr.TerminalNode
	Label() ILabelContext

	// IsGotoStatementContext differentiates from other interfaces.
	IsGotoStatementContext()
}

type GotoStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGotoStatementContext() *GotoStatementContext {
	var p = new(GotoStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_gotoStatement
	return p
}

func InitEmptyGotoStatementContext(p *GotoStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_gotoStatement
}

func (*GotoStatementContext) IsGotoStatementContext() {}

func NewGotoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GotoStatementContext {
	var p = new(GotoStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_gotoStatement

	return p
}

func (s *GotoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GotoStatementContext) GOTO() antlr.TerminalNode {
	return s.GetToken(pascalParserGOTO, 0)
}

func (s *GotoStatementContext) Label() ILabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *GotoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GotoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GotoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterGotoStatement(s)
	}
}

func (s *GotoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitGotoStatement(s)
	}
}

func (s *GotoStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitGotoStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) GotoStatement() (localctx IGotoStatementContext) {
	localctx = NewGotoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, pascalParserRULE_gotoStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1586)
		p.Match(pascalParserGOTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1587)
		p.Label()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInheritedStatementContext is an interface to support dynamic dispatch.
type IInheritedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INHERITED() antlr.TerminalNode
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext
	RPAREN() antlr.TerminalNode

	// IsInheritedStatementContext differentiates from other interfaces.
	IsInheritedStatementContext()
}

type InheritedStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInheritedStatementContext() *InheritedStatementContext {
	var p = new(InheritedStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_inheritedStatement
	return p
}

func InitEmptyInheritedStatementContext(p *InheritedStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_inheritedStatement
}

func (*InheritedStatementContext) IsInheritedStatementContext() {}

func NewInheritedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InheritedStatementContext {
	var p = new(InheritedStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_inheritedStatement

	return p
}

func (s *InheritedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InheritedStatementContext) INHERITED() antlr.TerminalNode {
	return s.GetToken(pascalParserINHERITED, 0)
}

func (s *InheritedStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InheritedStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *InheritedStatementContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *InheritedStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *InheritedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InheritedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InheritedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInheritedStatement(s)
	}
}

func (s *InheritedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInheritedStatement(s)
	}
}

func (s *InheritedStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInheritedStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InheritedStatement() (localctx IInheritedStatementContext) {
	localctx = NewInheritedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, pascalParserRULE_inheritedStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1589)
		p.Match(pascalParserINHERITED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1597)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-85)) & ^0x3f) == 0 && ((int64(1)<<(_la-85))&137438953483) != 0 {
		{
			p.SetState(1590)
			p.Identifier()
		}
		p.SetState(1595)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLPAREN {
			{
				p.SetState(1591)
				p.Match(pascalParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1592)
				p.ParameterList()
			}
			{
				p.SetState(1593)
				p.Match(pascalParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmptyStatement_Context is an interface to support dynamic dispatch.
type IEmptyStatement_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsEmptyStatement_Context differentiates from other interfaces.
	IsEmptyStatement_Context()
}

type EmptyStatement_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatement_Context() *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_emptyStatement_
	return p
}

func InitEmptyEmptyStatement_Context(p *EmptyStatement_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_emptyStatement_
}

func (*EmptyStatement_Context) IsEmptyStatement_Context() {}

func NewEmptyStatement_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_emptyStatement_

	return p
}

func (s *EmptyStatement_Context) GetParser() antlr.Parser { return s.parser }
func (s *EmptyStatement_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatement_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatement_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitEmptyStatement_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) EmptyStatement_() (localctx IEmptyStatement_Context) {
	localctx = NewEmptyStatement_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, pascalParserRULE_emptyStatement_)
	p.EnterOuterAlt(localctx, 1)

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmpty_Context is an interface to support dynamic dispatch.
type IEmpty_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsEmpty_Context differentiates from other interfaces.
	IsEmpty_Context()
}

type Empty_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmpty_Context() *Empty_Context {
	var p = new(Empty_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_empty_
	return p
}

func InitEmptyEmpty_Context(p *Empty_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_empty_
}

func (*Empty_Context) IsEmpty_Context() {}

func NewEmpty_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Empty_Context {
	var p = new(Empty_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_empty_

	return p
}

func (s *Empty_Context) GetParser() antlr.Parser { return s.parser }
func (s *Empty_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Empty_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Empty_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterEmpty_(s)
	}
}

func (s *Empty_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitEmpty_(s)
	}
}

func (s *Empty_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitEmpty_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Empty_() (localctx IEmpty_Context) {
	localctx = NewEmpty_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, pascalParserRULE_empty_)
	p.EnterOuterAlt(localctx, 1)

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructuredStatementContext is an interface to support dynamic dispatch.
type IStructuredStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CompoundStatement() ICompoundStatementContext
	ConditionalStatement() IConditionalStatementContext
	RepetetiveStatement() IRepetetiveStatementContext
	WithStatement() IWithStatementContext
	TryExceptStatement() ITryExceptStatementContext
	TryFinallyStatement() ITryFinallyStatementContext

	// IsStructuredStatementContext differentiates from other interfaces.
	IsStructuredStatementContext()
}

type StructuredStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructuredStatementContext() *StructuredStatementContext {
	var p = new(StructuredStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_structuredStatement
	return p
}

func InitEmptyStructuredStatementContext(p *StructuredStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_structuredStatement
}

func (*StructuredStatementContext) IsStructuredStatementContext() {}

func NewStructuredStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructuredStatementContext {
	var p = new(StructuredStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_structuredStatement

	return p
}

func (s *StructuredStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StructuredStatementContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *StructuredStatementContext) ConditionalStatement() IConditionalStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalStatementContext)
}

func (s *StructuredStatementContext) RepetetiveStatement() IRepetetiveStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepetetiveStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepetetiveStatementContext)
}

func (s *StructuredStatementContext) WithStatement() IWithStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithStatementContext)
}

func (s *StructuredStatementContext) TryExceptStatement() ITryExceptStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryExceptStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryExceptStatementContext)
}

func (s *StructuredStatementContext) TryFinallyStatement() ITryFinallyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryFinallyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryFinallyStatementContext)
}

func (s *StructuredStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructuredStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructuredStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStructuredStatement(s)
	}
}

func (s *StructuredStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStructuredStatement(s)
	}
}

func (s *StructuredStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStructuredStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) StructuredStatement() (localctx IStructuredStatementContext) {
	localctx = NewStructuredStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, pascalParserRULE_structuredStatement)
	p.SetState(1609)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 178, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1603)
			p.CompoundStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1604)
			p.ConditionalStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1605)
			p.RepetetiveStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1606)
			p.WithStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1607)
			p.TryExceptStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1608)
			p.TryFinallyStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompoundStatementContext is an interface to support dynamic dispatch.
type ICompoundStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEGIN() antlr.TerminalNode
	Statements() IStatementsContext
	END() antlr.TerminalNode

	// IsCompoundStatementContext differentiates from other interfaces.
	IsCompoundStatementContext()
}

type CompoundStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundStatementContext() *CompoundStatementContext {
	var p = new(CompoundStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_compoundStatement
	return p
}

func InitEmptyCompoundStatementContext(p *CompoundStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_compoundStatement
}

func (*CompoundStatementContext) IsCompoundStatementContext() {}

func NewCompoundStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundStatementContext {
	var p = new(CompoundStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_compoundStatement

	return p
}

func (s *CompoundStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundStatementContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(pascalParserBEGIN, 0)
}

func (s *CompoundStatementContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *CompoundStatementContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *CompoundStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitCompoundStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) CompoundStatement() (localctx ICompoundStatementContext) {
	localctx = NewCompoundStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, pascalParserRULE_compoundStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1611)
		p.Match(pascalParserBEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1612)
		p.Statements()
	}
	{
		p.SetState(1613)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementsContext is an interface to support dynamic dispatch.
type IStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsStatementsContext differentiates from other interfaces.
	IsStatementsContext()
}

type StatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsContext() *StatementsContext {
	var p = new(StatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_statements
	return p
}

func InitEmptyStatementsContext(p *StatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_statements
}

func (*StatementsContext) IsStatementsContext() {}

func NewStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsContext {
	var p = new(StatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_statements

	return p
}

func (s *StatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementsContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementsContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *StatementsContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *StatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStatements(s)
	}
}

func (s *StatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStatements(s)
	}
}

func (s *StatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Statements() (localctx IStatementsContext) {
	localctx = NewStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, pascalParserRULE_statements)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1615)
		p.Statement()
	}
	p.SetState(1620)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1616)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1617)
				p.Statement()
			}

		}
		p.SetState(1622)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionalStatementContext is an interface to support dynamic dispatch.
type IConditionalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IfStatement() IIfStatementContext
	CaseStatement() ICaseStatementContext

	// IsConditionalStatementContext differentiates from other interfaces.
	IsConditionalStatementContext()
}

type ConditionalStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalStatementContext() *ConditionalStatementContext {
	var p = new(ConditionalStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_conditionalStatement
	return p
}

func InitEmptyConditionalStatementContext(p *ConditionalStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_conditionalStatement
}

func (*ConditionalStatementContext) IsConditionalStatementContext() {}

func NewConditionalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalStatementContext {
	var p = new(ConditionalStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_conditionalStatement

	return p
}

func (s *ConditionalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalStatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *ConditionalStatementContext) CaseStatement() ICaseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseStatementContext)
}

func (s *ConditionalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConditionalStatement(s)
	}
}

func (s *ConditionalStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConditionalStatement(s)
	}
}

func (s *ConditionalStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConditionalStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConditionalStatement() (localctx IConditionalStatementContext) {
	localctx = NewConditionalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, pascalParserRULE_conditionalStatement)
	p.SetState(1625)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserIF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1623)
			p.IfStatement()
		}

	case pascalParserCASE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1624)
			p.CaseStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	Expression() IExpressionContext
	THEN() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	ELSE() antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_ifStatement
	return p
}

func InitEmptyIfStatementContext(p *IfStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_ifStatement
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(pascalParserIF, 0)
}

func (s *IfStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfStatementContext) THEN() antlr.TerminalNode {
	return s.GetToken(pascalParserTHEN, 0)
}

func (s *IfStatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(pascalParserELSE, 0)
}

func (s *IfStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, pascalParserRULE_ifStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1627)
		p.Match(pascalParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1628)
		p.Expression()
	}
	{
		p.SetState(1629)
		p.Match(pascalParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1630)
		p.Statement()
	}
	p.SetState(1633)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 181, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1631)
			p.Match(pascalParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1632)
			p.Statement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1636)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 182, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1635)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseStatementContext is an interface to support dynamic dispatch.
type ICaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	Expression() IExpressionContext
	OF() antlr.TerminalNode
	AllCaseListElement() []ICaseListElementContext
	CaseListElement(i int) ICaseListElementContext
	END() antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	ELSE() antlr.TerminalNode
	Statements() IStatementsContext

	// IsCaseStatementContext differentiates from other interfaces.
	IsCaseStatementContext()
}

type CaseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseStatementContext() *CaseStatementContext {
	var p = new(CaseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_caseStatement
	return p
}

func InitEmptyCaseStatementContext(p *CaseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_caseStatement
}

func (*CaseStatementContext) IsCaseStatementContext() {}

func NewCaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseStatementContext {
	var p = new(CaseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_caseStatement

	return p
}

func (s *CaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseStatementContext) CASE() antlr.TerminalNode {
	return s.GetToken(pascalParserCASE, 0)
}

func (s *CaseStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseStatementContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *CaseStatementContext) AllCaseListElement() []ICaseListElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseListElementContext); ok {
			len++
		}
	}

	tst := make([]ICaseListElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseListElementContext); ok {
			tst[i] = t.(ICaseListElementContext)
			i++
		}
	}

	return tst
}

func (s *CaseStatementContext) CaseListElement(i int) ICaseListElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseListElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseListElementContext)
}

func (s *CaseStatementContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *CaseStatementContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *CaseStatementContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *CaseStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(pascalParserELSE, 0)
}

func (s *CaseStatementContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *CaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterCaseStatement(s)
	}
}

func (s *CaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitCaseStatement(s)
	}
}

func (s *CaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitCaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) CaseStatement() (localctx ICaseStatementContext) {
	localctx = NewCaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, pascalParserRULE_caseStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1638)
		p.Match(pascalParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1639)
		p.Expression()
	}
	{
		p.SetState(1640)
		p.Match(pascalParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1641)
		p.CaseListElement()
	}
	p.SetState(1646)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 183, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1642)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1643)
				p.CaseListElement()
			}

		}
		p.SetState(1648)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 183, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1652)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 184, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1649)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1650)
			p.Match(pascalParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1651)
			p.Statements()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1655)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserSEMI {
		{
			p.SetState(1654)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1657)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseListElementContext is an interface to support dynamic dispatch.
type ICaseListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConstList() IConstListContext
	COLON() antlr.TerminalNode
	Statement() IStatementContext

	// IsCaseListElementContext differentiates from other interfaces.
	IsCaseListElementContext()
}

type CaseListElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseListElementContext() *CaseListElementContext {
	var p = new(CaseListElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_caseListElement
	return p
}

func InitEmptyCaseListElementContext(p *CaseListElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_caseListElement
}

func (*CaseListElementContext) IsCaseListElementContext() {}

func NewCaseListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseListElementContext {
	var p = new(CaseListElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_caseListElement

	return p
}

func (s *CaseListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseListElementContext) ConstList() IConstListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstListContext)
}

func (s *CaseListElementContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *CaseListElementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *CaseListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseListElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterCaseListElement(s)
	}
}

func (s *CaseListElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitCaseListElement(s)
	}
}

func (s *CaseListElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitCaseListElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) CaseListElement() (localctx ICaseListElementContext) {
	localctx = NewCaseListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, pascalParserRULE_caseListElement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1659)
		p.ConstList()
	}
	{
		p.SetState(1660)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1661)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRepetetiveStatementContext is an interface to support dynamic dispatch.
type IRepetetiveStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WhileStatement() IWhileStatementContext
	RepeatStatement() IRepeatStatementContext
	ForStatement() IForStatementContext

	// IsRepetetiveStatementContext differentiates from other interfaces.
	IsRepetetiveStatementContext()
}

type RepetetiveStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepetetiveStatementContext() *RepetetiveStatementContext {
	var p = new(RepetetiveStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_repetetiveStatement
	return p
}

func InitEmptyRepetetiveStatementContext(p *RepetetiveStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_repetetiveStatement
}

func (*RepetetiveStatementContext) IsRepetetiveStatementContext() {}

func NewRepetetiveStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RepetetiveStatementContext {
	var p = new(RepetetiveStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_repetetiveStatement

	return p
}

func (s *RepetetiveStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RepetetiveStatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *RepetetiveStatementContext) RepeatStatement() IRepeatStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepeatStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepeatStatementContext)
}

func (s *RepetetiveStatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *RepetetiveStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepetetiveStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RepetetiveStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRepetetiveStatement(s)
	}
}

func (s *RepetetiveStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRepetetiveStatement(s)
	}
}

func (s *RepetetiveStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRepetetiveStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RepetetiveStatement() (localctx IRepetetiveStatementContext) {
	localctx = NewRepetetiveStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, pascalParserRULE_repetetiveStatement)
	p.SetState(1666)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserWHILE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1663)
			p.WhileStatement()
		}

	case pascalParserREPEAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1664)
			p.RepeatStatement()
		}

	case pascalParserFOR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1665)
			p.ForStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHILE() antlr.TerminalNode
	Expression() IExpressionContext
	DO() antlr.TerminalNode
	Statement() IStatementContext

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_whileStatement
	return p
}

func InitEmptyWhileStatementContext(p *WhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_whileStatement
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(pascalParserWHILE, 0)
}

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(pascalParserDO, 0)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (s *WhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, pascalParserRULE_whileStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1668)
		p.Match(pascalParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1669)
		p.Expression()
	}
	{
		p.SetState(1670)
		p.Match(pascalParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1671)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRepeatStatementContext is an interface to support dynamic dispatch.
type IRepeatStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPEAT() antlr.TerminalNode
	Statements() IStatementsContext
	UNTIL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsRepeatStatementContext differentiates from other interfaces.
	IsRepeatStatementContext()
}

type RepeatStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepeatStatementContext() *RepeatStatementContext {
	var p = new(RepeatStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_repeatStatement
	return p
}

func InitEmptyRepeatStatementContext(p *RepeatStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_repeatStatement
}

func (*RepeatStatementContext) IsRepeatStatementContext() {}

func NewRepeatStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RepeatStatementContext {
	var p = new(RepeatStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_repeatStatement

	return p
}

func (s *RepeatStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RepeatStatementContext) REPEAT() antlr.TerminalNode {
	return s.GetToken(pascalParserREPEAT, 0)
}

func (s *RepeatStatementContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *RepeatStatementContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(pascalParserUNTIL, 0)
}

func (s *RepeatStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RepeatStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepeatStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RepeatStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRepeatStatement(s)
	}
}

func (s *RepeatStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRepeatStatement(s)
	}
}

func (s *RepeatStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRepeatStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RepeatStatement() (localctx IRepeatStatementContext) {
	localctx = NewRepeatStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, pascalParserRULE_repeatStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1673)
		p.Match(pascalParserREPEAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1674)
		p.Statements()
	}
	{
		p.SetState(1675)
		p.Match(pascalParserUNTIL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1676)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode
	ForList() IForListContext
	DO() antlr.TerminalNode
	Statement() IStatementContext

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forStatement
	return p
}

func InitEmptyForStatementContext(p *ForStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forStatement
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(pascalParserFOR, 0)
}

func (s *ForStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ForStatementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(pascalParserASSIGN, 0)
}

func (s *ForStatementContext) ForList() IForListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForListContext)
}

func (s *ForStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(pascalParserDO, 0)
}

func (s *ForStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (s *ForStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitForStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ForStatement() (localctx IForStatementContext) {
	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, pascalParserRULE_forStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1678)
		p.Match(pascalParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1679)
		p.Identifier()
	}
	{
		p.SetState(1680)
		p.Match(pascalParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1681)
		p.ForList()
	}
	{
		p.SetState(1682)
		p.Match(pascalParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1683)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForListContext is an interface to support dynamic dispatch.
type IForListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InitialValue() IInitialValueContext
	FinalValue() IFinalValueContext
	TO() antlr.TerminalNode
	DOWNTO() antlr.TerminalNode

	// IsForListContext differentiates from other interfaces.
	IsForListContext()
}

type ForListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForListContext() *ForListContext {
	var p = new(ForListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forList
	return p
}

func InitEmptyForListContext(p *ForListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forList
}

func (*ForListContext) IsForListContext() {}

func NewForListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForListContext {
	var p = new(ForListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_forList

	return p
}

func (s *ForListContext) GetParser() antlr.Parser { return s.parser }

func (s *ForListContext) InitialValue() IInitialValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitialValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitialValueContext)
}

func (s *ForListContext) FinalValue() IFinalValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinalValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinalValueContext)
}

func (s *ForListContext) TO() antlr.TerminalNode {
	return s.GetToken(pascalParserTO, 0)
}

func (s *ForListContext) DOWNTO() antlr.TerminalNode {
	return s.GetToken(pascalParserDOWNTO, 0)
}

func (s *ForListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterForList(s)
	}
}

func (s *ForListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitForList(s)
	}
}

func (s *ForListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitForList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ForList() (localctx IForListContext) {
	localctx = NewForListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, pascalParserRULE_forList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1685)
		p.InitialValue()
	}
	{
		p.SetState(1686)
		_la = p.GetTokenStream().LA(1)

		if !(_la == pascalParserDOWNTO || _la == pascalParserTO) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1687)
		p.FinalValue()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitialValueContext is an interface to support dynamic dispatch.
type IInitialValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsInitialValueContext differentiates from other interfaces.
	IsInitialValueContext()
}

type InitialValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitialValueContext() *InitialValueContext {
	var p = new(InitialValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_initialValue
	return p
}

func InitEmptyInitialValueContext(p *InitialValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_initialValue
}

func (*InitialValueContext) IsInitialValueContext() {}

func NewInitialValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitialValueContext {
	var p = new(InitialValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_initialValue

	return p
}

func (s *InitialValueContext) GetParser() antlr.Parser { return s.parser }

func (s *InitialValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InitialValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitialValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitialValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInitialValue(s)
	}
}

func (s *InitialValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInitialValue(s)
	}
}

func (s *InitialValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInitialValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InitialValue() (localctx IInitialValueContext) {
	localctx = NewInitialValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, pascalParserRULE_initialValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1689)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFinalValueContext is an interface to support dynamic dispatch.
type IFinalValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsFinalValueContext differentiates from other interfaces.
	IsFinalValueContext()
}

type FinalValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinalValueContext() *FinalValueContext {
	var p = new(FinalValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_finalValue
	return p
}

func InitEmptyFinalValueContext(p *FinalValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_finalValue
}

func (*FinalValueContext) IsFinalValueContext() {}

func NewFinalValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinalValueContext {
	var p = new(FinalValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_finalValue

	return p
}

func (s *FinalValueContext) GetParser() antlr.Parser { return s.parser }

func (s *FinalValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FinalValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinalValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinalValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFinalValue(s)
	}
}

func (s *FinalValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFinalValue(s)
	}
}

func (s *FinalValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFinalValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FinalValue() (localctx IFinalValueContext) {
	localctx = NewFinalValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, pascalParserRULE_finalValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1691)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithStatementContext is an interface to support dynamic dispatch.
type IWithStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	WithStatementVariableList() IWithStatementVariableListContext
	DO() antlr.TerminalNode
	Statement() IStatementContext
	Expression() IExpressionContext

	// IsWithStatementContext differentiates from other interfaces.
	IsWithStatementContext()
}

type WithStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithStatementContext() *WithStatementContext {
	var p = new(WithStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_withStatement
	return p
}

func InitEmptyWithStatementContext(p *WithStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_withStatement
}

func (*WithStatementContext) IsWithStatementContext() {}

func NewWithStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithStatementContext {
	var p = new(WithStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_withStatement

	return p
}

func (s *WithStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WithStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(pascalParserWITH, 0)
}

func (s *WithStatementContext) WithStatementVariableList() IWithStatementVariableListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithStatementVariableListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithStatementVariableListContext)
}

func (s *WithStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(pascalParserDO, 0)
}

func (s *WithStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WithStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WithStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterWithStatement(s)
	}
}

func (s *WithStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitWithStatement(s)
	}
}

func (s *WithStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitWithStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) WithStatement() (localctx IWithStatementContext) {
	localctx = NewWithStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, pascalParserRULE_withStatement)
	p.SetState(1703)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 187, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1693)
			p.Match(pascalParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1694)
			p.WithStatementVariableList()
		}
		{
			p.SetState(1695)
			p.Match(pascalParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1696)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1698)
			p.Match(pascalParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1699)
			p.Expression()
		}
		{
			p.SetState(1700)
			p.Match(pascalParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1701)
			p.Statement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryExceptStatementContext is an interface to support dynamic dispatch.
type ITryExceptStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRY() antlr.TerminalNode
	AllStatements() []IStatementsContext
	Statements(i int) IStatementsContext
	EXCEPT() antlr.TerminalNode
	END() antlr.TerminalNode

	// IsTryExceptStatementContext differentiates from other interfaces.
	IsTryExceptStatementContext()
}

type TryExceptStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryExceptStatementContext() *TryExceptStatementContext {
	var p = new(TryExceptStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tryExceptStatement
	return p
}

func InitEmptyTryExceptStatementContext(p *TryExceptStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tryExceptStatement
}

func (*TryExceptStatementContext) IsTryExceptStatementContext() {}

func NewTryExceptStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryExceptStatementContext {
	var p = new(TryExceptStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_tryExceptStatement

	return p
}

func (s *TryExceptStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryExceptStatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(pascalParserTRY, 0)
}

func (s *TryExceptStatementContext) AllStatements() []IStatementsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementsContext); ok {
			len++
		}
	}

	tst := make([]IStatementsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementsContext); ok {
			tst[i] = t.(IStatementsContext)
			i++
		}
	}

	return tst
}

func (s *TryExceptStatementContext) Statements(i int) IStatementsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *TryExceptStatementContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(pascalParserEXCEPT, 0)
}

func (s *TryExceptStatementContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *TryExceptStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryExceptStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryExceptStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTryExceptStatement(s)
	}
}

func (s *TryExceptStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTryExceptStatement(s)
	}
}

func (s *TryExceptStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTryExceptStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TryExceptStatement() (localctx ITryExceptStatementContext) {
	localctx = NewTryExceptStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, pascalParserRULE_tryExceptStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1705)
		p.Match(pascalParserTRY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1706)
		p.Statements()
	}
	{
		p.SetState(1707)
		p.Match(pascalParserEXCEPT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1708)
		p.Statements()
	}
	{
		p.SetState(1709)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryFinallyStatementContext is an interface to support dynamic dispatch.
type ITryFinallyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRY() antlr.TerminalNode
	AllStatements() []IStatementsContext
	Statements(i int) IStatementsContext
	FINALLY() antlr.TerminalNode
	END() antlr.TerminalNode

	// IsTryFinallyStatementContext differentiates from other interfaces.
	IsTryFinallyStatementContext()
}

type TryFinallyStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryFinallyStatementContext() *TryFinallyStatementContext {
	var p = new(TryFinallyStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tryFinallyStatement
	return p
}

func InitEmptyTryFinallyStatementContext(p *TryFinallyStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tryFinallyStatement
}

func (*TryFinallyStatementContext) IsTryFinallyStatementContext() {}

func NewTryFinallyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryFinallyStatementContext {
	var p = new(TryFinallyStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_tryFinallyStatement

	return p
}

func (s *TryFinallyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryFinallyStatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(pascalParserTRY, 0)
}

func (s *TryFinallyStatementContext) AllStatements() []IStatementsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementsContext); ok {
			len++
		}
	}

	tst := make([]IStatementsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementsContext); ok {
			tst[i] = t.(IStatementsContext)
			i++
		}
	}

	return tst
}

func (s *TryFinallyStatementContext) Statements(i int) IStatementsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *TryFinallyStatementContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(pascalParserFINALLY, 0)
}

func (s *TryFinallyStatementContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *TryFinallyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryFinallyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryFinallyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTryFinallyStatement(s)
	}
}

func (s *TryFinallyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTryFinallyStatement(s)
	}
}

func (s *TryFinallyStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTryFinallyStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TryFinallyStatement() (localctx ITryFinallyStatementContext) {
	localctx = NewTryFinallyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, pascalParserRULE_tryFinallyStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1711)
		p.Match(pascalParserTRY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1712)
		p.Statements()
	}
	{
		p.SetState(1713)
		p.Match(pascalParserFINALLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1714)
		p.Statements()
	}
	{
		p.SetState(1715)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithStatementVariableListContext is an interface to support dynamic dispatch.
type IWithStatementVariableListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariableDesignator() []IVariableDesignatorContext
	VariableDesignator(i int) IVariableDesignatorContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWithStatementVariableListContext differentiates from other interfaces.
	IsWithStatementVariableListContext()
}

type WithStatementVariableListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithStatementVariableListContext() *WithStatementVariableListContext {
	var p = new(WithStatementVariableListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_withStatementVariableList
	return p
}

func InitEmptyWithStatementVariableListContext(p *WithStatementVariableListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_withStatementVariableList
}

func (*WithStatementVariableListContext) IsWithStatementVariableListContext() {}

func NewWithStatementVariableListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithStatementVariableListContext {
	var p = new(WithStatementVariableListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_withStatementVariableList

	return p
}

func (s *WithStatementVariableListContext) GetParser() antlr.Parser { return s.parser }

func (s *WithStatementVariableListContext) AllVariableDesignator() []IVariableDesignatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDesignatorContext); ok {
			len++
		}
	}

	tst := make([]IVariableDesignatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDesignatorContext); ok {
			tst[i] = t.(IVariableDesignatorContext)
			i++
		}
	}

	return tst
}

func (s *WithStatementVariableListContext) VariableDesignator(i int) IVariableDesignatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDesignatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDesignatorContext)
}

func (s *WithStatementVariableListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *WithStatementVariableListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *WithStatementVariableListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithStatementVariableListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithStatementVariableListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterWithStatementVariableList(s)
	}
}

func (s *WithStatementVariableListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitWithStatementVariableList(s)
	}
}

func (s *WithStatementVariableListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitWithStatementVariableList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) WithStatementVariableList() (localctx IWithStatementVariableListContext) {
	localctx = NewWithStatementVariableListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, pascalParserRULE_withStatementVariableList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1717)
		p.VariableDesignator()
	}
	p.SetState(1722)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(1718)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1719)
			p.VariableDesignator()
		}

		p.SetState(1724)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeSectionContext is an interface to support dynamic dispatch.
type IAttributeSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	AttributeList() IAttributeListContext
	RBRACK() antlr.TerminalNode

	// IsAttributeSectionContext differentiates from other interfaces.
	IsAttributeSectionContext()
}

type AttributeSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeSectionContext() *AttributeSectionContext {
	var p = new(AttributeSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_attributeSection
	return p
}

func InitEmptyAttributeSectionContext(p *AttributeSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_attributeSection
}

func (*AttributeSectionContext) IsAttributeSectionContext() {}

func NewAttributeSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeSectionContext {
	var p = new(AttributeSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_attributeSection

	return p
}

func (s *AttributeSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeSectionContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *AttributeSectionContext) AttributeList() IAttributeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeListContext)
}

func (s *AttributeSectionContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *AttributeSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAttributeSection(s)
	}
}

func (s *AttributeSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAttributeSection(s)
	}
}

func (s *AttributeSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAttributeSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) AttributeSection() (localctx IAttributeSectionContext) {
	localctx = NewAttributeSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, pascalParserRULE_attributeSection)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1725)
		p.Match(pascalParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1726)
		p.AttributeList()
	}
	{
		p.SetState(1727)
		p.Match(pascalParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeListContext is an interface to support dynamic dispatch.
type IAttributeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAttributeItem() []IAttributeItemContext
	AttributeItem(i int) IAttributeItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAttributeListContext differentiates from other interfaces.
	IsAttributeListContext()
}

type AttributeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeListContext() *AttributeListContext {
	var p = new(AttributeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_attributeList
	return p
}

func InitEmptyAttributeListContext(p *AttributeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_attributeList
}

func (*AttributeListContext) IsAttributeListContext() {}

func NewAttributeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeListContext {
	var p = new(AttributeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_attributeList

	return p
}

func (s *AttributeListContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeListContext) AllAttributeItem() []IAttributeItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeItemContext); ok {
			len++
		}
	}

	tst := make([]IAttributeItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeItemContext); ok {
			tst[i] = t.(IAttributeItemContext)
			i++
		}
	}

	return tst
}

func (s *AttributeListContext) AttributeItem(i int) IAttributeItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeItemContext)
}

func (s *AttributeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *AttributeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *AttributeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAttributeList(s)
	}
}

func (s *AttributeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAttributeList(s)
	}
}

func (s *AttributeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAttributeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) AttributeList() (localctx IAttributeListContext) {
	localctx = NewAttributeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, pascalParserRULE_attributeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1729)
		p.AttributeItem()
	}
	p.SetState(1734)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(1730)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1731)
			p.AttributeItem()
		}

		p.SetState(1736)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeItemContext is an interface to support dynamic dispatch.
type IAttributeItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext
	RPAREN() antlr.TerminalNode

	// IsAttributeItemContext differentiates from other interfaces.
	IsAttributeItemContext()
}

type AttributeItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeItemContext() *AttributeItemContext {
	var p = new(AttributeItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_attributeItem
	return p
}

func InitEmptyAttributeItemContext(p *AttributeItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_attributeItem
}

func (*AttributeItemContext) IsAttributeItemContext() {}

func NewAttributeItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeItemContext {
	var p = new(AttributeItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_attributeItem

	return p
}

func (s *AttributeItemContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AttributeItemContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *AttributeItemContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *AttributeItemContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *AttributeItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAttributeItem(s)
	}
}

func (s *AttributeItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAttributeItem(s)
	}
}

func (s *AttributeItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAttributeItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) AttributeItem() (localctx IAttributeItemContext) {
	localctx = NewAttributeItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, pascalParserRULE_attributeItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1737)
		p.Identifier()
	}
	p.SetState(1742)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1738)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1739)
			p.ParameterList()
		}
		{
			p.SetState(1740)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *pascalParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 130:
		var t *FactorContext = nil
		if localctx != nil {
			t = localctx.(*FactorContext)
		}
		return p.Factor_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *pascalParser) Factor_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
