// Code generated from /home/tomas/development/tomas303/projects/pascallsp/palsp/internal/pascal.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // pascal

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type pascalParser struct {
	*antlr.BaseParser
}

var PascalParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func pascalParserInit() {
	staticData := &PascalParserStaticData
	staticData.LiteralNames = []string{
		"", "", "'AND'", "'ARRAY'", "'BEGIN'", "'BOOLEAN'", "'CASE'", "'CHAR'",
		"'CHR'", "'CONST'", "'DIV'", "'DO'", "'DOWNTO'", "'ELSE'", "'END'",
		"'FILE'", "'FOR'", "'FUNCTION'", "'GOTO'", "'HELPER'", "'IF'", "'IN'",
		"'INTEGER'", "'LABEL'", "'MOD'", "'NIL'", "'NOT'", "'OF'", "'OR'", "'PACKED'",
		"'PROCEDURE'", "'PROGRAM'", "'REAL'", "'RECORD'", "'REFERENCE'", "'REPEAT'",
		"'SET'", "'THEN'", "'TO'", "'TYPE'", "'UNTIL'", "'VAR'", "'WHILE'",
		"'WITH'", "'+'", "'-'", "'*'", "'/'", "':='", "','", "';'", "':'", "'='",
		"'<>'", "'<'", "'<='", "'>='", "'>'", "'('", "')'", "'['", "'(.'", "']'",
		"'.)'", "'^'", "'@'", "'.'", "'..'", "'{'", "'}'", "'UNIT'", "'INTERFACE'",
		"'USES'", "'STRING'", "'IMPLEMENTATION'", "'TRUE'", "'FALSE'", "'CLASS'",
		"'PRIVATE'", "'PROTECTED'", "'PUBLIC'", "'PUBLISHED'", "'STRICT'", "'OUT'",
		"'PROPERTY'", "'READ'", "'WRITE'", "'DEFAULT'", "'INDEX'", "'AS'", "'TRY'",
		"'FINALLY'", "'EXCEPT'", "'INITIALIZATION'", "'FINALIZATION'", "'OBJECT'",
		"'INHERITED'", "'ABSTRACT'", "'REINTRODUCE'", "'VIRTUAL'", "'OVERRIDE'",
		"'OVERLOAD'", "'INLINE'", "'CDECL'", "'stdcall'", "'STATIC'", "'CONSTRUCTOR'",
		"'DESTRUCTOR'", "'resourcestring'", "'FORWARD'", "'RAISE'", "'SHR'",
		"'SHL'", "'XOR'", "'Cardinal'", "'LONGBOOL'", "'LONGINT'", "'operator'",
		"", "", "", "", "", "", "", "", "", "", "'\\uFEFF'",
	}
	staticData.SymbolicNames = []string{
		"", "GUID_LITERAL", "AND", "ARRAY", "BEGIN", "BOOLEAN", "CASE", "CHAR",
		"CHR", "CONST", "DIV", "DO", "DOWNTO", "ELSE", "END", "FILE", "FOR",
		"FUNCTION", "GOTO", "HELPER", "IF", "IN", "INTEGER", "LABEL", "MOD",
		"NIL", "NOT", "OF", "OR", "PACKED", "PROCEDURE", "PROGRAM", "REAL",
		"RECORD", "REFERENCE", "REPEAT", "SET", "THEN", "TO", "TYPE", "UNTIL",
		"VAR", "WHILE", "WITH", "PLUS", "MINUS", "STAR", "SLASH", "ASSIGN",
		"COMMA", "SEMI", "COLON", "EQUAL", "NOT_EQUAL", "LT", "LE", "GE", "GT",
		"LPAREN", "RPAREN", "LBRACK", "LBRACK2", "RBRACK", "RBRACK2", "DEREFERENCE",
		"AT", "DOT", "DOTDOT", "LCURLY", "RCURLY", "UNIT", "INTERFACE", "USES",
		"STRING", "IMPLEMENTATION", "TRUE", "FALSE", "CLASS", "PRIVATE", "PROTECTED",
		"PUBLIC", "PUBLISHED", "STRICT", "OUT", "PROPERTY", "READ", "WRITE",
		"DEFAULT", "INDEX", "AS", "TRY", "FINALLY", "EXCEPT", "INITIALIZATION",
		"FINALIZATION", "OBJECT", "INHERITED", "ABSTRACT", "REINTRODUCE", "VIRTUAL",
		"OVERRIDE", "OVERLOAD", "INLINE", "CDECL", "STDCALL", "STATIC", "CONSTRUCTOR",
		"DESTRUCTOR", "RESOURCESTRING", "FORWARD", "RAISE", "SHR", "SHL", "XOR",
		"CARDINAL", "LONGBOOL", "LONGINT", "OPERATOR", "WS", "COMMENT_1", "COMMENT_2",
		"COMMENT_3", "IDENT", "HEX_LITERAL", "STRING_LITERAL", "STRING_CROSSHATCH_LITERAL",
		"NUM_INT", "NUM_REAL", "UTF8BOM",
	}
	staticData.RuleNames = []string{
		"source", "program", "unit", "interfaceSection", "implementationSection",
		"initializationSection", "finalizationSection", "identifier", "identifierPart",
		"interfaceBlock", "implementationBlock", "block", "usesUnits", "labelDeclarationPart",
		"label", "constantDefinitionPart", "constantDefinition", "constantChr",
		"hexConstant", "constant", "arrayConstant", "unsignedNumber", "unsignedInteger",
		"unsignedReal", "sign", "bool_", "string", "resourceDefinitionPart",
		"resourceDefinition", "typeDefinitionPart", "typeDefinition", "functionType",
		"procedureType", "forwardClassType", "forwardInterfaceType", "classType",
		"classImplementsInterfaces", "accessSpecifier", "classDeclaration",
		"classImplicitPublishedDeclaration", "classDeclarationPart", "interfaceGuidConst",
		"interfaceType", "interfaceDeclaration", "interfaceDeclarationPart",
		"errorInterfaceDeclarationPart", "errorClassDeclarationPart", "propertyDeclaration",
		"propertyReadDeclaration", "propertyWriteDeclaration", "propertyDefaultValueDeclaration",
		"propertyIndexDeclaration", "propertyIndexParameters", "propertyIndexParametersList",
		"genericTemplate", "genericTemplateList", "type_", "simpleType", "scalarType",
		"scalerList", "scalerMember", "subrangeType", "typeIdentifier", "structuredType",
		"unpackedStructuredType", "stringtype", "arrayType", "typeList", "indexType",
		"recordType", "recordDeclaration", "recordImplicitPublishedDeclaration",
		"recordDeclarationPart", "errorRecordDeclarationPart", "recordParts",
		"recordFixedPart", "recordVariantPart", "tag", "recordVariant", "helperType",
		"helperDeclaration", "helperImplicitPublishedDeclaration", "helperDeclarationPart",
		"errorHelperDeclarationPart", "setType", "fileType", "pointerType",
		"variableDeclarationPart", "variableDeclaration", "procedureHeader",
		"functionHeader", "procedureOrFunctionHeader", "procedureOrFunctionHeaderModifiers",
		"procedureOrFunctionDeclaration", "procedureDeclaration", "functionDeclaration",
		"procedureLambdaDeclaration", "functionLambdaDeclaration", "resultType",
		"procedureOrFunctionBody", "classOperatorHeader", "classOperatorDeclaration",
		"formalParameterList", "formalParameterSection", "parameterGroup", "identifierList",
		"constList", "defaultValue", "typedIdentifierList", "statement", "errorStatement",
		"unlabelledStatement", "simpleStatement", "assignmentStatement", "raiseExceptionStatement",
		"variableDeclarationStatement", "variableDesignator", "typeCast", "propertyDesignator",
		"expression", "relationaloperator", "simpleExpression", "additiveoperator",
		"term", "multiplicativeoperator", "signedFactor", "factor", "unsignedConstant",
		"functionDesignator", "parameterList", "set_", "elementList", "element",
		"procedureStatement", "methodCallStatement", "actualParameter", "parameterwidth",
		"gotoStatement", "inheritedStatement", "emptyStatement_", "empty_",
		"structuredStatement", "compoundStatement", "statements", "conditionalStatement",
		"ifStatement", "caseStatement", "caseListElement", "repetetiveStatement",
		"whileStatement", "repeatStatement", "forStatement", "forList", "initialValue",
		"finalValue", "withStatement", "tryExceptStatement", "tryFinallyStatement",
		"withStatementVariableList", "attributeSection", "attributeList", "attributeItem",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 128, 1705, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 1, 0, 1, 0,
		3, 0, 327, 8, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 335, 8, 1, 1,
		1, 1, 1, 3, 1, 339, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 353, 8, 2, 1, 2, 3, 2, 356, 8, 2, 1, 2,
		3, 2, 359, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 3, 1, 3, 3, 3, 367, 8, 3, 1,
		3, 1, 3, 1, 4, 1, 4, 3, 4, 373, 8, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 1,
		6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 5, 7, 386, 8, 7, 10, 7, 12, 7, 389, 9,
		7, 1, 8, 1, 8, 3, 8, 393, 8, 8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 5,
		9, 401, 8, 9, 10, 9, 12, 9, 404, 9, 9, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 5, 10, 417, 8, 10, 10, 10, 12,
		10, 420, 9, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 5, 11, 427, 8, 11, 10,
		11, 12, 11, 430, 9, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 13,
		1, 13, 5, 13, 440, 8, 13, 10, 13, 12, 13, 443, 9, 13, 1, 13, 1, 13, 1,
		14, 1, 14, 1, 15, 1, 15, 1, 15, 1, 15, 4, 15, 453, 8, 15, 11, 15, 12, 15,
		454, 1, 16, 1, 16, 1, 16, 3, 16, 460, 8, 16, 1, 16, 1, 16, 1, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 471, 8, 16, 1, 17, 1, 17, 1,
		17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19,
		1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 495,
		8, 19, 5, 19, 497, 8, 19, 10, 19, 12, 19, 500, 9, 19, 3, 19, 502, 8, 19,
		1, 20, 1, 20, 1, 20, 1, 20, 5, 20, 508, 8, 20, 10, 20, 12, 20, 511, 9,
		20, 1, 20, 1, 20, 1, 21, 1, 21, 3, 21, 517, 8, 21, 1, 22, 1, 22, 1, 23,
		1, 23, 1, 24, 1, 24, 1, 25, 1, 25, 1, 26, 4, 26, 528, 8, 26, 11, 26, 12,
		26, 529, 1, 27, 1, 27, 4, 27, 534, 8, 27, 11, 27, 12, 27, 535, 1, 28, 1,
		28, 1, 28, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 1, 29, 4, 29, 547, 8, 29,
		11, 29, 12, 29, 548, 1, 30, 3, 30, 552, 8, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 1, 30, 3, 30, 561, 8, 30, 1, 31, 1, 31, 3, 31, 565, 8,
		31, 1, 31, 1, 31, 1, 31, 1, 31, 3, 31, 571, 8, 31, 1, 31, 1, 31, 1, 31,
		1, 31, 1, 31, 1, 31, 3, 31, 579, 8, 31, 1, 31, 1, 31, 1, 31, 1, 31, 3,
		31, 585, 8, 31, 1, 32, 1, 32, 3, 32, 589, 8, 32, 1, 32, 1, 32, 3, 32, 593,
		8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 600, 8, 32, 1, 32, 3,
		32, 603, 8, 32, 1, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35,
		1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 617, 8, 35, 1, 35, 3, 35, 620, 8, 35,
		1, 35, 1, 35, 5, 35, 624, 8, 35, 10, 35, 12, 35, 627, 9, 35, 1, 35, 1,
		35, 1, 36, 1, 36, 5, 36, 633, 8, 36, 10, 36, 12, 36, 636, 9, 36, 1, 37,
		3, 37, 639, 8, 37, 1, 37, 1, 37, 3, 37, 643, 8, 37, 1, 37, 1, 37, 1, 37,
		3, 37, 648, 8, 37, 1, 38, 1, 38, 5, 38, 652, 8, 38, 10, 38, 12, 38, 655,
		9, 38, 1, 39, 5, 39, 658, 8, 39, 10, 39, 12, 39, 661, 9, 39, 1, 40, 3,
		40, 664, 8, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40,
		1, 40, 1, 40, 1, 40, 3, 40, 677, 8, 40, 1, 40, 1, 40, 1, 40, 3, 40, 682,
		8, 40, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 691, 8,
		42, 1, 42, 3, 42, 694, 8, 42, 1, 42, 1, 42, 1, 42, 1, 43, 5, 43, 700, 8,
		43, 10, 43, 12, 43, 703, 9, 43, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44,
		1, 44, 1, 44, 3, 44, 713, 8, 44, 1, 45, 4, 45, 716, 8, 45, 11, 45, 12,
		45, 717, 1, 46, 4, 46, 721, 8, 46, 11, 46, 12, 46, 722, 1, 47, 1, 47, 1,
		47, 3, 47, 728, 8, 47, 1, 47, 1, 47, 1, 47, 3, 47, 733, 8, 47, 1, 47, 3,
		47, 736, 8, 47, 1, 47, 3, 47, 739, 8, 47, 1, 47, 3, 47, 742, 8, 47, 1,
		47, 1, 47, 3, 47, 746, 8, 47, 1, 47, 1, 47, 1, 47, 3, 47, 751, 8, 47, 3,
		47, 753, 8, 47, 1, 48, 1, 48, 1, 48, 1, 49, 1, 49, 1, 49, 1, 50, 1, 50,
		1, 50, 1, 51, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52, 1, 52, 5, 52, 771, 8,
		52, 10, 52, 12, 52, 774, 9, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 1, 53,
		1, 53, 1, 53, 1, 53, 1, 53, 5, 53, 786, 8, 53, 10, 53, 12, 53, 789, 9,
		53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 5, 55, 798, 8, 55,
		10, 55, 12, 55, 801, 9, 55, 1, 56, 1, 56, 1, 56, 3, 56, 806, 8, 56, 1,
		57, 1, 57, 1, 57, 1, 57, 3, 57, 812, 8, 57, 1, 58, 1, 58, 1, 58, 1, 58,
		1, 59, 1, 59, 1, 59, 5, 59, 821, 8, 59, 10, 59, 12, 59, 824, 9, 59, 1,
		60, 1, 60, 1, 60, 3, 60, 829, 8, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 62,
		1, 62, 1, 62, 3, 62, 838, 8, 62, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1,
		63, 1, 63, 3, 63, 847, 8, 63, 1, 64, 1, 64, 1, 64, 3, 64, 852, 8, 64, 1,
		65, 1, 65, 1, 65, 1, 65, 3, 65, 858, 8, 65, 1, 65, 1, 65, 1, 66, 1, 66,
		1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66, 870, 8, 66, 1, 66, 1,
		66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66, 880, 8, 66, 1, 66,
		1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66, 888, 8, 66, 1, 67, 1, 67, 1,
		67, 5, 67, 893, 8, 67, 10, 67, 12, 67, 896, 9, 67, 1, 68, 1, 68, 1, 69,
		1, 69, 1, 69, 5, 69, 903, 8, 69, 10, 69, 12, 69, 906, 9, 69, 1, 69, 1,
		69, 1, 69, 1, 69, 3, 69, 912, 8, 69, 1, 69, 3, 69, 915, 8, 69, 1, 70, 1,
		70, 5, 70, 919, 8, 70, 10, 70, 12, 70, 922, 9, 70, 1, 71, 5, 71, 925, 8,
		71, 10, 71, 12, 71, 928, 9, 71, 1, 72, 3, 72, 931, 8, 72, 1, 72, 1, 72,
		1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3,
		72, 945, 8, 72, 1, 72, 1, 72, 1, 72, 3, 72, 950, 8, 72, 1, 73, 4, 73, 953,
		8, 73, 11, 73, 12, 73, 954, 1, 74, 1, 74, 1, 74, 3, 74, 960, 8, 74, 1,
		74, 3, 74, 963, 8, 74, 1, 75, 1, 75, 1, 75, 5, 75, 968, 8, 75, 10, 75,
		12, 75, 971, 9, 75, 1, 75, 3, 75, 974, 8, 75, 1, 76, 1, 76, 1, 76, 1, 76,
		1, 76, 1, 76, 5, 76, 982, 8, 76, 10, 76, 12, 76, 985, 9, 76, 1, 77, 1,
		77, 1, 77, 1, 77, 1, 77, 3, 77, 992, 8, 77, 1, 78, 1, 78, 1, 78, 1, 78,
		1, 78, 1, 78, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 5, 79, 1006, 8,
		79, 10, 79, 12, 79, 1009, 9, 79, 1, 79, 1, 79, 1, 80, 1, 80, 5, 80, 1015,
		8, 80, 10, 80, 12, 80, 1018, 9, 80, 1, 81, 5, 81, 1021, 8, 81, 10, 81,
		12, 81, 1024, 9, 81, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1,
		82, 3, 82, 1034, 8, 82, 1, 82, 1, 82, 1, 82, 3, 82, 1039, 8, 82, 1, 83,
		4, 83, 1042, 8, 83, 11, 83, 12, 83, 1043, 1, 84, 1, 84, 1, 84, 1, 84, 1,
		85, 1, 85, 1, 85, 1, 85, 3, 85, 1054, 8, 85, 1, 86, 1, 86, 1, 86, 1, 87,
		1, 87, 1, 87, 1, 87, 5, 87, 1063, 8, 87, 10, 87, 12, 87, 1066, 9, 87, 1,
		87, 1, 87, 1, 88, 3, 88, 1071, 8, 88, 1, 88, 1, 88, 1, 88, 3, 88, 1076,
		8, 88, 1, 89, 3, 89, 1079, 8, 89, 1, 89, 3, 89, 1082, 8, 89, 1, 89, 1,
		89, 1, 89, 3, 89, 1087, 8, 89, 1, 89, 1, 89, 1, 89, 1, 90, 3, 90, 1093,
		8, 90, 1, 90, 3, 90, 1096, 8, 90, 1, 90, 1, 90, 1, 90, 3, 90, 1101, 8,
		90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 91, 1, 91, 3, 91, 1110, 8, 91,
		1, 92, 1, 92, 5, 92, 1114, 8, 92, 10, 92, 12, 92, 1117, 9, 92, 1, 93, 1,
		93, 3, 93, 1121, 8, 93, 1, 94, 1, 94, 1, 94, 1, 94, 1, 95, 1, 95, 1, 95,
		1, 95, 1, 96, 1, 96, 3, 96, 1133, 8, 96, 1, 96, 1, 96, 1, 97, 1, 97, 3,
		97, 1139, 8, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 98, 1, 98, 1, 99, 1, 99,
		1, 99, 1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 1154, 8, 100, 1, 100, 1,
		100, 1, 100, 1, 100, 1, 100, 1, 101, 1, 101, 1, 101, 1, 101, 1, 102, 1,
		102, 1, 102, 1, 102, 5, 102, 1169, 8, 102, 10, 102, 12, 102, 1172, 9, 102,
		1, 102, 1, 102, 1, 103, 3, 103, 1177, 8, 103, 1, 103, 1, 103, 3, 103, 1181,
		8, 103, 1, 103, 1, 103, 1, 103, 3, 103, 1186, 8, 103, 1, 103, 1, 103, 1,
		103, 3, 103, 1191, 8, 103, 1, 103, 1, 103, 1, 103, 3, 103, 1196, 8, 103,
		1, 103, 1, 103, 1, 103, 3, 103, 1201, 8, 103, 1, 103, 1, 103, 3, 103, 1205,
		8, 103, 1, 104, 1, 104, 1, 104, 3, 104, 1210, 8, 104, 1, 104, 3, 104, 1213,
		8, 104, 1, 105, 1, 105, 1, 105, 5, 105, 1218, 8, 105, 10, 105, 12, 105,
		1221, 9, 105, 1, 106, 1, 106, 1, 106, 5, 106, 1226, 8, 106, 10, 106, 12,
		106, 1229, 9, 106, 1, 107, 1, 107, 1, 107, 1, 108, 1, 108, 1, 108, 1, 108,
		1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 3, 109, 1244, 8, 109, 1,
		110, 4, 110, 1247, 8, 110, 11, 110, 12, 110, 1248, 1, 111, 1, 111, 3, 111,
		1253, 8, 111, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1,
		112, 1, 112, 3, 112, 1264, 8, 112, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113,
		1, 113, 1, 113, 1, 113, 3, 113, 1274, 8, 113, 1, 114, 1, 114, 3, 114, 1278,
		8, 114, 1, 115, 1, 115, 1, 115, 1, 115, 3, 115, 1284, 8, 115, 1, 115, 1,
		115, 3, 115, 1288, 8, 115, 1, 116, 1, 116, 1, 116, 1, 116, 3, 116, 1294,
		8, 116, 1, 116, 1, 116, 1, 116, 1, 116, 5, 116, 1300, 8, 116, 10, 116,
		12, 116, 1303, 9, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116,
		5, 116, 1311, 8, 116, 10, 116, 12, 116, 1314, 9, 116, 1, 116, 1, 116, 1,
		116, 1, 116, 1, 116, 4, 116, 1321, 8, 116, 11, 116, 12, 116, 1322, 5, 116,
		1325, 8, 116, 10, 116, 12, 116, 1328, 9, 116, 1, 117, 1, 117, 1, 117, 1,
		117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 3, 117, 1341,
		8, 117, 1, 118, 1, 118, 1, 118, 5, 118, 1346, 8, 118, 10, 118, 12, 118,
		1349, 9, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 5, 118, 1357,
		8, 118, 10, 118, 12, 118, 1360, 9, 118, 1, 118, 1, 118, 3, 118, 1364, 8,
		118, 1, 119, 1, 119, 1, 119, 1, 119, 3, 119, 1370, 8, 119, 1, 120, 1, 120,
		1, 121, 1, 121, 1, 121, 1, 121, 3, 121, 1378, 8, 121, 1, 122, 1, 122, 1,
		123, 1, 123, 1, 123, 1, 123, 3, 123, 1386, 8, 123, 1, 124, 1, 124, 1, 125,
		3, 125, 1391, 8, 125, 1, 125, 1, 125, 1, 126, 1, 126, 3, 126, 1397, 8,
		126, 1, 126, 1, 126, 1, 126, 1, 126, 3, 126, 1403, 8, 126, 1, 126, 1, 126,
		1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 3, 126,
		1415, 8, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 3, 126, 1422, 8,
		126, 1, 126, 5, 126, 1425, 8, 126, 10, 126, 12, 126, 1428, 9, 126, 3, 126,
		1430, 8, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 5, 126, 1437, 8,
		126, 10, 126, 12, 126, 1440, 9, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1,
		126, 4, 126, 1447, 8, 126, 11, 126, 12, 126, 1448, 5, 126, 1451, 8, 126,
		10, 126, 12, 126, 1454, 9, 126, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127,
		3, 127, 1461, 8, 127, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 3, 128, 1468,
		8, 128, 1, 128, 1, 128, 1, 128, 1, 128, 3, 128, 1474, 8, 128, 1, 129, 1,
		129, 1, 129, 5, 129, 1479, 8, 129, 10, 129, 12, 129, 1482, 9, 129, 1, 130,
		1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 3, 130, 1492, 8,
		130, 1, 131, 1, 131, 1, 131, 5, 131, 1497, 8, 131, 10, 131, 12, 131, 1500,
		9, 131, 1, 131, 3, 131, 1503, 8, 131, 1, 132, 1, 132, 1, 132, 3, 132, 1508,
		8, 132, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 3, 133, 1515, 8, 133, 1,
		134, 1, 134, 1, 134, 5, 134, 1520, 8, 134, 10, 134, 12, 134, 1523, 9, 134,
		1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 3, 134, 1531, 8, 134, 1,
		135, 1, 135, 5, 135, 1535, 8, 135, 10, 135, 12, 135, 1538, 9, 135, 1, 135,
		1, 135, 3, 135, 1542, 8, 135, 1, 136, 1, 136, 1, 136, 1, 137, 1, 137, 1,
		137, 1, 138, 1, 138, 1, 138, 1, 138, 1, 138, 1, 138, 3, 138, 1556, 8, 138,
		3, 138, 1558, 8, 138, 1, 139, 1, 139, 1, 140, 1, 140, 1, 141, 1, 141, 1,
		141, 1, 141, 1, 141, 1, 141, 3, 141, 1570, 8, 141, 1, 142, 1, 142, 1, 142,
		1, 142, 1, 143, 1, 143, 1, 143, 5, 143, 1579, 8, 143, 10, 143, 12, 143,
		1582, 9, 143, 1, 144, 1, 144, 3, 144, 1586, 8, 144, 1, 145, 1, 145, 1,
		145, 1, 145, 1, 145, 1, 145, 3, 145, 1594, 8, 145, 1, 145, 3, 145, 1597,
		8, 145, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 5, 146, 1605, 8,
		146, 10, 146, 12, 146, 1608, 9, 146, 1, 146, 1, 146, 1, 146, 3, 146, 1613,
		8, 146, 1, 146, 3, 146, 1616, 8, 146, 1, 146, 1, 146, 1, 147, 1, 147, 1,
		147, 1, 147, 1, 148, 1, 148, 1, 148, 3, 148, 1627, 8, 148, 1, 149, 1, 149,
		1, 149, 1, 149, 1, 149, 1, 150, 1, 150, 1, 150, 1, 150, 1, 150, 1, 151,
		1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 152, 1, 152, 1, 152,
		1, 152, 1, 153, 1, 153, 1, 154, 1, 154, 1, 155, 1, 155, 1, 155, 1, 155,
		1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 3, 155, 1664, 8, 155, 1,
		156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 157, 1, 157, 1, 157, 1,
		157, 1, 157, 1, 157, 1, 158, 1, 158, 1, 158, 5, 158, 1681, 8, 158, 10,
		158, 12, 158, 1684, 9, 158, 1, 159, 1, 159, 1, 159, 1, 159, 1, 160, 1,
		160, 1, 160, 5, 160, 1693, 8, 160, 10, 160, 12, 160, 1696, 9, 160, 1, 161,
		1, 161, 1, 161, 1, 161, 1, 161, 3, 161, 1703, 8, 161, 1, 161, 0, 1, 252,
		162, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34,
		36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70,
		72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104,
		106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134,
		136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164,
		166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194,
		196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224,
		226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254,
		256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284,
		286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314,
		316, 318, 320, 322, 0, 14, 3, 0, 85, 86, 88, 88, 122, 122, 1, 0, 44, 45,
		1, 0, 75, 76, 1, 0, 124, 125, 1, 0, 14, 14, 2, 0, 14, 14, 78, 82, 6, 0,
		5, 5, 7, 7, 22, 22, 32, 32, 73, 73, 114, 116, 2, 0, 30, 30, 106, 107, 1,
		0, 97, 105, 2, 0, 14, 14, 50, 50, 2, 0, 21, 21, 52, 57, 2, 0, 28, 28, 44,
		45, 5, 0, 2, 2, 10, 10, 24, 24, 46, 47, 111, 113, 2, 0, 12, 12, 38, 38,
		1812, 0, 326, 1, 0, 0, 0, 2, 328, 1, 0, 0, 0, 4, 347, 1, 0, 0, 0, 6, 364,
		1, 0, 0, 0, 8, 370, 1, 0, 0, 0, 10, 376, 1, 0, 0, 0, 12, 379, 1, 0, 0,
		0, 14, 382, 1, 0, 0, 0, 16, 390, 1, 0, 0, 0, 18, 402, 1, 0, 0, 0, 20, 418,
		1, 0, 0, 0, 22, 428, 1, 0, 0, 0, 24, 431, 1, 0, 0, 0, 26, 435, 1, 0, 0,
		0, 28, 446, 1, 0, 0, 0, 30, 448, 1, 0, 0, 0, 32, 470, 1, 0, 0, 0, 34, 472,
		1, 0, 0, 0, 36, 477, 1, 0, 0, 0, 38, 501, 1, 0, 0, 0, 40, 503, 1, 0, 0,
		0, 42, 516, 1, 0, 0, 0, 44, 518, 1, 0, 0, 0, 46, 520, 1, 0, 0, 0, 48, 522,
		1, 0, 0, 0, 50, 524, 1, 0, 0, 0, 52, 527, 1, 0, 0, 0, 54, 531, 1, 0, 0,
		0, 56, 537, 1, 0, 0, 0, 58, 542, 1, 0, 0, 0, 60, 551, 1, 0, 0, 0, 62, 584,
		1, 0, 0, 0, 64, 602, 1, 0, 0, 0, 66, 604, 1, 0, 0, 0, 68, 607, 1, 0, 0,
		0, 70, 610, 1, 0, 0, 0, 72, 634, 1, 0, 0, 0, 74, 647, 1, 0, 0, 0, 76, 649,
		1, 0, 0, 0, 78, 659, 1, 0, 0, 0, 80, 681, 1, 0, 0, 0, 82, 683, 1, 0, 0,
		0, 84, 685, 1, 0, 0, 0, 86, 701, 1, 0, 0, 0, 88, 712, 1, 0, 0, 0, 90, 715,
		1, 0, 0, 0, 92, 720, 1, 0, 0, 0, 94, 752, 1, 0, 0, 0, 96, 754, 1, 0, 0,
		0, 98, 757, 1, 0, 0, 0, 100, 760, 1, 0, 0, 0, 102, 763, 1, 0, 0, 0, 104,
		766, 1, 0, 0, 0, 106, 777, 1, 0, 0, 0, 108, 790, 1, 0, 0, 0, 110, 794,
		1, 0, 0, 0, 112, 805, 1, 0, 0, 0, 114, 811, 1, 0, 0, 0, 116, 813, 1, 0,
		0, 0, 118, 817, 1, 0, 0, 0, 120, 825, 1, 0, 0, 0, 122, 830, 1, 0, 0, 0,
		124, 837, 1, 0, 0, 0, 126, 846, 1, 0, 0, 0, 128, 851, 1, 0, 0, 0, 130,
		853, 1, 0, 0, 0, 132, 887, 1, 0, 0, 0, 134, 889, 1, 0, 0, 0, 136, 897,
		1, 0, 0, 0, 138, 914, 1, 0, 0, 0, 140, 916, 1, 0, 0, 0, 142, 926, 1, 0,
		0, 0, 144, 949, 1, 0, 0, 0, 146, 952, 1, 0, 0, 0, 148, 962, 1, 0, 0, 0,
		150, 964, 1, 0, 0, 0, 152, 975, 1, 0, 0, 0, 154, 991, 1, 0, 0, 0, 156,
		993, 1, 0, 0, 0, 158, 999, 1, 0, 0, 0, 160, 1012, 1, 0, 0, 0, 162, 1022,
		1, 0, 0, 0, 164, 1038, 1, 0, 0, 0, 166, 1041, 1, 0, 0, 0, 168, 1045, 1,
		0, 0, 0, 170, 1053, 1, 0, 0, 0, 172, 1055, 1, 0, 0, 0, 174, 1058, 1, 0,
		0, 0, 176, 1070, 1, 0, 0, 0, 178, 1078, 1, 0, 0, 0, 180, 1092, 1, 0, 0,
		0, 182, 1109, 1, 0, 0, 0, 184, 1115, 1, 0, 0, 0, 186, 1120, 1, 0, 0, 0,
		188, 1122, 1, 0, 0, 0, 190, 1126, 1, 0, 0, 0, 192, 1130, 1, 0, 0, 0, 194,
		1136, 1, 0, 0, 0, 196, 1144, 1, 0, 0, 0, 198, 1146, 1, 0, 0, 0, 200, 1149,
		1, 0, 0, 0, 202, 1160, 1, 0, 0, 0, 204, 1164, 1, 0, 0, 0, 206, 1204, 1,
		0, 0, 0, 208, 1206, 1, 0, 0, 0, 210, 1214, 1, 0, 0, 0, 212, 1222, 1, 0,
		0, 0, 214, 1230, 1, 0, 0, 0, 216, 1233, 1, 0, 0, 0, 218, 1243, 1, 0, 0,
		0, 220, 1246, 1, 0, 0, 0, 222, 1252, 1, 0, 0, 0, 224, 1263, 1, 0, 0, 0,
		226, 1273, 1, 0, 0, 0, 228, 1275, 1, 0, 0, 0, 230, 1279, 1, 0, 0, 0, 232,
		1293, 1, 0, 0, 0, 234, 1340, 1, 0, 0, 0, 236, 1342, 1, 0, 0, 0, 238, 1365,
		1, 0, 0, 0, 240, 1371, 1, 0, 0, 0, 242, 1373, 1, 0, 0, 0, 244, 1379, 1,
		0, 0, 0, 246, 1381, 1, 0, 0, 0, 248, 1387, 1, 0, 0, 0, 250, 1390, 1, 0,
		0, 0, 252, 1429, 1, 0, 0, 0, 254, 1460, 1, 0, 0, 0, 256, 1462, 1, 0, 0,
		0, 258, 1475, 1, 0, 0, 0, 260, 1491, 1, 0, 0, 0, 262, 1502, 1, 0, 0, 0,
		264, 1504, 1, 0, 0, 0, 266, 1509, 1, 0, 0, 0, 268, 1516, 1, 0, 0, 0, 270,
		1541, 1, 0, 0, 0, 272, 1543, 1, 0, 0, 0, 274, 1546, 1, 0, 0, 0, 276, 1549,
		1, 0, 0, 0, 278, 1559, 1, 0, 0, 0, 280, 1561, 1, 0, 0, 0, 282, 1569, 1,
		0, 0, 0, 284, 1571, 1, 0, 0, 0, 286, 1575, 1, 0, 0, 0, 288, 1585, 1, 0,
		0, 0, 290, 1587, 1, 0, 0, 0, 292, 1598, 1, 0, 0, 0, 294, 1619, 1, 0, 0,
		0, 296, 1626, 1, 0, 0, 0, 298, 1628, 1, 0, 0, 0, 300, 1633, 1, 0, 0, 0,
		302, 1638, 1, 0, 0, 0, 304, 1645, 1, 0, 0, 0, 306, 1649, 1, 0, 0, 0, 308,
		1651, 1, 0, 0, 0, 310, 1663, 1, 0, 0, 0, 312, 1665, 1, 0, 0, 0, 314, 1671,
		1, 0, 0, 0, 316, 1677, 1, 0, 0, 0, 318, 1685, 1, 0, 0, 0, 320, 1689, 1,
		0, 0, 0, 322, 1697, 1, 0, 0, 0, 324, 327, 3, 2, 1, 0, 325, 327, 3, 4, 2,
		0, 326, 324, 1, 0, 0, 0, 326, 325, 1, 0, 0, 0, 327, 1, 1, 0, 0, 0, 328,
		329, 5, 31, 0, 0, 329, 334, 3, 14, 7, 0, 330, 331, 5, 58, 0, 0, 331, 332,
		3, 210, 105, 0, 332, 333, 5, 59, 0, 0, 333, 335, 1, 0, 0, 0, 334, 330,
		1, 0, 0, 0, 334, 335, 1, 0, 0, 0, 335, 336, 1, 0, 0, 0, 336, 338, 5, 50,
		0, 0, 337, 339, 3, 24, 12, 0, 338, 337, 1, 0, 0, 0, 338, 339, 1, 0, 0,
		0, 339, 340, 1, 0, 0, 0, 340, 341, 3, 20, 10, 0, 341, 342, 5, 4, 0, 0,
		342, 343, 3, 286, 143, 0, 343, 344, 5, 14, 0, 0, 344, 345, 5, 66, 0, 0,
		345, 346, 5, 0, 0, 1, 346, 3, 1, 0, 0, 0, 347, 348, 5, 70, 0, 0, 348, 349,
		3, 14, 7, 0, 349, 350, 5, 50, 0, 0, 350, 352, 3, 6, 3, 0, 351, 353, 3,
		8, 4, 0, 352, 351, 1, 0, 0, 0, 352, 353, 1, 0, 0, 0, 353, 355, 1, 0, 0,
		0, 354, 356, 3, 10, 5, 0, 355, 354, 1, 0, 0, 0, 355, 356, 1, 0, 0, 0, 356,
		358, 1, 0, 0, 0, 357, 359, 3, 12, 6, 0, 358, 357, 1, 0, 0, 0, 358, 359,
		1, 0, 0, 0, 359, 360, 1, 0, 0, 0, 360, 361, 5, 14, 0, 0, 361, 362, 5, 66,
		0, 0, 362, 363, 5, 0, 0, 1, 363, 5, 1, 0, 0, 0, 364, 366, 5, 71, 0, 0,
		365, 367, 3, 24, 12, 0, 366, 365, 1, 0, 0, 0, 366, 367, 1, 0, 0, 0, 367,
		368, 1, 0, 0, 0, 368, 369, 3, 18, 9, 0, 369, 7, 1, 0, 0, 0, 370, 372, 5,
		74, 0, 0, 371, 373, 3, 24, 12, 0, 372, 371, 1, 0, 0, 0, 372, 373, 1, 0,
		0, 0, 373, 374, 1, 0, 0, 0, 374, 375, 3, 20, 10, 0, 375, 9, 1, 0, 0, 0,
		376, 377, 5, 93, 0, 0, 377, 378, 3, 286, 143, 0, 378, 11, 1, 0, 0, 0, 379,
		380, 5, 94, 0, 0, 380, 381, 3, 286, 143, 0, 381, 13, 1, 0, 0, 0, 382, 387,
		3, 16, 8, 0, 383, 384, 5, 66, 0, 0, 384, 386, 3, 16, 8, 0, 385, 383, 1,
		0, 0, 0, 386, 389, 1, 0, 0, 0, 387, 385, 1, 0, 0, 0, 387, 388, 1, 0, 0,
		0, 388, 15, 1, 0, 0, 0, 389, 387, 1, 0, 0, 0, 390, 392, 7, 0, 0, 0, 391,
		393, 3, 108, 54, 0, 392, 391, 1, 0, 0, 0, 392, 393, 1, 0, 0, 0, 393, 17,
		1, 0, 0, 0, 394, 401, 3, 26, 13, 0, 395, 401, 3, 30, 15, 0, 396, 401, 3,
		54, 27, 0, 397, 401, 3, 58, 29, 0, 398, 401, 3, 174, 87, 0, 399, 401, 3,
		182, 91, 0, 400, 394, 1, 0, 0, 0, 400, 395, 1, 0, 0, 0, 400, 396, 1, 0,
		0, 0, 400, 397, 1, 0, 0, 0, 400, 398, 1, 0, 0, 0, 400, 399, 1, 0, 0, 0,
		401, 404, 1, 0, 0, 0, 402, 400, 1, 0, 0, 0, 402, 403, 1, 0, 0, 0, 403,
		19, 1, 0, 0, 0, 404, 402, 1, 0, 0, 0, 405, 417, 3, 26, 13, 0, 406, 417,
		3, 30, 15, 0, 407, 417, 3, 54, 27, 0, 408, 417, 3, 58, 29, 0, 409, 417,
		3, 174, 87, 0, 410, 417, 3, 186, 93, 0, 411, 412, 3, 182, 91, 0, 412, 413,
		5, 109, 0, 0, 413, 414, 5, 50, 0, 0, 414, 417, 1, 0, 0, 0, 415, 417, 3,
		202, 101, 0, 416, 405, 1, 0, 0, 0, 416, 406, 1, 0, 0, 0, 416, 407, 1, 0,
		0, 0, 416, 408, 1, 0, 0, 0, 416, 409, 1, 0, 0, 0, 416, 410, 1, 0, 0, 0,
		416, 411, 1, 0, 0, 0, 416, 415, 1, 0, 0, 0, 417, 420, 1, 0, 0, 0, 418,
		416, 1, 0, 0, 0, 418, 419, 1, 0, 0, 0, 419, 21, 1, 0, 0, 0, 420, 418, 1,
		0, 0, 0, 421, 427, 3, 26, 13, 0, 422, 427, 3, 30, 15, 0, 423, 427, 3, 174,
		87, 0, 424, 427, 3, 186, 93, 0, 425, 427, 3, 202, 101, 0, 426, 421, 1,
		0, 0, 0, 426, 422, 1, 0, 0, 0, 426, 423, 1, 0, 0, 0, 426, 424, 1, 0, 0,
		0, 426, 425, 1, 0, 0, 0, 427, 430, 1, 0, 0, 0, 428, 426, 1, 0, 0, 0, 428,
		429, 1, 0, 0, 0, 429, 23, 1, 0, 0, 0, 430, 428, 1, 0, 0, 0, 431, 432, 5,
		72, 0, 0, 432, 433, 3, 210, 105, 0, 433, 434, 5, 50, 0, 0, 434, 25, 1,
		0, 0, 0, 435, 436, 5, 23, 0, 0, 436, 441, 3, 28, 14, 0, 437, 438, 5, 49,
		0, 0, 438, 440, 3, 28, 14, 0, 439, 437, 1, 0, 0, 0, 440, 443, 1, 0, 0,
		0, 441, 439, 1, 0, 0, 0, 441, 442, 1, 0, 0, 0, 442, 444, 1, 0, 0, 0, 443,
		441, 1, 0, 0, 0, 444, 445, 5, 50, 0, 0, 445, 27, 1, 0, 0, 0, 446, 447,
		3, 44, 22, 0, 447, 29, 1, 0, 0, 0, 448, 452, 5, 9, 0, 0, 449, 450, 3, 32,
		16, 0, 450, 451, 5, 50, 0, 0, 451, 453, 1, 0, 0, 0, 452, 449, 1, 0, 0,
		0, 453, 454, 1, 0, 0, 0, 454, 452, 1, 0, 0, 0, 454, 455, 1, 0, 0, 0, 455,
		31, 1, 0, 0, 0, 456, 459, 3, 14, 7, 0, 457, 458, 5, 51, 0, 0, 458, 460,
		3, 124, 62, 0, 459, 457, 1, 0, 0, 0, 459, 460, 1, 0, 0, 0, 460, 461, 1,
		0, 0, 0, 461, 462, 5, 52, 0, 0, 462, 463, 3, 38, 19, 0, 463, 471, 1, 0,
		0, 0, 464, 465, 3, 14, 7, 0, 465, 466, 5, 51, 0, 0, 466, 467, 3, 132, 66,
		0, 467, 468, 5, 52, 0, 0, 468, 469, 3, 38, 19, 0, 469, 471, 1, 0, 0, 0,
		470, 456, 1, 0, 0, 0, 470, 464, 1, 0, 0, 0, 471, 33, 1, 0, 0, 0, 472, 473,
		5, 8, 0, 0, 473, 474, 5, 58, 0, 0, 474, 475, 3, 44, 22, 0, 475, 476, 5,
		59, 0, 0, 476, 35, 1, 0, 0, 0, 477, 478, 5, 123, 0, 0, 478, 37, 1, 0, 0,
		0, 479, 502, 3, 42, 21, 0, 480, 481, 3, 48, 24, 0, 481, 482, 3, 42, 21,
		0, 482, 502, 1, 0, 0, 0, 483, 502, 3, 14, 7, 0, 484, 485, 3, 48, 24, 0,
		485, 486, 3, 14, 7, 0, 486, 502, 1, 0, 0, 0, 487, 502, 3, 52, 26, 0, 488,
		502, 3, 34, 17, 0, 489, 502, 3, 116, 58, 0, 490, 498, 3, 40, 20, 0, 491,
		494, 5, 44, 0, 0, 492, 495, 3, 40, 20, 0, 493, 495, 3, 14, 7, 0, 494, 492,
		1, 0, 0, 0, 494, 493, 1, 0, 0, 0, 495, 497, 1, 0, 0, 0, 496, 491, 1, 0,
		0, 0, 497, 500, 1, 0, 0, 0, 498, 496, 1, 0, 0, 0, 498, 499, 1, 0, 0, 0,
		499, 502, 1, 0, 0, 0, 500, 498, 1, 0, 0, 0, 501, 479, 1, 0, 0, 0, 501,
		480, 1, 0, 0, 0, 501, 483, 1, 0, 0, 0, 501, 484, 1, 0, 0, 0, 501, 487,
		1, 0, 0, 0, 501, 488, 1, 0, 0, 0, 501, 489, 1, 0, 0, 0, 501, 490, 1, 0,
		0, 0, 502, 39, 1, 0, 0, 0, 503, 504, 5, 60, 0, 0, 504, 509, 3, 38, 19,
		0, 505, 506, 5, 49, 0, 0, 506, 508, 3, 38, 19, 0, 507, 505, 1, 0, 0, 0,
		508, 511, 1, 0, 0, 0, 509, 507, 1, 0, 0, 0, 509, 510, 1, 0, 0, 0, 510,
		512, 1, 0, 0, 0, 511, 509, 1, 0, 0, 0, 512, 513, 5, 62, 0, 0, 513, 41,
		1, 0, 0, 0, 514, 517, 3, 44, 22, 0, 515, 517, 3, 46, 23, 0, 516, 514, 1,
		0, 0, 0, 516, 515, 1, 0, 0, 0, 517, 43, 1, 0, 0, 0, 518, 519, 5, 126, 0,
		0, 519, 45, 1, 0, 0, 0, 520, 521, 5, 127, 0, 0, 521, 47, 1, 0, 0, 0, 522,
		523, 7, 1, 0, 0, 523, 49, 1, 0, 0, 0, 524, 525, 7, 2, 0, 0, 525, 51, 1,
		0, 0, 0, 526, 528, 7, 3, 0, 0, 527, 526, 1, 0, 0, 0, 528, 529, 1, 0, 0,
		0, 529, 527, 1, 0, 0, 0, 529, 530, 1, 0, 0, 0, 530, 53, 1, 0, 0, 0, 531,
		533, 5, 108, 0, 0, 532, 534, 3, 56, 28, 0, 533, 532, 1, 0, 0, 0, 534, 535,
		1, 0, 0, 0, 535, 533, 1, 0, 0, 0, 535, 536, 1, 0, 0, 0, 536, 55, 1, 0,
		0, 0, 537, 538, 3, 14, 7, 0, 538, 539, 5, 52, 0, 0, 539, 540, 3, 52, 26,
		0, 540, 541, 5, 50, 0, 0, 541, 57, 1, 0, 0, 0, 542, 546, 5, 39, 0, 0, 543,
		544, 3, 60, 30, 0, 544, 545, 5, 50, 0, 0, 545, 547, 1, 0, 0, 0, 546, 543,
		1, 0, 0, 0, 547, 548, 1, 0, 0, 0, 548, 546, 1, 0, 0, 0, 548, 549, 1, 0,
		0, 0, 549, 59, 1, 0, 0, 0, 550, 552, 3, 318, 159, 0, 551, 550, 1, 0, 0,
		0, 551, 552, 1, 0, 0, 0, 552, 553, 1, 0, 0, 0, 553, 554, 3, 14, 7, 0, 554,
		560, 5, 52, 0, 0, 555, 561, 3, 112, 56, 0, 556, 561, 3, 62, 31, 0, 557,
		561, 3, 64, 32, 0, 558, 561, 3, 66, 33, 0, 559, 561, 3, 68, 34, 0, 560,
		555, 1, 0, 0, 0, 560, 556, 1, 0, 0, 0, 560, 557, 1, 0, 0, 0, 560, 558,
		1, 0, 0, 0, 560, 559, 1, 0, 0, 0, 561, 61, 1, 0, 0, 0, 562, 564, 5, 17,
		0, 0, 563, 565, 3, 204, 102, 0, 564, 563, 1, 0, 0, 0, 564, 565, 1, 0, 0,
		0, 565, 566, 1, 0, 0, 0, 566, 567, 5, 51, 0, 0, 567, 570, 3, 196, 98, 0,
		568, 569, 5, 27, 0, 0, 569, 571, 5, 95, 0, 0, 570, 568, 1, 0, 0, 0, 570,
		571, 1, 0, 0, 0, 571, 572, 1, 0, 0, 0, 572, 573, 3, 184, 92, 0, 573, 585,
		1, 0, 0, 0, 574, 575, 5, 34, 0, 0, 575, 576, 5, 38, 0, 0, 576, 578, 5,
		17, 0, 0, 577, 579, 3, 204, 102, 0, 578, 577, 1, 0, 0, 0, 578, 579, 1,
		0, 0, 0, 579, 580, 1, 0, 0, 0, 580, 581, 5, 51, 0, 0, 581, 582, 3, 196,
		98, 0, 582, 583, 3, 184, 92, 0, 583, 585, 1, 0, 0, 0, 584, 562, 1, 0, 0,
		0, 584, 574, 1, 0, 0, 0, 585, 63, 1, 0, 0, 0, 586, 588, 5, 30, 0, 0, 587,
		589, 3, 204, 102, 0, 588, 587, 1, 0, 0, 0, 588, 589, 1, 0, 0, 0, 589, 592,
		1, 0, 0, 0, 590, 591, 5, 27, 0, 0, 591, 593, 5, 95, 0, 0, 592, 590, 1,
		0, 0, 0, 592, 593, 1, 0, 0, 0, 593, 594, 1, 0, 0, 0, 594, 603, 3, 184,
		92, 0, 595, 596, 5, 34, 0, 0, 596, 597, 5, 38, 0, 0, 597, 599, 5, 30, 0,
		0, 598, 600, 3, 204, 102, 0, 599, 598, 1, 0, 0, 0, 599, 600, 1, 0, 0, 0,
		600, 601, 1, 0, 0, 0, 601, 603, 3, 184, 92, 0, 602, 586, 1, 0, 0, 0, 602,
		595, 1, 0, 0, 0, 603, 65, 1, 0, 0, 0, 604, 605, 5, 77, 0, 0, 605, 606,
		5, 50, 0, 0, 606, 67, 1, 0, 0, 0, 607, 608, 5, 71, 0, 0, 608, 609, 5, 50,
		0, 0, 609, 69, 1, 0, 0, 0, 610, 616, 5, 77, 0, 0, 611, 612, 5, 58, 0, 0,
		612, 613, 3, 14, 7, 0, 613, 614, 3, 72, 36, 0, 614, 615, 5, 59, 0, 0, 615,
		617, 1, 0, 0, 0, 616, 611, 1, 0, 0, 0, 616, 617, 1, 0, 0, 0, 617, 619,
		1, 0, 0, 0, 618, 620, 5, 97, 0, 0, 619, 618, 1, 0, 0, 0, 619, 620, 1, 0,
		0, 0, 620, 621, 1, 0, 0, 0, 621, 625, 3, 78, 39, 0, 622, 624, 3, 76, 38,
		0, 623, 622, 1, 0, 0, 0, 624, 627, 1, 0, 0, 0, 625, 623, 1, 0, 0, 0, 625,
		626, 1, 0, 0, 0, 626, 628, 1, 0, 0, 0, 627, 625, 1, 0, 0, 0, 628, 629,
		5, 14, 0, 0, 629, 71, 1, 0, 0, 0, 630, 631, 5, 49, 0, 0, 631, 633, 3, 124,
		62, 0, 632, 630, 1, 0, 0, 0, 633, 636, 1, 0, 0, 0, 634, 632, 1, 0, 0, 0,
		634, 635, 1, 0, 0, 0, 635, 73, 1, 0, 0, 0, 636, 634, 1, 0, 0, 0, 637, 639,
		5, 82, 0, 0, 638, 637, 1, 0, 0, 0, 638, 639, 1, 0, 0, 0, 639, 640, 1, 0,
		0, 0, 640, 648, 5, 78, 0, 0, 641, 643, 5, 82, 0, 0, 642, 641, 1, 0, 0,
		0, 642, 643, 1, 0, 0, 0, 643, 644, 1, 0, 0, 0, 644, 648, 5, 79, 0, 0, 645,
		648, 5, 80, 0, 0, 646, 648, 5, 81, 0, 0, 647, 638, 1, 0, 0, 0, 647, 642,
		1, 0, 0, 0, 647, 645, 1, 0, 0, 0, 647, 646, 1, 0, 0, 0, 648, 75, 1, 0,
		0, 0, 649, 653, 3, 74, 37, 0, 650, 652, 3, 80, 40, 0, 651, 650, 1, 0, 0,
		0, 652, 655, 1, 0, 0, 0, 653, 651, 1, 0, 0, 0, 653, 654, 1, 0, 0, 0, 654,
		77, 1, 0, 0, 0, 655, 653, 1, 0, 0, 0, 656, 658, 3, 80, 40, 0, 657, 656,
		1, 0, 0, 0, 658, 661, 1, 0, 0, 0, 659, 657, 1, 0, 0, 0, 659, 660, 1, 0,
		0, 0, 660, 79, 1, 0, 0, 0, 661, 659, 1, 0, 0, 0, 662, 664, 3, 318, 159,
		0, 663, 662, 1, 0, 0, 0, 663, 664, 1, 0, 0, 0, 664, 665, 1, 0, 0, 0, 665,
		666, 3, 216, 108, 0, 666, 667, 5, 50, 0, 0, 667, 682, 1, 0, 0, 0, 668,
		682, 3, 58, 29, 0, 669, 682, 3, 30, 15, 0, 670, 682, 3, 180, 90, 0, 671,
		682, 3, 178, 89, 0, 672, 673, 3, 94, 47, 0, 673, 676, 5, 50, 0, 0, 674,
		675, 5, 87, 0, 0, 675, 677, 5, 50, 0, 0, 676, 674, 1, 0, 0, 0, 676, 677,
		1, 0, 0, 0, 677, 682, 1, 0, 0, 0, 678, 679, 3, 92, 46, 0, 679, 680, 5,
		50, 0, 0, 680, 682, 1, 0, 0, 0, 681, 663, 1, 0, 0, 0, 681, 668, 1, 0, 0,
		0, 681, 669, 1, 0, 0, 0, 681, 670, 1, 0, 0, 0, 681, 671, 1, 0, 0, 0, 681,
		672, 1, 0, 0, 0, 681, 678, 1, 0, 0, 0, 682, 81, 1, 0, 0, 0, 683, 684, 5,
		1, 0, 0, 684, 83, 1, 0, 0, 0, 685, 690, 5, 71, 0, 0, 686, 687, 5, 58, 0,
		0, 687, 688, 3, 14, 7, 0, 688, 689, 5, 59, 0, 0, 689, 691, 1, 0, 0, 0,
		690, 686, 1, 0, 0, 0, 690, 691, 1, 0, 0, 0, 691, 693, 1, 0, 0, 0, 692,
		694, 5, 1, 0, 0, 693, 692, 1, 0, 0, 0, 693, 694, 1, 0, 0, 0, 694, 695,
		1, 0, 0, 0, 695, 696, 3, 86, 43, 0, 696, 697, 5, 14, 0, 0, 697, 85, 1,
		0, 0, 0, 698, 700, 3, 88, 44, 0, 699, 698, 1, 0, 0, 0, 700, 703, 1, 0,
		0, 0, 701, 699, 1, 0, 0, 0, 701, 702, 1, 0, 0, 0, 702, 87, 1, 0, 0, 0,
		703, 701, 1, 0, 0, 0, 704, 713, 3, 180, 90, 0, 705, 713, 3, 178, 89, 0,
		706, 707, 3, 94, 47, 0, 707, 708, 5, 50, 0, 0, 708, 713, 1, 0, 0, 0, 709,
		710, 3, 90, 45, 0, 710, 711, 5, 50, 0, 0, 711, 713, 1, 0, 0, 0, 712, 704,
		1, 0, 0, 0, 712, 705, 1, 0, 0, 0, 712, 706, 1, 0, 0, 0, 712, 709, 1, 0,
		0, 0, 713, 89, 1, 0, 0, 0, 714, 716, 8, 4, 0, 0, 715, 714, 1, 0, 0, 0,
		716, 717, 1, 0, 0, 0, 717, 715, 1, 0, 0, 0, 717, 718, 1, 0, 0, 0, 718,
		91, 1, 0, 0, 0, 719, 721, 8, 5, 0, 0, 720, 719, 1, 0, 0, 0, 721, 722, 1,
		0, 0, 0, 722, 720, 1, 0, 0, 0, 722, 723, 1, 0, 0, 0, 723, 93, 1, 0, 0,
		0, 724, 725, 5, 84, 0, 0, 725, 727, 3, 14, 7, 0, 726, 728, 3, 104, 52,
		0, 727, 726, 1, 0, 0, 0, 727, 728, 1, 0, 0, 0, 728, 729, 1, 0, 0, 0, 729,
		730, 5, 51, 0, 0, 730, 732, 3, 124, 62, 0, 731, 733, 3, 96, 48, 0, 732,
		731, 1, 0, 0, 0, 732, 733, 1, 0, 0, 0, 733, 735, 1, 0, 0, 0, 734, 736,
		3, 98, 49, 0, 735, 734, 1, 0, 0, 0, 735, 736, 1, 0, 0, 0, 736, 738, 1,
		0, 0, 0, 737, 739, 3, 100, 50, 0, 738, 737, 1, 0, 0, 0, 738, 739, 1, 0,
		0, 0, 739, 741, 1, 0, 0, 0, 740, 742, 3, 102, 51, 0, 741, 740, 1, 0, 0,
		0, 741, 742, 1, 0, 0, 0, 742, 745, 1, 0, 0, 0, 743, 744, 5, 50, 0, 0, 744,
		746, 5, 87, 0, 0, 745, 743, 1, 0, 0, 0, 745, 746, 1, 0, 0, 0, 746, 753,
		1, 0, 0, 0, 747, 748, 5, 84, 0, 0, 748, 750, 3, 14, 7, 0, 749, 751, 3,
		100, 50, 0, 750, 749, 1, 0, 0, 0, 750, 751, 1, 0, 0, 0, 751, 753, 1, 0,
		0, 0, 752, 724, 1, 0, 0, 0, 752, 747, 1, 0, 0, 0, 753, 95, 1, 0, 0, 0,
		754, 755, 5, 85, 0, 0, 755, 756, 3, 14, 7, 0, 756, 97, 1, 0, 0, 0, 757,
		758, 5, 86, 0, 0, 758, 759, 3, 14, 7, 0, 759, 99, 1, 0, 0, 0, 760, 761,
		5, 87, 0, 0, 761, 762, 3, 238, 119, 0, 762, 101, 1, 0, 0, 0, 763, 764,
		5, 88, 0, 0, 764, 765, 3, 42, 21, 0, 765, 103, 1, 0, 0, 0, 766, 767, 5,
		60, 0, 0, 767, 772, 3, 206, 103, 0, 768, 769, 5, 49, 0, 0, 769, 771, 3,
		206, 103, 0, 770, 768, 1, 0, 0, 0, 771, 774, 1, 0, 0, 0, 772, 770, 1, 0,
		0, 0, 772, 773, 1, 0, 0, 0, 773, 775, 1, 0, 0, 0, 774, 772, 1, 0, 0, 0,
		775, 776, 5, 62, 0, 0, 776, 105, 1, 0, 0, 0, 777, 778, 3, 210, 105, 0,
		778, 779, 5, 51, 0, 0, 779, 787, 3, 136, 68, 0, 780, 781, 5, 50, 0, 0,
		781, 782, 3, 210, 105, 0, 782, 783, 5, 51, 0, 0, 783, 784, 3, 136, 68,
		0, 784, 786, 1, 0, 0, 0, 785, 780, 1, 0, 0, 0, 786, 789, 1, 0, 0, 0, 787,
		785, 1, 0, 0, 0, 787, 788, 1, 0, 0, 0, 788, 107, 1, 0, 0, 0, 789, 787,
		1, 0, 0, 0, 790, 791, 5, 54, 0, 0, 791, 792, 3, 110, 55, 0, 792, 793, 5,
		57, 0, 0, 793, 109, 1, 0, 0, 0, 794, 799, 3, 124, 62, 0, 795, 796, 5, 49,
		0, 0, 796, 798, 3, 124, 62, 0, 797, 795, 1, 0, 0, 0, 798, 801, 1, 0, 0,
		0, 799, 797, 1, 0, 0, 0, 799, 800, 1, 0, 0, 0, 800, 111, 1, 0, 0, 0, 801,
		799, 1, 0, 0, 0, 802, 806, 3, 114, 57, 0, 803, 806, 3, 126, 63, 0, 804,
		806, 3, 172, 86, 0, 805, 802, 1, 0, 0, 0, 805, 803, 1, 0, 0, 0, 805, 804,
		1, 0, 0, 0, 806, 113, 1, 0, 0, 0, 807, 812, 3, 116, 58, 0, 808, 812, 3,
		122, 61, 0, 809, 812, 3, 124, 62, 0, 810, 812, 3, 130, 65, 0, 811, 807,
		1, 0, 0, 0, 811, 808, 1, 0, 0, 0, 811, 809, 1, 0, 0, 0, 811, 810, 1, 0,
		0, 0, 812, 115, 1, 0, 0, 0, 813, 814, 5, 58, 0, 0, 814, 815, 3, 118, 59,
		0, 815, 816, 5, 59, 0, 0, 816, 117, 1, 0, 0, 0, 817, 822, 3, 120, 60, 0,
		818, 819, 5, 49, 0, 0, 819, 821, 3, 120, 60, 0, 820, 818, 1, 0, 0, 0, 821,
		824, 1, 0, 0, 0, 822, 820, 1, 0, 0, 0, 822, 823, 1, 0, 0, 0, 823, 119,
		1, 0, 0, 0, 824, 822, 1, 0, 0, 0, 825, 828, 3, 14, 7, 0, 826, 827, 5, 52,
		0, 0, 827, 829, 3, 238, 119, 0, 828, 826, 1, 0, 0, 0, 828, 829, 1, 0, 0,
		0, 829, 121, 1, 0, 0, 0, 830, 831, 3, 242, 121, 0, 831, 832, 5, 67, 0,
		0, 832, 833, 3, 242, 121, 0, 833, 123, 1, 0, 0, 0, 834, 838, 3, 14, 7,
		0, 835, 838, 7, 6, 0, 0, 836, 838, 3, 132, 66, 0, 837, 834, 1, 0, 0, 0,
		837, 835, 1, 0, 0, 0, 837, 836, 1, 0, 0, 0, 838, 125, 1, 0, 0, 0, 839,
		840, 5, 29, 0, 0, 840, 847, 3, 128, 64, 0, 841, 847, 3, 128, 64, 0, 842,
		847, 3, 158, 79, 0, 843, 847, 3, 70, 35, 0, 844, 847, 3, 138, 69, 0, 845,
		847, 3, 84, 42, 0, 846, 839, 1, 0, 0, 0, 846, 841, 1, 0, 0, 0, 846, 842,
		1, 0, 0, 0, 846, 843, 1, 0, 0, 0, 846, 844, 1, 0, 0, 0, 846, 845, 1, 0,
		0, 0, 847, 127, 1, 0, 0, 0, 848, 852, 3, 132, 66, 0, 849, 852, 3, 168,
		84, 0, 850, 852, 3, 170, 85, 0, 851, 848, 1, 0, 0, 0, 851, 849, 1, 0, 0,
		0, 851, 850, 1, 0, 0, 0, 852, 129, 1, 0, 0, 0, 853, 854, 5, 73, 0, 0, 854,
		857, 5, 60, 0, 0, 855, 858, 3, 14, 7, 0, 856, 858, 3, 42, 21, 0, 857, 855,
		1, 0, 0, 0, 857, 856, 1, 0, 0, 0, 858, 859, 1, 0, 0, 0, 859, 860, 5, 62,
		0, 0, 860, 131, 1, 0, 0, 0, 861, 862, 5, 3, 0, 0, 862, 863, 5, 60, 0, 0,
		863, 864, 3, 134, 67, 0, 864, 865, 5, 62, 0, 0, 865, 866, 5, 27, 0, 0,
		866, 869, 3, 112, 56, 0, 867, 868, 5, 52, 0, 0, 868, 870, 3, 116, 58, 0,
		869, 867, 1, 0, 0, 0, 869, 870, 1, 0, 0, 0, 870, 888, 1, 0, 0, 0, 871,
		872, 5, 3, 0, 0, 872, 873, 5, 61, 0, 0, 873, 874, 3, 134, 67, 0, 874, 875,
		5, 63, 0, 0, 875, 876, 5, 27, 0, 0, 876, 879, 3, 112, 56, 0, 877, 878,
		5, 52, 0, 0, 878, 880, 3, 116, 58, 0, 879, 877, 1, 0, 0, 0, 879, 880, 1,
		0, 0, 0, 880, 888, 1, 0, 0, 0, 881, 882, 5, 3, 0, 0, 882, 883, 5, 27, 0,
		0, 883, 888, 5, 9, 0, 0, 884, 885, 5, 3, 0, 0, 885, 886, 5, 27, 0, 0, 886,
		888, 3, 112, 56, 0, 887, 861, 1, 0, 0, 0, 887, 871, 1, 0, 0, 0, 887, 881,
		1, 0, 0, 0, 887, 884, 1, 0, 0, 0, 888, 133, 1, 0, 0, 0, 889, 894, 3, 136,
		68, 0, 890, 891, 5, 49, 0, 0, 891, 893, 3, 136, 68, 0, 892, 890, 1, 0,
		0, 0, 893, 896, 1, 0, 0, 0, 894, 892, 1, 0, 0, 0, 894, 895, 1, 0, 0, 0,
		895, 135, 1, 0, 0, 0, 896, 894, 1, 0, 0, 0, 897, 898, 3, 114, 57, 0, 898,
		137, 1, 0, 0, 0, 899, 900, 5, 33, 0, 0, 900, 904, 3, 142, 71, 0, 901, 903,
		3, 140, 70, 0, 902, 901, 1, 0, 0, 0, 903, 906, 1, 0, 0, 0, 904, 902, 1,
		0, 0, 0, 904, 905, 1, 0, 0, 0, 905, 907, 1, 0, 0, 0, 906, 904, 1, 0, 0,
		0, 907, 908, 5, 14, 0, 0, 908, 915, 1, 0, 0, 0, 909, 911, 5, 33, 0, 0,
		910, 912, 3, 148, 74, 0, 911, 910, 1, 0, 0, 0, 911, 912, 1, 0, 0, 0, 912,
		913, 1, 0, 0, 0, 913, 915, 5, 14, 0, 0, 914, 899, 1, 0, 0, 0, 914, 909,
		1, 0, 0, 0, 915, 139, 1, 0, 0, 0, 916, 920, 3, 74, 37, 0, 917, 919, 3,
		144, 72, 0, 918, 917, 1, 0, 0, 0, 919, 922, 1, 0, 0, 0, 920, 918, 1, 0,
		0, 0, 920, 921, 1, 0, 0, 0, 921, 141, 1, 0, 0, 0, 922, 920, 1, 0, 0, 0,
		923, 925, 3, 144, 72, 0, 924, 923, 1, 0, 0, 0, 925, 928, 1, 0, 0, 0, 926,
		924, 1, 0, 0, 0, 926, 927, 1, 0, 0, 0, 927, 143, 1, 0, 0, 0, 928, 926,
		1, 0, 0, 0, 929, 931, 3, 318, 159, 0, 930, 929, 1, 0, 0, 0, 930, 931, 1,
		0, 0, 0, 931, 932, 1, 0, 0, 0, 932, 933, 3, 216, 108, 0, 933, 934, 5, 50,
		0, 0, 934, 950, 1, 0, 0, 0, 935, 950, 3, 58, 29, 0, 936, 950, 3, 30, 15,
		0, 937, 950, 3, 180, 90, 0, 938, 950, 3, 178, 89, 0, 939, 950, 3, 200,
		100, 0, 940, 941, 3, 94, 47, 0, 941, 944, 5, 50, 0, 0, 942, 943, 5, 87,
		0, 0, 943, 945, 5, 50, 0, 0, 944, 942, 1, 0, 0, 0, 944, 945, 1, 0, 0, 0,
		945, 950, 1, 0, 0, 0, 946, 947, 3, 146, 73, 0, 947, 948, 5, 50, 0, 0, 948,
		950, 1, 0, 0, 0, 949, 930, 1, 0, 0, 0, 949, 935, 1, 0, 0, 0, 949, 936,
		1, 0, 0, 0, 949, 937, 1, 0, 0, 0, 949, 938, 1, 0, 0, 0, 949, 939, 1, 0,
		0, 0, 949, 940, 1, 0, 0, 0, 949, 946, 1, 0, 0, 0, 950, 145, 1, 0, 0, 0,
		951, 953, 8, 5, 0, 0, 952, 951, 1, 0, 0, 0, 953, 954, 1, 0, 0, 0, 954,
		952, 1, 0, 0, 0, 954, 955, 1, 0, 0, 0, 955, 147, 1, 0, 0, 0, 956, 959,
		3, 150, 75, 0, 957, 958, 5, 50, 0, 0, 958, 960, 3, 152, 76, 0, 959, 957,
		1, 0, 0, 0, 959, 960, 1, 0, 0, 0, 960, 963, 1, 0, 0, 0, 961, 963, 3, 152,
		76, 0, 962, 956, 1, 0, 0, 0, 962, 961, 1, 0, 0, 0, 963, 149, 1, 0, 0, 0,
		964, 969, 3, 216, 108, 0, 965, 966, 5, 50, 0, 0, 966, 968, 3, 216, 108,
		0, 967, 965, 1, 0, 0, 0, 968, 971, 1, 0, 0, 0, 969, 967, 1, 0, 0, 0, 969,
		970, 1, 0, 0, 0, 970, 973, 1, 0, 0, 0, 971, 969, 1, 0, 0, 0, 972, 974,
		5, 50, 0, 0, 973, 972, 1, 0, 0, 0, 973, 974, 1, 0, 0, 0, 974, 151, 1, 0,
		0, 0, 975, 976, 5, 6, 0, 0, 976, 977, 3, 154, 77, 0, 977, 978, 5, 27, 0,
		0, 978, 983, 3, 156, 78, 0, 979, 980, 5, 50, 0, 0, 980, 982, 3, 156, 78,
		0, 981, 979, 1, 0, 0, 0, 982, 985, 1, 0, 0, 0, 983, 981, 1, 0, 0, 0, 983,
		984, 1, 0, 0, 0, 984, 153, 1, 0, 0, 0, 985, 983, 1, 0, 0, 0, 986, 987,
		3, 14, 7, 0, 987, 988, 5, 51, 0, 0, 988, 989, 3, 124, 62, 0, 989, 992,
		1, 0, 0, 0, 990, 992, 3, 124, 62, 0, 991, 986, 1, 0, 0, 0, 991, 990, 1,
		0, 0, 0, 992, 155, 1, 0, 0, 0, 993, 994, 3, 212, 106, 0, 994, 995, 5, 51,
		0, 0, 995, 996, 5, 58, 0, 0, 996, 997, 3, 148, 74, 0, 997, 998, 5, 59,
		0, 0, 998, 157, 1, 0, 0, 0, 999, 1000, 5, 77, 0, 0, 1000, 1001, 5, 19,
		0, 0, 1001, 1002, 5, 16, 0, 0, 1002, 1003, 3, 124, 62, 0, 1003, 1007, 3,
		162, 81, 0, 1004, 1006, 3, 160, 80, 0, 1005, 1004, 1, 0, 0, 0, 1006, 1009,
		1, 0, 0, 0, 1007, 1005, 1, 0, 0, 0, 1007, 1008, 1, 0, 0, 0, 1008, 1010,
		1, 0, 0, 0, 1009, 1007, 1, 0, 0, 0, 1010, 1011, 5, 14, 0, 0, 1011, 159,
		1, 0, 0, 0, 1012, 1016, 3, 74, 37, 0, 1013, 1015, 3, 164, 82, 0, 1014,
		1013, 1, 0, 0, 0, 1015, 1018, 1, 0, 0, 0, 1016, 1014, 1, 0, 0, 0, 1016,
		1017, 1, 0, 0, 0, 1017, 161, 1, 0, 0, 0, 1018, 1016, 1, 0, 0, 0, 1019,
		1021, 3, 164, 82, 0, 1020, 1019, 1, 0, 0, 0, 1021, 1024, 1, 0, 0, 0, 1022,
		1020, 1, 0, 0, 0, 1022, 1023, 1, 0, 0, 0, 1023, 163, 1, 0, 0, 0, 1024,
		1022, 1, 0, 0, 0, 1025, 1039, 3, 58, 29, 0, 1026, 1039, 3, 30, 15, 0, 1027,
		1039, 3, 180, 90, 0, 1028, 1039, 3, 178, 89, 0, 1029, 1030, 3, 94, 47,
		0, 1030, 1033, 5, 50, 0, 0, 1031, 1032, 5, 87, 0, 0, 1032, 1034, 5, 50,
		0, 0, 1033, 1031, 1, 0, 0, 0, 1033, 1034, 1, 0, 0, 0, 1034, 1039, 1, 0,
		0, 0, 1035, 1036, 3, 166, 83, 0, 1036, 1037, 5, 50, 0, 0, 1037, 1039, 1,
		0, 0, 0, 1038, 1025, 1, 0, 0, 0, 1038, 1026, 1, 0, 0, 0, 1038, 1027, 1,
		0, 0, 0, 1038, 1028, 1, 0, 0, 0, 1038, 1029, 1, 0, 0, 0, 1038, 1035, 1,
		0, 0, 0, 1039, 165, 1, 0, 0, 0, 1040, 1042, 8, 5, 0, 0, 1041, 1040, 1,
		0, 0, 0, 1042, 1043, 1, 0, 0, 0, 1043, 1041, 1, 0, 0, 0, 1043, 1044, 1,
		0, 0, 0, 1044, 167, 1, 0, 0, 0, 1045, 1046, 5, 36, 0, 0, 1046, 1047, 5,
		27, 0, 0, 1047, 1048, 3, 114, 57, 0, 1048, 169, 1, 0, 0, 0, 1049, 1050,
		5, 15, 0, 0, 1050, 1051, 5, 27, 0, 0, 1051, 1054, 3, 112, 56, 0, 1052,
		1054, 5, 15, 0, 0, 1053, 1049, 1, 0, 0, 0, 1053, 1052, 1, 0, 0, 0, 1054,
		171, 1, 0, 0, 0, 1055, 1056, 5, 64, 0, 0, 1056, 1057, 3, 124, 62, 0, 1057,
		173, 1, 0, 0, 0, 1058, 1059, 5, 41, 0, 0, 1059, 1064, 3, 176, 88, 0, 1060,
		1061, 5, 50, 0, 0, 1061, 1063, 3, 176, 88, 0, 1062, 1060, 1, 0, 0, 0, 1063,
		1066, 1, 0, 0, 0, 1064, 1062, 1, 0, 0, 0, 1064, 1065, 1, 0, 0, 0, 1065,
		1067, 1, 0, 0, 0, 1066, 1064, 1, 0, 0, 0, 1067, 1068, 5, 50, 0, 0, 1068,
		175, 1, 0, 0, 0, 1069, 1071, 3, 318, 159, 0, 1070, 1069, 1, 0, 0, 0, 1070,
		1071, 1, 0, 0, 0, 1071, 1072, 1, 0, 0, 0, 1072, 1075, 3, 216, 108, 0, 1073,
		1074, 5, 52, 0, 0, 1074, 1076, 3, 242, 121, 0, 1075, 1073, 1, 0, 0, 0,
		1075, 1076, 1, 0, 0, 0, 1076, 177, 1, 0, 0, 0, 1077, 1079, 3, 318, 159,
		0, 1078, 1077, 1, 0, 0, 0, 1078, 1079, 1, 0, 0, 0, 1079, 1081, 1, 0, 0,
		0, 1080, 1082, 5, 77, 0, 0, 1081, 1080, 1, 0, 0, 0, 1081, 1082, 1, 0, 0,
		0, 1082, 1083, 1, 0, 0, 0, 1083, 1084, 7, 7, 0, 0, 1084, 1086, 3, 14, 7,
		0, 1085, 1087, 3, 204, 102, 0, 1086, 1085, 1, 0, 0, 0, 1086, 1087, 1, 0,
		0, 0, 1087, 1088, 1, 0, 0, 0, 1088, 1089, 3, 184, 92, 0, 1089, 1090, 5,
		50, 0, 0, 1090, 179, 1, 0, 0, 0, 1091, 1093, 3, 318, 159, 0, 1092, 1091,
		1, 0, 0, 0, 1092, 1093, 1, 0, 0, 0, 1093, 1095, 1, 0, 0, 0, 1094, 1096,
		5, 77, 0, 0, 1095, 1094, 1, 0, 0, 0, 1095, 1096, 1, 0, 0, 0, 1096, 1097,
		1, 0, 0, 0, 1097, 1098, 5, 17, 0, 0, 1098, 1100, 3, 14, 7, 0, 1099, 1101,
		3, 204, 102, 0, 1100, 1099, 1, 0, 0, 0, 1100, 1101, 1, 0, 0, 0, 1101, 1102,
		1, 0, 0, 0, 1102, 1103, 5, 51, 0, 0, 1103, 1104, 3, 196, 98, 0, 1104, 1105,
		3, 184, 92, 0, 1105, 1106, 5, 50, 0, 0, 1106, 181, 1, 0, 0, 0, 1107, 1110,
		3, 178, 89, 0, 1108, 1110, 3, 180, 90, 0, 1109, 1107, 1, 0, 0, 0, 1109,
		1108, 1, 0, 0, 0, 1110, 183, 1, 0, 0, 0, 1111, 1112, 5, 50, 0, 0, 1112,
		1114, 7, 8, 0, 0, 1113, 1111, 1, 0, 0, 0, 1114, 1117, 1, 0, 0, 0, 1115,
		1113, 1, 0, 0, 0, 1115, 1116, 1, 0, 0, 0, 1116, 185, 1, 0, 0, 0, 1117,
		1115, 1, 0, 0, 0, 1118, 1121, 3, 188, 94, 0, 1119, 1121, 3, 190, 95, 0,
		1120, 1118, 1, 0, 0, 0, 1120, 1119, 1, 0, 0, 0, 1121, 187, 1, 0, 0, 0,
		1122, 1123, 3, 178, 89, 0, 1123, 1124, 3, 198, 99, 0, 1124, 1125, 5, 50,
		0, 0, 1125, 189, 1, 0, 0, 0, 1126, 1127, 3, 180, 90, 0, 1127, 1128, 3,
		198, 99, 0, 1128, 1129, 5, 50, 0, 0, 1129, 191, 1, 0, 0, 0, 1130, 1132,
		5, 30, 0, 0, 1131, 1133, 3, 204, 102, 0, 1132, 1131, 1, 0, 0, 0, 1132,
		1133, 1, 0, 0, 0, 1133, 1134, 1, 0, 0, 0, 1134, 1135, 3, 198, 99, 0, 1135,
		193, 1, 0, 0, 0, 1136, 1138, 5, 17, 0, 0, 1137, 1139, 3, 204, 102, 0, 1138,
		1137, 1, 0, 0, 0, 1138, 1139, 1, 0, 0, 0, 1139, 1140, 1, 0, 0, 0, 1140,
		1141, 3, 198, 99, 0, 1141, 1142, 5, 51, 0, 0, 1142, 1143, 3, 196, 98, 0,
		1143, 195, 1, 0, 0, 0, 1144, 1145, 3, 124, 62, 0, 1145, 197, 1, 0, 0, 0,
		1146, 1147, 3, 22, 11, 0, 1147, 1148, 3, 284, 142, 0, 1148, 199, 1, 0,
		0, 0, 1149, 1150, 5, 77, 0, 0, 1150, 1151, 5, 117, 0, 0, 1151, 1153, 3,
		14, 7, 0, 1152, 1154, 3, 204, 102, 0, 1153, 1152, 1, 0, 0, 0, 1153, 1154,
		1, 0, 0, 0, 1154, 1155, 1, 0, 0, 0, 1155, 1156, 5, 51, 0, 0, 1156, 1157,
		3, 196, 98, 0, 1157, 1158, 3, 184, 92, 0, 1158, 1159, 5, 50, 0, 0, 1159,
		201, 1, 0, 0, 0, 1160, 1161, 3, 200, 100, 0, 1161, 1162, 3, 198, 99, 0,
		1162, 1163, 5, 50, 0, 0, 1163, 203, 1, 0, 0, 0, 1164, 1165, 5, 58, 0, 0,
		1165, 1170, 3, 206, 103, 0, 1166, 1167, 5, 50, 0, 0, 1167, 1169, 3, 206,
		103, 0, 1168, 1166, 1, 0, 0, 0, 1169, 1172, 1, 0, 0, 0, 1170, 1168, 1,
		0, 0, 0, 1170, 1171, 1, 0, 0, 0, 1171, 1173, 1, 0, 0, 0, 1172, 1170, 1,
		0, 0, 0, 1173, 1174, 5, 59, 0, 0, 1174, 205, 1, 0, 0, 0, 1175, 1177, 3,
		318, 159, 0, 1176, 1175, 1, 0, 0, 0, 1176, 1177, 1, 0, 0, 0, 1177, 1178,
		1, 0, 0, 0, 1178, 1205, 3, 208, 104, 0, 1179, 1181, 3, 318, 159, 0, 1180,
		1179, 1, 0, 0, 0, 1180, 1181, 1, 0, 0, 0, 1181, 1182, 1, 0, 0, 0, 1182,
		1183, 5, 41, 0, 0, 1183, 1205, 3, 208, 104, 0, 1184, 1186, 3, 318, 159,
		0, 1185, 1184, 1, 0, 0, 0, 1185, 1186, 1, 0, 0, 0, 1186, 1187, 1, 0, 0,
		0, 1187, 1188, 5, 9, 0, 0, 1188, 1205, 3, 208, 104, 0, 1189, 1191, 3, 318,
		159, 0, 1190, 1189, 1, 0, 0, 0, 1190, 1191, 1, 0, 0, 0, 1191, 1192, 1,
		0, 0, 0, 1192, 1193, 5, 83, 0, 0, 1193, 1205, 3, 208, 104, 0, 1194, 1196,
		3, 318, 159, 0, 1195, 1194, 1, 0, 0, 0, 1195, 1196, 1, 0, 0, 0, 1196, 1197,
		1, 0, 0, 0, 1197, 1198, 5, 17, 0, 0, 1198, 1205, 3, 208, 104, 0, 1199,
		1201, 3, 318, 159, 0, 1200, 1199, 1, 0, 0, 0, 1200, 1201, 1, 0, 0, 0, 1201,
		1202, 1, 0, 0, 0, 1202, 1203, 5, 30, 0, 0, 1203, 1205, 3, 208, 104, 0,
		1204, 1176, 1, 0, 0, 0, 1204, 1180, 1, 0, 0, 0, 1204, 1185, 1, 0, 0, 0,
		1204, 1190, 1, 0, 0, 0, 1204, 1195, 1, 0, 0, 0, 1204, 1200, 1, 0, 0, 0,
		1205, 207, 1, 0, 0, 0, 1206, 1209, 3, 210, 105, 0, 1207, 1208, 5, 51, 0,
		0, 1208, 1210, 3, 124, 62, 0, 1209, 1207, 1, 0, 0, 0, 1209, 1210, 1, 0,
		0, 0, 1210, 1212, 1, 0, 0, 0, 1211, 1213, 3, 214, 107, 0, 1212, 1211, 1,
		0, 0, 0, 1212, 1213, 1, 0, 0, 0, 1213, 209, 1, 0, 0, 0, 1214, 1219, 3,
		14, 7, 0, 1215, 1216, 5, 49, 0, 0, 1216, 1218, 3, 14, 7, 0, 1217, 1215,
		1, 0, 0, 0, 1218, 1221, 1, 0, 0, 0, 1219, 1217, 1, 0, 0, 0, 1219, 1220,
		1, 0, 0, 0, 1220, 211, 1, 0, 0, 0, 1221, 1219, 1, 0, 0, 0, 1222, 1227,
		3, 38, 19, 0, 1223, 1224, 5, 49, 0, 0, 1224, 1226, 3, 38, 19, 0, 1225,
		1223, 1, 0, 0, 0, 1226, 1229, 1, 0, 0, 0, 1227, 1225, 1, 0, 0, 0, 1227,
		1228, 1, 0, 0, 0, 1228, 213, 1, 0, 0, 0, 1229, 1227, 1, 0, 0, 0, 1230,
		1231, 5, 52, 0, 0, 1231, 1232, 3, 238, 119, 0, 1232, 215, 1, 0, 0, 0, 1233,
		1234, 3, 210, 105, 0, 1234, 1235, 5, 51, 0, 0, 1235, 1236, 3, 112, 56,
		0, 1236, 217, 1, 0, 0, 0, 1237, 1238, 3, 28, 14, 0, 1238, 1239, 5, 51,
		0, 0, 1239, 1240, 3, 222, 111, 0, 1240, 1244, 1, 0, 0, 0, 1241, 1244, 3,
		222, 111, 0, 1242, 1244, 3, 220, 110, 0, 1243, 1237, 1, 0, 0, 0, 1243,
		1241, 1, 0, 0, 0, 1243, 1242, 1, 0, 0, 0, 1244, 219, 1, 0, 0, 0, 1245,
		1247, 8, 9, 0, 0, 1246, 1245, 1, 0, 0, 0, 1247, 1248, 1, 0, 0, 0, 1248,
		1246, 1, 0, 0, 0, 1248, 1249, 1, 0, 0, 0, 1249, 221, 1, 0, 0, 0, 1250,
		1253, 3, 224, 112, 0, 1251, 1253, 3, 282, 141, 0, 1252, 1250, 1, 0, 0,
		0, 1252, 1251, 1, 0, 0, 0, 1253, 223, 1, 0, 0, 0, 1254, 1264, 3, 226, 113,
		0, 1255, 1264, 3, 268, 134, 0, 1256, 1264, 3, 266, 133, 0, 1257, 1264,
		3, 274, 137, 0, 1258, 1264, 3, 276, 138, 0, 1259, 1264, 3, 234, 117, 0,
		1260, 1264, 3, 278, 139, 0, 1261, 1264, 3, 228, 114, 0, 1262, 1264, 3,
		230, 115, 0, 1263, 1254, 1, 0, 0, 0, 1263, 1255, 1, 0, 0, 0, 1263, 1256,
		1, 0, 0, 0, 1263, 1257, 1, 0, 0, 0, 1263, 1258, 1, 0, 0, 0, 1263, 1259,
		1, 0, 0, 0, 1263, 1260, 1, 0, 0, 0, 1263, 1261, 1, 0, 0, 0, 1263, 1262,
		1, 0, 0, 0, 1264, 225, 1, 0, 0, 0, 1265, 1266, 3, 232, 116, 0, 1266, 1267,
		5, 48, 0, 0, 1267, 1268, 3, 238, 119, 0, 1268, 1274, 1, 0, 0, 0, 1269,
		1270, 3, 236, 118, 0, 1270, 1271, 5, 48, 0, 0, 1271, 1272, 3, 238, 119,
		0, 1272, 1274, 1, 0, 0, 0, 1273, 1265, 1, 0, 0, 0, 1273, 1269, 1, 0, 0,
		0, 1274, 227, 1, 0, 0, 0, 1275, 1277, 5, 110, 0, 0, 1276, 1278, 3, 238,
		119, 0, 1277, 1276, 1, 0, 0, 0, 1277, 1278, 1, 0, 0, 0, 1278, 229, 1, 0,
		0, 0, 1279, 1280, 5, 41, 0, 0, 1280, 1283, 3, 210, 105, 0, 1281, 1282,
		5, 51, 0, 0, 1282, 1284, 3, 60, 30, 0, 1283, 1281, 1, 0, 0, 0, 1283, 1284,
		1, 0, 0, 0, 1284, 1287, 1, 0, 0, 0, 1285, 1286, 5, 48, 0, 0, 1286, 1288,
		3, 238, 119, 0, 1287, 1285, 1, 0, 0, 0, 1287, 1288, 1, 0, 0, 0, 1288, 231,
		1, 0, 0, 0, 1289, 1294, 3, 234, 117, 0, 1290, 1291, 5, 65, 0, 0, 1291,
		1294, 3, 14, 7, 0, 1292, 1294, 3, 256, 128, 0, 1293, 1289, 1, 0, 0, 0,
		1293, 1290, 1, 0, 0, 0, 1293, 1292, 1, 0, 0, 0, 1294, 1326, 1, 0, 0, 0,
		1295, 1296, 5, 60, 0, 0, 1296, 1301, 3, 238, 119, 0, 1297, 1298, 5, 49,
		0, 0, 1298, 1300, 3, 238, 119, 0, 1299, 1297, 1, 0, 0, 0, 1300, 1303, 1,
		0, 0, 0, 1301, 1299, 1, 0, 0, 0, 1301, 1302, 1, 0, 0, 0, 1302, 1304, 1,
		0, 0, 0, 1303, 1301, 1, 0, 0, 0, 1304, 1305, 5, 62, 0, 0, 1305, 1325, 1,
		0, 0, 0, 1306, 1307, 5, 61, 0, 0, 1307, 1312, 3, 238, 119, 0, 1308, 1309,
		5, 49, 0, 0, 1309, 1311, 3, 238, 119, 0, 1310, 1308, 1, 0, 0, 0, 1311,
		1314, 1, 0, 0, 0, 1312, 1310, 1, 0, 0, 0, 1312, 1313, 1, 0, 0, 0, 1313,
		1315, 1, 0, 0, 0, 1314, 1312, 1, 0, 0, 0, 1315, 1316, 5, 63, 0, 0, 1316,
		1325, 1, 0, 0, 0, 1317, 1318, 5, 66, 0, 0, 1318, 1325, 3, 256, 128, 0,
		1319, 1321, 5, 64, 0, 0, 1320, 1319, 1, 0, 0, 0, 1321, 1322, 1, 0, 0, 0,
		1322, 1320, 1, 0, 0, 0, 1322, 1323, 1, 0, 0, 0, 1323, 1325, 1, 0, 0, 0,
		1324, 1295, 1, 0, 0, 0, 1324, 1306, 1, 0, 0, 0, 1324, 1317, 1, 0, 0, 0,
		1324, 1320, 1, 0, 0, 0, 1325, 1328, 1, 0, 0, 0, 1326, 1324, 1, 0, 0, 0,
		1326, 1327, 1, 0, 0, 0, 1327, 233, 1, 0, 0, 0, 1328, 1326, 1, 0, 0, 0,
		1329, 1330, 3, 124, 62, 0, 1330, 1331, 5, 58, 0, 0, 1331, 1332, 3, 238,
		119, 0, 1332, 1333, 5, 59, 0, 0, 1333, 1341, 1, 0, 0, 0, 1334, 1335, 5,
		58, 0, 0, 1335, 1336, 3, 238, 119, 0, 1336, 1337, 5, 89, 0, 0, 1337, 1338,
		3, 124, 62, 0, 1338, 1339, 5, 59, 0, 0, 1339, 1341, 1, 0, 0, 0, 1340, 1329,
		1, 0, 0, 0, 1340, 1334, 1, 0, 0, 0, 1341, 235, 1, 0, 0, 0, 1342, 1347,
		3, 256, 128, 0, 1343, 1344, 5, 66, 0, 0, 1344, 1346, 3, 256, 128, 0, 1345,
		1343, 1, 0, 0, 0, 1346, 1349, 1, 0, 0, 0, 1347, 1345, 1, 0, 0, 0, 1347,
		1348, 1, 0, 0, 0, 1348, 1350, 1, 0, 0, 0, 1349, 1347, 1, 0, 0, 0, 1350,
		1351, 5, 66, 0, 0, 1351, 1363, 3, 14, 7, 0, 1352, 1353, 5, 60, 0, 0, 1353,
		1358, 3, 238, 119, 0, 1354, 1355, 5, 49, 0, 0, 1355, 1357, 3, 238, 119,
		0, 1356, 1354, 1, 0, 0, 0, 1357, 1360, 1, 0, 0, 0, 1358, 1356, 1, 0, 0,
		0, 1358, 1359, 1, 0, 0, 0, 1359, 1361, 1, 0, 0, 0, 1360, 1358, 1, 0, 0,
		0, 1361, 1362, 5, 62, 0, 0, 1362, 1364, 1, 0, 0, 0, 1363, 1352, 1, 0, 0,
		0, 1363, 1364, 1, 0, 0, 0, 1364, 237, 1, 0, 0, 0, 1365, 1369, 3, 242, 121,
		0, 1366, 1367, 3, 240, 120, 0, 1367, 1368, 3, 238, 119, 0, 1368, 1370,
		1, 0, 0, 0, 1369, 1366, 1, 0, 0, 0, 1369, 1370, 1, 0, 0, 0, 1370, 239,
		1, 0, 0, 0, 1371, 1372, 7, 10, 0, 0, 1372, 241, 1, 0, 0, 0, 1373, 1377,
		3, 246, 123, 0, 1374, 1375, 3, 244, 122, 0, 1375, 1376, 3, 242, 121, 0,
		1376, 1378, 1, 0, 0, 0, 1377, 1374, 1, 0, 0, 0, 1377, 1378, 1, 0, 0, 0,
		1378, 243, 1, 0, 0, 0, 1379, 1380, 7, 11, 0, 0, 1380, 245, 1, 0, 0, 0,
		1381, 1385, 3, 250, 125, 0, 1382, 1383, 3, 248, 124, 0, 1383, 1384, 3,
		246, 123, 0, 1384, 1386, 1, 0, 0, 0, 1385, 1382, 1, 0, 0, 0, 1385, 1386,
		1, 0, 0, 0, 1386, 247, 1, 0, 0, 0, 1387, 1388, 7, 12, 0, 0, 1388, 249,
		1, 0, 0, 0, 1389, 1391, 7, 1, 0, 0, 1390, 1389, 1, 0, 0, 0, 1390, 1391,
		1, 0, 0, 0, 1391, 1392, 1, 0, 0, 0, 1392, 1393, 3, 252, 126, 0, 1393, 251,
		1, 0, 0, 0, 1394, 1396, 6, 126, -1, 0, 1395, 1397, 5, 96, 0, 0, 1396, 1395,
		1, 0, 0, 0, 1396, 1397, 1, 0, 0, 0, 1397, 1398, 1, 0, 0, 0, 1398, 1430,
		3, 256, 128, 0, 1399, 1402, 3, 232, 116, 0, 1400, 1401, 5, 89, 0, 0, 1401,
		1403, 3, 14, 7, 0, 1402, 1400, 1, 0, 0, 0, 1402, 1403, 1, 0, 0, 0, 1403,
		1430, 1, 0, 0, 0, 1404, 1405, 5, 58, 0, 0, 1405, 1406, 3, 238, 119, 0,
		1406, 1407, 5, 59, 0, 0, 1407, 1430, 1, 0, 0, 0, 1408, 1430, 3, 254, 127,
		0, 1409, 1430, 3, 260, 130, 0, 1410, 1411, 5, 26, 0, 0, 1411, 1430, 3,
		252, 126, 5, 1412, 1430, 3, 50, 25, 0, 1413, 1415, 5, 65, 0, 0, 1414, 1413,
		1, 0, 0, 0, 1414, 1415, 1, 0, 0, 0, 1415, 1416, 1, 0, 0, 0, 1416, 1421,
		3, 124, 62, 0, 1417, 1418, 5, 58, 0, 0, 1418, 1419, 3, 238, 119, 0, 1419,
		1420, 5, 59, 0, 0, 1420, 1422, 1, 0, 0, 0, 1421, 1417, 1, 0, 0, 0, 1421,
		1422, 1, 0, 0, 0, 1422, 1426, 1, 0, 0, 0, 1423, 1425, 5, 64, 0, 0, 1424,
		1423, 1, 0, 0, 0, 1425, 1428, 1, 0, 0, 0, 1426, 1424, 1, 0, 0, 0, 1426,
		1427, 1, 0, 0, 0, 1427, 1430, 1, 0, 0, 0, 1428, 1426, 1, 0, 0, 0, 1429,
		1394, 1, 0, 0, 0, 1429, 1399, 1, 0, 0, 0, 1429, 1404, 1, 0, 0, 0, 1429,
		1408, 1, 0, 0, 0, 1429, 1409, 1, 0, 0, 0, 1429, 1410, 1, 0, 0, 0, 1429,
		1412, 1, 0, 0, 0, 1429, 1414, 1, 0, 0, 0, 1430, 1452, 1, 0, 0, 0, 1431,
		1432, 10, 3, 0, 0, 1432, 1433, 5, 60, 0, 0, 1433, 1438, 3, 238, 119, 0,
		1434, 1435, 5, 49, 0, 0, 1435, 1437, 3, 238, 119, 0, 1436, 1434, 1, 0,
		0, 0, 1437, 1440, 1, 0, 0, 0, 1438, 1436, 1, 0, 0, 0, 1438, 1439, 1, 0,
		0, 0, 1439, 1441, 1, 0, 0, 0, 1440, 1438, 1, 0, 0, 0, 1441, 1442, 5, 62,
		0, 0, 1442, 1451, 1, 0, 0, 0, 1443, 1446, 10, 1, 0, 0, 1444, 1445, 5, 66,
		0, 0, 1445, 1447, 3, 238, 119, 0, 1446, 1444, 1, 0, 0, 0, 1447, 1448, 1,
		0, 0, 0, 1448, 1446, 1, 0, 0, 0, 1448, 1449, 1, 0, 0, 0, 1449, 1451, 1,
		0, 0, 0, 1450, 1431, 1, 0, 0, 0, 1450, 1443, 1, 0, 0, 0, 1451, 1454, 1,
		0, 0, 0, 1452, 1450, 1, 0, 0, 0, 1452, 1453, 1, 0, 0, 0, 1453, 253, 1,
		0, 0, 0, 1454, 1452, 1, 0, 0, 0, 1455, 1461, 3, 42, 21, 0, 1456, 1461,
		3, 34, 17, 0, 1457, 1461, 3, 36, 18, 0, 1458, 1461, 3, 52, 26, 0, 1459,
		1461, 5, 25, 0, 0, 1460, 1455, 1, 0, 0, 0, 1460, 1456, 1, 0, 0, 0, 1460,
		1457, 1, 0, 0, 0, 1460, 1458, 1, 0, 0, 0, 1460, 1459, 1, 0, 0, 0, 1461,
		255, 1, 0, 0, 0, 1462, 1467, 3, 14, 7, 0, 1463, 1464, 5, 54, 0, 0, 1464,
		1465, 3, 124, 62, 0, 1465, 1466, 5, 57, 0, 0, 1466, 1468, 1, 0, 0, 0, 1467,
		1463, 1, 0, 0, 0, 1467, 1468, 1, 0, 0, 0, 1468, 1473, 1, 0, 0, 0, 1469,
		1470, 5, 58, 0, 0, 1470, 1471, 3, 258, 129, 0, 1471, 1472, 5, 59, 0, 0,
		1472, 1474, 1, 0, 0, 0, 1473, 1469, 1, 0, 0, 0, 1473, 1474, 1, 0, 0, 0,
		1474, 257, 1, 0, 0, 0, 1475, 1480, 3, 270, 135, 0, 1476, 1477, 5, 49, 0,
		0, 1477, 1479, 3, 270, 135, 0, 1478, 1476, 1, 0, 0, 0, 1479, 1482, 1, 0,
		0, 0, 1480, 1478, 1, 0, 0, 0, 1480, 1481, 1, 0, 0, 0, 1481, 259, 1, 0,
		0, 0, 1482, 1480, 1, 0, 0, 0, 1483, 1484, 5, 60, 0, 0, 1484, 1485, 3, 262,
		131, 0, 1485, 1486, 5, 62, 0, 0, 1486, 1492, 1, 0, 0, 0, 1487, 1488, 5,
		61, 0, 0, 1488, 1489, 3, 262, 131, 0, 1489, 1490, 5, 63, 0, 0, 1490, 1492,
		1, 0, 0, 0, 1491, 1483, 1, 0, 0, 0, 1491, 1487, 1, 0, 0, 0, 1492, 261,
		1, 0, 0, 0, 1493, 1498, 3, 264, 132, 0, 1494, 1495, 5, 49, 0, 0, 1495,
		1497, 3, 264, 132, 0, 1496, 1494, 1, 0, 0, 0, 1497, 1500, 1, 0, 0, 0, 1498,
		1496, 1, 0, 0, 0, 1498, 1499, 1, 0, 0, 0, 1499, 1503, 1, 0, 0, 0, 1500,
		1498, 1, 0, 0, 0, 1501, 1503, 1, 0, 0, 0, 1502, 1493, 1, 0, 0, 0, 1502,
		1501, 1, 0, 0, 0, 1503, 263, 1, 0, 0, 0, 1504, 1507, 3, 238, 119, 0, 1505,
		1506, 5, 67, 0, 0, 1506, 1508, 3, 238, 119, 0, 1507, 1505, 1, 0, 0, 0,
		1507, 1508, 1, 0, 0, 0, 1508, 265, 1, 0, 0, 0, 1509, 1514, 3, 14, 7, 0,
		1510, 1511, 5, 58, 0, 0, 1511, 1512, 3, 258, 129, 0, 1512, 1513, 5, 59,
		0, 0, 1513, 1515, 1, 0, 0, 0, 1514, 1510, 1, 0, 0, 0, 1514, 1515, 1, 0,
		0, 0, 1515, 267, 1, 0, 0, 0, 1516, 1521, 3, 232, 116, 0, 1517, 1518, 5,
		66, 0, 0, 1518, 1520, 3, 232, 116, 0, 1519, 1517, 1, 0, 0, 0, 1520, 1523,
		1, 0, 0, 0, 1521, 1519, 1, 0, 0, 0, 1521, 1522, 1, 0, 0, 0, 1522, 1524,
		1, 0, 0, 0, 1523, 1521, 1, 0, 0, 0, 1524, 1525, 5, 66, 0, 0, 1525, 1530,
		3, 14, 7, 0, 1526, 1527, 5, 58, 0, 0, 1527, 1528, 3, 258, 129, 0, 1528,
		1529, 5, 59, 0, 0, 1529, 1531, 1, 0, 0, 0, 1530, 1526, 1, 0, 0, 0, 1530,
		1531, 1, 0, 0, 0, 1531, 269, 1, 0, 0, 0, 1532, 1536, 3, 238, 119, 0, 1533,
		1535, 3, 272, 136, 0, 1534, 1533, 1, 0, 0, 0, 1535, 1538, 1, 0, 0, 0, 1536,
		1534, 1, 0, 0, 0, 1536, 1537, 1, 0, 0, 0, 1537, 1542, 1, 0, 0, 0, 1538,
		1536, 1, 0, 0, 0, 1539, 1542, 3, 192, 96, 0, 1540, 1542, 3, 194, 97, 0,
		1541, 1532, 1, 0, 0, 0, 1541, 1539, 1, 0, 0, 0, 1541, 1540, 1, 0, 0, 0,
		1542, 271, 1, 0, 0, 0, 1543, 1544, 5, 51, 0, 0, 1544, 1545, 3, 238, 119,
		0, 1545, 273, 1, 0, 0, 0, 1546, 1547, 5, 18, 0, 0, 1547, 1548, 3, 28, 14,
		0, 1548, 275, 1, 0, 0, 0, 1549, 1557, 5, 96, 0, 0, 1550, 1555, 3, 14, 7,
		0, 1551, 1552, 5, 58, 0, 0, 1552, 1553, 3, 258, 129, 0, 1553, 1554, 5,
		59, 0, 0, 1554, 1556, 1, 0, 0, 0, 1555, 1551, 1, 0, 0, 0, 1555, 1556, 1,
		0, 0, 0, 1556, 1558, 1, 0, 0, 0, 1557, 1550, 1, 0, 0, 0, 1557, 1558, 1,
		0, 0, 0, 1558, 277, 1, 0, 0, 0, 1559, 1560, 1, 0, 0, 0, 1560, 279, 1, 0,
		0, 0, 1561, 1562, 1, 0, 0, 0, 1562, 281, 1, 0, 0, 0, 1563, 1570, 3, 284,
		142, 0, 1564, 1570, 3, 288, 144, 0, 1565, 1570, 3, 296, 148, 0, 1566, 1570,
		3, 310, 155, 0, 1567, 1570, 3, 312, 156, 0, 1568, 1570, 3, 314, 157, 0,
		1569, 1563, 1, 0, 0, 0, 1569, 1564, 1, 0, 0, 0, 1569, 1565, 1, 0, 0, 0,
		1569, 1566, 1, 0, 0, 0, 1569, 1567, 1, 0, 0, 0, 1569, 1568, 1, 0, 0, 0,
		1570, 283, 1, 0, 0, 0, 1571, 1572, 5, 4, 0, 0, 1572, 1573, 3, 286, 143,
		0, 1573, 1574, 5, 14, 0, 0, 1574, 285, 1, 0, 0, 0, 1575, 1580, 3, 218,
		109, 0, 1576, 1577, 5, 50, 0, 0, 1577, 1579, 3, 218, 109, 0, 1578, 1576,
		1, 0, 0, 0, 1579, 1582, 1, 0, 0, 0, 1580, 1578, 1, 0, 0, 0, 1580, 1581,
		1, 0, 0, 0, 1581, 287, 1, 0, 0, 0, 1582, 1580, 1, 0, 0, 0, 1583, 1586,
		3, 290, 145, 0, 1584, 1586, 3, 292, 146, 0, 1585, 1583, 1, 0, 0, 0, 1585,
		1584, 1, 0, 0, 0, 1586, 289, 1, 0, 0, 0, 1587, 1588, 5, 20, 0, 0, 1588,
		1589, 3, 238, 119, 0, 1589, 1590, 5, 37, 0, 0, 1590, 1593, 3, 218, 109,
		0, 1591, 1592, 5, 13, 0, 0, 1592, 1594, 3, 218, 109, 0, 1593, 1591, 1,
		0, 0, 0, 1593, 1594, 1, 0, 0, 0, 1594, 1596, 1, 0, 0, 0, 1595, 1597, 5,
		50, 0, 0, 1596, 1595, 1, 0, 0, 0, 1596, 1597, 1, 0, 0, 0, 1597, 291, 1,
		0, 0, 0, 1598, 1599, 5, 6, 0, 0, 1599, 1600, 3, 238, 119, 0, 1600, 1601,
		5, 27, 0, 0, 1601, 1606, 3, 294, 147, 0, 1602, 1603, 5, 50, 0, 0, 1603,
		1605, 3, 294, 147, 0, 1604, 1602, 1, 0, 0, 0, 1605, 1608, 1, 0, 0, 0, 1606,
		1604, 1, 0, 0, 0, 1606, 1607, 1, 0, 0, 0, 1607, 1612, 1, 0, 0, 0, 1608,
		1606, 1, 0, 0, 0, 1609, 1610, 5, 50, 0, 0, 1610, 1611, 5, 13, 0, 0, 1611,
		1613, 3, 286, 143, 0, 1612, 1609, 1, 0, 0, 0, 1612, 1613, 1, 0, 0, 0, 1613,
		1615, 1, 0, 0, 0, 1614, 1616, 5, 50, 0, 0, 1615, 1614, 1, 0, 0, 0, 1615,
		1616, 1, 0, 0, 0, 1616, 1617, 1, 0, 0, 0, 1617, 1618, 5, 14, 0, 0, 1618,
		293, 1, 0, 0, 0, 1619, 1620, 3, 212, 106, 0, 1620, 1621, 5, 51, 0, 0, 1621,
		1622, 3, 218, 109, 0, 1622, 295, 1, 0, 0, 0, 1623, 1627, 3, 298, 149, 0,
		1624, 1627, 3, 300, 150, 0, 1625, 1627, 3, 302, 151, 0, 1626, 1623, 1,
		0, 0, 0, 1626, 1624, 1, 0, 0, 0, 1626, 1625, 1, 0, 0, 0, 1627, 297, 1,
		0, 0, 0, 1628, 1629, 5, 42, 0, 0, 1629, 1630, 3, 238, 119, 0, 1630, 1631,
		5, 11, 0, 0, 1631, 1632, 3, 218, 109, 0, 1632, 299, 1, 0, 0, 0, 1633, 1634,
		5, 35, 0, 0, 1634, 1635, 3, 286, 143, 0, 1635, 1636, 5, 40, 0, 0, 1636,
		1637, 3, 238, 119, 0, 1637, 301, 1, 0, 0, 0, 1638, 1639, 5, 16, 0, 0, 1639,
		1640, 3, 14, 7, 0, 1640, 1641, 5, 48, 0, 0, 1641, 1642, 3, 304, 152, 0,
		1642, 1643, 5, 11, 0, 0, 1643, 1644, 3, 218, 109, 0, 1644, 303, 1, 0, 0,
		0, 1645, 1646, 3, 306, 153, 0, 1646, 1647, 7, 13, 0, 0, 1647, 1648, 3,
		308, 154, 0, 1648, 305, 1, 0, 0, 0, 1649, 1650, 3, 238, 119, 0, 1650, 307,
		1, 0, 0, 0, 1651, 1652, 3, 238, 119, 0, 1652, 309, 1, 0, 0, 0, 1653, 1654,
		5, 43, 0, 0, 1654, 1655, 3, 316, 158, 0, 1655, 1656, 5, 11, 0, 0, 1656,
		1657, 3, 218, 109, 0, 1657, 1664, 1, 0, 0, 0, 1658, 1659, 5, 43, 0, 0,
		1659, 1660, 3, 238, 119, 0, 1660, 1661, 5, 11, 0, 0, 1661, 1662, 3, 218,
		109, 0, 1662, 1664, 1, 0, 0, 0, 1663, 1653, 1, 0, 0, 0, 1663, 1658, 1,
		0, 0, 0, 1664, 311, 1, 0, 0, 0, 1665, 1666, 5, 90, 0, 0, 1666, 1667, 3,
		286, 143, 0, 1667, 1668, 5, 92, 0, 0, 1668, 1669, 3, 286, 143, 0, 1669,
		1670, 5, 14, 0, 0, 1670, 313, 1, 0, 0, 0, 1671, 1672, 5, 90, 0, 0, 1672,
		1673, 3, 286, 143, 0, 1673, 1674, 5, 91, 0, 0, 1674, 1675, 3, 286, 143,
		0, 1675, 1676, 5, 14, 0, 0, 1676, 315, 1, 0, 0, 0, 1677, 1682, 3, 232,
		116, 0, 1678, 1679, 5, 49, 0, 0, 1679, 1681, 3, 232, 116, 0, 1680, 1678,
		1, 0, 0, 0, 1681, 1684, 1, 0, 0, 0, 1682, 1680, 1, 0, 0, 0, 1682, 1683,
		1, 0, 0, 0, 1683, 317, 1, 0, 0, 0, 1684, 1682, 1, 0, 0, 0, 1685, 1686,
		5, 60, 0, 0, 1686, 1687, 3, 320, 160, 0, 1687, 1688, 5, 62, 0, 0, 1688,
		319, 1, 0, 0, 0, 1689, 1694, 3, 322, 161, 0, 1690, 1691, 5, 49, 0, 0, 1691,
		1693, 3, 322, 161, 0, 1692, 1690, 1, 0, 0, 0, 1693, 1696, 1, 0, 0, 0, 1694,
		1692, 1, 0, 0, 0, 1694, 1695, 1, 0, 0, 0, 1695, 321, 1, 0, 0, 0, 1696,
		1694, 1, 0, 0, 0, 1697, 1702, 3, 14, 7, 0, 1698, 1699, 5, 58, 0, 0, 1699,
		1700, 3, 258, 129, 0, 1700, 1701, 5, 59, 0, 0, 1701, 1703, 1, 0, 0, 0,
		1702, 1698, 1, 0, 0, 0, 1702, 1703, 1, 0, 0, 0, 1703, 323, 1, 0, 0, 0,
		188, 326, 334, 338, 352, 355, 358, 366, 372, 387, 392, 400, 402, 416, 418,
		426, 428, 441, 454, 459, 470, 494, 498, 501, 509, 516, 529, 535, 548, 551,
		560, 564, 570, 578, 584, 588, 592, 599, 602, 616, 619, 625, 634, 638, 642,
		647, 653, 659, 663, 676, 681, 690, 693, 701, 712, 717, 722, 727, 732, 735,
		738, 741, 745, 750, 752, 772, 787, 799, 805, 811, 822, 828, 837, 846, 851,
		857, 869, 879, 887, 894, 904, 911, 914, 920, 926, 930, 944, 949, 954, 959,
		962, 969, 973, 983, 991, 1007, 1016, 1022, 1033, 1038, 1043, 1053, 1064,
		1070, 1075, 1078, 1081, 1086, 1092, 1095, 1100, 1109, 1115, 1120, 1132,
		1138, 1153, 1170, 1176, 1180, 1185, 1190, 1195, 1200, 1204, 1209, 1212,
		1219, 1227, 1243, 1248, 1252, 1263, 1273, 1277, 1283, 1287, 1293, 1301,
		1312, 1322, 1324, 1326, 1340, 1347, 1358, 1363, 1369, 1377, 1385, 1390,
		1396, 1402, 1414, 1421, 1426, 1429, 1438, 1448, 1450, 1452, 1460, 1467,
		1473, 1480, 1491, 1498, 1502, 1507, 1514, 1521, 1530, 1536, 1541, 1555,
		1557, 1569, 1580, 1585, 1593, 1596, 1606, 1612, 1615, 1626, 1663, 1682,
		1694, 1702,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// pascalParserInit initializes any static state used to implement pascalParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewpascalParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func PascalParserInit() {
	staticData := &PascalParserStaticData
	staticData.once.Do(pascalParserInit)
}

// NewpascalParser produces a new parser instance for the optional input antlr.TokenStream.
func NewpascalParser(input antlr.TokenStream) *pascalParser {
	PascalParserInit()
	this := new(pascalParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &PascalParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "pascal.g4"

	return this
}

// pascalParser tokens.
const (
	pascalParserEOF                       = antlr.TokenEOF
	pascalParserGUID_LITERAL              = 1
	pascalParserAND                       = 2
	pascalParserARRAY                     = 3
	pascalParserBEGIN                     = 4
	pascalParserBOOLEAN                   = 5
	pascalParserCASE                      = 6
	pascalParserCHAR                      = 7
	pascalParserCHR                       = 8
	pascalParserCONST                     = 9
	pascalParserDIV                       = 10
	pascalParserDO                        = 11
	pascalParserDOWNTO                    = 12
	pascalParserELSE                      = 13
	pascalParserEND                       = 14
	pascalParserFILE                      = 15
	pascalParserFOR                       = 16
	pascalParserFUNCTION                  = 17
	pascalParserGOTO                      = 18
	pascalParserHELPER                    = 19
	pascalParserIF                        = 20
	pascalParserIN                        = 21
	pascalParserINTEGER                   = 22
	pascalParserLABEL                     = 23
	pascalParserMOD                       = 24
	pascalParserNIL                       = 25
	pascalParserNOT                       = 26
	pascalParserOF                        = 27
	pascalParserOR                        = 28
	pascalParserPACKED                    = 29
	pascalParserPROCEDURE                 = 30
	pascalParserPROGRAM                   = 31
	pascalParserREAL                      = 32
	pascalParserRECORD                    = 33
	pascalParserREFERENCE                 = 34
	pascalParserREPEAT                    = 35
	pascalParserSET                       = 36
	pascalParserTHEN                      = 37
	pascalParserTO                        = 38
	pascalParserTYPE                      = 39
	pascalParserUNTIL                     = 40
	pascalParserVAR                       = 41
	pascalParserWHILE                     = 42
	pascalParserWITH                      = 43
	pascalParserPLUS                      = 44
	pascalParserMINUS                     = 45
	pascalParserSTAR                      = 46
	pascalParserSLASH                     = 47
	pascalParserASSIGN                    = 48
	pascalParserCOMMA                     = 49
	pascalParserSEMI                      = 50
	pascalParserCOLON                     = 51
	pascalParserEQUAL                     = 52
	pascalParserNOT_EQUAL                 = 53
	pascalParserLT                        = 54
	pascalParserLE                        = 55
	pascalParserGE                        = 56
	pascalParserGT                        = 57
	pascalParserLPAREN                    = 58
	pascalParserRPAREN                    = 59
	pascalParserLBRACK                    = 60
	pascalParserLBRACK2                   = 61
	pascalParserRBRACK                    = 62
	pascalParserRBRACK2                   = 63
	pascalParserDEREFERENCE               = 64
	pascalParserAT                        = 65
	pascalParserDOT                       = 66
	pascalParserDOTDOT                    = 67
	pascalParserLCURLY                    = 68
	pascalParserRCURLY                    = 69
	pascalParserUNIT                      = 70
	pascalParserINTERFACE                 = 71
	pascalParserUSES                      = 72
	pascalParserSTRING                    = 73
	pascalParserIMPLEMENTATION            = 74
	pascalParserTRUE                      = 75
	pascalParserFALSE                     = 76
	pascalParserCLASS                     = 77
	pascalParserPRIVATE                   = 78
	pascalParserPROTECTED                 = 79
	pascalParserPUBLIC                    = 80
	pascalParserPUBLISHED                 = 81
	pascalParserSTRICT                    = 82
	pascalParserOUT                       = 83
	pascalParserPROPERTY                  = 84
	pascalParserREAD                      = 85
	pascalParserWRITE                     = 86
	pascalParserDEFAULT                   = 87
	pascalParserINDEX                     = 88
	pascalParserAS                        = 89
	pascalParserTRY                       = 90
	pascalParserFINALLY                   = 91
	pascalParserEXCEPT                    = 92
	pascalParserINITIALIZATION            = 93
	pascalParserFINALIZATION              = 94
	pascalParserOBJECT                    = 95
	pascalParserINHERITED                 = 96
	pascalParserABSTRACT                  = 97
	pascalParserREINTRODUCE               = 98
	pascalParserVIRTUAL                   = 99
	pascalParserOVERRIDE                  = 100
	pascalParserOVERLOAD                  = 101
	pascalParserINLINE                    = 102
	pascalParserCDECL                     = 103
	pascalParserSTDCALL                   = 104
	pascalParserSTATIC                    = 105
	pascalParserCONSTRUCTOR               = 106
	pascalParserDESTRUCTOR                = 107
	pascalParserRESOURCESTRING            = 108
	pascalParserFORWARD                   = 109
	pascalParserRAISE                     = 110
	pascalParserSHR                       = 111
	pascalParserSHL                       = 112
	pascalParserXOR                       = 113
	pascalParserCARDINAL                  = 114
	pascalParserLONGBOOL                  = 115
	pascalParserLONGINT                   = 116
	pascalParserOPERATOR                  = 117
	pascalParserWS                        = 118
	pascalParserCOMMENT_1                 = 119
	pascalParserCOMMENT_2                 = 120
	pascalParserCOMMENT_3                 = 121
	pascalParserIDENT                     = 122
	pascalParserHEX_LITERAL               = 123
	pascalParserSTRING_LITERAL            = 124
	pascalParserSTRING_CROSSHATCH_LITERAL = 125
	pascalParserNUM_INT                   = 126
	pascalParserNUM_REAL                  = 127
	pascalParserUTF8BOM                   = 128
)

// pascalParser rules.
const (
	pascalParserRULE_source                             = 0
	pascalParserRULE_program                            = 1
	pascalParserRULE_unit                               = 2
	pascalParserRULE_interfaceSection                   = 3
	pascalParserRULE_implementationSection              = 4
	pascalParserRULE_initializationSection              = 5
	pascalParserRULE_finalizationSection                = 6
	pascalParserRULE_identifier                         = 7
	pascalParserRULE_identifierPart                     = 8
	pascalParserRULE_interfaceBlock                     = 9
	pascalParserRULE_implementationBlock                = 10
	pascalParserRULE_block                              = 11
	pascalParserRULE_usesUnits                          = 12
	pascalParserRULE_labelDeclarationPart               = 13
	pascalParserRULE_label                              = 14
	pascalParserRULE_constantDefinitionPart             = 15
	pascalParserRULE_constantDefinition                 = 16
	pascalParserRULE_constantChr                        = 17
	pascalParserRULE_hexConstant                        = 18
	pascalParserRULE_constant                           = 19
	pascalParserRULE_arrayConstant                      = 20
	pascalParserRULE_unsignedNumber                     = 21
	pascalParserRULE_unsignedInteger                    = 22
	pascalParserRULE_unsignedReal                       = 23
	pascalParserRULE_sign                               = 24
	pascalParserRULE_bool_                              = 25
	pascalParserRULE_string                             = 26
	pascalParserRULE_resourceDefinitionPart             = 27
	pascalParserRULE_resourceDefinition                 = 28
	pascalParserRULE_typeDefinitionPart                 = 29
	pascalParserRULE_typeDefinition                     = 30
	pascalParserRULE_functionType                       = 31
	pascalParserRULE_procedureType                      = 32
	pascalParserRULE_forwardClassType                   = 33
	pascalParserRULE_forwardInterfaceType               = 34
	pascalParserRULE_classType                          = 35
	pascalParserRULE_classImplementsInterfaces          = 36
	pascalParserRULE_accessSpecifier                    = 37
	pascalParserRULE_classDeclaration                   = 38
	pascalParserRULE_classImplicitPublishedDeclaration  = 39
	pascalParserRULE_classDeclarationPart               = 40
	pascalParserRULE_interfaceGuidConst                 = 41
	pascalParserRULE_interfaceType                      = 42
	pascalParserRULE_interfaceDeclaration               = 43
	pascalParserRULE_interfaceDeclarationPart           = 44
	pascalParserRULE_errorInterfaceDeclarationPart      = 45
	pascalParserRULE_errorClassDeclarationPart          = 46
	pascalParserRULE_propertyDeclaration                = 47
	pascalParserRULE_propertyReadDeclaration            = 48
	pascalParserRULE_propertyWriteDeclaration           = 49
	pascalParserRULE_propertyDefaultValueDeclaration    = 50
	pascalParserRULE_propertyIndexDeclaration           = 51
	pascalParserRULE_propertyIndexParameters            = 52
	pascalParserRULE_propertyIndexParametersList        = 53
	pascalParserRULE_genericTemplate                    = 54
	pascalParserRULE_genericTemplateList                = 55
	pascalParserRULE_type_                              = 56
	pascalParserRULE_simpleType                         = 57
	pascalParserRULE_scalarType                         = 58
	pascalParserRULE_scalerList                         = 59
	pascalParserRULE_scalerMember                       = 60
	pascalParserRULE_subrangeType                       = 61
	pascalParserRULE_typeIdentifier                     = 62
	pascalParserRULE_structuredType                     = 63
	pascalParserRULE_unpackedStructuredType             = 64
	pascalParserRULE_stringtype                         = 65
	pascalParserRULE_arrayType                          = 66
	pascalParserRULE_typeList                           = 67
	pascalParserRULE_indexType                          = 68
	pascalParserRULE_recordType                         = 69
	pascalParserRULE_recordDeclaration                  = 70
	pascalParserRULE_recordImplicitPublishedDeclaration = 71
	pascalParserRULE_recordDeclarationPart              = 72
	pascalParserRULE_errorRecordDeclarationPart         = 73
	pascalParserRULE_recordParts                        = 74
	pascalParserRULE_recordFixedPart                    = 75
	pascalParserRULE_recordVariantPart                  = 76
	pascalParserRULE_tag                                = 77
	pascalParserRULE_recordVariant                      = 78
	pascalParserRULE_helperType                         = 79
	pascalParserRULE_helperDeclaration                  = 80
	pascalParserRULE_helperImplicitPublishedDeclaration = 81
	pascalParserRULE_helperDeclarationPart              = 82
	pascalParserRULE_errorHelperDeclarationPart         = 83
	pascalParserRULE_setType                            = 84
	pascalParserRULE_fileType                           = 85
	pascalParserRULE_pointerType                        = 86
	pascalParserRULE_variableDeclarationPart            = 87
	pascalParserRULE_variableDeclaration                = 88
	pascalParserRULE_procedureHeader                    = 89
	pascalParserRULE_functionHeader                     = 90
	pascalParserRULE_procedureOrFunctionHeader          = 91
	pascalParserRULE_procedureOrFunctionHeaderModifiers = 92
	pascalParserRULE_procedureOrFunctionDeclaration     = 93
	pascalParserRULE_procedureDeclaration               = 94
	pascalParserRULE_functionDeclaration                = 95
	pascalParserRULE_procedureLambdaDeclaration         = 96
	pascalParserRULE_functionLambdaDeclaration          = 97
	pascalParserRULE_resultType                         = 98
	pascalParserRULE_procedureOrFunctionBody            = 99
	pascalParserRULE_classOperatorHeader                = 100
	pascalParserRULE_classOperatorDeclaration           = 101
	pascalParserRULE_formalParameterList                = 102
	pascalParserRULE_formalParameterSection             = 103
	pascalParserRULE_parameterGroup                     = 104
	pascalParserRULE_identifierList                     = 105
	pascalParserRULE_constList                          = 106
	pascalParserRULE_defaultValue                       = 107
	pascalParserRULE_typedIdentifierList                = 108
	pascalParserRULE_statement                          = 109
	pascalParserRULE_errorStatement                     = 110
	pascalParserRULE_unlabelledStatement                = 111
	pascalParserRULE_simpleStatement                    = 112
	pascalParserRULE_assignmentStatement                = 113
	pascalParserRULE_raiseExceptionStatement            = 114
	pascalParserRULE_variableDeclarationStatement       = 115
	pascalParserRULE_variableDesignator                 = 116
	pascalParserRULE_typeCast                           = 117
	pascalParserRULE_propertyDesignator                 = 118
	pascalParserRULE_expression                         = 119
	pascalParserRULE_relationaloperator                 = 120
	pascalParserRULE_simpleExpression                   = 121
	pascalParserRULE_additiveoperator                   = 122
	pascalParserRULE_term                               = 123
	pascalParserRULE_multiplicativeoperator             = 124
	pascalParserRULE_signedFactor                       = 125
	pascalParserRULE_factor                             = 126
	pascalParserRULE_unsignedConstant                   = 127
	pascalParserRULE_functionDesignator                 = 128
	pascalParserRULE_parameterList                      = 129
	pascalParserRULE_set_                               = 130
	pascalParserRULE_elementList                        = 131
	pascalParserRULE_element                            = 132
	pascalParserRULE_procedureStatement                 = 133
	pascalParserRULE_methodCallStatement                = 134
	pascalParserRULE_actualParameter                    = 135
	pascalParserRULE_parameterwidth                     = 136
	pascalParserRULE_gotoStatement                      = 137
	pascalParserRULE_inheritedStatement                 = 138
	pascalParserRULE_emptyStatement_                    = 139
	pascalParserRULE_empty_                             = 140
	pascalParserRULE_structuredStatement                = 141
	pascalParserRULE_compoundStatement                  = 142
	pascalParserRULE_statements                         = 143
	pascalParserRULE_conditionalStatement               = 144
	pascalParserRULE_ifStatement                        = 145
	pascalParserRULE_caseStatement                      = 146
	pascalParserRULE_caseListElement                    = 147
	pascalParserRULE_repetetiveStatement                = 148
	pascalParserRULE_whileStatement                     = 149
	pascalParserRULE_repeatStatement                    = 150
	pascalParserRULE_forStatement                       = 151
	pascalParserRULE_forList                            = 152
	pascalParserRULE_initialValue                       = 153
	pascalParserRULE_finalValue                         = 154
	pascalParserRULE_withStatement                      = 155
	pascalParserRULE_tryExceptStatement                 = 156
	pascalParserRULE_tryFinallyStatement                = 157
	pascalParserRULE_withStatementVariableList          = 158
	pascalParserRULE_attributeSection                   = 159
	pascalParserRULE_attributeList                      = 160
	pascalParserRULE_attributeItem                      = 161
)

// ISourceContext is an interface to support dynamic dispatch.
type ISourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Program() IProgramContext
	Unit() IUnitContext

	// IsSourceContext differentiates from other interfaces.
	IsSourceContext()
}

type SourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceContext() *SourceContext {
	var p = new(SourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_source
	return p
}

func InitEmptySourceContext(p *SourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_source
}

func (*SourceContext) IsSourceContext() {}

func NewSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceContext {
	var p = new(SourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_source

	return p
}

func (s *SourceContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceContext) Program() IProgramContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProgramContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProgramContext)
}

func (s *SourceContext) Unit() IUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitContext)
}

func (s *SourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSource(s)
	}
}

func (s *SourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSource(s)
	}
}

func (s *SourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSource(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Source() (localctx ISourceContext) {
	localctx = NewSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, pascalParserRULE_source)
	p.SetState(326)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserPROGRAM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(324)
			p.Program()
		}

	case pascalParserUNIT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(325)
			p.Unit()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROGRAM() antlr.TerminalNode
	Identifier() IIdentifierContext
	SEMI() antlr.TerminalNode
	ImplementationBlock() IImplementationBlockContext
	BEGIN() antlr.TerminalNode
	Statements() IStatementsContext
	END() antlr.TerminalNode
	DOT() antlr.TerminalNode
	EOF() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	RPAREN() antlr.TerminalNode
	UsesUnits() IUsesUnitsContext

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) PROGRAM() antlr.TerminalNode {
	return s.GetToken(pascalParserPROGRAM, 0)
}

func (s *ProgramContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ProgramContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ProgramContext) ImplementationBlock() IImplementationBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplementationBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplementationBlockContext)
}

func (s *ProgramContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(pascalParserBEGIN, 0)
}

func (s *ProgramContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *ProgramContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *ProgramContext) DOT() antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, 0)
}

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(pascalParserEOF, 0)
}

func (s *ProgramContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ProgramContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ProgramContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ProgramContext) UsesUnits() IUsesUnitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsesUnitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsesUnitsContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProgram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, pascalParserRULE_program)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(328)
		p.Match(pascalParserPROGRAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(329)
		p.Identifier()
	}
	p.SetState(334)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(330)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(331)
			p.IdentifierList()
		}
		{
			p.SetState(332)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(336)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(338)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserUSES {
		{
			p.SetState(337)
			p.UsesUnits()
		}

	}
	{
		p.SetState(340)
		p.ImplementationBlock()
	}
	{
		p.SetState(341)
		p.Match(pascalParserBEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(342)
		p.Statements()
	}
	{
		p.SetState(343)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(344)
		p.Match(pascalParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(345)
		p.Match(pascalParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitContext is an interface to support dynamic dispatch.
type IUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNIT() antlr.TerminalNode
	Identifier() IIdentifierContext
	SEMI() antlr.TerminalNode
	InterfaceSection() IInterfaceSectionContext
	END() antlr.TerminalNode
	DOT() antlr.TerminalNode
	EOF() antlr.TerminalNode
	ImplementationSection() IImplementationSectionContext
	InitializationSection() IInitializationSectionContext
	FinalizationSection() IFinalizationSectionContext

	// IsUnitContext differentiates from other interfaces.
	IsUnitContext()
}

type UnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitContext() *UnitContext {
	var p = new(UnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unit
	return p
}

func InitEmptyUnitContext(p *UnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unit
}

func (*UnitContext) IsUnitContext() {}

func NewUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitContext {
	var p = new(UnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unit

	return p
}

func (s *UnitContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitContext) UNIT() antlr.TerminalNode {
	return s.GetToken(pascalParserUNIT, 0)
}

func (s *UnitContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnitContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *UnitContext) InterfaceSection() IInterfaceSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceSectionContext)
}

func (s *UnitContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *UnitContext) DOT() antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, 0)
}

func (s *UnitContext) EOF() antlr.TerminalNode {
	return s.GetToken(pascalParserEOF, 0)
}

func (s *UnitContext) ImplementationSection() IImplementationSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplementationSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplementationSectionContext)
}

func (s *UnitContext) InitializationSection() IInitializationSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializationSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializationSectionContext)
}

func (s *UnitContext) FinalizationSection() IFinalizationSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinalizationSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinalizationSectionContext)
}

func (s *UnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnit(s)
	}
}

func (s *UnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnit(s)
	}
}

func (s *UnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Unit() (localctx IUnitContext) {
	localctx = NewUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, pascalParserRULE_unit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(347)
		p.Match(pascalParserUNIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(348)
		p.Identifier()
	}
	{
		p.SetState(349)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(350)
		p.InterfaceSection()
	}
	p.SetState(352)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserIMPLEMENTATION {
		{
			p.SetState(351)
			p.ImplementationSection()
		}

	}
	p.SetState(355)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserINITIALIZATION {
		{
			p.SetState(354)
			p.InitializationSection()
		}

	}
	p.SetState(358)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserFINALIZATION {
		{
			p.SetState(357)
			p.FinalizationSection()
		}

	}
	{
		p.SetState(360)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(361)
		p.Match(pascalParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(362)
		p.Match(pascalParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceSectionContext is an interface to support dynamic dispatch.
type IInterfaceSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	InterfaceBlock() IInterfaceBlockContext
	UsesUnits() IUsesUnitsContext

	// IsInterfaceSectionContext differentiates from other interfaces.
	IsInterfaceSectionContext()
}

type InterfaceSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceSectionContext() *InterfaceSectionContext {
	var p = new(InterfaceSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceSection
	return p
}

func InitEmptyInterfaceSectionContext(p *InterfaceSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceSection
}

func (*InterfaceSectionContext) IsInterfaceSectionContext() {}

func NewInterfaceSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceSectionContext {
	var p = new(InterfaceSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceSection

	return p
}

func (s *InterfaceSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceSectionContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(pascalParserINTERFACE, 0)
}

func (s *InterfaceSectionContext) InterfaceBlock() IInterfaceBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceBlockContext)
}

func (s *InterfaceSectionContext) UsesUnits() IUsesUnitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsesUnitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsesUnitsContext)
}

func (s *InterfaceSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceSection(s)
	}
}

func (s *InterfaceSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceSection(s)
	}
}

func (s *InterfaceSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceSection() (localctx IInterfaceSectionContext) {
	localctx = NewInterfaceSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, pascalParserRULE_interfaceSection)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(364)
		p.Match(pascalParserINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(366)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserUSES {
		{
			p.SetState(365)
			p.UsesUnits()
		}

	}
	{
		p.SetState(368)
		p.InterfaceBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImplementationSectionContext is an interface to support dynamic dispatch.
type IImplementationSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPLEMENTATION() antlr.TerminalNode
	ImplementationBlock() IImplementationBlockContext
	UsesUnits() IUsesUnitsContext

	// IsImplementationSectionContext differentiates from other interfaces.
	IsImplementationSectionContext()
}

type ImplementationSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplementationSectionContext() *ImplementationSectionContext {
	var p = new(ImplementationSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_implementationSection
	return p
}

func InitEmptyImplementationSectionContext(p *ImplementationSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_implementationSection
}

func (*ImplementationSectionContext) IsImplementationSectionContext() {}

func NewImplementationSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplementationSectionContext {
	var p = new(ImplementationSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_implementationSection

	return p
}

func (s *ImplementationSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplementationSectionContext) IMPLEMENTATION() antlr.TerminalNode {
	return s.GetToken(pascalParserIMPLEMENTATION, 0)
}

func (s *ImplementationSectionContext) ImplementationBlock() IImplementationBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplementationBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplementationBlockContext)
}

func (s *ImplementationSectionContext) UsesUnits() IUsesUnitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsesUnitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsesUnitsContext)
}

func (s *ImplementationSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplementationSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplementationSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterImplementationSection(s)
	}
}

func (s *ImplementationSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitImplementationSection(s)
	}
}

func (s *ImplementationSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitImplementationSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ImplementationSection() (localctx IImplementationSectionContext) {
	localctx = NewImplementationSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, pascalParserRULE_implementationSection)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(370)
		p.Match(pascalParserIMPLEMENTATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(372)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserUSES {
		{
			p.SetState(371)
			p.UsesUnits()
		}

	}
	{
		p.SetState(374)
		p.ImplementationBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitializationSectionContext is an interface to support dynamic dispatch.
type IInitializationSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INITIALIZATION() antlr.TerminalNode
	Statements() IStatementsContext

	// IsInitializationSectionContext differentiates from other interfaces.
	IsInitializationSectionContext()
}

type InitializationSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializationSectionContext() *InitializationSectionContext {
	var p = new(InitializationSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_initializationSection
	return p
}

func InitEmptyInitializationSectionContext(p *InitializationSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_initializationSection
}

func (*InitializationSectionContext) IsInitializationSectionContext() {}

func NewInitializationSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializationSectionContext {
	var p = new(InitializationSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_initializationSection

	return p
}

func (s *InitializationSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializationSectionContext) INITIALIZATION() antlr.TerminalNode {
	return s.GetToken(pascalParserINITIALIZATION, 0)
}

func (s *InitializationSectionContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *InitializationSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializationSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializationSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInitializationSection(s)
	}
}

func (s *InitializationSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInitializationSection(s)
	}
}

func (s *InitializationSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInitializationSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InitializationSection() (localctx IInitializationSectionContext) {
	localctx = NewInitializationSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, pascalParserRULE_initializationSection)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(376)
		p.Match(pascalParserINITIALIZATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(377)
		p.Statements()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFinalizationSectionContext is an interface to support dynamic dispatch.
type IFinalizationSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FINALIZATION() antlr.TerminalNode
	Statements() IStatementsContext

	// IsFinalizationSectionContext differentiates from other interfaces.
	IsFinalizationSectionContext()
}

type FinalizationSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinalizationSectionContext() *FinalizationSectionContext {
	var p = new(FinalizationSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_finalizationSection
	return p
}

func InitEmptyFinalizationSectionContext(p *FinalizationSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_finalizationSection
}

func (*FinalizationSectionContext) IsFinalizationSectionContext() {}

func NewFinalizationSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinalizationSectionContext {
	var p = new(FinalizationSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_finalizationSection

	return p
}

func (s *FinalizationSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *FinalizationSectionContext) FINALIZATION() antlr.TerminalNode {
	return s.GetToken(pascalParserFINALIZATION, 0)
}

func (s *FinalizationSectionContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *FinalizationSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinalizationSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinalizationSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFinalizationSection(s)
	}
}

func (s *FinalizationSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFinalizationSection(s)
	}
}

func (s *FinalizationSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFinalizationSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FinalizationSection() (localctx IFinalizationSectionContext) {
	localctx = NewFinalizationSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, pascalParserRULE_finalizationSection)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(379)
		p.Match(pascalParserFINALIZATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(380)
		p.Statements()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierPart() []IIdentifierPartContext
	IdentifierPart(i int) IIdentifierPartContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) AllIdentifierPart() []IIdentifierPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierPartContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierPartContext); ok {
			tst[i] = t.(IIdentifierPartContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierContext) IdentifierPart(i int) IIdentifierPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierPartContext)
}

func (s *IdentifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDOT)
}

func (s *IdentifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, i)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, pascalParserRULE_identifier)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(382)
		p.IdentifierPart()
	}
	p.SetState(387)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(383)
				p.Match(pascalParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(384)
				p.IdentifierPart()
			}

		}
		p.SetState(389)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierPartContext is an interface to support dynamic dispatch.
type IIdentifierPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENT() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	READ() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	GenericTemplate() IGenericTemplateContext

	// IsIdentifierPartContext differentiates from other interfaces.
	IsIdentifierPartContext()
}

type IdentifierPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierPartContext() *IdentifierPartContext {
	var p = new(IdentifierPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifierPart
	return p
}

func InitEmptyIdentifierPartContext(p *IdentifierPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifierPart
}

func (*IdentifierPartContext) IsIdentifierPartContext() {}

func NewIdentifierPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierPartContext {
	var p = new(IdentifierPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_identifierPart

	return p
}

func (s *IdentifierPartContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierPartContext) IDENT() antlr.TerminalNode {
	return s.GetToken(pascalParserIDENT, 0)
}

func (s *IdentifierPartContext) INDEX() antlr.TerminalNode {
	return s.GetToken(pascalParserINDEX, 0)
}

func (s *IdentifierPartContext) READ() antlr.TerminalNode {
	return s.GetToken(pascalParserREAD, 0)
}

func (s *IdentifierPartContext) WRITE() antlr.TerminalNode {
	return s.GetToken(pascalParserWRITE, 0)
}

func (s *IdentifierPartContext) GenericTemplate() IGenericTemplateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericTemplateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericTemplateContext)
}

func (s *IdentifierPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterIdentifierPart(s)
	}
}

func (s *IdentifierPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitIdentifierPart(s)
	}
}

func (s *IdentifierPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitIdentifierPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) IdentifierPart() (localctx IIdentifierPartContext) {
	localctx = NewIdentifierPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, pascalParserRULE_identifierPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(390)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-85)) & ^0x3f) == 0 && ((int64(1)<<(_la-85))&137438953483) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(392)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(391)
			p.GenericTemplate()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceBlockContext is an interface to support dynamic dispatch.
type IInterfaceBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLabelDeclarationPart() []ILabelDeclarationPartContext
	LabelDeclarationPart(i int) ILabelDeclarationPartContext
	AllConstantDefinitionPart() []IConstantDefinitionPartContext
	ConstantDefinitionPart(i int) IConstantDefinitionPartContext
	AllResourceDefinitionPart() []IResourceDefinitionPartContext
	ResourceDefinitionPart(i int) IResourceDefinitionPartContext
	AllTypeDefinitionPart() []ITypeDefinitionPartContext
	TypeDefinitionPart(i int) ITypeDefinitionPartContext
	AllVariableDeclarationPart() []IVariableDeclarationPartContext
	VariableDeclarationPart(i int) IVariableDeclarationPartContext
	AllProcedureOrFunctionHeader() []IProcedureOrFunctionHeaderContext
	ProcedureOrFunctionHeader(i int) IProcedureOrFunctionHeaderContext

	// IsInterfaceBlockContext differentiates from other interfaces.
	IsInterfaceBlockContext()
}

type InterfaceBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceBlockContext() *InterfaceBlockContext {
	var p = new(InterfaceBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceBlock
	return p
}

func InitEmptyInterfaceBlockContext(p *InterfaceBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceBlock
}

func (*InterfaceBlockContext) IsInterfaceBlockContext() {}

func NewInterfaceBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceBlockContext {
	var p = new(InterfaceBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceBlock

	return p
}

func (s *InterfaceBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceBlockContext) AllLabelDeclarationPart() []ILabelDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]ILabelDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelDeclarationPartContext); ok {
			tst[i] = t.(ILabelDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) LabelDeclarationPart(i int) ILabelDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelDeclarationPartContext)
}

func (s *InterfaceBlockContext) AllConstantDefinitionPart() []IConstantDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IConstantDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantDefinitionPartContext); ok {
			tst[i] = t.(IConstantDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) ConstantDefinitionPart(i int) IConstantDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *InterfaceBlockContext) AllResourceDefinitionPart() []IResourceDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResourceDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IResourceDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResourceDefinitionPartContext); ok {
			tst[i] = t.(IResourceDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) ResourceDefinitionPart(i int) IResourceDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceDefinitionPartContext)
}

func (s *InterfaceBlockContext) AllTypeDefinitionPart() []ITypeDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]ITypeDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeDefinitionPartContext); ok {
			tst[i] = t.(ITypeDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) TypeDefinitionPart(i int) ITypeDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionPartContext)
}

func (s *InterfaceBlockContext) AllVariableDeclarationPart() []IVariableDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationPartContext); ok {
			tst[i] = t.(IVariableDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) VariableDeclarationPart(i int) IVariableDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationPartContext)
}

func (s *InterfaceBlockContext) AllProcedureOrFunctionHeader() []IProcedureOrFunctionHeaderContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			len++
		}
	}

	tst := make([]IProcedureOrFunctionHeaderContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			tst[i] = t.(IProcedureOrFunctionHeaderContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) ProcedureOrFunctionHeader(i int) IProcedureOrFunctionHeaderContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderContext)
}

func (s *InterfaceBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceBlock(s)
	}
}

func (s *InterfaceBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceBlock(s)
	}
}

func (s *InterfaceBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceBlock() (localctx IInterfaceBlockContext) {
	localctx = NewInterfaceBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, pascalParserRULE_interfaceBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(402)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1152924254468178432) != 0) || ((int64((_la-77)) & ^0x3f) == 0 && ((int64(1)<<(_la-77))&3758096385) != 0) {
		p.SetState(400)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case pascalParserLABEL:
			{
				p.SetState(394)
				p.LabelDeclarationPart()
			}

		case pascalParserCONST:
			{
				p.SetState(395)
				p.ConstantDefinitionPart()
			}

		case pascalParserRESOURCESTRING:
			{
				p.SetState(396)
				p.ResourceDefinitionPart()
			}

		case pascalParserTYPE:
			{
				p.SetState(397)
				p.TypeDefinitionPart()
			}

		case pascalParserVAR:
			{
				p.SetState(398)
				p.VariableDeclarationPart()
			}

		case pascalParserFUNCTION, pascalParserPROCEDURE, pascalParserLBRACK, pascalParserCLASS, pascalParserCONSTRUCTOR, pascalParserDESTRUCTOR:
			{
				p.SetState(399)
				p.ProcedureOrFunctionHeader()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(404)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImplementationBlockContext is an interface to support dynamic dispatch.
type IImplementationBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLabelDeclarationPart() []ILabelDeclarationPartContext
	LabelDeclarationPart(i int) ILabelDeclarationPartContext
	AllConstantDefinitionPart() []IConstantDefinitionPartContext
	ConstantDefinitionPart(i int) IConstantDefinitionPartContext
	AllResourceDefinitionPart() []IResourceDefinitionPartContext
	ResourceDefinitionPart(i int) IResourceDefinitionPartContext
	AllTypeDefinitionPart() []ITypeDefinitionPartContext
	TypeDefinitionPart(i int) ITypeDefinitionPartContext
	AllVariableDeclarationPart() []IVariableDeclarationPartContext
	VariableDeclarationPart(i int) IVariableDeclarationPartContext
	AllProcedureOrFunctionDeclaration() []IProcedureOrFunctionDeclarationContext
	ProcedureOrFunctionDeclaration(i int) IProcedureOrFunctionDeclarationContext
	AllProcedureOrFunctionHeader() []IProcedureOrFunctionHeaderContext
	ProcedureOrFunctionHeader(i int) IProcedureOrFunctionHeaderContext
	AllFORWARD() []antlr.TerminalNode
	FORWARD(i int) antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AllClassOperatorDeclaration() []IClassOperatorDeclarationContext
	ClassOperatorDeclaration(i int) IClassOperatorDeclarationContext

	// IsImplementationBlockContext differentiates from other interfaces.
	IsImplementationBlockContext()
}

type ImplementationBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplementationBlockContext() *ImplementationBlockContext {
	var p = new(ImplementationBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_implementationBlock
	return p
}

func InitEmptyImplementationBlockContext(p *ImplementationBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_implementationBlock
}

func (*ImplementationBlockContext) IsImplementationBlockContext() {}

func NewImplementationBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplementationBlockContext {
	var p = new(ImplementationBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_implementationBlock

	return p
}

func (s *ImplementationBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplementationBlockContext) AllLabelDeclarationPart() []ILabelDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]ILabelDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelDeclarationPartContext); ok {
			tst[i] = t.(ILabelDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) LabelDeclarationPart(i int) ILabelDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelDeclarationPartContext)
}

func (s *ImplementationBlockContext) AllConstantDefinitionPart() []IConstantDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IConstantDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantDefinitionPartContext); ok {
			tst[i] = t.(IConstantDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) ConstantDefinitionPart(i int) IConstantDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *ImplementationBlockContext) AllResourceDefinitionPart() []IResourceDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResourceDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IResourceDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResourceDefinitionPartContext); ok {
			tst[i] = t.(IResourceDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) ResourceDefinitionPart(i int) IResourceDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceDefinitionPartContext)
}

func (s *ImplementationBlockContext) AllTypeDefinitionPart() []ITypeDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]ITypeDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeDefinitionPartContext); ok {
			tst[i] = t.(ITypeDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) TypeDefinitionPart(i int) ITypeDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionPartContext)
}

func (s *ImplementationBlockContext) AllVariableDeclarationPart() []IVariableDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationPartContext); ok {
			tst[i] = t.(IVariableDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) VariableDeclarationPart(i int) IVariableDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationPartContext)
}

func (s *ImplementationBlockContext) AllProcedureOrFunctionDeclaration() []IProcedureOrFunctionDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IProcedureOrFunctionDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			tst[i] = t.(IProcedureOrFunctionDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) ProcedureOrFunctionDeclaration(i int) IProcedureOrFunctionDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionDeclarationContext)
}

func (s *ImplementationBlockContext) AllProcedureOrFunctionHeader() []IProcedureOrFunctionHeaderContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			len++
		}
	}

	tst := make([]IProcedureOrFunctionHeaderContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			tst[i] = t.(IProcedureOrFunctionHeaderContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) ProcedureOrFunctionHeader(i int) IProcedureOrFunctionHeaderContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderContext)
}

func (s *ImplementationBlockContext) AllFORWARD() []antlr.TerminalNode {
	return s.GetTokens(pascalParserFORWARD)
}

func (s *ImplementationBlockContext) FORWARD(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserFORWARD, i)
}

func (s *ImplementationBlockContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ImplementationBlockContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ImplementationBlockContext) AllClassOperatorDeclaration() []IClassOperatorDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassOperatorDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassOperatorDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassOperatorDeclarationContext); ok {
			tst[i] = t.(IClassOperatorDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) ClassOperatorDeclaration(i int) IClassOperatorDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOperatorDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOperatorDeclarationContext)
}

func (s *ImplementationBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplementationBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplementationBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterImplementationBlock(s)
	}
}

func (s *ImplementationBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitImplementationBlock(s)
	}
}

func (s *ImplementationBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitImplementationBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ImplementationBlock() (localctx IImplementationBlockContext) {
	localctx = NewImplementationBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, pascalParserRULE_implementationBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(418)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1152924254468178432) != 0) || ((int64((_la-77)) & ^0x3f) == 0 && ((int64(1)<<(_la-77))&3758096385) != 0) {
		p.SetState(416)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(405)
				p.LabelDeclarationPart()
			}

		case 2:
			{
				p.SetState(406)
				p.ConstantDefinitionPart()
			}

		case 3:
			{
				p.SetState(407)
				p.ResourceDefinitionPart()
			}

		case 4:
			{
				p.SetState(408)
				p.TypeDefinitionPart()
			}

		case 5:
			{
				p.SetState(409)
				p.VariableDeclarationPart()
			}

		case 6:
			{
				p.SetState(410)
				p.ProcedureOrFunctionDeclaration()
			}

		case 7:
			{
				p.SetState(411)
				p.ProcedureOrFunctionHeader()
			}
			{
				p.SetState(412)
				p.Match(pascalParserFORWARD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(413)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 8:
			{
				p.SetState(415)
				p.ClassOperatorDeclaration()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(420)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLabelDeclarationPart() []ILabelDeclarationPartContext
	LabelDeclarationPart(i int) ILabelDeclarationPartContext
	AllConstantDefinitionPart() []IConstantDefinitionPartContext
	ConstantDefinitionPart(i int) IConstantDefinitionPartContext
	AllVariableDeclarationPart() []IVariableDeclarationPartContext
	VariableDeclarationPart(i int) IVariableDeclarationPartContext
	AllProcedureOrFunctionDeclaration() []IProcedureOrFunctionDeclarationContext
	ProcedureOrFunctionDeclaration(i int) IProcedureOrFunctionDeclarationContext
	AllClassOperatorDeclaration() []IClassOperatorDeclarationContext
	ClassOperatorDeclaration(i int) IClassOperatorDeclarationContext

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) AllLabelDeclarationPart() []ILabelDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]ILabelDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelDeclarationPartContext); ok {
			tst[i] = t.(ILabelDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) LabelDeclarationPart(i int) ILabelDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelDeclarationPartContext)
}

func (s *BlockContext) AllConstantDefinitionPart() []IConstantDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IConstantDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantDefinitionPartContext); ok {
			tst[i] = t.(IConstantDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) ConstantDefinitionPart(i int) IConstantDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *BlockContext) AllVariableDeclarationPart() []IVariableDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationPartContext); ok {
			tst[i] = t.(IVariableDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) VariableDeclarationPart(i int) IVariableDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationPartContext)
}

func (s *BlockContext) AllProcedureOrFunctionDeclaration() []IProcedureOrFunctionDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IProcedureOrFunctionDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			tst[i] = t.(IProcedureOrFunctionDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) ProcedureOrFunctionDeclaration(i int) IProcedureOrFunctionDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionDeclarationContext)
}

func (s *BlockContext) AllClassOperatorDeclaration() []IClassOperatorDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassOperatorDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassOperatorDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassOperatorDeclarationContext); ok {
			tst[i] = t.(IClassOperatorDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) ClassOperatorDeclaration(i int) IClassOperatorDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOperatorDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOperatorDeclarationContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (s *BlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, pascalParserRULE_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(428)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1152923704712364544) != 0) || ((int64((_la-77)) & ^0x3f) == 0 && ((int64(1)<<(_la-77))&1610612737) != 0) {
		p.SetState(426)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(421)
				p.LabelDeclarationPart()
			}

		case 2:
			{
				p.SetState(422)
				p.ConstantDefinitionPart()
			}

		case 3:
			{
				p.SetState(423)
				p.VariableDeclarationPart()
			}

		case 4:
			{
				p.SetState(424)
				p.ProcedureOrFunctionDeclaration()
			}

		case 5:
			{
				p.SetState(425)
				p.ClassOperatorDeclaration()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(430)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsesUnitsContext is an interface to support dynamic dispatch.
type IUsesUnitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USES() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	SEMI() antlr.TerminalNode

	// IsUsesUnitsContext differentiates from other interfaces.
	IsUsesUnitsContext()
}

type UsesUnitsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsesUnitsContext() *UsesUnitsContext {
	var p = new(UsesUnitsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_usesUnits
	return p
}

func InitEmptyUsesUnitsContext(p *UsesUnitsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_usesUnits
}

func (*UsesUnitsContext) IsUsesUnitsContext() {}

func NewUsesUnitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsesUnitsContext {
	var p = new(UsesUnitsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_usesUnits

	return p
}

func (s *UsesUnitsContext) GetParser() antlr.Parser { return s.parser }

func (s *UsesUnitsContext) USES() antlr.TerminalNode {
	return s.GetToken(pascalParserUSES, 0)
}

func (s *UsesUnitsContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *UsesUnitsContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *UsesUnitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsesUnitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsesUnitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUsesUnits(s)
	}
}

func (s *UsesUnitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUsesUnits(s)
	}
}

func (s *UsesUnitsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUsesUnits(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UsesUnits() (localctx IUsesUnitsContext) {
	localctx = NewUsesUnitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, pascalParserRULE_usesUnits)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(431)
		p.Match(pascalParserUSES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(432)
		p.IdentifierList()
	}
	{
		p.SetState(433)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelDeclarationPartContext is an interface to support dynamic dispatch.
type ILabelDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LABEL() antlr.TerminalNode
	AllLabel() []ILabelContext
	Label(i int) ILabelContext
	SEMI() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLabelDeclarationPartContext differentiates from other interfaces.
	IsLabelDeclarationPartContext()
}

type LabelDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelDeclarationPartContext() *LabelDeclarationPartContext {
	var p = new(LabelDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_labelDeclarationPart
	return p
}

func InitEmptyLabelDeclarationPartContext(p *LabelDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_labelDeclarationPart
}

func (*LabelDeclarationPartContext) IsLabelDeclarationPartContext() {}

func NewLabelDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelDeclarationPartContext {
	var p = new(LabelDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_labelDeclarationPart

	return p
}

func (s *LabelDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelDeclarationPartContext) LABEL() antlr.TerminalNode {
	return s.GetToken(pascalParserLABEL, 0)
}

func (s *LabelDeclarationPartContext) AllLabel() []ILabelContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelContext); ok {
			len++
		}
	}

	tst := make([]ILabelContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelContext); ok {
			tst[i] = t.(ILabelContext)
			i++
		}
	}

	return tst
}

func (s *LabelDeclarationPartContext) Label(i int) ILabelContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *LabelDeclarationPartContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *LabelDeclarationPartContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *LabelDeclarationPartContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *LabelDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterLabelDeclarationPart(s)
	}
}

func (s *LabelDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitLabelDeclarationPart(s)
	}
}

func (s *LabelDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitLabelDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) LabelDeclarationPart() (localctx ILabelDeclarationPartContext) {
	localctx = NewLabelDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, pascalParserRULE_labelDeclarationPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(435)
		p.Match(pascalParserLABEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(436)
		p.Label()
	}
	p.SetState(441)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(437)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(438)
			p.Label()
		}

		p.SetState(443)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(444)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelContext is an interface to support dynamic dispatch.
type ILabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedInteger() IUnsignedIntegerContext

	// IsLabelContext differentiates from other interfaces.
	IsLabelContext()
}

type LabelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelContext() *LabelContext {
	var p = new(LabelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_label
	return p
}

func InitEmptyLabelContext(p *LabelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_label
}

func (*LabelContext) IsLabelContext() {}

func NewLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelContext {
	var p = new(LabelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_label

	return p
}

func (s *LabelContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelContext) UnsignedInteger() IUnsignedIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerContext)
}

func (s *LabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterLabel(s)
	}
}

func (s *LabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitLabel(s)
	}
}

func (s *LabelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitLabel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Label() (localctx ILabelContext) {
	localctx = NewLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, pascalParserRULE_label)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(446)
		p.UnsignedInteger()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantDefinitionPartContext is an interface to support dynamic dispatch.
type IConstantDefinitionPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONST() antlr.TerminalNode
	AllConstantDefinition() []IConstantDefinitionContext
	ConstantDefinition(i int) IConstantDefinitionContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsConstantDefinitionPartContext differentiates from other interfaces.
	IsConstantDefinitionPartContext()
}

type ConstantDefinitionPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantDefinitionPartContext() *ConstantDefinitionPartContext {
	var p = new(ConstantDefinitionPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantDefinitionPart
	return p
}

func InitEmptyConstantDefinitionPartContext(p *ConstantDefinitionPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantDefinitionPart
}

func (*ConstantDefinitionPartContext) IsConstantDefinitionPartContext() {}

func NewConstantDefinitionPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantDefinitionPartContext {
	var p = new(ConstantDefinitionPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constantDefinitionPart

	return p
}

func (s *ConstantDefinitionPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantDefinitionPartContext) CONST() antlr.TerminalNode {
	return s.GetToken(pascalParserCONST, 0)
}

func (s *ConstantDefinitionPartContext) AllConstantDefinition() []IConstantDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IConstantDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantDefinitionContext); ok {
			tst[i] = t.(IConstantDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *ConstantDefinitionPartContext) ConstantDefinition(i int) IConstantDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionContext)
}

func (s *ConstantDefinitionPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ConstantDefinitionPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ConstantDefinitionPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantDefinitionPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantDefinitionPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstantDefinitionPart(s)
	}
}

func (s *ConstantDefinitionPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstantDefinitionPart(s)
	}
}

func (s *ConstantDefinitionPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstantDefinitionPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConstantDefinitionPart() (localctx IConstantDefinitionPartContext) {
	localctx = NewConstantDefinitionPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, pascalParserRULE_constantDefinitionPart)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(448)
		p.Match(pascalParserCONST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(452)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(449)
				p.ConstantDefinition()
			}
			{
				p.SetState(450)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(454)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantDefinitionContext is an interface to support dynamic dispatch.
type IConstantDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQUAL() antlr.TerminalNode
	Constant() IConstantContext
	COLON() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	ArrayType() IArrayTypeContext

	// IsConstantDefinitionContext differentiates from other interfaces.
	IsConstantDefinitionContext()
}

type ConstantDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantDefinitionContext() *ConstantDefinitionContext {
	var p = new(ConstantDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantDefinition
	return p
}

func InitEmptyConstantDefinitionContext(p *ConstantDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantDefinition
}

func (*ConstantDefinitionContext) IsConstantDefinitionContext() {}

func NewConstantDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantDefinitionContext {
	var p = new(ConstantDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constantDefinition

	return p
}

func (s *ConstantDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConstantDefinitionContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *ConstantDefinitionContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantDefinitionContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *ConstantDefinitionContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ConstantDefinitionContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *ConstantDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstantDefinition(s)
	}
}

func (s *ConstantDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstantDefinition(s)
	}
}

func (s *ConstantDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstantDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConstantDefinition() (localctx IConstantDefinitionContext) {
	localctx = NewConstantDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, pascalParserRULE_constantDefinition)
	var _la int

	p.SetState(470)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(456)
			p.Identifier()
		}
		p.SetState(459)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserCOLON {
			{
				p.SetState(457)
				p.Match(pascalParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(458)
				p.TypeIdentifier()
			}

		}
		{
			p.SetState(461)
			p.Match(pascalParserEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(462)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(464)
			p.Identifier()
		}
		{
			p.SetState(465)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(466)
			p.ArrayType()
		}
		{
			p.SetState(467)
			p.Match(pascalParserEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(468)
			p.Constant()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantChrContext is an interface to support dynamic dispatch.
type IConstantChrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHR() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	UnsignedInteger() IUnsignedIntegerContext
	RPAREN() antlr.TerminalNode

	// IsConstantChrContext differentiates from other interfaces.
	IsConstantChrContext()
}

type ConstantChrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantChrContext() *ConstantChrContext {
	var p = new(ConstantChrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantChr
	return p
}

func InitEmptyConstantChrContext(p *ConstantChrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantChr
}

func (*ConstantChrContext) IsConstantChrContext() {}

func NewConstantChrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantChrContext {
	var p = new(ConstantChrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constantChr

	return p
}

func (s *ConstantChrContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantChrContext) CHR() antlr.TerminalNode {
	return s.GetToken(pascalParserCHR, 0)
}

func (s *ConstantChrContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ConstantChrContext) UnsignedInteger() IUnsignedIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerContext)
}

func (s *ConstantChrContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ConstantChrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantChrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantChrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstantChr(s)
	}
}

func (s *ConstantChrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstantChr(s)
	}
}

func (s *ConstantChrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstantChr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConstantChr() (localctx IConstantChrContext) {
	localctx = NewConstantChrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, pascalParserRULE_constantChr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(472)
		p.Match(pascalParserCHR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(473)
		p.Match(pascalParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(474)
		p.UnsignedInteger()
	}
	{
		p.SetState(475)
		p.Match(pascalParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHexConstantContext is an interface to support dynamic dispatch.
type IHexConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HEX_LITERAL() antlr.TerminalNode

	// IsHexConstantContext differentiates from other interfaces.
	IsHexConstantContext()
}

type HexConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexConstantContext() *HexConstantContext {
	var p = new(HexConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_hexConstant
	return p
}

func InitEmptyHexConstantContext(p *HexConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_hexConstant
}

func (*HexConstantContext) IsHexConstantContext() {}

func NewHexConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexConstantContext {
	var p = new(HexConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_hexConstant

	return p
}

func (s *HexConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *HexConstantContext) HEX_LITERAL() antlr.TerminalNode {
	return s.GetToken(pascalParserHEX_LITERAL, 0)
}

func (s *HexConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterHexConstant(s)
	}
}

func (s *HexConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitHexConstant(s)
	}
}

func (s *HexConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitHexConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) HexConstant() (localctx IHexConstantContext) {
	localctx = NewHexConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, pascalParserRULE_hexConstant)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(477)
		p.Match(pascalParserHEX_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedNumber() IUnsignedNumberContext
	Sign() ISignContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	String_() IStringContext
	ConstantChr() IConstantChrContext
	ScalarType() IScalarTypeContext
	AllArrayConstant() []IArrayConstantContext
	ArrayConstant(i int) IArrayConstantContext
	AllPLUS() []antlr.TerminalNode
	PLUS(i int) antlr.TerminalNode

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constant
	return p
}

func InitEmptyConstantContext(p *ConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constant
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) UnsignedNumber() IUnsignedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedNumberContext)
}

func (s *ConstantContext) Sign() ISignContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignContext)
}

func (s *ConstantContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ConstantContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConstantContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ConstantContext) ConstantChr() IConstantChrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantChrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantChrContext)
}

func (s *ConstantContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ConstantContext) AllArrayConstant() []IArrayConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayConstantContext); ok {
			len++
		}
	}

	tst := make([]IArrayConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayConstantContext); ok {
			tst[i] = t.(IArrayConstantContext)
			i++
		}
	}

	return tst
}

func (s *ConstantContext) ArrayConstant(i int) IArrayConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayConstantContext)
}

func (s *ConstantContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPLUS)
}

func (s *ConstantContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPLUS, i)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstant(s)
	}
}

func (s *ConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, pascalParserRULE_constant)
	var _la int

	p.SetState(501)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(479)
			p.UnsignedNumber()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(480)
			p.Sign()
		}
		{
			p.SetState(481)
			p.UnsignedNumber()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(483)
			p.Identifier()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(484)
			p.Sign()
		}
		{
			p.SetState(485)
			p.Identifier()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(487)
			p.String_()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(488)
			p.ConstantChr()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(489)
			p.ScalarType()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(490)
			p.ArrayConstant()
		}
		p.SetState(498)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == pascalParserPLUS {
			{
				p.SetState(491)
				p.Match(pascalParserPLUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(494)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case pascalParserLBRACK:
				{
					p.SetState(492)
					p.ArrayConstant()
				}

			case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
				{
					p.SetState(493)
					p.Identifier()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(500)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayConstantContext is an interface to support dynamic dispatch.
type IArrayConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	RBRACK() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsArrayConstantContext differentiates from other interfaces.
	IsArrayConstantContext()
}

type ArrayConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayConstantContext() *ArrayConstantContext {
	var p = new(ArrayConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_arrayConstant
	return p
}

func InitEmptyArrayConstantContext(p *ArrayConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_arrayConstant
}

func (*ArrayConstantContext) IsArrayConstantContext() {}

func NewArrayConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayConstantContext {
	var p = new(ArrayConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_arrayConstant

	return p
}

func (s *ArrayConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayConstantContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *ArrayConstantContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *ArrayConstantContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ArrayConstantContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *ArrayConstantContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ArrayConstantContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ArrayConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterArrayConstant(s)
	}
}

func (s *ArrayConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitArrayConstant(s)
	}
}

func (s *ArrayConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitArrayConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ArrayConstant() (localctx IArrayConstantContext) {
	localctx = NewArrayConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, pascalParserRULE_arrayConstant)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(503)
		p.Match(pascalParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(504)
		p.Constant()
	}
	p.SetState(509)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(505)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(506)
			p.Constant()
		}

		p.SetState(511)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(512)
		p.Match(pascalParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedNumberContext is an interface to support dynamic dispatch.
type IUnsignedNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedInteger() IUnsignedIntegerContext
	UnsignedReal() IUnsignedRealContext

	// IsUnsignedNumberContext differentiates from other interfaces.
	IsUnsignedNumberContext()
}

type UnsignedNumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedNumberContext() *UnsignedNumberContext {
	var p = new(UnsignedNumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedNumber
	return p
}

func InitEmptyUnsignedNumberContext(p *UnsignedNumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedNumber
}

func (*UnsignedNumberContext) IsUnsignedNumberContext() {}

func NewUnsignedNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedNumberContext {
	var p = new(UnsignedNumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unsignedNumber

	return p
}

func (s *UnsignedNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedNumberContext) UnsignedInteger() IUnsignedIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerContext)
}

func (s *UnsignedNumberContext) UnsignedReal() IUnsignedRealContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedRealContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedRealContext)
}

func (s *UnsignedNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnsignedNumber(s)
	}
}

func (s *UnsignedNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnsignedNumber(s)
	}
}

func (s *UnsignedNumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnsignedNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnsignedNumber() (localctx IUnsignedNumberContext) {
	localctx = NewUnsignedNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, pascalParserRULE_unsignedNumber)
	p.SetState(516)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserNUM_INT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(514)
			p.UnsignedInteger()
		}

	case pascalParserNUM_REAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(515)
			p.UnsignedReal()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedIntegerContext is an interface to support dynamic dispatch.
type IUnsignedIntegerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUM_INT() antlr.TerminalNode

	// IsUnsignedIntegerContext differentiates from other interfaces.
	IsUnsignedIntegerContext()
}

type UnsignedIntegerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedIntegerContext() *UnsignedIntegerContext {
	var p = new(UnsignedIntegerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedInteger
	return p
}

func InitEmptyUnsignedIntegerContext(p *UnsignedIntegerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedInteger
}

func (*UnsignedIntegerContext) IsUnsignedIntegerContext() {}

func NewUnsignedIntegerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedIntegerContext {
	var p = new(UnsignedIntegerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unsignedInteger

	return p
}

func (s *UnsignedIntegerContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedIntegerContext) NUM_INT() antlr.TerminalNode {
	return s.GetToken(pascalParserNUM_INT, 0)
}

func (s *UnsignedIntegerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedIntegerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedIntegerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnsignedInteger(s)
	}
}

func (s *UnsignedIntegerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnsignedInteger(s)
	}
}

func (s *UnsignedIntegerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnsignedInteger(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnsignedInteger() (localctx IUnsignedIntegerContext) {
	localctx = NewUnsignedIntegerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, pascalParserRULE_unsignedInteger)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(518)
		p.Match(pascalParserNUM_INT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedRealContext is an interface to support dynamic dispatch.
type IUnsignedRealContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUM_REAL() antlr.TerminalNode

	// IsUnsignedRealContext differentiates from other interfaces.
	IsUnsignedRealContext()
}

type UnsignedRealContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedRealContext() *UnsignedRealContext {
	var p = new(UnsignedRealContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedReal
	return p
}

func InitEmptyUnsignedRealContext(p *UnsignedRealContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedReal
}

func (*UnsignedRealContext) IsUnsignedRealContext() {}

func NewUnsignedRealContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedRealContext {
	var p = new(UnsignedRealContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unsignedReal

	return p
}

func (s *UnsignedRealContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedRealContext) NUM_REAL() antlr.TerminalNode {
	return s.GetToken(pascalParserNUM_REAL, 0)
}

func (s *UnsignedRealContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedRealContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedRealContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnsignedReal(s)
	}
}

func (s *UnsignedRealContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnsignedReal(s)
	}
}

func (s *UnsignedRealContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnsignedReal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnsignedReal() (localctx IUnsignedRealContext) {
	localctx = NewUnsignedRealContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, pascalParserRULE_unsignedReal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(520)
		p.Match(pascalParserNUM_REAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignContext is an interface to support dynamic dispatch.
type ISignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsSignContext differentiates from other interfaces.
	IsSignContext()
}

type SignContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignContext() *SignContext {
	var p = new(SignContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_sign
	return p
}

func InitEmptySignContext(p *SignContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_sign
}

func (*SignContext) IsSignContext() {}

func NewSignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignContext {
	var p = new(SignContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_sign

	return p
}

func (s *SignContext) GetParser() antlr.Parser { return s.parser }

func (s *SignContext) PLUS() antlr.TerminalNode {
	return s.GetToken(pascalParserPLUS, 0)
}

func (s *SignContext) MINUS() antlr.TerminalNode {
	return s.GetToken(pascalParserMINUS, 0)
}

func (s *SignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSign(s)
	}
}

func (s *SignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSign(s)
	}
}

func (s *SignContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSign(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Sign() (localctx ISignContext) {
	localctx = NewSignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, pascalParserRULE_sign)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(522)
		_la = p.GetTokenStream().LA(1)

		if !(_la == pascalParserPLUS || _la == pascalParserMINUS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_Context is an interface to support dynamic dispatch.
type IBool_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBool_Context differentiates from other interfaces.
	IsBool_Context()
}

type Bool_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_Context() *Bool_Context {
	var p = new(Bool_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_bool_
	return p
}

func InitEmptyBool_Context(p *Bool_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_bool_
}

func (*Bool_Context) IsBool_Context() {}

func NewBool_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_Context {
	var p = new(Bool_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_bool_

	return p
}

func (s *Bool_Context) GetParser() antlr.Parser { return s.parser }

func (s *Bool_Context) TRUE() antlr.TerminalNode {
	return s.GetToken(pascalParserTRUE, 0)
}

func (s *Bool_Context) FALSE() antlr.TerminalNode {
	return s.GetToken(pascalParserFALSE, 0)
}

func (s *Bool_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterBool_(s)
	}
}

func (s *Bool_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitBool_(s)
	}
}

func (s *Bool_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitBool_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Bool_() (localctx IBool_Context) {
	localctx = NewBool_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, pascalParserRULE_bool_)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(524)
		_la = p.GetTokenStream().LA(1)

		if !(_la == pascalParserTRUE || _la == pascalParserFALSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringContext is an interface to support dynamic dispatch.
type IStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	AllSTRING_CROSSHATCH_LITERAL() []antlr.TerminalNode
	STRING_CROSSHATCH_LITERAL(i int) antlr.TerminalNode

	// IsStringContext differentiates from other interfaces.
	IsStringContext()
}

type StringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringContext() *StringContext {
	var p = new(StringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_string
	return p
}

func InitEmptyStringContext(p *StringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_string
}

func (*StringContext) IsStringContext() {}

func NewStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringContext {
	var p = new(StringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_string

	return p
}

func (s *StringContext) GetParser() antlr.Parser { return s.parser }

func (s *StringContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTRING_LITERAL)
}

func (s *StringContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTRING_LITERAL, i)
}

func (s *StringContext) AllSTRING_CROSSHATCH_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTRING_CROSSHATCH_LITERAL)
}

func (s *StringContext) STRING_CROSSHATCH_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTRING_CROSSHATCH_LITERAL, i)
}

func (s *StringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterString(s)
	}
}

func (s *StringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitString(s)
	}
}

func (s *StringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) String_() (localctx IStringContext) {
	localctx = NewStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, pascalParserRULE_string)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(527)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(526)
				_la = p.GetTokenStream().LA(1)

				if !(_la == pascalParserSTRING_LITERAL || _la == pascalParserSTRING_CROSSHATCH_LITERAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(529)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceDefinitionPartContext is an interface to support dynamic dispatch.
type IResourceDefinitionPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESOURCESTRING() antlr.TerminalNode
	AllResourceDefinition() []IResourceDefinitionContext
	ResourceDefinition(i int) IResourceDefinitionContext

	// IsResourceDefinitionPartContext differentiates from other interfaces.
	IsResourceDefinitionPartContext()
}

type ResourceDefinitionPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceDefinitionPartContext() *ResourceDefinitionPartContext {
	var p = new(ResourceDefinitionPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resourceDefinitionPart
	return p
}

func InitEmptyResourceDefinitionPartContext(p *ResourceDefinitionPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resourceDefinitionPart
}

func (*ResourceDefinitionPartContext) IsResourceDefinitionPartContext() {}

func NewResourceDefinitionPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceDefinitionPartContext {
	var p = new(ResourceDefinitionPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_resourceDefinitionPart

	return p
}

func (s *ResourceDefinitionPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceDefinitionPartContext) RESOURCESTRING() antlr.TerminalNode {
	return s.GetToken(pascalParserRESOURCESTRING, 0)
}

func (s *ResourceDefinitionPartContext) AllResourceDefinition() []IResourceDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResourceDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IResourceDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResourceDefinitionContext); ok {
			tst[i] = t.(IResourceDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *ResourceDefinitionPartContext) ResourceDefinition(i int) IResourceDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceDefinitionContext)
}

func (s *ResourceDefinitionPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceDefinitionPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceDefinitionPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterResourceDefinitionPart(s)
	}
}

func (s *ResourceDefinitionPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitResourceDefinitionPart(s)
	}
}

func (s *ResourceDefinitionPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitResourceDefinitionPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ResourceDefinitionPart() (localctx IResourceDefinitionPartContext) {
	localctx = NewResourceDefinitionPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, pascalParserRULE_resourceDefinitionPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(531)
		p.Match(pascalParserRESOURCESTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(533)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64((_la-85)) & ^0x3f) == 0 && ((int64(1)<<(_la-85))&137438953483) != 0) {
		{
			p.SetState(532)
			p.ResourceDefinition()
		}

		p.SetState(535)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceDefinitionContext is an interface to support dynamic dispatch.
type IResourceDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQUAL() antlr.TerminalNode
	String_() IStringContext
	SEMI() antlr.TerminalNode

	// IsResourceDefinitionContext differentiates from other interfaces.
	IsResourceDefinitionContext()
}

type ResourceDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceDefinitionContext() *ResourceDefinitionContext {
	var p = new(ResourceDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resourceDefinition
	return p
}

func InitEmptyResourceDefinitionContext(p *ResourceDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resourceDefinition
}

func (*ResourceDefinitionContext) IsResourceDefinitionContext() {}

func NewResourceDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceDefinitionContext {
	var p = new(ResourceDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_resourceDefinition

	return p
}

func (s *ResourceDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ResourceDefinitionContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *ResourceDefinitionContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ResourceDefinitionContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ResourceDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterResourceDefinition(s)
	}
}

func (s *ResourceDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitResourceDefinition(s)
	}
}

func (s *ResourceDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitResourceDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ResourceDefinition() (localctx IResourceDefinitionContext) {
	localctx = NewResourceDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, pascalParserRULE_resourceDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(537)
		p.Identifier()
	}
	{
		p.SetState(538)
		p.Match(pascalParserEQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(539)
		p.String_()
	}
	{
		p.SetState(540)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDefinitionPartContext is an interface to support dynamic dispatch.
type ITypeDefinitionPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE() antlr.TerminalNode
	AllTypeDefinition() []ITypeDefinitionContext
	TypeDefinition(i int) ITypeDefinitionContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsTypeDefinitionPartContext differentiates from other interfaces.
	IsTypeDefinitionPartContext()
}

type TypeDefinitionPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDefinitionPartContext() *TypeDefinitionPartContext {
	var p = new(TypeDefinitionPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeDefinitionPart
	return p
}

func InitEmptyTypeDefinitionPartContext(p *TypeDefinitionPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeDefinitionPart
}

func (*TypeDefinitionPartContext) IsTypeDefinitionPartContext() {}

func NewTypeDefinitionPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDefinitionPartContext {
	var p = new(TypeDefinitionPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typeDefinitionPart

	return p
}

func (s *TypeDefinitionPartContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDefinitionPartContext) TYPE() antlr.TerminalNode {
	return s.GetToken(pascalParserTYPE, 0)
}

func (s *TypeDefinitionPartContext) AllTypeDefinition() []ITypeDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ITypeDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeDefinitionContext); ok {
			tst[i] = t.(ITypeDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *TypeDefinitionPartContext) TypeDefinition(i int) ITypeDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionContext)
}

func (s *TypeDefinitionPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *TypeDefinitionPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *TypeDefinitionPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDefinitionPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDefinitionPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypeDefinitionPart(s)
	}
}

func (s *TypeDefinitionPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypeDefinitionPart(s)
	}
}

func (s *TypeDefinitionPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypeDefinitionPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypeDefinitionPart() (localctx ITypeDefinitionPartContext) {
	localctx = NewTypeDefinitionPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, pascalParserRULE_typeDefinitionPart)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(542)
		p.Match(pascalParserTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(546)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(543)
				p.TypeDefinition()
			}
			{
				p.SetState(544)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(548)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDefinitionContext is an interface to support dynamic dispatch.
type ITypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQUAL() antlr.TerminalNode
	Type_() IType_Context
	FunctionType() IFunctionTypeContext
	ProcedureType() IProcedureTypeContext
	ForwardClassType() IForwardClassTypeContext
	ForwardInterfaceType() IForwardInterfaceTypeContext
	AttributeSection() IAttributeSectionContext

	// IsTypeDefinitionContext differentiates from other interfaces.
	IsTypeDefinitionContext()
}

type TypeDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDefinitionContext() *TypeDefinitionContext {
	var p = new(TypeDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeDefinition
	return p
}

func InitEmptyTypeDefinitionContext(p *TypeDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeDefinition
}

func (*TypeDefinitionContext) IsTypeDefinitionContext() {}

func NewTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDefinitionContext {
	var p = new(TypeDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typeDefinition

	return p
}

func (s *TypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeDefinitionContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *TypeDefinitionContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeDefinitionContext) FunctionType() IFunctionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *TypeDefinitionContext) ProcedureType() IProcedureTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureTypeContext)
}

func (s *TypeDefinitionContext) ForwardClassType() IForwardClassTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForwardClassTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForwardClassTypeContext)
}

func (s *TypeDefinitionContext) ForwardInterfaceType() IForwardInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForwardInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForwardInterfaceTypeContext)
}

func (s *TypeDefinitionContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *TypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypeDefinition(s)
	}
}

func (s *TypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypeDefinition(s)
	}
}

func (s *TypeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypeDefinition() (localctx ITypeDefinitionContext) {
	localctx = NewTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, pascalParserRULE_typeDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(551)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLBRACK {
		{
			p.SetState(550)
			p.AttributeSection()
		}

	}
	{
		p.SetState(553)
		p.Identifier()
	}
	{
		p.SetState(554)
		p.Match(pascalParserEQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(560)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(555)
			p.Type_()
		}

	case 2:
		{
			p.SetState(556)
			p.FunctionType()
		}

	case 3:
		{
			p.SetState(557)
			p.ProcedureType()
		}

	case 4:
		{
			p.SetState(558)
			p.ForwardClassType()
		}

	case 5:
		{
			p.SetState(559)
			p.ForwardInterfaceType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTypeContext is an interface to support dynamic dispatch.
type IFunctionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNCTION() antlr.TerminalNode
	COLON() antlr.TerminalNode
	ResultType() IResultTypeContext
	ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext
	FormalParameterList() IFormalParameterListContext
	OF() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	REFERENCE() antlr.TerminalNode
	TO() antlr.TerminalNode

	// IsFunctionTypeContext differentiates from other interfaces.
	IsFunctionTypeContext()
}

type FunctionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeContext() *FunctionTypeContext {
	var p = new(FunctionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionType
	return p
}

func InitEmptyFunctionTypeContext(p *FunctionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionType
}

func (*FunctionTypeContext) IsFunctionTypeContext() {}

func NewFunctionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeContext {
	var p = new(FunctionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_functionType

	return p
}

func (s *FunctionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(pascalParserFUNCTION, 0)
}

func (s *FunctionTypeContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *FunctionTypeContext) ResultType() IResultTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultTypeContext)
}

func (s *FunctionTypeContext) ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderModifiersContext)
}

func (s *FunctionTypeContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *FunctionTypeContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(pascalParserOBJECT, 0)
}

func (s *FunctionTypeContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(pascalParserREFERENCE, 0)
}

func (s *FunctionTypeContext) TO() antlr.TerminalNode {
	return s.GetToken(pascalParserTO, 0)
}

func (s *FunctionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFunctionType(s)
	}
}

func (s *FunctionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFunctionType(s)
	}
}

func (s *FunctionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFunctionType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FunctionType() (localctx IFunctionTypeContext) {
	localctx = NewFunctionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, pascalParserRULE_functionType)
	var _la int

	p.SetState(584)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserFUNCTION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(562)
			p.Match(pascalParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(564)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLPAREN {
			{
				p.SetState(563)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(566)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(567)
			p.ResultType()
		}
		p.SetState(570)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserOF {
			{
				p.SetState(568)
				p.Match(pascalParserOF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(569)
				p.Match(pascalParserOBJECT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(572)
			p.ProcedureOrFunctionHeaderModifiers()
		}

	case pascalParserREFERENCE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(574)
			p.Match(pascalParserREFERENCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(575)
			p.Match(pascalParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(576)
			p.Match(pascalParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(578)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLPAREN {
			{
				p.SetState(577)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(580)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(581)
			p.ResultType()
		}
		{
			p.SetState(582)
			p.ProcedureOrFunctionHeaderModifiers()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureTypeContext is an interface to support dynamic dispatch.
type IProcedureTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROCEDURE() antlr.TerminalNode
	ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext
	FormalParameterList() IFormalParameterListContext
	OF() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	REFERENCE() antlr.TerminalNode
	TO() antlr.TerminalNode

	// IsProcedureTypeContext differentiates from other interfaces.
	IsProcedureTypeContext()
}

type ProcedureTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureTypeContext() *ProcedureTypeContext {
	var p = new(ProcedureTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureType
	return p
}

func InitEmptyProcedureTypeContext(p *ProcedureTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureType
}

func (*ProcedureTypeContext) IsProcedureTypeContext() {}

func NewProcedureTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureTypeContext {
	var p = new(ProcedureTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureType

	return p
}

func (s *ProcedureTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureTypeContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(pascalParserPROCEDURE, 0)
}

func (s *ProcedureTypeContext) ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderModifiersContext)
}

func (s *ProcedureTypeContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ProcedureTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *ProcedureTypeContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(pascalParserOBJECT, 0)
}

func (s *ProcedureTypeContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(pascalParserREFERENCE, 0)
}

func (s *ProcedureTypeContext) TO() antlr.TerminalNode {
	return s.GetToken(pascalParserTO, 0)
}

func (s *ProcedureTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureType(s)
	}
}

func (s *ProcedureTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureType(s)
	}
}

func (s *ProcedureTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureType() (localctx IProcedureTypeContext) {
	localctx = NewProcedureTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, pascalParserRULE_procedureType)
	var _la int

	p.SetState(602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserPROCEDURE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(586)
			p.Match(pascalParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(588)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLPAREN {
			{
				p.SetState(587)
				p.FormalParameterList()
			}

		}
		p.SetState(592)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserOF {
			{
				p.SetState(590)
				p.Match(pascalParserOF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(591)
				p.Match(pascalParserOBJECT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(594)
			p.ProcedureOrFunctionHeaderModifiers()
		}

	case pascalParserREFERENCE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(595)
			p.Match(pascalParserREFERENCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(596)
			p.Match(pascalParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(597)
			p.Match(pascalParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(599)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLPAREN {
			{
				p.SetState(598)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(601)
			p.ProcedureOrFunctionHeaderModifiers()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForwardClassTypeContext is an interface to support dynamic dispatch.
type IForwardClassTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsForwardClassTypeContext differentiates from other interfaces.
	IsForwardClassTypeContext()
}

type ForwardClassTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForwardClassTypeContext() *ForwardClassTypeContext {
	var p = new(ForwardClassTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forwardClassType
	return p
}

func InitEmptyForwardClassTypeContext(p *ForwardClassTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forwardClassType
}

func (*ForwardClassTypeContext) IsForwardClassTypeContext() {}

func NewForwardClassTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForwardClassTypeContext {
	var p = new(ForwardClassTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_forwardClassType

	return p
}

func (s *ForwardClassTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ForwardClassTypeContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *ForwardClassTypeContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ForwardClassTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForwardClassTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForwardClassTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterForwardClassType(s)
	}
}

func (s *ForwardClassTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitForwardClassType(s)
	}
}

func (s *ForwardClassTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitForwardClassType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ForwardClassType() (localctx IForwardClassTypeContext) {
	localctx = NewForwardClassTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, pascalParserRULE_forwardClassType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(604)
		p.Match(pascalParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(605)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForwardInterfaceTypeContext is an interface to support dynamic dispatch.
type IForwardInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsForwardInterfaceTypeContext differentiates from other interfaces.
	IsForwardInterfaceTypeContext()
}

type ForwardInterfaceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForwardInterfaceTypeContext() *ForwardInterfaceTypeContext {
	var p = new(ForwardInterfaceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forwardInterfaceType
	return p
}

func InitEmptyForwardInterfaceTypeContext(p *ForwardInterfaceTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forwardInterfaceType
}

func (*ForwardInterfaceTypeContext) IsForwardInterfaceTypeContext() {}

func NewForwardInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForwardInterfaceTypeContext {
	var p = new(ForwardInterfaceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_forwardInterfaceType

	return p
}

func (s *ForwardInterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ForwardInterfaceTypeContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(pascalParserINTERFACE, 0)
}

func (s *ForwardInterfaceTypeContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ForwardInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForwardInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForwardInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterForwardInterfaceType(s)
	}
}

func (s *ForwardInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitForwardInterfaceType(s)
	}
}

func (s *ForwardInterfaceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitForwardInterfaceType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ForwardInterfaceType() (localctx IForwardInterfaceTypeContext) {
	localctx = NewForwardInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, pascalParserRULE_forwardInterfaceType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(607)
		p.Match(pascalParserINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(608)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassTypeContext is an interface to support dynamic dispatch.
type IClassTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	ClassImplicitPublishedDeclaration() IClassImplicitPublishedDeclarationContext
	END() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	ClassImplementsInterfaces() IClassImplementsInterfacesContext
	RPAREN() antlr.TerminalNode
	ABSTRACT() antlr.TerminalNode
	AllClassDeclaration() []IClassDeclarationContext
	ClassDeclaration(i int) IClassDeclarationContext

	// IsClassTypeContext differentiates from other interfaces.
	IsClassTypeContext()
}

type ClassTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassTypeContext() *ClassTypeContext {
	var p = new(ClassTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classType
	return p
}

func InitEmptyClassTypeContext(p *ClassTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classType
}

func (*ClassTypeContext) IsClassTypeContext() {}

func NewClassTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassTypeContext {
	var p = new(ClassTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classType

	return p
}

func (s *ClassTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassTypeContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *ClassTypeContext) ClassImplicitPublishedDeclaration() IClassImplicitPublishedDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassImplicitPublishedDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassImplicitPublishedDeclarationContext)
}

func (s *ClassTypeContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *ClassTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ClassTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassTypeContext) ClassImplementsInterfaces() IClassImplementsInterfacesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassImplementsInterfacesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassImplementsInterfacesContext)
}

func (s *ClassTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ClassTypeContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(pascalParserABSTRACT, 0)
}

func (s *ClassTypeContext) AllClassDeclaration() []IClassDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassDeclarationContext); ok {
			tst[i] = t.(IClassDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ClassTypeContext) ClassDeclaration(i int) IClassDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *ClassTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassType(s)
	}
}

func (s *ClassTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassType(s)
	}
}

func (s *ClassTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassType() (localctx IClassTypeContext) {
	localctx = NewClassTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, pascalParserRULE_classType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(610)
		p.Match(pascalParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(616)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(611)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(612)
			p.Identifier()
		}
		{
			p.SetState(613)
			p.ClassImplementsInterfaces()
		}
		{
			p.SetState(614)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(619)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(618)
			p.Match(pascalParserABSTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(621)
		p.ClassImplicitPublishedDeclaration()
	}
	p.SetState(625)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&31) != 0 {
		{
			p.SetState(622)
			p.ClassDeclaration()
		}

		p.SetState(627)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(628)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassImplementsInterfacesContext is an interface to support dynamic dispatch.
type IClassImplementsInterfacesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllTypeIdentifier() []ITypeIdentifierContext
	TypeIdentifier(i int) ITypeIdentifierContext

	// IsClassImplementsInterfacesContext differentiates from other interfaces.
	IsClassImplementsInterfacesContext()
}

type ClassImplementsInterfacesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassImplementsInterfacesContext() *ClassImplementsInterfacesContext {
	var p = new(ClassImplementsInterfacesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classImplementsInterfaces
	return p
}

func InitEmptyClassImplementsInterfacesContext(p *ClassImplementsInterfacesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classImplementsInterfaces
}

func (*ClassImplementsInterfacesContext) IsClassImplementsInterfacesContext() {}

func NewClassImplementsInterfacesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassImplementsInterfacesContext {
	var p = new(ClassImplementsInterfacesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classImplementsInterfaces

	return p
}

func (s *ClassImplementsInterfacesContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassImplementsInterfacesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ClassImplementsInterfacesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ClassImplementsInterfacesContext) AllTypeIdentifier() []ITypeIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			len++
		}
	}

	tst := make([]ITypeIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeIdentifierContext); ok {
			tst[i] = t.(ITypeIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ClassImplementsInterfacesContext) TypeIdentifier(i int) ITypeIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ClassImplementsInterfacesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassImplementsInterfacesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassImplementsInterfacesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassImplementsInterfaces(s)
	}
}

func (s *ClassImplementsInterfacesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassImplementsInterfaces(s)
	}
}

func (s *ClassImplementsInterfacesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassImplementsInterfaces(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassImplementsInterfaces() (localctx IClassImplementsInterfacesContext) {
	localctx = NewClassImplementsInterfacesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, pascalParserRULE_classImplementsInterfaces)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(634)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(630)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(631)
			p.TypeIdentifier()
		}

		p.SetState(636)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAccessSpecifierContext is an interface to support dynamic dispatch.
type IAccessSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRIVATE() antlr.TerminalNode
	STRICT() antlr.TerminalNode
	PROTECTED() antlr.TerminalNode
	PUBLIC() antlr.TerminalNode
	PUBLISHED() antlr.TerminalNode

	// IsAccessSpecifierContext differentiates from other interfaces.
	IsAccessSpecifierContext()
}

type AccessSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccessSpecifierContext() *AccessSpecifierContext {
	var p = new(AccessSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_accessSpecifier
	return p
}

func InitEmptyAccessSpecifierContext(p *AccessSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_accessSpecifier
}

func (*AccessSpecifierContext) IsAccessSpecifierContext() {}

func NewAccessSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccessSpecifierContext {
	var p = new(AccessSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_accessSpecifier

	return p
}

func (s *AccessSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AccessSpecifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(pascalParserPRIVATE, 0)
}

func (s *AccessSpecifierContext) STRICT() antlr.TerminalNode {
	return s.GetToken(pascalParserSTRICT, 0)
}

func (s *AccessSpecifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(pascalParserPROTECTED, 0)
}

func (s *AccessSpecifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLIC, 0)
}

func (s *AccessSpecifierContext) PUBLISHED() antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLISHED, 0)
}

func (s *AccessSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccessSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AccessSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAccessSpecifier(s)
	}
}

func (s *AccessSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAccessSpecifier(s)
	}
}

func (s *AccessSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAccessSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) AccessSpecifier() (localctx IAccessSpecifierContext) {
	localctx = NewAccessSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, pascalParserRULE_accessSpecifier)
	var _la int

	p.SetState(647)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(638)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserSTRICT {
			{
				p.SetState(637)
				p.Match(pascalParserSTRICT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(640)
			p.Match(pascalParserPRIVATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(642)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserSTRICT {
			{
				p.SetState(641)
				p.Match(pascalParserSTRICT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(644)
			p.Match(pascalParserPROTECTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(645)
			p.Match(pascalParserPUBLIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(646)
			p.Match(pascalParserPUBLISHED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AccessSpecifier() IAccessSpecifierContext
	AllClassDeclarationPart() []IClassDeclarationPartContext
	ClassDeclarationPart(i int) IClassDeclarationPartContext

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classDeclaration
	return p
}

func InitEmptyClassDeclarationContext(p *ClassDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classDeclaration
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) AccessSpecifier() IAccessSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessSpecifierContext)
}

func (s *ClassDeclarationContext) AllClassDeclarationPart() []IClassDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IClassDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassDeclarationPartContext); ok {
			tst[i] = t.(IClassDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ClassDeclarationContext) ClassDeclarationPart(i int) IClassDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationPartContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, pascalParserRULE_classDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(649)
		p.AccessSpecifier()
	}
	p.SetState(653)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-8193) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-253953) != 0) {
		{
			p.SetState(650)
			p.ClassDeclarationPart()
		}

		p.SetState(655)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassImplicitPublishedDeclarationContext is an interface to support dynamic dispatch.
type IClassImplicitPublishedDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllClassDeclarationPart() []IClassDeclarationPartContext
	ClassDeclarationPart(i int) IClassDeclarationPartContext

	// IsClassImplicitPublishedDeclarationContext differentiates from other interfaces.
	IsClassImplicitPublishedDeclarationContext()
}

type ClassImplicitPublishedDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassImplicitPublishedDeclarationContext() *ClassImplicitPublishedDeclarationContext {
	var p = new(ClassImplicitPublishedDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classImplicitPublishedDeclaration
	return p
}

func InitEmptyClassImplicitPublishedDeclarationContext(p *ClassImplicitPublishedDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classImplicitPublishedDeclaration
}

func (*ClassImplicitPublishedDeclarationContext) IsClassImplicitPublishedDeclarationContext() {}

func NewClassImplicitPublishedDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassImplicitPublishedDeclarationContext {
	var p = new(ClassImplicitPublishedDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classImplicitPublishedDeclaration

	return p
}

func (s *ClassImplicitPublishedDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassImplicitPublishedDeclarationContext) AllClassDeclarationPart() []IClassDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IClassDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassDeclarationPartContext); ok {
			tst[i] = t.(IClassDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ClassImplicitPublishedDeclarationContext) ClassDeclarationPart(i int) IClassDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationPartContext)
}

func (s *ClassImplicitPublishedDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassImplicitPublishedDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassImplicitPublishedDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassImplicitPublishedDeclaration(s)
	}
}

func (s *ClassImplicitPublishedDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassImplicitPublishedDeclaration(s)
	}
}

func (s *ClassImplicitPublishedDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassImplicitPublishedDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassImplicitPublishedDeclaration() (localctx IClassImplicitPublishedDeclarationContext) {
	localctx = NewClassImplicitPublishedDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, pascalParserRULE_classImplicitPublishedDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(659)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-8193) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-253953) != 0) {
		{
			p.SetState(656)
			p.ClassDeclarationPart()
		}

		p.SetState(661)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassDeclarationPartContext is an interface to support dynamic dispatch.
type IClassDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypedIdentifierList() ITypedIdentifierListContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AttributeSection() IAttributeSectionContext
	TypeDefinitionPart() ITypeDefinitionPartContext
	ConstantDefinitionPart() IConstantDefinitionPartContext
	FunctionHeader() IFunctionHeaderContext
	ProcedureHeader() IProcedureHeaderContext
	PropertyDeclaration() IPropertyDeclarationContext
	DEFAULT() antlr.TerminalNode
	ErrorClassDeclarationPart() IErrorClassDeclarationPartContext

	// IsClassDeclarationPartContext differentiates from other interfaces.
	IsClassDeclarationPartContext()
}

type ClassDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationPartContext() *ClassDeclarationPartContext {
	var p = new(ClassDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classDeclarationPart
	return p
}

func InitEmptyClassDeclarationPartContext(p *ClassDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classDeclarationPart
}

func (*ClassDeclarationPartContext) IsClassDeclarationPartContext() {}

func NewClassDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationPartContext {
	var p = new(ClassDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classDeclarationPart

	return p
}

func (s *ClassDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationPartContext) TypedIdentifierList() ITypedIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIdentifierListContext)
}

func (s *ClassDeclarationPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ClassDeclarationPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ClassDeclarationPartContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *ClassDeclarationPartContext) TypeDefinitionPart() ITypeDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionPartContext)
}

func (s *ClassDeclarationPartContext) ConstantDefinitionPart() IConstantDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *ClassDeclarationPartContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *ClassDeclarationPartContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *ClassDeclarationPartContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *ClassDeclarationPartContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *ClassDeclarationPartContext) ErrorClassDeclarationPart() IErrorClassDeclarationPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorClassDeclarationPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorClassDeclarationPartContext)
}

func (s *ClassDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassDeclarationPart(s)
	}
}

func (s *ClassDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassDeclarationPart(s)
	}
}

func (s *ClassDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassDeclarationPart() (localctx IClassDeclarationPartContext) {
	localctx = NewClassDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, pascalParserRULE_classDeclarationPart)
	var _la int

	p.SetState(681)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(663)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(662)
				p.AttributeSection()
			}

		}
		{
			p.SetState(665)
			p.TypedIdentifierList()
		}
		{
			p.SetState(666)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(668)
			p.TypeDefinitionPart()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(669)
			p.ConstantDefinitionPart()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(670)
			p.FunctionHeader()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(671)
			p.ProcedureHeader()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(672)
			p.PropertyDeclaration()
		}
		{
			p.SetState(673)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(676)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(674)
				p.Match(pascalParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(675)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(678)
			p.ErrorClassDeclarationPart()
		}
		{
			p.SetState(679)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceGuidConstContext is an interface to support dynamic dispatch.
type IInterfaceGuidConstContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GUID_LITERAL() antlr.TerminalNode

	// IsInterfaceGuidConstContext differentiates from other interfaces.
	IsInterfaceGuidConstContext()
}

type InterfaceGuidConstContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceGuidConstContext() *InterfaceGuidConstContext {
	var p = new(InterfaceGuidConstContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceGuidConst
	return p
}

func InitEmptyInterfaceGuidConstContext(p *InterfaceGuidConstContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceGuidConst
}

func (*InterfaceGuidConstContext) IsInterfaceGuidConstContext() {}

func NewInterfaceGuidConstContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceGuidConstContext {
	var p = new(InterfaceGuidConstContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceGuidConst

	return p
}

func (s *InterfaceGuidConstContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceGuidConstContext) GUID_LITERAL() antlr.TerminalNode {
	return s.GetToken(pascalParserGUID_LITERAL, 0)
}

func (s *InterfaceGuidConstContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceGuidConstContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceGuidConstContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceGuidConst(s)
	}
}

func (s *InterfaceGuidConstContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceGuidConst(s)
	}
}

func (s *InterfaceGuidConstContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceGuidConst(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceGuidConst() (localctx IInterfaceGuidConstContext) {
	localctx = NewInterfaceGuidConstContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, pascalParserRULE_interfaceGuidConst)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(683)
		p.Match(pascalParserGUID_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceTypeContext is an interface to support dynamic dispatch.
type IInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	InterfaceDeclaration() IInterfaceDeclarationContext
	END() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	RPAREN() antlr.TerminalNode
	GUID_LITERAL() antlr.TerminalNode

	// IsInterfaceTypeContext differentiates from other interfaces.
	IsInterfaceTypeContext()
}

type InterfaceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceTypeContext() *InterfaceTypeContext {
	var p = new(InterfaceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceType
	return p
}

func InitEmptyInterfaceTypeContext(p *InterfaceTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceType
}

func (*InterfaceTypeContext) IsInterfaceTypeContext() {}

func NewInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceTypeContext {
	var p = new(InterfaceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceType

	return p
}

func (s *InterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceTypeContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(pascalParserINTERFACE, 0)
}

func (s *InterfaceTypeContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *InterfaceTypeContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *InterfaceTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *InterfaceTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InterfaceTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *InterfaceTypeContext) GUID_LITERAL() antlr.TerminalNode {
	return s.GetToken(pascalParserGUID_LITERAL, 0)
}

func (s *InterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceType(s)
	}
}

func (s *InterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceType(s)
	}
}

func (s *InterfaceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceType() (localctx IInterfaceTypeContext) {
	localctx = NewInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, pascalParserRULE_interfaceType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(685)
		p.Match(pascalParserINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(690)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(686)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(687)
			p.Identifier()
		}
		{
			p.SetState(688)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(693)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(692)
			p.Match(pascalParserGUID_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(695)
		p.InterfaceDeclaration()
	}
	{
		p.SetState(696)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInterfaceDeclarationPart() []IInterfaceDeclarationPartContext
	InterfaceDeclarationPart(i int) IInterfaceDeclarationPartContext

	// IsInterfaceDeclarationContext differentiates from other interfaces.
	IsInterfaceDeclarationContext()
}

type InterfaceDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclarationContext() *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceDeclaration
	return p
}

func InitEmptyInterfaceDeclarationContext(p *InterfaceDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceDeclaration
}

func (*InterfaceDeclarationContext) IsInterfaceDeclarationContext() {}

func NewInterfaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceDeclaration

	return p
}

func (s *InterfaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclarationContext) AllInterfaceDeclarationPart() []IInterfaceDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceDeclarationPartContext); ok {
			tst[i] = t.(IInterfaceDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceDeclarationContext) InterfaceDeclarationPart(i int) IInterfaceDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationPartContext)
}

func (s *InterfaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceDeclaration(s)
	}
}

func (s *InterfaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceDeclaration(s)
	}
}

func (s *InterfaceDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceDeclaration() (localctx IInterfaceDeclarationContext) {
	localctx = NewInterfaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, pascalParserRULE_interfaceDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(701)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-8193) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-1) != 0) {
		{
			p.SetState(698)
			p.InterfaceDeclarationPart()
		}

		p.SetState(703)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceDeclarationPartContext is an interface to support dynamic dispatch.
type IInterfaceDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionHeader() IFunctionHeaderContext
	ProcedureHeader() IProcedureHeaderContext
	PropertyDeclaration() IPropertyDeclarationContext
	SEMI() antlr.TerminalNode
	ErrorInterfaceDeclarationPart() IErrorInterfaceDeclarationPartContext

	// IsInterfaceDeclarationPartContext differentiates from other interfaces.
	IsInterfaceDeclarationPartContext()
}

type InterfaceDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclarationPartContext() *InterfaceDeclarationPartContext {
	var p = new(InterfaceDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceDeclarationPart
	return p
}

func InitEmptyInterfaceDeclarationPartContext(p *InterfaceDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceDeclarationPart
}

func (*InterfaceDeclarationPartContext) IsInterfaceDeclarationPartContext() {}

func NewInterfaceDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclarationPartContext {
	var p = new(InterfaceDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceDeclarationPart

	return p
}

func (s *InterfaceDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclarationPartContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *InterfaceDeclarationPartContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *InterfaceDeclarationPartContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *InterfaceDeclarationPartContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *InterfaceDeclarationPartContext) ErrorInterfaceDeclarationPart() IErrorInterfaceDeclarationPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorInterfaceDeclarationPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorInterfaceDeclarationPartContext)
}

func (s *InterfaceDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceDeclarationPart(s)
	}
}

func (s *InterfaceDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceDeclarationPart(s)
	}
}

func (s *InterfaceDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceDeclarationPart() (localctx IInterfaceDeclarationPartContext) {
	localctx = NewInterfaceDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, pascalParserRULE_interfaceDeclarationPart)
	p.SetState(712)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(704)
			p.FunctionHeader()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(705)
			p.ProcedureHeader()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(706)
			p.PropertyDeclaration()
		}
		{
			p.SetState(707)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(709)
			p.ErrorInterfaceDeclarationPart()
		}
		{
			p.SetState(710)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorInterfaceDeclarationPartContext is an interface to support dynamic dispatch.
type IErrorInterfaceDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEND() []antlr.TerminalNode
	END(i int) antlr.TerminalNode

	// IsErrorInterfaceDeclarationPartContext differentiates from other interfaces.
	IsErrorInterfaceDeclarationPartContext()
}

type ErrorInterfaceDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorInterfaceDeclarationPartContext() *ErrorInterfaceDeclarationPartContext {
	var p = new(ErrorInterfaceDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorInterfaceDeclarationPart
	return p
}

func InitEmptyErrorInterfaceDeclarationPartContext(p *ErrorInterfaceDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorInterfaceDeclarationPart
}

func (*ErrorInterfaceDeclarationPartContext) IsErrorInterfaceDeclarationPartContext() {}

func NewErrorInterfaceDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorInterfaceDeclarationPartContext {
	var p = new(ErrorInterfaceDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_errorInterfaceDeclarationPart

	return p
}

func (s *ErrorInterfaceDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorInterfaceDeclarationPartContext) AllEND() []antlr.TerminalNode {
	return s.GetTokens(pascalParserEND)
}

func (s *ErrorInterfaceDeclarationPartContext) END(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserEND, i)
}

func (s *ErrorInterfaceDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorInterfaceDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorInterfaceDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterErrorInterfaceDeclarationPart(s)
	}
}

func (s *ErrorInterfaceDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitErrorInterfaceDeclarationPart(s)
	}
}

func (s *ErrorInterfaceDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitErrorInterfaceDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ErrorInterfaceDeclarationPart() (localctx IErrorInterfaceDeclarationPartContext) {
	localctx = NewErrorInterfaceDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, pascalParserRULE_errorInterfaceDeclarationPart)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(715)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(714)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || _la == pascalParserEND {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(717)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorClassDeclarationPartContext is an interface to support dynamic dispatch.
type IErrorClassDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRICT() []antlr.TerminalNode
	STRICT(i int) antlr.TerminalNode
	AllPRIVATE() []antlr.TerminalNode
	PRIVATE(i int) antlr.TerminalNode
	AllPROTECTED() []antlr.TerminalNode
	PROTECTED(i int) antlr.TerminalNode
	AllPUBLIC() []antlr.TerminalNode
	PUBLIC(i int) antlr.TerminalNode
	AllPUBLISHED() []antlr.TerminalNode
	PUBLISHED(i int) antlr.TerminalNode
	AllEND() []antlr.TerminalNode
	END(i int) antlr.TerminalNode

	// IsErrorClassDeclarationPartContext differentiates from other interfaces.
	IsErrorClassDeclarationPartContext()
}

type ErrorClassDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorClassDeclarationPartContext() *ErrorClassDeclarationPartContext {
	var p = new(ErrorClassDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorClassDeclarationPart
	return p
}

func InitEmptyErrorClassDeclarationPartContext(p *ErrorClassDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorClassDeclarationPart
}

func (*ErrorClassDeclarationPartContext) IsErrorClassDeclarationPartContext() {}

func NewErrorClassDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorClassDeclarationPartContext {
	var p = new(ErrorClassDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_errorClassDeclarationPart

	return p
}

func (s *ErrorClassDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorClassDeclarationPartContext) AllSTRICT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTRICT)
}

func (s *ErrorClassDeclarationPartContext) STRICT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTRICT, i)
}

func (s *ErrorClassDeclarationPartContext) AllPRIVATE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPRIVATE)
}

func (s *ErrorClassDeclarationPartContext) PRIVATE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPRIVATE, i)
}

func (s *ErrorClassDeclarationPartContext) AllPROTECTED() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPROTECTED)
}

func (s *ErrorClassDeclarationPartContext) PROTECTED(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPROTECTED, i)
}

func (s *ErrorClassDeclarationPartContext) AllPUBLIC() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPUBLIC)
}

func (s *ErrorClassDeclarationPartContext) PUBLIC(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLIC, i)
}

func (s *ErrorClassDeclarationPartContext) AllPUBLISHED() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPUBLISHED)
}

func (s *ErrorClassDeclarationPartContext) PUBLISHED(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLISHED, i)
}

func (s *ErrorClassDeclarationPartContext) AllEND() []antlr.TerminalNode {
	return s.GetTokens(pascalParserEND)
}

func (s *ErrorClassDeclarationPartContext) END(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserEND, i)
}

func (s *ErrorClassDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorClassDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorClassDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterErrorClassDeclarationPart(s)
	}
}

func (s *ErrorClassDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitErrorClassDeclarationPart(s)
	}
}

func (s *ErrorClassDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitErrorClassDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ErrorClassDeclarationPart() (localctx IErrorClassDeclarationPartContext) {
	localctx = NewErrorClassDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, pascalParserRULE_errorClassDeclarationPart)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(720)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(719)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || _la == pascalParserEND || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&31) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(722)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyDeclarationContext is an interface to support dynamic dispatch.
type IPropertyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROPERTY() antlr.TerminalNode
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	PropertyIndexParameters() IPropertyIndexParametersContext
	PropertyReadDeclaration() IPropertyReadDeclarationContext
	PropertyWriteDeclaration() IPropertyWriteDeclarationContext
	PropertyDefaultValueDeclaration() IPropertyDefaultValueDeclarationContext
	PropertyIndexDeclaration() IPropertyIndexDeclarationContext
	SEMI() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode

	// IsPropertyDeclarationContext differentiates from other interfaces.
	IsPropertyDeclarationContext()
}

type PropertyDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDeclarationContext() *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDeclaration
	return p
}

func InitEmptyPropertyDeclarationContext(p *PropertyDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDeclaration
}

func (*PropertyDeclarationContext) IsPropertyDeclarationContext() {}

func NewPropertyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyDeclaration

	return p
}

func (s *PropertyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDeclarationContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(pascalParserPROPERTY, 0)
}

func (s *PropertyDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *PropertyDeclarationContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *PropertyDeclarationContext) PropertyIndexParameters() IPropertyIndexParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyIndexParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyIndexParametersContext)
}

func (s *PropertyDeclarationContext) PropertyReadDeclaration() IPropertyReadDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyReadDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyReadDeclarationContext)
}

func (s *PropertyDeclarationContext) PropertyWriteDeclaration() IPropertyWriteDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyWriteDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyWriteDeclarationContext)
}

func (s *PropertyDeclarationContext) PropertyDefaultValueDeclaration() IPropertyDefaultValueDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDefaultValueDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDefaultValueDeclarationContext)
}

func (s *PropertyDeclarationContext) PropertyIndexDeclaration() IPropertyIndexDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyIndexDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyIndexDeclarationContext)
}

func (s *PropertyDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *PropertyDeclarationContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *PropertyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyDeclaration(s)
	}
}

func (s *PropertyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyDeclaration(s)
	}
}

func (s *PropertyDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyDeclaration() (localctx IPropertyDeclarationContext) {
	localctx = NewPropertyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, pascalParserRULE_propertyDeclaration)
	var _la int

	p.SetState(752)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(724)
			p.Match(pascalParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(725)
			p.Identifier()
		}
		p.SetState(727)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(726)
				p.PropertyIndexParameters()
			}

		}
		{
			p.SetState(729)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(730)
			p.TypeIdentifier()
		}
		p.SetState(732)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserREAD {
			{
				p.SetState(731)
				p.PropertyReadDeclaration()
			}

		}
		p.SetState(735)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserWRITE {
			{
				p.SetState(734)
				p.PropertyWriteDeclaration()
			}

		}
		p.SetState(738)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserDEFAULT {
			{
				p.SetState(737)
				p.PropertyDefaultValueDeclaration()
			}

		}
		p.SetState(741)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserINDEX {
			{
				p.SetState(740)
				p.PropertyIndexDeclaration()
			}

		}
		p.SetState(745)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(743)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(744)
				p.Match(pascalParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(747)
			p.Match(pascalParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(748)
			p.Identifier()
		}
		p.SetState(750)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserDEFAULT {
			{
				p.SetState(749)
				p.PropertyDefaultValueDeclaration()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyReadDeclarationContext is an interface to support dynamic dispatch.
type IPropertyReadDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsPropertyReadDeclarationContext differentiates from other interfaces.
	IsPropertyReadDeclarationContext()
}

type PropertyReadDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyReadDeclarationContext() *PropertyReadDeclarationContext {
	var p = new(PropertyReadDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyReadDeclaration
	return p
}

func InitEmptyPropertyReadDeclarationContext(p *PropertyReadDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyReadDeclaration
}

func (*PropertyReadDeclarationContext) IsPropertyReadDeclarationContext() {}

func NewPropertyReadDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyReadDeclarationContext {
	var p = new(PropertyReadDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyReadDeclaration

	return p
}

func (s *PropertyReadDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyReadDeclarationContext) READ() antlr.TerminalNode {
	return s.GetToken(pascalParserREAD, 0)
}

func (s *PropertyReadDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyReadDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyReadDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyReadDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyReadDeclaration(s)
	}
}

func (s *PropertyReadDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyReadDeclaration(s)
	}
}

func (s *PropertyReadDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyReadDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyReadDeclaration() (localctx IPropertyReadDeclarationContext) {
	localctx = NewPropertyReadDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, pascalParserRULE_propertyReadDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(754)
		p.Match(pascalParserREAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(755)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyWriteDeclarationContext is an interface to support dynamic dispatch.
type IPropertyWriteDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WRITE() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsPropertyWriteDeclarationContext differentiates from other interfaces.
	IsPropertyWriteDeclarationContext()
}

type PropertyWriteDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyWriteDeclarationContext() *PropertyWriteDeclarationContext {
	var p = new(PropertyWriteDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyWriteDeclaration
	return p
}

func InitEmptyPropertyWriteDeclarationContext(p *PropertyWriteDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyWriteDeclaration
}

func (*PropertyWriteDeclarationContext) IsPropertyWriteDeclarationContext() {}

func NewPropertyWriteDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyWriteDeclarationContext {
	var p = new(PropertyWriteDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyWriteDeclaration

	return p
}

func (s *PropertyWriteDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyWriteDeclarationContext) WRITE() antlr.TerminalNode {
	return s.GetToken(pascalParserWRITE, 0)
}

func (s *PropertyWriteDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyWriteDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyWriteDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyWriteDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyWriteDeclaration(s)
	}
}

func (s *PropertyWriteDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyWriteDeclaration(s)
	}
}

func (s *PropertyWriteDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyWriteDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyWriteDeclaration() (localctx IPropertyWriteDeclarationContext) {
	localctx = NewPropertyWriteDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, pascalParserRULE_propertyWriteDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(757)
		p.Match(pascalParserWRITE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(758)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyDefaultValueDeclarationContext is an interface to support dynamic dispatch.
type IPropertyDefaultValueDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	Expression() IExpressionContext

	// IsPropertyDefaultValueDeclarationContext differentiates from other interfaces.
	IsPropertyDefaultValueDeclarationContext()
}

type PropertyDefaultValueDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDefaultValueDeclarationContext() *PropertyDefaultValueDeclarationContext {
	var p = new(PropertyDefaultValueDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDefaultValueDeclaration
	return p
}

func InitEmptyPropertyDefaultValueDeclarationContext(p *PropertyDefaultValueDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDefaultValueDeclaration
}

func (*PropertyDefaultValueDeclarationContext) IsPropertyDefaultValueDeclarationContext() {}

func NewPropertyDefaultValueDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDefaultValueDeclarationContext {
	var p = new(PropertyDefaultValueDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyDefaultValueDeclaration

	return p
}

func (s *PropertyDefaultValueDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDefaultValueDeclarationContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *PropertyDefaultValueDeclarationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PropertyDefaultValueDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDefaultValueDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyDefaultValueDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyDefaultValueDeclaration(s)
	}
}

func (s *PropertyDefaultValueDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyDefaultValueDeclaration(s)
	}
}

func (s *PropertyDefaultValueDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyDefaultValueDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyDefaultValueDeclaration() (localctx IPropertyDefaultValueDeclarationContext) {
	localctx = NewPropertyDefaultValueDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, pascalParserRULE_propertyDefaultValueDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(760)
		p.Match(pascalParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(761)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyIndexDeclarationContext is an interface to support dynamic dispatch.
type IPropertyIndexDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INDEX() antlr.TerminalNode
	UnsignedNumber() IUnsignedNumberContext

	// IsPropertyIndexDeclarationContext differentiates from other interfaces.
	IsPropertyIndexDeclarationContext()
}

type PropertyIndexDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyIndexDeclarationContext() *PropertyIndexDeclarationContext {
	var p = new(PropertyIndexDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexDeclaration
	return p
}

func InitEmptyPropertyIndexDeclarationContext(p *PropertyIndexDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexDeclaration
}

func (*PropertyIndexDeclarationContext) IsPropertyIndexDeclarationContext() {}

func NewPropertyIndexDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyIndexDeclarationContext {
	var p = new(PropertyIndexDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyIndexDeclaration

	return p
}

func (s *PropertyIndexDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyIndexDeclarationContext) INDEX() antlr.TerminalNode {
	return s.GetToken(pascalParserINDEX, 0)
}

func (s *PropertyIndexDeclarationContext) UnsignedNumber() IUnsignedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedNumberContext)
}

func (s *PropertyIndexDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyIndexDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyIndexDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyIndexDeclaration(s)
	}
}

func (s *PropertyIndexDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyIndexDeclaration(s)
	}
}

func (s *PropertyIndexDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyIndexDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyIndexDeclaration() (localctx IPropertyIndexDeclarationContext) {
	localctx = NewPropertyIndexDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, pascalParserRULE_propertyIndexDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(763)
		p.Match(pascalParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(764)
		p.UnsignedNumber()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyIndexParametersContext is an interface to support dynamic dispatch.
type IPropertyIndexParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	AllFormalParameterSection() []IFormalParameterSectionContext
	FormalParameterSection(i int) IFormalParameterSectionContext
	RBRACK() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPropertyIndexParametersContext differentiates from other interfaces.
	IsPropertyIndexParametersContext()
}

type PropertyIndexParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyIndexParametersContext() *PropertyIndexParametersContext {
	var p = new(PropertyIndexParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexParameters
	return p
}

func InitEmptyPropertyIndexParametersContext(p *PropertyIndexParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexParameters
}

func (*PropertyIndexParametersContext) IsPropertyIndexParametersContext() {}

func NewPropertyIndexParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyIndexParametersContext {
	var p = new(PropertyIndexParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyIndexParameters

	return p
}

func (s *PropertyIndexParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyIndexParametersContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *PropertyIndexParametersContext) AllFormalParameterSection() []IFormalParameterSectionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormalParameterSectionContext); ok {
			len++
		}
	}

	tst := make([]IFormalParameterSectionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormalParameterSectionContext); ok {
			tst[i] = t.(IFormalParameterSectionContext)
			i++
		}
	}

	return tst
}

func (s *PropertyIndexParametersContext) FormalParameterSection(i int) IFormalParameterSectionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterSectionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterSectionContext)
}

func (s *PropertyIndexParametersContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *PropertyIndexParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *PropertyIndexParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *PropertyIndexParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyIndexParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyIndexParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyIndexParameters(s)
	}
}

func (s *PropertyIndexParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyIndexParameters(s)
	}
}

func (s *PropertyIndexParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyIndexParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyIndexParameters() (localctx IPropertyIndexParametersContext) {
	localctx = NewPropertyIndexParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, pascalParserRULE_propertyIndexParameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(766)
		p.Match(pascalParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(767)
		p.FormalParameterSection()
	}
	p.SetState(772)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(768)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(769)
			p.FormalParameterSection()
		}

		p.SetState(774)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(775)
		p.Match(pascalParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyIndexParametersListContext is an interface to support dynamic dispatch.
type IPropertyIndexParametersListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierList() []IIdentifierListContext
	IdentifierList(i int) IIdentifierListContext
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllIndexType() []IIndexTypeContext
	IndexType(i int) IIndexTypeContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsPropertyIndexParametersListContext differentiates from other interfaces.
	IsPropertyIndexParametersListContext()
}

type PropertyIndexParametersListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyIndexParametersListContext() *PropertyIndexParametersListContext {
	var p = new(PropertyIndexParametersListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexParametersList
	return p
}

func InitEmptyPropertyIndexParametersListContext(p *PropertyIndexParametersListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexParametersList
}

func (*PropertyIndexParametersListContext) IsPropertyIndexParametersListContext() {}

func NewPropertyIndexParametersListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyIndexParametersListContext {
	var p = new(PropertyIndexParametersListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyIndexParametersList

	return p
}

func (s *PropertyIndexParametersListContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyIndexParametersListContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *PropertyIndexParametersListContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PropertyIndexParametersListContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOLON)
}

func (s *PropertyIndexParametersListContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, i)
}

func (s *PropertyIndexParametersListContext) AllIndexType() []IIndexTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexTypeContext); ok {
			len++
		}
	}

	tst := make([]IIndexTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexTypeContext); ok {
			tst[i] = t.(IIndexTypeContext)
			i++
		}
	}

	return tst
}

func (s *PropertyIndexParametersListContext) IndexType(i int) IIndexTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *PropertyIndexParametersListContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *PropertyIndexParametersListContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *PropertyIndexParametersListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyIndexParametersListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyIndexParametersListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyIndexParametersList(s)
	}
}

func (s *PropertyIndexParametersListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyIndexParametersList(s)
	}
}

func (s *PropertyIndexParametersListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyIndexParametersList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyIndexParametersList() (localctx IPropertyIndexParametersListContext) {
	localctx = NewPropertyIndexParametersListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, pascalParserRULE_propertyIndexParametersList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(777)
		p.IdentifierList()
	}
	{
		p.SetState(778)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(779)
		p.IndexType()
	}
	p.SetState(787)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserSEMI {
		{
			p.SetState(780)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(781)
			p.IdentifierList()
		}
		{
			p.SetState(782)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(783)
			p.IndexType()
		}

		p.SetState(789)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericTemplateContext is an interface to support dynamic dispatch.
type IGenericTemplateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	GenericTemplateList() IGenericTemplateListContext
	GT() antlr.TerminalNode

	// IsGenericTemplateContext differentiates from other interfaces.
	IsGenericTemplateContext()
}

type GenericTemplateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericTemplateContext() *GenericTemplateContext {
	var p = new(GenericTemplateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericTemplate
	return p
}

func InitEmptyGenericTemplateContext(p *GenericTemplateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericTemplate
}

func (*GenericTemplateContext) IsGenericTemplateContext() {}

func NewGenericTemplateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericTemplateContext {
	var p = new(GenericTemplateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_genericTemplate

	return p
}

func (s *GenericTemplateContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericTemplateContext) LT() antlr.TerminalNode {
	return s.GetToken(pascalParserLT, 0)
}

func (s *GenericTemplateContext) GenericTemplateList() IGenericTemplateListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericTemplateListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericTemplateListContext)
}

func (s *GenericTemplateContext) GT() antlr.TerminalNode {
	return s.GetToken(pascalParserGT, 0)
}

func (s *GenericTemplateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericTemplateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericTemplateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterGenericTemplate(s)
	}
}

func (s *GenericTemplateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitGenericTemplate(s)
	}
}

func (s *GenericTemplateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitGenericTemplate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) GenericTemplate() (localctx IGenericTemplateContext) {
	localctx = NewGenericTemplateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, pascalParserRULE_genericTemplate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(790)
		p.Match(pascalParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(791)
		p.GenericTemplateList()
	}
	{
		p.SetState(792)
		p.Match(pascalParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericTemplateListContext is an interface to support dynamic dispatch.
type IGenericTemplateListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeIdentifier() []ITypeIdentifierContext
	TypeIdentifier(i int) ITypeIdentifierContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGenericTemplateListContext differentiates from other interfaces.
	IsGenericTemplateListContext()
}

type GenericTemplateListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericTemplateListContext() *GenericTemplateListContext {
	var p = new(GenericTemplateListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericTemplateList
	return p
}

func InitEmptyGenericTemplateListContext(p *GenericTemplateListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericTemplateList
}

func (*GenericTemplateListContext) IsGenericTemplateListContext() {}

func NewGenericTemplateListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericTemplateListContext {
	var p = new(GenericTemplateListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_genericTemplateList

	return p
}

func (s *GenericTemplateListContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericTemplateListContext) AllTypeIdentifier() []ITypeIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			len++
		}
	}

	tst := make([]ITypeIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeIdentifierContext); ok {
			tst[i] = t.(ITypeIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *GenericTemplateListContext) TypeIdentifier(i int) ITypeIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *GenericTemplateListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *GenericTemplateListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *GenericTemplateListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericTemplateListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericTemplateListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterGenericTemplateList(s)
	}
}

func (s *GenericTemplateListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitGenericTemplateList(s)
	}
}

func (s *GenericTemplateListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitGenericTemplateList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) GenericTemplateList() (localctx IGenericTemplateListContext) {
	localctx = NewGenericTemplateListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, pascalParserRULE_genericTemplateList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(794)
		p.TypeIdentifier()
	}
	p.SetState(799)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(795)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(796)
			p.TypeIdentifier()
		}

		p.SetState(801)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_Context is an interface to support dynamic dispatch.
type IType_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleType() ISimpleTypeContext
	StructuredType() IStructuredTypeContext
	PointerType() IPointerTypeContext

	// IsType_Context differentiates from other interfaces.
	IsType_Context()
}

type Type_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_Context() *Type_Context {
	var p = new(Type_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_type_
	return p
}

func InitEmptyType_Context(p *Type_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_type_
}

func (*Type_Context) IsType_Context() {}

func NewType_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_Context {
	var p = new(Type_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_type_

	return p
}

func (s *Type_Context) GetParser() antlr.Parser { return s.parser }

func (s *Type_Context) SimpleType() ISimpleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeContext)
}

func (s *Type_Context) StructuredType() IStructuredTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructuredTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructuredTypeContext)
}

func (s *Type_Context) PointerType() IPointerTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerTypeContext)
}

func (s *Type_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterType_(s)
	}
}

func (s *Type_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitType_(s)
	}
}

func (s *Type_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitType_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Type_() (localctx IType_Context) {
	localctx = NewType_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, pascalParserRULE_type_)
	p.SetState(805)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(802)
			p.SimpleType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(803)
			p.StructuredType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(804)
			p.PointerType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleTypeContext is an interface to support dynamic dispatch.
type ISimpleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ScalarType() IScalarTypeContext
	SubrangeType() ISubrangeTypeContext
	TypeIdentifier() ITypeIdentifierContext
	Stringtype() IStringtypeContext

	// IsSimpleTypeContext differentiates from other interfaces.
	IsSimpleTypeContext()
}

type SimpleTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleTypeContext() *SimpleTypeContext {
	var p = new(SimpleTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleType
	return p
}

func InitEmptySimpleTypeContext(p *SimpleTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleType
}

func (*SimpleTypeContext) IsSimpleTypeContext() {}

func NewSimpleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleTypeContext {
	var p = new(SimpleTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_simpleType

	return p
}

func (s *SimpleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleTypeContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *SimpleTypeContext) SubrangeType() ISubrangeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubrangeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubrangeTypeContext)
}

func (s *SimpleTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *SimpleTypeContext) Stringtype() IStringtypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringtypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringtypeContext)
}

func (s *SimpleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSimpleType(s)
	}
}

func (s *SimpleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSimpleType(s)
	}
}

func (s *SimpleTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSimpleType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SimpleType() (localctx ISimpleTypeContext) {
	localctx = NewSimpleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, pascalParserRULE_simpleType)
	p.SetState(811)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(807)
			p.ScalarType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(808)
			p.SubrangeType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(809)
			p.TypeIdentifier()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(810)
			p.Stringtype()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScalarTypeContext is an interface to support dynamic dispatch.
type IScalarTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	ScalerList() IScalerListContext
	RPAREN() antlr.TerminalNode

	// IsScalarTypeContext differentiates from other interfaces.
	IsScalarTypeContext()
}

type ScalarTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalarTypeContext() *ScalarTypeContext {
	var p = new(ScalarTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalarType
	return p
}

func InitEmptyScalarTypeContext(p *ScalarTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalarType
}

func (*ScalarTypeContext) IsScalarTypeContext() {}

func NewScalarTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalarTypeContext {
	var p = new(ScalarTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_scalarType

	return p
}

func (s *ScalarTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalarTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ScalarTypeContext) ScalerList() IScalerListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalerListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalerListContext)
}

func (s *ScalarTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ScalarTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalarTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterScalarType(s)
	}
}

func (s *ScalarTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitScalarType(s)
	}
}

func (s *ScalarTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitScalarType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ScalarType() (localctx IScalarTypeContext) {
	localctx = NewScalarTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, pascalParserRULE_scalarType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(813)
		p.Match(pascalParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(814)
		p.ScalerList()
	}
	{
		p.SetState(815)
		p.Match(pascalParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScalerListContext is an interface to support dynamic dispatch.
type IScalerListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllScalerMember() []IScalerMemberContext
	ScalerMember(i int) IScalerMemberContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsScalerListContext differentiates from other interfaces.
	IsScalerListContext()
}

type ScalerListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalerListContext() *ScalerListContext {
	var p = new(ScalerListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalerList
	return p
}

func InitEmptyScalerListContext(p *ScalerListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalerList
}

func (*ScalerListContext) IsScalerListContext() {}

func NewScalerListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalerListContext {
	var p = new(ScalerListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_scalerList

	return p
}

func (s *ScalerListContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalerListContext) AllScalerMember() []IScalerMemberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScalerMemberContext); ok {
			len++
		}
	}

	tst := make([]IScalerMemberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScalerMemberContext); ok {
			tst[i] = t.(IScalerMemberContext)
			i++
		}
	}

	return tst
}

func (s *ScalerListContext) ScalerMember(i int) IScalerMemberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalerMemberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalerMemberContext)
}

func (s *ScalerListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ScalerListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ScalerListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalerListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalerListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterScalerList(s)
	}
}

func (s *ScalerListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitScalerList(s)
	}
}

func (s *ScalerListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitScalerList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ScalerList() (localctx IScalerListContext) {
	localctx = NewScalerListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, pascalParserRULE_scalerList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(817)
		p.ScalerMember()
	}
	p.SetState(822)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(818)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(819)
			p.ScalerMember()
		}

		p.SetState(824)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScalerMemberContext is an interface to support dynamic dispatch.
type IScalerMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQUAL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsScalerMemberContext differentiates from other interfaces.
	IsScalerMemberContext()
}

type ScalerMemberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalerMemberContext() *ScalerMemberContext {
	var p = new(ScalerMemberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalerMember
	return p
}

func InitEmptyScalerMemberContext(p *ScalerMemberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalerMember
}

func (*ScalerMemberContext) IsScalerMemberContext() {}

func NewScalerMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalerMemberContext {
	var p = new(ScalerMemberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_scalerMember

	return p
}

func (s *ScalerMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalerMemberContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScalerMemberContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *ScalerMemberContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ScalerMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalerMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalerMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterScalerMember(s)
	}
}

func (s *ScalerMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitScalerMember(s)
	}
}

func (s *ScalerMemberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitScalerMember(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ScalerMember() (localctx IScalerMemberContext) {
	localctx = NewScalerMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, pascalParserRULE_scalerMember)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(825)
		p.Identifier()
	}
	p.SetState(828)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserEQUAL {
		{
			p.SetState(826)
			p.Match(pascalParserEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(827)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubrangeTypeContext is an interface to support dynamic dispatch.
type ISubrangeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSimpleExpression() []ISimpleExpressionContext
	SimpleExpression(i int) ISimpleExpressionContext
	DOTDOT() antlr.TerminalNode

	// IsSubrangeTypeContext differentiates from other interfaces.
	IsSubrangeTypeContext()
}

type SubrangeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubrangeTypeContext() *SubrangeTypeContext {
	var p = new(SubrangeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_subrangeType
	return p
}

func InitEmptySubrangeTypeContext(p *SubrangeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_subrangeType
}

func (*SubrangeTypeContext) IsSubrangeTypeContext() {}

func NewSubrangeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubrangeTypeContext {
	var p = new(SubrangeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_subrangeType

	return p
}

func (s *SubrangeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SubrangeTypeContext) AllSimpleExpression() []ISimpleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISimpleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleExpressionContext); ok {
			tst[i] = t.(ISimpleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SubrangeTypeContext) SimpleExpression(i int) ISimpleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExpressionContext)
}

func (s *SubrangeTypeContext) DOTDOT() antlr.TerminalNode {
	return s.GetToken(pascalParserDOTDOT, 0)
}

func (s *SubrangeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubrangeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubrangeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSubrangeType(s)
	}
}

func (s *SubrangeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSubrangeType(s)
	}
}

func (s *SubrangeTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSubrangeType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SubrangeType() (localctx ISubrangeTypeContext) {
	localctx = NewSubrangeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, pascalParserRULE_subrangeType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(830)
		p.SimpleExpression()
	}
	{
		p.SetState(831)
		p.Match(pascalParserDOTDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(832)
		p.SimpleExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeIdentifierContext is an interface to support dynamic dispatch.
type ITypeIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	CHAR() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	REAL() antlr.TerminalNode
	STRING() antlr.TerminalNode
	CARDINAL() antlr.TerminalNode
	LONGBOOL() antlr.TerminalNode
	LONGINT() antlr.TerminalNode
	ArrayType() IArrayTypeContext

	// IsTypeIdentifierContext differentiates from other interfaces.
	IsTypeIdentifierContext()
}

type TypeIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeIdentifierContext() *TypeIdentifierContext {
	var p = new(TypeIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeIdentifier
	return p
}

func InitEmptyTypeIdentifierContext(p *TypeIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeIdentifier
}

func (*TypeIdentifierContext) IsTypeIdentifierContext() {}

func NewTypeIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeIdentifierContext {
	var p = new(TypeIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typeIdentifier

	return p
}

func (s *TypeIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeIdentifierContext) CHAR() antlr.TerminalNode {
	return s.GetToken(pascalParserCHAR, 0)
}

func (s *TypeIdentifierContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(pascalParserBOOLEAN, 0)
}

func (s *TypeIdentifierContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(pascalParserINTEGER, 0)
}

func (s *TypeIdentifierContext) REAL() antlr.TerminalNode {
	return s.GetToken(pascalParserREAL, 0)
}

func (s *TypeIdentifierContext) STRING() antlr.TerminalNode {
	return s.GetToken(pascalParserSTRING, 0)
}

func (s *TypeIdentifierContext) CARDINAL() antlr.TerminalNode {
	return s.GetToken(pascalParserCARDINAL, 0)
}

func (s *TypeIdentifierContext) LONGBOOL() antlr.TerminalNode {
	return s.GetToken(pascalParserLONGBOOL, 0)
}

func (s *TypeIdentifierContext) LONGINT() antlr.TerminalNode {
	return s.GetToken(pascalParserLONGINT, 0)
}

func (s *TypeIdentifierContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *TypeIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypeIdentifier(s)
	}
}

func (s *TypeIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypeIdentifier(s)
	}
}

func (s *TypeIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypeIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypeIdentifier() (localctx ITypeIdentifierContext) {
	localctx = NewTypeIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, pascalParserRULE_typeIdentifier)
	var _la int

	p.SetState(837)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(834)
			p.Identifier()
		}

	case pascalParserBOOLEAN, pascalParserCHAR, pascalParserINTEGER, pascalParserREAL, pascalParserSTRING, pascalParserCARDINAL, pascalParserLONGBOOL, pascalParserLONGINT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(835)
			_la = p.GetTokenStream().LA(1)

			if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4299161760) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&15393162788865) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case pascalParserARRAY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(836)
			p.ArrayType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructuredTypeContext is an interface to support dynamic dispatch.
type IStructuredTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PACKED() antlr.TerminalNode
	UnpackedStructuredType() IUnpackedStructuredTypeContext
	HelperType() IHelperTypeContext
	ClassType() IClassTypeContext
	RecordType() IRecordTypeContext
	InterfaceType() IInterfaceTypeContext

	// IsStructuredTypeContext differentiates from other interfaces.
	IsStructuredTypeContext()
}

type StructuredTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructuredTypeContext() *StructuredTypeContext {
	var p = new(StructuredTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_structuredType
	return p
}

func InitEmptyStructuredTypeContext(p *StructuredTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_structuredType
}

func (*StructuredTypeContext) IsStructuredTypeContext() {}

func NewStructuredTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructuredTypeContext {
	var p = new(StructuredTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_structuredType

	return p
}

func (s *StructuredTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StructuredTypeContext) PACKED() antlr.TerminalNode {
	return s.GetToken(pascalParserPACKED, 0)
}

func (s *StructuredTypeContext) UnpackedStructuredType() IUnpackedStructuredTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpackedStructuredTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpackedStructuredTypeContext)
}

func (s *StructuredTypeContext) HelperType() IHelperTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelperTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelperTypeContext)
}

func (s *StructuredTypeContext) ClassType() IClassTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTypeContext)
}

func (s *StructuredTypeContext) RecordType() IRecordTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordTypeContext)
}

func (s *StructuredTypeContext) InterfaceType() IInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceTypeContext)
}

func (s *StructuredTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructuredTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructuredTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStructuredType(s)
	}
}

func (s *StructuredTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStructuredType(s)
	}
}

func (s *StructuredTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStructuredType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) StructuredType() (localctx IStructuredTypeContext) {
	localctx = NewStructuredTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, pascalParserRULE_structuredType)
	p.SetState(846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(839)
			p.Match(pascalParserPACKED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(840)
			p.UnpackedStructuredType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(841)
			p.UnpackedStructuredType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(842)
			p.HelperType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(843)
			p.ClassType()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(844)
			p.RecordType()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(845)
			p.InterfaceType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpackedStructuredTypeContext is an interface to support dynamic dispatch.
type IUnpackedStructuredTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ArrayType() IArrayTypeContext
	SetType() ISetTypeContext
	FileType() IFileTypeContext

	// IsUnpackedStructuredTypeContext differentiates from other interfaces.
	IsUnpackedStructuredTypeContext()
}

type UnpackedStructuredTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpackedStructuredTypeContext() *UnpackedStructuredTypeContext {
	var p = new(UnpackedStructuredTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unpackedStructuredType
	return p
}

func InitEmptyUnpackedStructuredTypeContext(p *UnpackedStructuredTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unpackedStructuredType
}

func (*UnpackedStructuredTypeContext) IsUnpackedStructuredTypeContext() {}

func NewUnpackedStructuredTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpackedStructuredTypeContext {
	var p = new(UnpackedStructuredTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unpackedStructuredType

	return p
}

func (s *UnpackedStructuredTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpackedStructuredTypeContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *UnpackedStructuredTypeContext) SetType() ISetTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetTypeContext)
}

func (s *UnpackedStructuredTypeContext) FileType() IFileTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileTypeContext)
}

func (s *UnpackedStructuredTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpackedStructuredTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpackedStructuredTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnpackedStructuredType(s)
	}
}

func (s *UnpackedStructuredTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnpackedStructuredType(s)
	}
}

func (s *UnpackedStructuredTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnpackedStructuredType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnpackedStructuredType() (localctx IUnpackedStructuredTypeContext) {
	localctx = NewUnpackedStructuredTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, pascalParserRULE_unpackedStructuredType)
	p.SetState(851)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserARRAY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(848)
			p.ArrayType()
		}

	case pascalParserSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(849)
			p.SetType()
		}

	case pascalParserFILE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(850)
			p.FileType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringtypeContext is an interface to support dynamic dispatch.
type IStringtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	Identifier() IIdentifierContext
	UnsignedNumber() IUnsignedNumberContext

	// IsStringtypeContext differentiates from other interfaces.
	IsStringtypeContext()
}

type StringtypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringtypeContext() *StringtypeContext {
	var p = new(StringtypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_stringtype
	return p
}

func InitEmptyStringtypeContext(p *StringtypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_stringtype
}

func (*StringtypeContext) IsStringtypeContext() {}

func NewStringtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringtypeContext {
	var p = new(StringtypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_stringtype

	return p
}

func (s *StringtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StringtypeContext) STRING() antlr.TerminalNode {
	return s.GetToken(pascalParserSTRING, 0)
}

func (s *StringtypeContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *StringtypeContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *StringtypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StringtypeContext) UnsignedNumber() IUnsignedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedNumberContext)
}

func (s *StringtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStringtype(s)
	}
}

func (s *StringtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStringtype(s)
	}
}

func (s *StringtypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStringtype(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Stringtype() (localctx IStringtypeContext) {
	localctx = NewStringtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, pascalParserRULE_stringtype)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(853)
		p.Match(pascalParserSTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(854)
		p.Match(pascalParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(857)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
		{
			p.SetState(855)
			p.Identifier()
		}

	case pascalParserNUM_INT, pascalParserNUM_REAL:
		{
			p.SetState(856)
			p.UnsignedNumber()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(859)
		p.Match(pascalParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY() antlr.TerminalNode
	LBRACK() antlr.TerminalNode
	TypeList() ITypeListContext
	RBRACK() antlr.TerminalNode
	OF() antlr.TerminalNode
	Type_() IType_Context
	EQUAL() antlr.TerminalNode
	ScalarType() IScalarTypeContext
	LBRACK2() antlr.TerminalNode
	RBRACK2() antlr.TerminalNode
	CONST() antlr.TerminalNode

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_arrayType
	return p
}

func InitEmptyArrayTypeContext(p *ArrayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_arrayType
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(pascalParserARRAY, 0)
}

func (s *ArrayTypeContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *ArrayTypeContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *ArrayTypeContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *ArrayTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *ArrayTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ArrayTypeContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *ArrayTypeContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ArrayTypeContext) LBRACK2() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK2, 0)
}

func (s *ArrayTypeContext) RBRACK2() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK2, 0)
}

func (s *ArrayTypeContext) CONST() antlr.TerminalNode {
	return s.GetToken(pascalParserCONST, 0)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (s *ArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, pascalParserRULE_arrayType)
	p.SetState(887)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(861)
			p.Match(pascalParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(862)
			p.Match(pascalParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(863)
			p.TypeList()
		}
		{
			p.SetState(864)
			p.Match(pascalParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(865)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(866)
			p.Type_()
		}
		p.SetState(869)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(867)
				p.Match(pascalParserEQUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(868)
				p.ScalarType()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(871)
			p.Match(pascalParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(872)
			p.Match(pascalParserLBRACK2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(873)
			p.TypeList()
		}
		{
			p.SetState(874)
			p.Match(pascalParserRBRACK2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(875)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(876)
			p.Type_()
		}
		p.SetState(879)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(877)
				p.Match(pascalParserEQUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(878)
				p.ScalarType()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(881)
			p.Match(pascalParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(882)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(883)
			p.Match(pascalParserCONST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(884)
			p.Match(pascalParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(885)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(886)
			p.Type_()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIndexType() []IIndexTypeContext
	IndexType(i int) IIndexTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeList
	return p
}

func InitEmptyTypeListContext(p *TypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeList
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllIndexType() []IIndexTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexTypeContext); ok {
			len++
		}
	}

	tst := make([]IIndexTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexTypeContext); ok {
			tst[i] = t.(IIndexTypeContext)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) IndexType(i int) IIndexTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *TypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *TypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypeList(s)
	}
}

func (s *TypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypeList(s)
	}
}

func (s *TypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, pascalParserRULE_typeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(889)
		p.IndexType()
	}
	p.SetState(894)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(890)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(891)
			p.IndexType()
		}

		p.SetState(896)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexTypeContext is an interface to support dynamic dispatch.
type IIndexTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleType() ISimpleTypeContext

	// IsIndexTypeContext differentiates from other interfaces.
	IsIndexTypeContext()
}

type IndexTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexTypeContext() *IndexTypeContext {
	var p = new(IndexTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_indexType
	return p
}

func InitEmptyIndexTypeContext(p *IndexTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_indexType
}

func (*IndexTypeContext) IsIndexTypeContext() {}

func NewIndexTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexTypeContext {
	var p = new(IndexTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_indexType

	return p
}

func (s *IndexTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexTypeContext) SimpleType() ISimpleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeContext)
}

func (s *IndexTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterIndexType(s)
	}
}

func (s *IndexTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitIndexType(s)
	}
}

func (s *IndexTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitIndexType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) IndexType() (localctx IIndexTypeContext) {
	localctx = NewIndexTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, pascalParserRULE_indexType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(897)
		p.SimpleType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordTypeContext is an interface to support dynamic dispatch.
type IRecordTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RECORD() antlr.TerminalNode
	RecordImplicitPublishedDeclaration() IRecordImplicitPublishedDeclarationContext
	END() antlr.TerminalNode
	AllRecordDeclaration() []IRecordDeclarationContext
	RecordDeclaration(i int) IRecordDeclarationContext
	RecordParts() IRecordPartsContext

	// IsRecordTypeContext differentiates from other interfaces.
	IsRecordTypeContext()
}

type RecordTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordTypeContext() *RecordTypeContext {
	var p = new(RecordTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordType
	return p
}

func InitEmptyRecordTypeContext(p *RecordTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordType
}

func (*RecordTypeContext) IsRecordTypeContext() {}

func NewRecordTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordTypeContext {
	var p = new(RecordTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordType

	return p
}

func (s *RecordTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordTypeContext) RECORD() antlr.TerminalNode {
	return s.GetToken(pascalParserRECORD, 0)
}

func (s *RecordTypeContext) RecordImplicitPublishedDeclaration() IRecordImplicitPublishedDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordImplicitPublishedDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordImplicitPublishedDeclarationContext)
}

func (s *RecordTypeContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *RecordTypeContext) AllRecordDeclaration() []IRecordDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IRecordDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordDeclarationContext); ok {
			tst[i] = t.(IRecordDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *RecordTypeContext) RecordDeclaration(i int) IRecordDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDeclarationContext)
}

func (s *RecordTypeContext) RecordParts() IRecordPartsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordPartsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordPartsContext)
}

func (s *RecordTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordType(s)
	}
}

func (s *RecordTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordType(s)
	}
}

func (s *RecordTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordType() (localctx IRecordTypeContext) {
	localctx = NewRecordTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, pascalParserRULE_recordType)
	var _la int

	p.SetState(914)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(899)
			p.Match(pascalParserRECORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(900)
			p.RecordImplicitPublishedDeclaration()
		}
		p.SetState(904)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&31) != 0 {
			{
				p.SetState(901)
				p.RecordDeclaration()
			}

			p.SetState(906)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(907)
			p.Match(pascalParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(909)
			p.Match(pascalParserRECORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(911)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserCASE || ((int64((_la-85)) & ^0x3f) == 0 && ((int64(1)<<(_la-85))&137438953483) != 0) {
			{
				p.SetState(910)
				p.RecordParts()
			}

		}
		{
			p.SetState(913)
			p.Match(pascalParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordDeclarationContext is an interface to support dynamic dispatch.
type IRecordDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AccessSpecifier() IAccessSpecifierContext
	AllRecordDeclarationPart() []IRecordDeclarationPartContext
	RecordDeclarationPart(i int) IRecordDeclarationPartContext

	// IsRecordDeclarationContext differentiates from other interfaces.
	IsRecordDeclarationContext()
}

type RecordDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordDeclarationContext() *RecordDeclarationContext {
	var p = new(RecordDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordDeclaration
	return p
}

func InitEmptyRecordDeclarationContext(p *RecordDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordDeclaration
}

func (*RecordDeclarationContext) IsRecordDeclarationContext() {}

func NewRecordDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordDeclarationContext {
	var p = new(RecordDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordDeclaration

	return p
}

func (s *RecordDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordDeclarationContext) AccessSpecifier() IAccessSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessSpecifierContext)
}

func (s *RecordDeclarationContext) AllRecordDeclarationPart() []IRecordDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IRecordDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordDeclarationPartContext); ok {
			tst[i] = t.(IRecordDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *RecordDeclarationContext) RecordDeclarationPart(i int) IRecordDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDeclarationPartContext)
}

func (s *RecordDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordDeclaration(s)
	}
}

func (s *RecordDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordDeclaration(s)
	}
}

func (s *RecordDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordDeclaration() (localctx IRecordDeclarationContext) {
	localctx = NewRecordDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, pascalParserRULE_recordDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(916)
		p.AccessSpecifier()
	}
	p.SetState(920)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-8193) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-253953) != 0) {
		{
			p.SetState(917)
			p.RecordDeclarationPart()
		}

		p.SetState(922)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordImplicitPublishedDeclarationContext is an interface to support dynamic dispatch.
type IRecordImplicitPublishedDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRecordDeclarationPart() []IRecordDeclarationPartContext
	RecordDeclarationPart(i int) IRecordDeclarationPartContext

	// IsRecordImplicitPublishedDeclarationContext differentiates from other interfaces.
	IsRecordImplicitPublishedDeclarationContext()
}

type RecordImplicitPublishedDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordImplicitPublishedDeclarationContext() *RecordImplicitPublishedDeclarationContext {
	var p = new(RecordImplicitPublishedDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordImplicitPublishedDeclaration
	return p
}

func InitEmptyRecordImplicitPublishedDeclarationContext(p *RecordImplicitPublishedDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordImplicitPublishedDeclaration
}

func (*RecordImplicitPublishedDeclarationContext) IsRecordImplicitPublishedDeclarationContext() {}

func NewRecordImplicitPublishedDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordImplicitPublishedDeclarationContext {
	var p = new(RecordImplicitPublishedDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordImplicitPublishedDeclaration

	return p
}

func (s *RecordImplicitPublishedDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordImplicitPublishedDeclarationContext) AllRecordDeclarationPart() []IRecordDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IRecordDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordDeclarationPartContext); ok {
			tst[i] = t.(IRecordDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *RecordImplicitPublishedDeclarationContext) RecordDeclarationPart(i int) IRecordDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDeclarationPartContext)
}

func (s *RecordImplicitPublishedDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordImplicitPublishedDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordImplicitPublishedDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordImplicitPublishedDeclaration(s)
	}
}

func (s *RecordImplicitPublishedDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordImplicitPublishedDeclaration(s)
	}
}

func (s *RecordImplicitPublishedDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordImplicitPublishedDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordImplicitPublishedDeclaration() (localctx IRecordImplicitPublishedDeclarationContext) {
	localctx = NewRecordImplicitPublishedDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, pascalParserRULE_recordImplicitPublishedDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(926)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-8193) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-253953) != 0) {
		{
			p.SetState(923)
			p.RecordDeclarationPart()
		}

		p.SetState(928)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordDeclarationPartContext is an interface to support dynamic dispatch.
type IRecordDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypedIdentifierList() ITypedIdentifierListContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AttributeSection() IAttributeSectionContext
	TypeDefinitionPart() ITypeDefinitionPartContext
	ConstantDefinitionPart() IConstantDefinitionPartContext
	FunctionHeader() IFunctionHeaderContext
	ProcedureHeader() IProcedureHeaderContext
	ClassOperatorHeader() IClassOperatorHeaderContext
	PropertyDeclaration() IPropertyDeclarationContext
	DEFAULT() antlr.TerminalNode
	ErrorRecordDeclarationPart() IErrorRecordDeclarationPartContext

	// IsRecordDeclarationPartContext differentiates from other interfaces.
	IsRecordDeclarationPartContext()
}

type RecordDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordDeclarationPartContext() *RecordDeclarationPartContext {
	var p = new(RecordDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordDeclarationPart
	return p
}

func InitEmptyRecordDeclarationPartContext(p *RecordDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordDeclarationPart
}

func (*RecordDeclarationPartContext) IsRecordDeclarationPartContext() {}

func NewRecordDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordDeclarationPartContext {
	var p = new(RecordDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordDeclarationPart

	return p
}

func (s *RecordDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordDeclarationPartContext) TypedIdentifierList() ITypedIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIdentifierListContext)
}

func (s *RecordDeclarationPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *RecordDeclarationPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *RecordDeclarationPartContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *RecordDeclarationPartContext) TypeDefinitionPart() ITypeDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionPartContext)
}

func (s *RecordDeclarationPartContext) ConstantDefinitionPart() IConstantDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *RecordDeclarationPartContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *RecordDeclarationPartContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *RecordDeclarationPartContext) ClassOperatorHeader() IClassOperatorHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOperatorHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOperatorHeaderContext)
}

func (s *RecordDeclarationPartContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *RecordDeclarationPartContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *RecordDeclarationPartContext) ErrorRecordDeclarationPart() IErrorRecordDeclarationPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorRecordDeclarationPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorRecordDeclarationPartContext)
}

func (s *RecordDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordDeclarationPart(s)
	}
}

func (s *RecordDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordDeclarationPart(s)
	}
}

func (s *RecordDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordDeclarationPart() (localctx IRecordDeclarationPartContext) {
	localctx = NewRecordDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, pascalParserRULE_recordDeclarationPart)
	var _la int

	p.SetState(949)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(930)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(929)
				p.AttributeSection()
			}

		}
		{
			p.SetState(932)
			p.TypedIdentifierList()
		}
		{
			p.SetState(933)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(935)
			p.TypeDefinitionPart()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(936)
			p.ConstantDefinitionPart()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(937)
			p.FunctionHeader()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(938)
			p.ProcedureHeader()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(939)
			p.ClassOperatorHeader()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(940)
			p.PropertyDeclaration()
		}
		{
			p.SetState(941)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(944)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(942)
				p.Match(pascalParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(943)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(946)
			p.ErrorRecordDeclarationPart()
		}
		{
			p.SetState(947)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorRecordDeclarationPartContext is an interface to support dynamic dispatch.
type IErrorRecordDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRICT() []antlr.TerminalNode
	STRICT(i int) antlr.TerminalNode
	AllPRIVATE() []antlr.TerminalNode
	PRIVATE(i int) antlr.TerminalNode
	AllPROTECTED() []antlr.TerminalNode
	PROTECTED(i int) antlr.TerminalNode
	AllPUBLIC() []antlr.TerminalNode
	PUBLIC(i int) antlr.TerminalNode
	AllPUBLISHED() []antlr.TerminalNode
	PUBLISHED(i int) antlr.TerminalNode
	AllEND() []antlr.TerminalNode
	END(i int) antlr.TerminalNode

	// IsErrorRecordDeclarationPartContext differentiates from other interfaces.
	IsErrorRecordDeclarationPartContext()
}

type ErrorRecordDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorRecordDeclarationPartContext() *ErrorRecordDeclarationPartContext {
	var p = new(ErrorRecordDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorRecordDeclarationPart
	return p
}

func InitEmptyErrorRecordDeclarationPartContext(p *ErrorRecordDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorRecordDeclarationPart
}

func (*ErrorRecordDeclarationPartContext) IsErrorRecordDeclarationPartContext() {}

func NewErrorRecordDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorRecordDeclarationPartContext {
	var p = new(ErrorRecordDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_errorRecordDeclarationPart

	return p
}

func (s *ErrorRecordDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorRecordDeclarationPartContext) AllSTRICT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTRICT)
}

func (s *ErrorRecordDeclarationPartContext) STRICT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTRICT, i)
}

func (s *ErrorRecordDeclarationPartContext) AllPRIVATE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPRIVATE)
}

func (s *ErrorRecordDeclarationPartContext) PRIVATE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPRIVATE, i)
}

func (s *ErrorRecordDeclarationPartContext) AllPROTECTED() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPROTECTED)
}

func (s *ErrorRecordDeclarationPartContext) PROTECTED(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPROTECTED, i)
}

func (s *ErrorRecordDeclarationPartContext) AllPUBLIC() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPUBLIC)
}

func (s *ErrorRecordDeclarationPartContext) PUBLIC(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLIC, i)
}

func (s *ErrorRecordDeclarationPartContext) AllPUBLISHED() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPUBLISHED)
}

func (s *ErrorRecordDeclarationPartContext) PUBLISHED(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLISHED, i)
}

func (s *ErrorRecordDeclarationPartContext) AllEND() []antlr.TerminalNode {
	return s.GetTokens(pascalParserEND)
}

func (s *ErrorRecordDeclarationPartContext) END(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserEND, i)
}

func (s *ErrorRecordDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorRecordDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorRecordDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterErrorRecordDeclarationPart(s)
	}
}

func (s *ErrorRecordDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitErrorRecordDeclarationPart(s)
	}
}

func (s *ErrorRecordDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitErrorRecordDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ErrorRecordDeclarationPart() (localctx IErrorRecordDeclarationPartContext) {
	localctx = NewErrorRecordDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, pascalParserRULE_errorRecordDeclarationPart)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(952)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(951)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || _la == pascalParserEND || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&31) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(954)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordPartsContext is an interface to support dynamic dispatch.
type IRecordPartsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RecordFixedPart() IRecordFixedPartContext
	SEMI() antlr.TerminalNode
	RecordVariantPart() IRecordVariantPartContext

	// IsRecordPartsContext differentiates from other interfaces.
	IsRecordPartsContext()
}

type RecordPartsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordPartsContext() *RecordPartsContext {
	var p = new(RecordPartsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordParts
	return p
}

func InitEmptyRecordPartsContext(p *RecordPartsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordParts
}

func (*RecordPartsContext) IsRecordPartsContext() {}

func NewRecordPartsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordPartsContext {
	var p = new(RecordPartsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordParts

	return p
}

func (s *RecordPartsContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordPartsContext) RecordFixedPart() IRecordFixedPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordFixedPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordFixedPartContext)
}

func (s *RecordPartsContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *RecordPartsContext) RecordVariantPart() IRecordVariantPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordVariantPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordVariantPartContext)
}

func (s *RecordPartsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordPartsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordPartsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordParts(s)
	}
}

func (s *RecordPartsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordParts(s)
	}
}

func (s *RecordPartsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordParts(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordParts() (localctx IRecordPartsContext) {
	localctx = NewRecordPartsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, pascalParserRULE_recordParts)
	var _la int

	p.SetState(962)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(956)
			p.RecordFixedPart()
		}
		p.SetState(959)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserSEMI {
			{
				p.SetState(957)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(958)
				p.RecordVariantPart()
			}

		}

	case pascalParserCASE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(961)
			p.RecordVariantPart()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordFixedPartContext is an interface to support dynamic dispatch.
type IRecordFixedPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypedIdentifierList() []ITypedIdentifierListContext
	TypedIdentifierList(i int) ITypedIdentifierListContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsRecordFixedPartContext differentiates from other interfaces.
	IsRecordFixedPartContext()
}

type RecordFixedPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordFixedPartContext() *RecordFixedPartContext {
	var p = new(RecordFixedPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordFixedPart
	return p
}

func InitEmptyRecordFixedPartContext(p *RecordFixedPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordFixedPart
}

func (*RecordFixedPartContext) IsRecordFixedPartContext() {}

func NewRecordFixedPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordFixedPartContext {
	var p = new(RecordFixedPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordFixedPart

	return p
}

func (s *RecordFixedPartContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordFixedPartContext) AllTypedIdentifierList() []ITypedIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypedIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]ITypedIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypedIdentifierListContext); ok {
			tst[i] = t.(ITypedIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *RecordFixedPartContext) TypedIdentifierList(i int) ITypedIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIdentifierListContext)
}

func (s *RecordFixedPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *RecordFixedPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *RecordFixedPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordFixedPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordFixedPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordFixedPart(s)
	}
}

func (s *RecordFixedPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordFixedPart(s)
	}
}

func (s *RecordFixedPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordFixedPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordFixedPart() (localctx IRecordFixedPartContext) {
	localctx = NewRecordFixedPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, pascalParserRULE_recordFixedPart)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(964)
		p.TypedIdentifierList()
	}
	p.SetState(969)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(965)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(966)
				p.TypedIdentifierList()
			}

		}
		p.SetState(971)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(973)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(972)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordVariantPartContext is an interface to support dynamic dispatch.
type IRecordVariantPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	Tag() ITagContext
	OF() antlr.TerminalNode
	AllRecordVariant() []IRecordVariantContext
	RecordVariant(i int) IRecordVariantContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsRecordVariantPartContext differentiates from other interfaces.
	IsRecordVariantPartContext()
}

type RecordVariantPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordVariantPartContext() *RecordVariantPartContext {
	var p = new(RecordVariantPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordVariantPart
	return p
}

func InitEmptyRecordVariantPartContext(p *RecordVariantPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordVariantPart
}

func (*RecordVariantPartContext) IsRecordVariantPartContext() {}

func NewRecordVariantPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordVariantPartContext {
	var p = new(RecordVariantPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordVariantPart

	return p
}

func (s *RecordVariantPartContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordVariantPartContext) CASE() antlr.TerminalNode {
	return s.GetToken(pascalParserCASE, 0)
}

func (s *RecordVariantPartContext) Tag() ITagContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITagContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITagContext)
}

func (s *RecordVariantPartContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *RecordVariantPartContext) AllRecordVariant() []IRecordVariantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordVariantContext); ok {
			len++
		}
	}

	tst := make([]IRecordVariantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordVariantContext); ok {
			tst[i] = t.(IRecordVariantContext)
			i++
		}
	}

	return tst
}

func (s *RecordVariantPartContext) RecordVariant(i int) IRecordVariantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordVariantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordVariantContext)
}

func (s *RecordVariantPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *RecordVariantPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *RecordVariantPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordVariantPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordVariantPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordVariantPart(s)
	}
}

func (s *RecordVariantPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordVariantPart(s)
	}
}

func (s *RecordVariantPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordVariantPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordVariantPart() (localctx IRecordVariantPartContext) {
	localctx = NewRecordVariantPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, pascalParserRULE_recordVariantPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(975)
		p.Match(pascalParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(976)
		p.Tag()
	}
	{
		p.SetState(977)
		p.Match(pascalParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(978)
		p.RecordVariant()
	}
	p.SetState(983)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserSEMI {
		{
			p.SetState(979)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(980)
			p.RecordVariant()
		}

		p.SetState(985)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITagContext is an interface to support dynamic dispatch.
type ITagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext

	// IsTagContext differentiates from other interfaces.
	IsTagContext()
}

type TagContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTagContext() *TagContext {
	var p = new(TagContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tag
	return p
}

func InitEmptyTagContext(p *TagContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tag
}

func (*TagContext) IsTagContext() {}

func NewTagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TagContext {
	var p = new(TagContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_tag

	return p
}

func (s *TagContext) GetParser() antlr.Parser { return s.parser }

func (s *TagContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TagContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *TagContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *TagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTag(s)
	}
}

func (s *TagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTag(s)
	}
}

func (s *TagContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTag(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Tag() (localctx ITagContext) {
	localctx = NewTagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, pascalParserRULE_tag)
	p.SetState(991)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(986)
			p.Identifier()
		}
		{
			p.SetState(987)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(988)
			p.TypeIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(990)
			p.TypeIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordVariantContext is an interface to support dynamic dispatch.
type IRecordVariantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConstList() IConstListContext
	COLON() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RecordParts() IRecordPartsContext
	RPAREN() antlr.TerminalNode

	// IsRecordVariantContext differentiates from other interfaces.
	IsRecordVariantContext()
}

type RecordVariantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordVariantContext() *RecordVariantContext {
	var p = new(RecordVariantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordVariant
	return p
}

func InitEmptyRecordVariantContext(p *RecordVariantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordVariant
}

func (*RecordVariantContext) IsRecordVariantContext() {}

func NewRecordVariantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordVariantContext {
	var p = new(RecordVariantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordVariant

	return p
}

func (s *RecordVariantContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordVariantContext) ConstList() IConstListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstListContext)
}

func (s *RecordVariantContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *RecordVariantContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *RecordVariantContext) RecordParts() IRecordPartsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordPartsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordPartsContext)
}

func (s *RecordVariantContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *RecordVariantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordVariantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordVariantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordVariant(s)
	}
}

func (s *RecordVariantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordVariant(s)
	}
}

func (s *RecordVariantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordVariant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordVariant() (localctx IRecordVariantContext) {
	localctx = NewRecordVariantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, pascalParserRULE_recordVariant)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(993)
		p.ConstList()
	}
	{
		p.SetState(994)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(995)
		p.Match(pascalParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(996)
		p.RecordParts()
	}
	{
		p.SetState(997)
		p.Match(pascalParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHelperTypeContext is an interface to support dynamic dispatch.
type IHelperTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	HELPER() antlr.TerminalNode
	FOR() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	HelperImplicitPublishedDeclaration() IHelperImplicitPublishedDeclarationContext
	END() antlr.TerminalNode
	AllHelperDeclaration() []IHelperDeclarationContext
	HelperDeclaration(i int) IHelperDeclarationContext

	// IsHelperTypeContext differentiates from other interfaces.
	IsHelperTypeContext()
}

type HelperTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelperTypeContext() *HelperTypeContext {
	var p = new(HelperTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperType
	return p
}

func InitEmptyHelperTypeContext(p *HelperTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperType
}

func (*HelperTypeContext) IsHelperTypeContext() {}

func NewHelperTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelperTypeContext {
	var p = new(HelperTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_helperType

	return p
}

func (s *HelperTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *HelperTypeContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *HelperTypeContext) HELPER() antlr.TerminalNode {
	return s.GetToken(pascalParserHELPER, 0)
}

func (s *HelperTypeContext) FOR() antlr.TerminalNode {
	return s.GetToken(pascalParserFOR, 0)
}

func (s *HelperTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *HelperTypeContext) HelperImplicitPublishedDeclaration() IHelperImplicitPublishedDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelperImplicitPublishedDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelperImplicitPublishedDeclarationContext)
}

func (s *HelperTypeContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *HelperTypeContext) AllHelperDeclaration() []IHelperDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHelperDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IHelperDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHelperDeclarationContext); ok {
			tst[i] = t.(IHelperDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *HelperTypeContext) HelperDeclaration(i int) IHelperDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelperDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelperDeclarationContext)
}

func (s *HelperTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelperTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelperTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterHelperType(s)
	}
}

func (s *HelperTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitHelperType(s)
	}
}

func (s *HelperTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitHelperType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) HelperType() (localctx IHelperTypeContext) {
	localctx = NewHelperTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, pascalParserRULE_helperType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(999)
		p.Match(pascalParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1000)
		p.Match(pascalParserHELPER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1001)
		p.Match(pascalParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1002)
		p.TypeIdentifier()
	}
	{
		p.SetState(1003)
		p.HelperImplicitPublishedDeclaration()
	}
	p.SetState(1007)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&31) != 0 {
		{
			p.SetState(1004)
			p.HelperDeclaration()
		}

		p.SetState(1009)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1010)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHelperDeclarationContext is an interface to support dynamic dispatch.
type IHelperDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AccessSpecifier() IAccessSpecifierContext
	AllHelperDeclarationPart() []IHelperDeclarationPartContext
	HelperDeclarationPart(i int) IHelperDeclarationPartContext

	// IsHelperDeclarationContext differentiates from other interfaces.
	IsHelperDeclarationContext()
}

type HelperDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelperDeclarationContext() *HelperDeclarationContext {
	var p = new(HelperDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperDeclaration
	return p
}

func InitEmptyHelperDeclarationContext(p *HelperDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperDeclaration
}

func (*HelperDeclarationContext) IsHelperDeclarationContext() {}

func NewHelperDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelperDeclarationContext {
	var p = new(HelperDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_helperDeclaration

	return p
}

func (s *HelperDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *HelperDeclarationContext) AccessSpecifier() IAccessSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessSpecifierContext)
}

func (s *HelperDeclarationContext) AllHelperDeclarationPart() []IHelperDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHelperDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IHelperDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHelperDeclarationPartContext); ok {
			tst[i] = t.(IHelperDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *HelperDeclarationContext) HelperDeclarationPart(i int) IHelperDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelperDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelperDeclarationPartContext)
}

func (s *HelperDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelperDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelperDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterHelperDeclaration(s)
	}
}

func (s *HelperDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitHelperDeclaration(s)
	}
}

func (s *HelperDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitHelperDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) HelperDeclaration() (localctx IHelperDeclarationContext) {
	localctx = NewHelperDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, pascalParserRULE_helperDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1012)
		p.AccessSpecifier()
	}
	p.SetState(1016)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-8193) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-253953) != 0) {
		{
			p.SetState(1013)
			p.HelperDeclarationPart()
		}

		p.SetState(1018)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHelperImplicitPublishedDeclarationContext is an interface to support dynamic dispatch.
type IHelperImplicitPublishedDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllHelperDeclarationPart() []IHelperDeclarationPartContext
	HelperDeclarationPart(i int) IHelperDeclarationPartContext

	// IsHelperImplicitPublishedDeclarationContext differentiates from other interfaces.
	IsHelperImplicitPublishedDeclarationContext()
}

type HelperImplicitPublishedDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelperImplicitPublishedDeclarationContext() *HelperImplicitPublishedDeclarationContext {
	var p = new(HelperImplicitPublishedDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperImplicitPublishedDeclaration
	return p
}

func InitEmptyHelperImplicitPublishedDeclarationContext(p *HelperImplicitPublishedDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperImplicitPublishedDeclaration
}

func (*HelperImplicitPublishedDeclarationContext) IsHelperImplicitPublishedDeclarationContext() {}

func NewHelperImplicitPublishedDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelperImplicitPublishedDeclarationContext {
	var p = new(HelperImplicitPublishedDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_helperImplicitPublishedDeclaration

	return p
}

func (s *HelperImplicitPublishedDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *HelperImplicitPublishedDeclarationContext) AllHelperDeclarationPart() []IHelperDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHelperDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IHelperDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHelperDeclarationPartContext); ok {
			tst[i] = t.(IHelperDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *HelperImplicitPublishedDeclarationContext) HelperDeclarationPart(i int) IHelperDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelperDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelperDeclarationPartContext)
}

func (s *HelperImplicitPublishedDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelperImplicitPublishedDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelperImplicitPublishedDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterHelperImplicitPublishedDeclaration(s)
	}
}

func (s *HelperImplicitPublishedDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitHelperImplicitPublishedDeclaration(s)
	}
}

func (s *HelperImplicitPublishedDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitHelperImplicitPublishedDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) HelperImplicitPublishedDeclaration() (localctx IHelperImplicitPublishedDeclarationContext) {
	localctx = NewHelperImplicitPublishedDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, pascalParserRULE_helperImplicitPublishedDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1022)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-8193) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-253953) != 0) {
		{
			p.SetState(1019)
			p.HelperDeclarationPart()
		}

		p.SetState(1024)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHelperDeclarationPartContext is an interface to support dynamic dispatch.
type IHelperDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeDefinitionPart() ITypeDefinitionPartContext
	ConstantDefinitionPart() IConstantDefinitionPartContext
	FunctionHeader() IFunctionHeaderContext
	ProcedureHeader() IProcedureHeaderContext
	PropertyDeclaration() IPropertyDeclarationContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	ErrorHelperDeclarationPart() IErrorHelperDeclarationPartContext

	// IsHelperDeclarationPartContext differentiates from other interfaces.
	IsHelperDeclarationPartContext()
}

type HelperDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelperDeclarationPartContext() *HelperDeclarationPartContext {
	var p = new(HelperDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperDeclarationPart
	return p
}

func InitEmptyHelperDeclarationPartContext(p *HelperDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperDeclarationPart
}

func (*HelperDeclarationPartContext) IsHelperDeclarationPartContext() {}

func NewHelperDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelperDeclarationPartContext {
	var p = new(HelperDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_helperDeclarationPart

	return p
}

func (s *HelperDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *HelperDeclarationPartContext) TypeDefinitionPart() ITypeDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionPartContext)
}

func (s *HelperDeclarationPartContext) ConstantDefinitionPart() IConstantDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *HelperDeclarationPartContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *HelperDeclarationPartContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *HelperDeclarationPartContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *HelperDeclarationPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *HelperDeclarationPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *HelperDeclarationPartContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *HelperDeclarationPartContext) ErrorHelperDeclarationPart() IErrorHelperDeclarationPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorHelperDeclarationPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorHelperDeclarationPartContext)
}

func (s *HelperDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelperDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelperDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterHelperDeclarationPart(s)
	}
}

func (s *HelperDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitHelperDeclarationPart(s)
	}
}

func (s *HelperDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitHelperDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) HelperDeclarationPart() (localctx IHelperDeclarationPartContext) {
	localctx = NewHelperDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, pascalParserRULE_helperDeclarationPart)
	p.SetState(1038)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1025)
			p.TypeDefinitionPart()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1026)
			p.ConstantDefinitionPart()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1027)
			p.FunctionHeader()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1028)
			p.ProcedureHeader()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1029)
			p.PropertyDeclaration()
		}
		{
			p.SetState(1030)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1033)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1031)
				p.Match(pascalParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1032)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1035)
			p.ErrorHelperDeclarationPart()
		}
		{
			p.SetState(1036)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorHelperDeclarationPartContext is an interface to support dynamic dispatch.
type IErrorHelperDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRICT() []antlr.TerminalNode
	STRICT(i int) antlr.TerminalNode
	AllPRIVATE() []antlr.TerminalNode
	PRIVATE(i int) antlr.TerminalNode
	AllPROTECTED() []antlr.TerminalNode
	PROTECTED(i int) antlr.TerminalNode
	AllPUBLIC() []antlr.TerminalNode
	PUBLIC(i int) antlr.TerminalNode
	AllPUBLISHED() []antlr.TerminalNode
	PUBLISHED(i int) antlr.TerminalNode
	AllEND() []antlr.TerminalNode
	END(i int) antlr.TerminalNode

	// IsErrorHelperDeclarationPartContext differentiates from other interfaces.
	IsErrorHelperDeclarationPartContext()
}

type ErrorHelperDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorHelperDeclarationPartContext() *ErrorHelperDeclarationPartContext {
	var p = new(ErrorHelperDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorHelperDeclarationPart
	return p
}

func InitEmptyErrorHelperDeclarationPartContext(p *ErrorHelperDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorHelperDeclarationPart
}

func (*ErrorHelperDeclarationPartContext) IsErrorHelperDeclarationPartContext() {}

func NewErrorHelperDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorHelperDeclarationPartContext {
	var p = new(ErrorHelperDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_errorHelperDeclarationPart

	return p
}

func (s *ErrorHelperDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorHelperDeclarationPartContext) AllSTRICT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTRICT)
}

func (s *ErrorHelperDeclarationPartContext) STRICT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTRICT, i)
}

func (s *ErrorHelperDeclarationPartContext) AllPRIVATE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPRIVATE)
}

func (s *ErrorHelperDeclarationPartContext) PRIVATE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPRIVATE, i)
}

func (s *ErrorHelperDeclarationPartContext) AllPROTECTED() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPROTECTED)
}

func (s *ErrorHelperDeclarationPartContext) PROTECTED(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPROTECTED, i)
}

func (s *ErrorHelperDeclarationPartContext) AllPUBLIC() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPUBLIC)
}

func (s *ErrorHelperDeclarationPartContext) PUBLIC(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLIC, i)
}

func (s *ErrorHelperDeclarationPartContext) AllPUBLISHED() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPUBLISHED)
}

func (s *ErrorHelperDeclarationPartContext) PUBLISHED(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLISHED, i)
}

func (s *ErrorHelperDeclarationPartContext) AllEND() []antlr.TerminalNode {
	return s.GetTokens(pascalParserEND)
}

func (s *ErrorHelperDeclarationPartContext) END(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserEND, i)
}

func (s *ErrorHelperDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorHelperDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorHelperDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterErrorHelperDeclarationPart(s)
	}
}

func (s *ErrorHelperDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitErrorHelperDeclarationPart(s)
	}
}

func (s *ErrorHelperDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitErrorHelperDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ErrorHelperDeclarationPart() (localctx IErrorHelperDeclarationPartContext) {
	localctx = NewErrorHelperDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, pascalParserRULE_errorHelperDeclarationPart)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1041)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1040)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || _la == pascalParserEND || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&31) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1043)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetTypeContext is an interface to support dynamic dispatch.
type ISetTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	OF() antlr.TerminalNode
	SimpleType() ISimpleTypeContext

	// IsSetTypeContext differentiates from other interfaces.
	IsSetTypeContext()
}

type SetTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetTypeContext() *SetTypeContext {
	var p = new(SetTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_setType
	return p
}

func InitEmptySetTypeContext(p *SetTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_setType
}

func (*SetTypeContext) IsSetTypeContext() {}

func NewSetTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetTypeContext {
	var p = new(SetTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_setType

	return p
}

func (s *SetTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SetTypeContext) SET() antlr.TerminalNode {
	return s.GetToken(pascalParserSET, 0)
}

func (s *SetTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *SetTypeContext) SimpleType() ISimpleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeContext)
}

func (s *SetTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSetType(s)
	}
}

func (s *SetTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSetType(s)
	}
}

func (s *SetTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSetType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SetType() (localctx ISetTypeContext) {
	localctx = NewSetTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, pascalParserRULE_setType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1045)
		p.Match(pascalParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1046)
		p.Match(pascalParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1047)
		p.SimpleType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFileTypeContext is an interface to support dynamic dispatch.
type IFileTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FILE() antlr.TerminalNode
	OF() antlr.TerminalNode
	Type_() IType_Context

	// IsFileTypeContext differentiates from other interfaces.
	IsFileTypeContext()
}

type FileTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileTypeContext() *FileTypeContext {
	var p = new(FileTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_fileType
	return p
}

func InitEmptyFileTypeContext(p *FileTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_fileType
}

func (*FileTypeContext) IsFileTypeContext() {}

func NewFileTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileTypeContext {
	var p = new(FileTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_fileType

	return p
}

func (s *FileTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FileTypeContext) FILE() antlr.TerminalNode {
	return s.GetToken(pascalParserFILE, 0)
}

func (s *FileTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *FileTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *FileTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFileType(s)
	}
}

func (s *FileTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFileType(s)
	}
}

func (s *FileTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFileType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FileType() (localctx IFileTypeContext) {
	localctx = NewFileTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, pascalParserRULE_fileType)
	p.SetState(1053)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1049)
			p.Match(pascalParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1050)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1051)
			p.Type_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1052)
			p.Match(pascalParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPointerTypeContext is an interface to support dynamic dispatch.
type IPointerTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEREFERENCE() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext

	// IsPointerTypeContext differentiates from other interfaces.
	IsPointerTypeContext()
}

type PointerTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPointerTypeContext() *PointerTypeContext {
	var p = new(PointerTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_pointerType
	return p
}

func InitEmptyPointerTypeContext(p *PointerTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_pointerType
}

func (*PointerTypeContext) IsPointerTypeContext() {}

func NewPointerTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PointerTypeContext {
	var p = new(PointerTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_pointerType

	return p
}

func (s *PointerTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PointerTypeContext) DEREFERENCE() antlr.TerminalNode {
	return s.GetToken(pascalParserDEREFERENCE, 0)
}

func (s *PointerTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *PointerTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PointerTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PointerTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPointerType(s)
	}
}

func (s *PointerTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPointerType(s)
	}
}

func (s *PointerTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPointerType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PointerType() (localctx IPointerTypeContext) {
	localctx = NewPointerTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, pascalParserRULE_pointerType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1055)
		p.Match(pascalParserDEREFERENCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1056)
		p.TypeIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationPartContext is an interface to support dynamic dispatch.
type IVariableDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VAR() antlr.TerminalNode
	AllVariableDeclaration() []IVariableDeclarationContext
	VariableDeclaration(i int) IVariableDeclarationContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsVariableDeclarationPartContext differentiates from other interfaces.
	IsVariableDeclarationPartContext()
}

type VariableDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationPartContext() *VariableDeclarationPartContext {
	var p = new(VariableDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclarationPart
	return p
}

func InitEmptyVariableDeclarationPartContext(p *VariableDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclarationPart
}

func (*VariableDeclarationPartContext) IsVariableDeclarationPartContext() {}

func NewVariableDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationPartContext {
	var p = new(VariableDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_variableDeclarationPart

	return p
}

func (s *VariableDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationPartContext) VAR() antlr.TerminalNode {
	return s.GetToken(pascalParserVAR, 0)
}

func (s *VariableDeclarationPartContext) AllVariableDeclaration() []IVariableDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationContext); ok {
			tst[i] = t.(IVariableDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclarationPartContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *VariableDeclarationPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *VariableDeclarationPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *VariableDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterVariableDeclarationPart(s)
	}
}

func (s *VariableDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitVariableDeclarationPart(s)
	}
}

func (s *VariableDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitVariableDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) VariableDeclarationPart() (localctx IVariableDeclarationPartContext) {
	localctx = NewVariableDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, pascalParserRULE_variableDeclarationPart)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1058)
		p.Match(pascalParserVAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1059)
		p.VariableDeclaration()
	}
	p.SetState(1064)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1060)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1061)
				p.VariableDeclaration()
			}

		}
		p.SetState(1066)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1067)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypedIdentifierList() ITypedIdentifierListContext
	AttributeSection() IAttributeSectionContext
	EQUAL() antlr.TerminalNode
	SimpleExpression() ISimpleExpressionContext

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclaration
	return p
}

func InitEmptyVariableDeclarationContext(p *VariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclaration
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) TypedIdentifierList() ITypedIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIdentifierListContext)
}

func (s *VariableDeclarationContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *VariableDeclarationContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *VariableDeclarationContext) SimpleExpression() ISimpleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExpressionContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitVariableDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, pascalParserRULE_variableDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1070)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLBRACK {
		{
			p.SetState(1069)
			p.AttributeSection()
		}

	}
	{
		p.SetState(1072)
		p.TypedIdentifierList()
	}
	p.SetState(1075)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserEQUAL {
		{
			p.SetState(1073)
			p.Match(pascalParserEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1074)
			p.SimpleExpression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureHeaderContext is an interface to support dynamic dispatch.
type IProcedureHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext
	SEMI() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	CONSTRUCTOR() antlr.TerminalNode
	DESTRUCTOR() antlr.TerminalNode
	AttributeSection() IAttributeSectionContext
	CLASS() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext

	// IsProcedureHeaderContext differentiates from other interfaces.
	IsProcedureHeaderContext()
}

type ProcedureHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureHeaderContext() *ProcedureHeaderContext {
	var p = new(ProcedureHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureHeader
	return p
}

func InitEmptyProcedureHeaderContext(p *ProcedureHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureHeader
}

func (*ProcedureHeaderContext) IsProcedureHeaderContext() {}

func NewProcedureHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureHeaderContext {
	var p = new(ProcedureHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureHeader

	return p
}

func (s *ProcedureHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureHeaderContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ProcedureHeaderContext) ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderModifiersContext)
}

func (s *ProcedureHeaderContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ProcedureHeaderContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(pascalParserPROCEDURE, 0)
}

func (s *ProcedureHeaderContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(pascalParserCONSTRUCTOR, 0)
}

func (s *ProcedureHeaderContext) DESTRUCTOR() antlr.TerminalNode {
	return s.GetToken(pascalParserDESTRUCTOR, 0)
}

func (s *ProcedureHeaderContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *ProcedureHeaderContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *ProcedureHeaderContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ProcedureHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureHeader(s)
	}
}

func (s *ProcedureHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureHeader(s)
	}
}

func (s *ProcedureHeaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureHeader(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureHeader() (localctx IProcedureHeaderContext) {
	localctx = NewProcedureHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, pascalParserRULE_procedureHeader)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1078)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLBRACK {
		{
			p.SetState(1077)
			p.AttributeSection()
		}

	}
	p.SetState(1081)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserCLASS {
		{
			p.SetState(1080)
			p.Match(pascalParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1083)
		_la = p.GetTokenStream().LA(1)

		if !(_la == pascalParserPROCEDURE || _la == pascalParserCONSTRUCTOR || _la == pascalParserDESTRUCTOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1084)
		p.Identifier()
	}
	p.SetState(1086)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1085)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1088)
		p.ProcedureOrFunctionHeaderModifiers()
	}
	{
		p.SetState(1089)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionHeaderContext is an interface to support dynamic dispatch.
type IFunctionHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNCTION() antlr.TerminalNode
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	ResultType() IResultTypeContext
	ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext
	SEMI() antlr.TerminalNode
	AttributeSection() IAttributeSectionContext
	CLASS() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext

	// IsFunctionHeaderContext differentiates from other interfaces.
	IsFunctionHeaderContext()
}

type FunctionHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionHeaderContext() *FunctionHeaderContext {
	var p = new(FunctionHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionHeader
	return p
}

func InitEmptyFunctionHeaderContext(p *FunctionHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionHeader
}

func (*FunctionHeaderContext) IsFunctionHeaderContext() {}

func NewFunctionHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionHeaderContext {
	var p = new(FunctionHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_functionHeader

	return p
}

func (s *FunctionHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionHeaderContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(pascalParserFUNCTION, 0)
}

func (s *FunctionHeaderContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionHeaderContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *FunctionHeaderContext) ResultType() IResultTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultTypeContext)
}

func (s *FunctionHeaderContext) ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderModifiersContext)
}

func (s *FunctionHeaderContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *FunctionHeaderContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *FunctionHeaderContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *FunctionHeaderContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFunctionHeader(s)
	}
}

func (s *FunctionHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFunctionHeader(s)
	}
}

func (s *FunctionHeaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFunctionHeader(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FunctionHeader() (localctx IFunctionHeaderContext) {
	localctx = NewFunctionHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, pascalParserRULE_functionHeader)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1092)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLBRACK {
		{
			p.SetState(1091)
			p.AttributeSection()
		}

	}
	p.SetState(1095)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserCLASS {
		{
			p.SetState(1094)
			p.Match(pascalParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1097)
		p.Match(pascalParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1098)
		p.Identifier()
	}
	p.SetState(1100)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1099)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1102)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1103)
		p.ResultType()
	}
	{
		p.SetState(1104)
		p.ProcedureOrFunctionHeaderModifiers()
	}
	{
		p.SetState(1105)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureOrFunctionHeaderContext is an interface to support dynamic dispatch.
type IProcedureOrFunctionHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ProcedureHeader() IProcedureHeaderContext
	FunctionHeader() IFunctionHeaderContext

	// IsProcedureOrFunctionHeaderContext differentiates from other interfaces.
	IsProcedureOrFunctionHeaderContext()
}

type ProcedureOrFunctionHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureOrFunctionHeaderContext() *ProcedureOrFunctionHeaderContext {
	var p = new(ProcedureOrFunctionHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeader
	return p
}

func InitEmptyProcedureOrFunctionHeaderContext(p *ProcedureOrFunctionHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeader
}

func (*ProcedureOrFunctionHeaderContext) IsProcedureOrFunctionHeaderContext() {}

func NewProcedureOrFunctionHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureOrFunctionHeaderContext {
	var p = new(ProcedureOrFunctionHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeader

	return p
}

func (s *ProcedureOrFunctionHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureOrFunctionHeaderContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *ProcedureOrFunctionHeaderContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *ProcedureOrFunctionHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureOrFunctionHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureOrFunctionHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureOrFunctionHeader(s)
	}
}

func (s *ProcedureOrFunctionHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureOrFunctionHeader(s)
	}
}

func (s *ProcedureOrFunctionHeaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureOrFunctionHeader(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureOrFunctionHeader() (localctx IProcedureOrFunctionHeaderContext) {
	localctx = NewProcedureOrFunctionHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, pascalParserRULE_procedureOrFunctionHeader)
	p.SetState(1109)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1107)
			p.ProcedureHeader()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1108)
			p.FunctionHeader()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureOrFunctionHeaderModifiersContext is an interface to support dynamic dispatch.
type IProcedureOrFunctionHeaderModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AllABSTRACT() []antlr.TerminalNode
	ABSTRACT(i int) antlr.TerminalNode
	AllVIRTUAL() []antlr.TerminalNode
	VIRTUAL(i int) antlr.TerminalNode
	AllOVERRIDE() []antlr.TerminalNode
	OVERRIDE(i int) antlr.TerminalNode
	AllREINTRODUCE() []antlr.TerminalNode
	REINTRODUCE(i int) antlr.TerminalNode
	AllOVERLOAD() []antlr.TerminalNode
	OVERLOAD(i int) antlr.TerminalNode
	AllINLINE() []antlr.TerminalNode
	INLINE(i int) antlr.TerminalNode
	AllSTDCALL() []antlr.TerminalNode
	STDCALL(i int) antlr.TerminalNode
	AllCDECL() []antlr.TerminalNode
	CDECL(i int) antlr.TerminalNode
	AllSTATIC() []antlr.TerminalNode
	STATIC(i int) antlr.TerminalNode

	// IsProcedureOrFunctionHeaderModifiersContext differentiates from other interfaces.
	IsProcedureOrFunctionHeaderModifiersContext()
}

type ProcedureOrFunctionHeaderModifiersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureOrFunctionHeaderModifiersContext() *ProcedureOrFunctionHeaderModifiersContext {
	var p = new(ProcedureOrFunctionHeaderModifiersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeaderModifiers
	return p
}

func InitEmptyProcedureOrFunctionHeaderModifiersContext(p *ProcedureOrFunctionHeaderModifiersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeaderModifiers
}

func (*ProcedureOrFunctionHeaderModifiersContext) IsProcedureOrFunctionHeaderModifiersContext() {}

func NewProcedureOrFunctionHeaderModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureOrFunctionHeaderModifiersContext {
	var p = new(ProcedureOrFunctionHeaderModifiersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeaderModifiers

	return p
}

func (s *ProcedureOrFunctionHeaderModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureOrFunctionHeaderModifiersContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllABSTRACT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserABSTRACT)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) ABSTRACT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserABSTRACT, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllVIRTUAL() []antlr.TerminalNode {
	return s.GetTokens(pascalParserVIRTUAL)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) VIRTUAL(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserVIRTUAL, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllOVERRIDE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserOVERRIDE)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) OVERRIDE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserOVERRIDE, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllREINTRODUCE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserREINTRODUCE)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) REINTRODUCE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserREINTRODUCE, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllOVERLOAD() []antlr.TerminalNode {
	return s.GetTokens(pascalParserOVERLOAD)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) OVERLOAD(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserOVERLOAD, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllINLINE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserINLINE)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) INLINE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserINLINE, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllSTDCALL() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTDCALL)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) STDCALL(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTDCALL, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllCDECL() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCDECL)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) CDECL(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCDECL, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllSTATIC() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTATIC)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) STATIC(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTATIC, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureOrFunctionHeaderModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureOrFunctionHeaderModifiers(s)
	}
}

func (s *ProcedureOrFunctionHeaderModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureOrFunctionHeaderModifiers(s)
	}
}

func (s *ProcedureOrFunctionHeaderModifiersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureOrFunctionHeaderModifiers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureOrFunctionHeaderModifiers() (localctx IProcedureOrFunctionHeaderModifiersContext) {
	localctx = NewProcedureOrFunctionHeaderModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, pascalParserRULE_procedureOrFunctionHeaderModifiers)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1115)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 111, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1111)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1112)
				_la = p.GetTokenStream().LA(1)

				if !((int64((_la-97)) & ^0x3f) == 0 && ((int64(1)<<(_la-97))&511) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1117)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 111, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureOrFunctionDeclarationContext is an interface to support dynamic dispatch.
type IProcedureOrFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ProcedureDeclaration() IProcedureDeclarationContext
	FunctionDeclaration() IFunctionDeclarationContext

	// IsProcedureOrFunctionDeclarationContext differentiates from other interfaces.
	IsProcedureOrFunctionDeclarationContext()
}

type ProcedureOrFunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureOrFunctionDeclarationContext() *ProcedureOrFunctionDeclarationContext {
	var p = new(ProcedureOrFunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionDeclaration
	return p
}

func InitEmptyProcedureOrFunctionDeclarationContext(p *ProcedureOrFunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionDeclaration
}

func (*ProcedureOrFunctionDeclarationContext) IsProcedureOrFunctionDeclarationContext() {}

func NewProcedureOrFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureOrFunctionDeclarationContext {
	var p = new(ProcedureOrFunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureOrFunctionDeclaration

	return p
}

func (s *ProcedureOrFunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureOrFunctionDeclarationContext) ProcedureDeclaration() IProcedureDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureDeclarationContext)
}

func (s *ProcedureOrFunctionDeclarationContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *ProcedureOrFunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureOrFunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureOrFunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureOrFunctionDeclaration(s)
	}
}

func (s *ProcedureOrFunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureOrFunctionDeclaration(s)
	}
}

func (s *ProcedureOrFunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureOrFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureOrFunctionDeclaration() (localctx IProcedureOrFunctionDeclarationContext) {
	localctx = NewProcedureOrFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, pascalParserRULE_procedureOrFunctionDeclaration)
	p.SetState(1120)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1118)
			p.ProcedureDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1119)
			p.FunctionDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureDeclarationContext is an interface to support dynamic dispatch.
type IProcedureDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ProcedureHeader() IProcedureHeaderContext
	ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext
	SEMI() antlr.TerminalNode

	// IsProcedureDeclarationContext differentiates from other interfaces.
	IsProcedureDeclarationContext()
}

type ProcedureDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDeclarationContext() *ProcedureDeclarationContext {
	var p = new(ProcedureDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureDeclaration
	return p
}

func InitEmptyProcedureDeclarationContext(p *ProcedureDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureDeclaration
}

func (*ProcedureDeclarationContext) IsProcedureDeclarationContext() {}

func NewProcedureDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDeclarationContext {
	var p = new(ProcedureDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureDeclaration

	return p
}

func (s *ProcedureDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDeclarationContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *ProcedureDeclarationContext) ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionBodyContext)
}

func (s *ProcedureDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ProcedureDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureDeclaration(s)
	}
}

func (s *ProcedureDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureDeclaration(s)
	}
}

func (s *ProcedureDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureDeclaration() (localctx IProcedureDeclarationContext) {
	localctx = NewProcedureDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, pascalParserRULE_procedureDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1122)
		p.ProcedureHeader()
	}
	{
		p.SetState(1123)
		p.ProcedureOrFunctionBody()
	}
	{
		p.SetState(1124)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionHeader() IFunctionHeaderContext
	ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext
	SEMI() antlr.TerminalNode

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionDeclaration
	return p
}

func InitEmptyFunctionDeclarationContext(p *FunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionDeclaration
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *FunctionDeclarationContext) ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionBodyContext)
}

func (s *FunctionDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, pascalParserRULE_functionDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1126)
		p.FunctionHeader()
	}
	{
		p.SetState(1127)
		p.ProcedureOrFunctionBody()
	}
	{
		p.SetState(1128)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureLambdaDeclarationContext is an interface to support dynamic dispatch.
type IProcedureLambdaDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROCEDURE() antlr.TerminalNode
	ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext
	FormalParameterList() IFormalParameterListContext

	// IsProcedureLambdaDeclarationContext differentiates from other interfaces.
	IsProcedureLambdaDeclarationContext()
}

type ProcedureLambdaDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureLambdaDeclarationContext() *ProcedureLambdaDeclarationContext {
	var p = new(ProcedureLambdaDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureLambdaDeclaration
	return p
}

func InitEmptyProcedureLambdaDeclarationContext(p *ProcedureLambdaDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureLambdaDeclaration
}

func (*ProcedureLambdaDeclarationContext) IsProcedureLambdaDeclarationContext() {}

func NewProcedureLambdaDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureLambdaDeclarationContext {
	var p = new(ProcedureLambdaDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureLambdaDeclaration

	return p
}

func (s *ProcedureLambdaDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureLambdaDeclarationContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(pascalParserPROCEDURE, 0)
}

func (s *ProcedureLambdaDeclarationContext) ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionBodyContext)
}

func (s *ProcedureLambdaDeclarationContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ProcedureLambdaDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureLambdaDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureLambdaDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureLambdaDeclaration(s)
	}
}

func (s *ProcedureLambdaDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureLambdaDeclaration(s)
	}
}

func (s *ProcedureLambdaDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureLambdaDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureLambdaDeclaration() (localctx IProcedureLambdaDeclarationContext) {
	localctx = NewProcedureLambdaDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, pascalParserRULE_procedureLambdaDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1130)
		p.Match(pascalParserPROCEDURE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1132)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1131)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1134)
		p.ProcedureOrFunctionBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionLambdaDeclarationContext is an interface to support dynamic dispatch.
type IFunctionLambdaDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNCTION() antlr.TerminalNode
	ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext
	COLON() antlr.TerminalNode
	ResultType() IResultTypeContext
	FormalParameterList() IFormalParameterListContext

	// IsFunctionLambdaDeclarationContext differentiates from other interfaces.
	IsFunctionLambdaDeclarationContext()
}

type FunctionLambdaDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionLambdaDeclarationContext() *FunctionLambdaDeclarationContext {
	var p = new(FunctionLambdaDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionLambdaDeclaration
	return p
}

func InitEmptyFunctionLambdaDeclarationContext(p *FunctionLambdaDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionLambdaDeclaration
}

func (*FunctionLambdaDeclarationContext) IsFunctionLambdaDeclarationContext() {}

func NewFunctionLambdaDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionLambdaDeclarationContext {
	var p = new(FunctionLambdaDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_functionLambdaDeclaration

	return p
}

func (s *FunctionLambdaDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionLambdaDeclarationContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(pascalParserFUNCTION, 0)
}

func (s *FunctionLambdaDeclarationContext) ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionBodyContext)
}

func (s *FunctionLambdaDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *FunctionLambdaDeclarationContext) ResultType() IResultTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultTypeContext)
}

func (s *FunctionLambdaDeclarationContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionLambdaDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionLambdaDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionLambdaDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFunctionLambdaDeclaration(s)
	}
}

func (s *FunctionLambdaDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFunctionLambdaDeclaration(s)
	}
}

func (s *FunctionLambdaDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFunctionLambdaDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FunctionLambdaDeclaration() (localctx IFunctionLambdaDeclarationContext) {
	localctx = NewFunctionLambdaDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, pascalParserRULE_functionLambdaDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1136)
		p.Match(pascalParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1138)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1137)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1140)
		p.ProcedureOrFunctionBody()
	}
	{
		p.SetState(1141)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1142)
		p.ResultType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResultTypeContext is an interface to support dynamic dispatch.
type IResultTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIdentifier() ITypeIdentifierContext

	// IsResultTypeContext differentiates from other interfaces.
	IsResultTypeContext()
}

type ResultTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResultTypeContext() *ResultTypeContext {
	var p = new(ResultTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resultType
	return p
}

func InitEmptyResultTypeContext(p *ResultTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resultType
}

func (*ResultTypeContext) IsResultTypeContext() {}

func NewResultTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResultTypeContext {
	var p = new(ResultTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_resultType

	return p
}

func (s *ResultTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ResultTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ResultTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResultTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResultTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterResultType(s)
	}
}

func (s *ResultTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitResultType(s)
	}
}

func (s *ResultTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitResultType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ResultType() (localctx IResultTypeContext) {
	localctx = NewResultTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, pascalParserRULE_resultType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1144)
		p.TypeIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureOrFunctionBodyContext is an interface to support dynamic dispatch.
type IProcedureOrFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	CompoundStatement() ICompoundStatementContext

	// IsProcedureOrFunctionBodyContext differentiates from other interfaces.
	IsProcedureOrFunctionBodyContext()
}

type ProcedureOrFunctionBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureOrFunctionBodyContext() *ProcedureOrFunctionBodyContext {
	var p = new(ProcedureOrFunctionBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionBody
	return p
}

func InitEmptyProcedureOrFunctionBodyContext(p *ProcedureOrFunctionBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionBody
}

func (*ProcedureOrFunctionBodyContext) IsProcedureOrFunctionBodyContext() {}

func NewProcedureOrFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureOrFunctionBodyContext {
	var p = new(ProcedureOrFunctionBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureOrFunctionBody

	return p
}

func (s *ProcedureOrFunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureOrFunctionBodyContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ProcedureOrFunctionBodyContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *ProcedureOrFunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureOrFunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureOrFunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureOrFunctionBody(s)
	}
}

func (s *ProcedureOrFunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureOrFunctionBody(s)
	}
}

func (s *ProcedureOrFunctionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureOrFunctionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureOrFunctionBody() (localctx IProcedureOrFunctionBodyContext) {
	localctx = NewProcedureOrFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, pascalParserRULE_procedureOrFunctionBody)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1146)
		p.Block()
	}
	{
		p.SetState(1147)
		p.CompoundStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassOperatorHeaderContext is an interface to support dynamic dispatch.
type IClassOperatorHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	OPERATOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	ResultType() IResultTypeContext
	ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext
	SEMI() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext

	// IsClassOperatorHeaderContext differentiates from other interfaces.
	IsClassOperatorHeaderContext()
}

type ClassOperatorHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOperatorHeaderContext() *ClassOperatorHeaderContext {
	var p = new(ClassOperatorHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classOperatorHeader
	return p
}

func InitEmptyClassOperatorHeaderContext(p *ClassOperatorHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classOperatorHeader
}

func (*ClassOperatorHeaderContext) IsClassOperatorHeaderContext() {}

func NewClassOperatorHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOperatorHeaderContext {
	var p = new(ClassOperatorHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classOperatorHeader

	return p
}

func (s *ClassOperatorHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOperatorHeaderContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *ClassOperatorHeaderContext) OPERATOR() antlr.TerminalNode {
	return s.GetToken(pascalParserOPERATOR, 0)
}

func (s *ClassOperatorHeaderContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassOperatorHeaderContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *ClassOperatorHeaderContext) ResultType() IResultTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultTypeContext)
}

func (s *ClassOperatorHeaderContext) ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderModifiersContext)
}

func (s *ClassOperatorHeaderContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ClassOperatorHeaderContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ClassOperatorHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOperatorHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOperatorHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassOperatorHeader(s)
	}
}

func (s *ClassOperatorHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassOperatorHeader(s)
	}
}

func (s *ClassOperatorHeaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassOperatorHeader(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassOperatorHeader() (localctx IClassOperatorHeaderContext) {
	localctx = NewClassOperatorHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, pascalParserRULE_classOperatorHeader)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1149)
		p.Match(pascalParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1150)
		p.Match(pascalParserOPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1151)
		p.Identifier()
	}
	p.SetState(1153)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1152)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1155)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1156)
		p.ResultType()
	}
	{
		p.SetState(1157)
		p.ProcedureOrFunctionHeaderModifiers()
	}
	{
		p.SetState(1158)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassOperatorDeclarationContext is an interface to support dynamic dispatch.
type IClassOperatorDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassOperatorHeader() IClassOperatorHeaderContext
	ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext
	SEMI() antlr.TerminalNode

	// IsClassOperatorDeclarationContext differentiates from other interfaces.
	IsClassOperatorDeclarationContext()
}

type ClassOperatorDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOperatorDeclarationContext() *ClassOperatorDeclarationContext {
	var p = new(ClassOperatorDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classOperatorDeclaration
	return p
}

func InitEmptyClassOperatorDeclarationContext(p *ClassOperatorDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classOperatorDeclaration
}

func (*ClassOperatorDeclarationContext) IsClassOperatorDeclarationContext() {}

func NewClassOperatorDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOperatorDeclarationContext {
	var p = new(ClassOperatorDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classOperatorDeclaration

	return p
}

func (s *ClassOperatorDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOperatorDeclarationContext) ClassOperatorHeader() IClassOperatorHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOperatorHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOperatorHeaderContext)
}

func (s *ClassOperatorDeclarationContext) ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionBodyContext)
}

func (s *ClassOperatorDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ClassOperatorDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOperatorDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOperatorDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassOperatorDeclaration(s)
	}
}

func (s *ClassOperatorDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassOperatorDeclaration(s)
	}
}

func (s *ClassOperatorDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassOperatorDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassOperatorDeclaration() (localctx IClassOperatorDeclarationContext) {
	localctx = NewClassOperatorDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, pascalParserRULE_classOperatorDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1160)
		p.ClassOperatorHeader()
	}
	{
		p.SetState(1161)
		p.ProcedureOrFunctionBody()
	}
	{
		p.SetState(1162)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllFormalParameterSection() []IFormalParameterSectionContext
	FormalParameterSection(i int) IFormalParameterSectionContext
	RPAREN() antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_formalParameterList
	return p
}

func InitEmptyFormalParameterListContext(p *FormalParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_formalParameterList
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *FormalParameterListContext) AllFormalParameterSection() []IFormalParameterSectionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormalParameterSectionContext); ok {
			len++
		}
	}

	tst := make([]IFormalParameterSectionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormalParameterSectionContext); ok {
			tst[i] = t.(IFormalParameterSectionContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameterSection(i int) IFormalParameterSectionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterSectionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterSectionContext)
}

func (s *FormalParameterListContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *FormalParameterListContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *FormalParameterListContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFormalParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FormalParameterList() (localctx IFormalParameterListContext) {
	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, pascalParserRULE_formalParameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1164)
		p.Match(pascalParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1165)
		p.FormalParameterSection()
	}
	p.SetState(1170)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserSEMI {
		{
			p.SetState(1166)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1167)
			p.FormalParameterSection()
		}

		p.SetState(1172)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1173)
		p.Match(pascalParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterSectionContext is an interface to support dynamic dispatch.
type IFormalParameterSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParameterGroup() IParameterGroupContext
	AttributeSection() IAttributeSectionContext
	VAR() antlr.TerminalNode
	CONST() antlr.TerminalNode
	OUT() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode

	// IsFormalParameterSectionContext differentiates from other interfaces.
	IsFormalParameterSectionContext()
}

type FormalParameterSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterSectionContext() *FormalParameterSectionContext {
	var p = new(FormalParameterSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_formalParameterSection
	return p
}

func InitEmptyFormalParameterSectionContext(p *FormalParameterSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_formalParameterSection
}

func (*FormalParameterSectionContext) IsFormalParameterSectionContext() {}

func NewFormalParameterSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterSectionContext {
	var p = new(FormalParameterSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_formalParameterSection

	return p
}

func (s *FormalParameterSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterSectionContext) ParameterGroup() IParameterGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterGroupContext)
}

func (s *FormalParameterSectionContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *FormalParameterSectionContext) VAR() antlr.TerminalNode {
	return s.GetToken(pascalParserVAR, 0)
}

func (s *FormalParameterSectionContext) CONST() antlr.TerminalNode {
	return s.GetToken(pascalParserCONST, 0)
}

func (s *FormalParameterSectionContext) OUT() antlr.TerminalNode {
	return s.GetToken(pascalParserOUT, 0)
}

func (s *FormalParameterSectionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(pascalParserFUNCTION, 0)
}

func (s *FormalParameterSectionContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(pascalParserPROCEDURE, 0)
}

func (s *FormalParameterSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFormalParameterSection(s)
	}
}

func (s *FormalParameterSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFormalParameterSection(s)
	}
}

func (s *FormalParameterSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFormalParameterSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FormalParameterSection() (localctx IFormalParameterSectionContext) {
	localctx = NewFormalParameterSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, pascalParserRULE_formalParameterSection)
	var _la int

	p.SetState(1204)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1176)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1175)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1178)
			p.ParameterGroup()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1180)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1179)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1182)
			p.Match(pascalParserVAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1183)
			p.ParameterGroup()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1185)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1184)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1187)
			p.Match(pascalParserCONST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1188)
			p.ParameterGroup()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1190)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1189)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1192)
			p.Match(pascalParserOUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1193)
			p.ParameterGroup()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1195)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1194)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1197)
			p.Match(pascalParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1198)
			p.ParameterGroup()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1200)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1199)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1202)
			p.Match(pascalParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1203)
			p.ParameterGroup()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterGroupContext is an interface to support dynamic dispatch.
type IParameterGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierList() IIdentifierListContext
	COLON() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	DefaultValue() IDefaultValueContext

	// IsParameterGroupContext differentiates from other interfaces.
	IsParameterGroupContext()
}

type ParameterGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterGroupContext() *ParameterGroupContext {
	var p = new(ParameterGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterGroup
	return p
}

func InitEmptyParameterGroupContext(p *ParameterGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterGroup
}

func (*ParameterGroupContext) IsParameterGroupContext() {}

func NewParameterGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterGroupContext {
	var p = new(ParameterGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_parameterGroup

	return p
}

func (s *ParameterGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterGroupContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ParameterGroupContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *ParameterGroupContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ParameterGroupContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *ParameterGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterParameterGroup(s)
	}
}

func (s *ParameterGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitParameterGroup(s)
	}
}

func (s *ParameterGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitParameterGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ParameterGroup() (localctx IParameterGroupContext) {
	localctx = NewParameterGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, pascalParserRULE_parameterGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1206)
		p.IdentifierList()
	}
	p.SetState(1209)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserCOLON {
		{
			p.SetState(1207)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1208)
			p.TypeIdentifier()
		}

	}
	p.SetState(1212)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserEQUAL {
		{
			p.SetState(1211)
			p.DefaultValue()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifierList
	return p
}

func InitEmptyIdentifierListContext(p *IdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifierList
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierListContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *IdentifierListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (s *IdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, pascalParserRULE_identifierList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1214)
		p.Identifier()
	}
	p.SetState(1219)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1215)
				p.Match(pascalParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1216)
				p.Identifier()
			}

		}
		p.SetState(1221)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstListContext is an interface to support dynamic dispatch.
type IConstListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsConstListContext differentiates from other interfaces.
	IsConstListContext()
}

type ConstListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstListContext() *ConstListContext {
	var p = new(ConstListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constList
	return p
}

func InitEmptyConstListContext(p *ConstListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constList
}

func (*ConstListContext) IsConstListContext() {}

func NewConstListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstListContext {
	var p = new(ConstListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constList

	return p
}

func (s *ConstListContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstListContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *ConstListContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ConstListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ConstListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstList(s)
	}
}

func (s *ConstListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstList(s)
	}
}

func (s *ConstListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConstList() (localctx IConstListContext) {
	localctx = NewConstListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, pascalParserRULE_constList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1222)
		p.Constant()
	}
	p.SetState(1227)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(1223)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1224)
			p.Constant()
		}

		p.SetState(1229)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultValueContext is an interface to support dynamic dispatch.
type IDefaultValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsDefaultValueContext differentiates from other interfaces.
	IsDefaultValueContext()
}

type DefaultValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultValueContext() *DefaultValueContext {
	var p = new(DefaultValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_defaultValue
	return p
}

func InitEmptyDefaultValueContext(p *DefaultValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_defaultValue
}

func (*DefaultValueContext) IsDefaultValueContext() {}

func NewDefaultValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultValueContext {
	var p = new(DefaultValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_defaultValue

	return p
}

func (s *DefaultValueContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultValueContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *DefaultValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DefaultValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterDefaultValue(s)
	}
}

func (s *DefaultValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitDefaultValue(s)
	}
}

func (s *DefaultValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitDefaultValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) DefaultValue() (localctx IDefaultValueContext) {
	localctx = NewDefaultValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, pascalParserRULE_defaultValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1230)
		p.Match(pascalParserEQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1231)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypedIdentifierListContext is an interface to support dynamic dispatch.
type ITypedIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierList() IIdentifierListContext
	COLON() antlr.TerminalNode
	Type_() IType_Context

	// IsTypedIdentifierListContext differentiates from other interfaces.
	IsTypedIdentifierListContext()
}

type TypedIdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedIdentifierListContext() *TypedIdentifierListContext {
	var p = new(TypedIdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typedIdentifierList
	return p
}

func InitEmptyTypedIdentifierListContext(p *TypedIdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typedIdentifierList
}

func (*TypedIdentifierListContext) IsTypedIdentifierListContext() {}

func NewTypedIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedIdentifierListContext {
	var p = new(TypedIdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typedIdentifierList

	return p
}

func (s *TypedIdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedIdentifierListContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *TypedIdentifierListContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *TypedIdentifierListContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypedIdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedIdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedIdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypedIdentifierList(s)
	}
}

func (s *TypedIdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypedIdentifierList(s)
	}
}

func (s *TypedIdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypedIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypedIdentifierList() (localctx ITypedIdentifierListContext) {
	localctx = NewTypedIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, pascalParserRULE_typedIdentifierList)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1233)
		p.IdentifierList()
	}
	{
		p.SetState(1234)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1235)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Label() ILabelContext
	COLON() antlr.TerminalNode
	UnlabelledStatement() IUnlabelledStatementContext
	ErrorStatement() IErrorStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Label() ILabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *StatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *StatementContext) UnlabelledStatement() IUnlabelledStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnlabelledStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnlabelledStatementContext)
}

func (s *StatementContext) ErrorStatement() IErrorStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, pascalParserRULE_statement)
	p.SetState(1243)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 128, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1237)
			p.Label()
		}
		{
			p.SetState(1238)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1239)
			p.UnlabelledStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1241)
			p.UnlabelledStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1242)
			p.ErrorStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorStatementContext is an interface to support dynamic dispatch.
type IErrorStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEND() []antlr.TerminalNode
	END(i int) antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsErrorStatementContext differentiates from other interfaces.
	IsErrorStatementContext()
}

type ErrorStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorStatementContext() *ErrorStatementContext {
	var p = new(ErrorStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorStatement
	return p
}

func InitEmptyErrorStatementContext(p *ErrorStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorStatement
}

func (*ErrorStatementContext) IsErrorStatementContext() {}

func NewErrorStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorStatementContext {
	var p = new(ErrorStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_errorStatement

	return p
}

func (s *ErrorStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorStatementContext) AllEND() []antlr.TerminalNode {
	return s.GetTokens(pascalParserEND)
}

func (s *ErrorStatementContext) END(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserEND, i)
}

func (s *ErrorStatementContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ErrorStatementContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ErrorStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterErrorStatement(s)
	}
}

func (s *ErrorStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitErrorStatement(s)
	}
}

func (s *ErrorStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitErrorStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ErrorStatement() (localctx IErrorStatementContext) {
	localctx = NewErrorStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, pascalParserRULE_errorStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1246)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1245)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || _la == pascalParserEND || _la == pascalParserSEMI {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1248)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnlabelledStatementContext is an interface to support dynamic dispatch.
type IUnlabelledStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleStatement() ISimpleStatementContext
	StructuredStatement() IStructuredStatementContext

	// IsUnlabelledStatementContext differentiates from other interfaces.
	IsUnlabelledStatementContext()
}

type UnlabelledStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnlabelledStatementContext() *UnlabelledStatementContext {
	var p = new(UnlabelledStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unlabelledStatement
	return p
}

func InitEmptyUnlabelledStatementContext(p *UnlabelledStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unlabelledStatement
}

func (*UnlabelledStatementContext) IsUnlabelledStatementContext() {}

func NewUnlabelledStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnlabelledStatementContext {
	var p = new(UnlabelledStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unlabelledStatement

	return p
}

func (s *UnlabelledStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnlabelledStatementContext) SimpleStatement() ISimpleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStatementContext)
}

func (s *UnlabelledStatementContext) StructuredStatement() IStructuredStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructuredStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructuredStatementContext)
}

func (s *UnlabelledStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnlabelledStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnlabelledStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnlabelledStatement(s)
	}
}

func (s *UnlabelledStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnlabelledStatement(s)
	}
}

func (s *UnlabelledStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnlabelledStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnlabelledStatement() (localctx IUnlabelledStatementContext) {
	localctx = NewUnlabelledStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, pascalParserRULE_unlabelledStatement)
	p.SetState(1252)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserARRAY, pascalParserBOOLEAN, pascalParserCHAR, pascalParserELSE, pascalParserEND, pascalParserGOTO, pascalParserINTEGER, pascalParserREAL, pascalParserUNTIL, pascalParserVAR, pascalParserSEMI, pascalParserLPAREN, pascalParserAT, pascalParserSTRING, pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserFINALLY, pascalParserEXCEPT, pascalParserFINALIZATION, pascalParserINHERITED, pascalParserRAISE, pascalParserCARDINAL, pascalParserLONGBOOL, pascalParserLONGINT, pascalParserIDENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1250)
			p.SimpleStatement()
		}

	case pascalParserBEGIN, pascalParserCASE, pascalParserFOR, pascalParserIF, pascalParserREPEAT, pascalParserWHILE, pascalParserWITH, pascalParserTRY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1251)
			p.StructuredStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleStatementContext is an interface to support dynamic dispatch.
type ISimpleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssignmentStatement() IAssignmentStatementContext
	MethodCallStatement() IMethodCallStatementContext
	ProcedureStatement() IProcedureStatementContext
	GotoStatement() IGotoStatementContext
	InheritedStatement() IInheritedStatementContext
	TypeCast() ITypeCastContext
	EmptyStatement_() IEmptyStatement_Context
	RaiseExceptionStatement() IRaiseExceptionStatementContext
	VariableDeclarationStatement() IVariableDeclarationStatementContext

	// IsSimpleStatementContext differentiates from other interfaces.
	IsSimpleStatementContext()
}

type SimpleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleStatementContext() *SimpleStatementContext {
	var p = new(SimpleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleStatement
	return p
}

func InitEmptySimpleStatementContext(p *SimpleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleStatement
}

func (*SimpleStatementContext) IsSimpleStatementContext() {}

func NewSimpleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleStatementContext {
	var p = new(SimpleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_simpleStatement

	return p
}

func (s *SimpleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleStatementContext) AssignmentStatement() IAssignmentStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentStatementContext)
}

func (s *SimpleStatementContext) MethodCallStatement() IMethodCallStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodCallStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodCallStatementContext)
}

func (s *SimpleStatementContext) ProcedureStatement() IProcedureStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureStatementContext)
}

func (s *SimpleStatementContext) GotoStatement() IGotoStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGotoStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGotoStatementContext)
}

func (s *SimpleStatementContext) InheritedStatement() IInheritedStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInheritedStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInheritedStatementContext)
}

func (s *SimpleStatementContext) TypeCast() ITypeCastContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeCastContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeCastContext)
}

func (s *SimpleStatementContext) EmptyStatement_() IEmptyStatement_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatement_Context)
}

func (s *SimpleStatementContext) RaiseExceptionStatement() IRaiseExceptionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRaiseExceptionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRaiseExceptionStatementContext)
}

func (s *SimpleStatementContext) VariableDeclarationStatement() IVariableDeclarationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationStatementContext)
}

func (s *SimpleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSimpleStatement(s)
	}
}

func (s *SimpleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSimpleStatement(s)
	}
}

func (s *SimpleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSimpleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SimpleStatement() (localctx ISimpleStatementContext) {
	localctx = NewSimpleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, pascalParserRULE_simpleStatement)
	p.SetState(1263)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 131, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1254)
			p.AssignmentStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1255)
			p.MethodCallStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1256)
			p.ProcedureStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1257)
			p.GotoStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1258)
			p.InheritedStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1259)
			p.TypeCast()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1260)
			p.EmptyStatement_()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1261)
			p.RaiseExceptionStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1262)
			p.VariableDeclarationStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentStatementContext is an interface to support dynamic dispatch.
type IAssignmentStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableDesignator() IVariableDesignatorContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext
	PropertyDesignator() IPropertyDesignatorContext

	// IsAssignmentStatementContext differentiates from other interfaces.
	IsAssignmentStatementContext()
}

type AssignmentStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentStatementContext() *AssignmentStatementContext {
	var p = new(AssignmentStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_assignmentStatement
	return p
}

func InitEmptyAssignmentStatementContext(p *AssignmentStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_assignmentStatement
}

func (*AssignmentStatementContext) IsAssignmentStatementContext() {}

func NewAssignmentStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentStatementContext {
	var p = new(AssignmentStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_assignmentStatement

	return p
}

func (s *AssignmentStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentStatementContext) VariableDesignator() IVariableDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDesignatorContext)
}

func (s *AssignmentStatementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(pascalParserASSIGN, 0)
}

func (s *AssignmentStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentStatementContext) PropertyDesignator() IPropertyDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDesignatorContext)
}

func (s *AssignmentStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAssignmentStatement(s)
	}
}

func (s *AssignmentStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAssignmentStatement(s)
	}
}

func (s *AssignmentStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAssignmentStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) AssignmentStatement() (localctx IAssignmentStatementContext) {
	localctx = NewAssignmentStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, pascalParserRULE_assignmentStatement)
	p.SetState(1273)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 132, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1265)
			p.VariableDesignator()
		}
		{
			p.SetState(1266)
			p.Match(pascalParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1267)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1269)
			p.PropertyDesignator()
		}
		{
			p.SetState(1270)
			p.Match(pascalParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1271)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRaiseExceptionStatementContext is an interface to support dynamic dispatch.
type IRaiseExceptionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RAISE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsRaiseExceptionStatementContext differentiates from other interfaces.
	IsRaiseExceptionStatementContext()
}

type RaiseExceptionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaiseExceptionStatementContext() *RaiseExceptionStatementContext {
	var p = new(RaiseExceptionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_raiseExceptionStatement
	return p
}

func InitEmptyRaiseExceptionStatementContext(p *RaiseExceptionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_raiseExceptionStatement
}

func (*RaiseExceptionStatementContext) IsRaiseExceptionStatementContext() {}

func NewRaiseExceptionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RaiseExceptionStatementContext {
	var p = new(RaiseExceptionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_raiseExceptionStatement

	return p
}

func (s *RaiseExceptionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RaiseExceptionStatementContext) RAISE() antlr.TerminalNode {
	return s.GetToken(pascalParserRAISE, 0)
}

func (s *RaiseExceptionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RaiseExceptionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RaiseExceptionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RaiseExceptionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRaiseExceptionStatement(s)
	}
}

func (s *RaiseExceptionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRaiseExceptionStatement(s)
	}
}

func (s *RaiseExceptionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRaiseExceptionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RaiseExceptionStatement() (localctx IRaiseExceptionStatementContext) {
	localctx = NewRaiseExceptionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, pascalParserRULE_raiseExceptionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1275)
		p.Match(pascalParserRAISE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1277)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3747047670930211240) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&9083197500611890433) != 0) {
		{
			p.SetState(1276)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationStatementContext is an interface to support dynamic dispatch.
type IVariableDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VAR() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	COLON() antlr.TerminalNode
	TypeDefinition() ITypeDefinitionContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsVariableDeclarationStatementContext differentiates from other interfaces.
	IsVariableDeclarationStatementContext()
}

type VariableDeclarationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationStatementContext() *VariableDeclarationStatementContext {
	var p = new(VariableDeclarationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclarationStatement
	return p
}

func InitEmptyVariableDeclarationStatementContext(p *VariableDeclarationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclarationStatement
}

func (*VariableDeclarationStatementContext) IsVariableDeclarationStatementContext() {}

func NewVariableDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationStatementContext {
	var p = new(VariableDeclarationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_variableDeclarationStatement

	return p
}

func (s *VariableDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationStatementContext) VAR() antlr.TerminalNode {
	return s.GetToken(pascalParserVAR, 0)
}

func (s *VariableDeclarationStatementContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *VariableDeclarationStatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *VariableDeclarationStatementContext) TypeDefinition() ITypeDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionContext)
}

func (s *VariableDeclarationStatementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(pascalParserASSIGN, 0)
}

func (s *VariableDeclarationStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterVariableDeclarationStatement(s)
	}
}

func (s *VariableDeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitVariableDeclarationStatement(s)
	}
}

func (s *VariableDeclarationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitVariableDeclarationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) VariableDeclarationStatement() (localctx IVariableDeclarationStatementContext) {
	localctx = NewVariableDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, pascalParserRULE_variableDeclarationStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1279)
		p.Match(pascalParserVAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1280)
		p.IdentifierList()
	}
	p.SetState(1283)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserCOLON {
		{
			p.SetState(1281)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1282)
			p.TypeDefinition()
		}

	}
	p.SetState(1287)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserASSIGN {
		{
			p.SetState(1285)
			p.Match(pascalParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1286)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDesignatorContext is an interface to support dynamic dispatch.
type IVariableDesignatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeCast() ITypeCastContext
	AT() antlr.TerminalNode
	Identifier() IIdentifierContext
	AllFunctionDesignator() []IFunctionDesignatorContext
	FunctionDesignator(i int) IFunctionDesignatorContext
	AllLBRACK() []antlr.TerminalNode
	LBRACK(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllRBRACK() []antlr.TerminalNode
	RBRACK(i int) antlr.TerminalNode
	AllLBRACK2() []antlr.TerminalNode
	LBRACK2(i int) antlr.TerminalNode
	AllRBRACK2() []antlr.TerminalNode
	RBRACK2(i int) antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllDEREFERENCE() []antlr.TerminalNode
	DEREFERENCE(i int) antlr.TerminalNode

	// IsVariableDesignatorContext differentiates from other interfaces.
	IsVariableDesignatorContext()
}

type VariableDesignatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDesignatorContext() *VariableDesignatorContext {
	var p = new(VariableDesignatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDesignator
	return p
}

func InitEmptyVariableDesignatorContext(p *VariableDesignatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDesignator
}

func (*VariableDesignatorContext) IsVariableDesignatorContext() {}

func NewVariableDesignatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDesignatorContext {
	var p = new(VariableDesignatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_variableDesignator

	return p
}

func (s *VariableDesignatorContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDesignatorContext) TypeCast() ITypeCastContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeCastContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeCastContext)
}

func (s *VariableDesignatorContext) AT() antlr.TerminalNode {
	return s.GetToken(pascalParserAT, 0)
}

func (s *VariableDesignatorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableDesignatorContext) AllFunctionDesignator() []IFunctionDesignatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionDesignatorContext); ok {
			len++
		}
	}

	tst := make([]IFunctionDesignatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionDesignatorContext); ok {
			tst[i] = t.(IFunctionDesignatorContext)
			i++
		}
	}

	return tst
}

func (s *VariableDesignatorContext) FunctionDesignator(i int) IFunctionDesignatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDesignatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDesignatorContext)
}

func (s *VariableDesignatorContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(pascalParserLBRACK)
}

func (s *VariableDesignatorContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, i)
}

func (s *VariableDesignatorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *VariableDesignatorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableDesignatorContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(pascalParserRBRACK)
}

func (s *VariableDesignatorContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, i)
}

func (s *VariableDesignatorContext) AllLBRACK2() []antlr.TerminalNode {
	return s.GetTokens(pascalParserLBRACK2)
}

func (s *VariableDesignatorContext) LBRACK2(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK2, i)
}

func (s *VariableDesignatorContext) AllRBRACK2() []antlr.TerminalNode {
	return s.GetTokens(pascalParserRBRACK2)
}

func (s *VariableDesignatorContext) RBRACK2(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK2, i)
}

func (s *VariableDesignatorContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDOT)
}

func (s *VariableDesignatorContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, i)
}

func (s *VariableDesignatorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *VariableDesignatorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *VariableDesignatorContext) AllDEREFERENCE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDEREFERENCE)
}

func (s *VariableDesignatorContext) DEREFERENCE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDEREFERENCE, i)
}

func (s *VariableDesignatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDesignatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDesignatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterVariableDesignator(s)
	}
}

func (s *VariableDesignatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitVariableDesignator(s)
	}
}

func (s *VariableDesignatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitVariableDesignator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) VariableDesignator() (localctx IVariableDesignatorContext) {
	localctx = NewVariableDesignatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, pascalParserRULE_variableDesignator)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1293)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1289)
			p.TypeCast()
		}

	case 2:
		{
			p.SetState(1290)
			p.Match(pascalParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1291)
			p.Identifier()
		}

	case 3:
		{
			p.SetState(1292)
			p.FunctionDesignator()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(1326)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 141, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1324)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case pascalParserLBRACK:
				{
					p.SetState(1295)
					p.Match(pascalParserLBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1296)
					p.Expression()
				}
				p.SetState(1301)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == pascalParserCOMMA {
					{
						p.SetState(1297)
						p.Match(pascalParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1298)
						p.Expression()
					}

					p.SetState(1303)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1304)
					p.Match(pascalParserRBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case pascalParserLBRACK2:
				{
					p.SetState(1306)
					p.Match(pascalParserLBRACK2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1307)
					p.Expression()
				}
				p.SetState(1312)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == pascalParserCOMMA {
					{
						p.SetState(1308)
						p.Match(pascalParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1309)
						p.Expression()
					}

					p.SetState(1314)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1315)
					p.Match(pascalParserRBRACK2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case pascalParserDOT:
				{
					p.SetState(1317)
					p.Match(pascalParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1318)
					p.FunctionDesignator()
				}

			case pascalParserDEREFERENCE:
				p.SetState(1320)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = 1
				for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					switch _alt {
					case 1:
						{
							p.SetState(1319)
							p.Match(pascalParserDEREFERENCE)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					default:
						p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
						goto errorExit
					}

					p.SetState(1322)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 139, p.GetParserRuleContext())
					if p.HasError() {
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(1328)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 141, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeCastContext is an interface to support dynamic dispatch.
type ITypeCastContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIdentifier() ITypeIdentifierContext
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsTypeCastContext differentiates from other interfaces.
	IsTypeCastContext()
}

type TypeCastContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeCastContext() *TypeCastContext {
	var p = new(TypeCastContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeCast
	return p
}

func InitEmptyTypeCastContext(p *TypeCastContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeCast
}

func (*TypeCastContext) IsTypeCastContext() {}

func NewTypeCastContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeCastContext {
	var p = new(TypeCastContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typeCast

	return p
}

func (s *TypeCastContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeCastContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *TypeCastContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *TypeCastContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TypeCastContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *TypeCastContext) AS() antlr.TerminalNode {
	return s.GetToken(pascalParserAS, 0)
}

func (s *TypeCastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeCastContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeCastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypeCast(s)
	}
}

func (s *TypeCastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypeCast(s)
	}
}

func (s *TypeCastContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypeCast(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypeCast() (localctx ITypeCastContext) {
	localctx = NewTypeCastContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, pascalParserRULE_typeCast)
	p.SetState(1340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserARRAY, pascalParserBOOLEAN, pascalParserCHAR, pascalParserINTEGER, pascalParserREAL, pascalParserSTRING, pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserCARDINAL, pascalParserLONGBOOL, pascalParserLONGINT, pascalParserIDENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1329)
			p.TypeIdentifier()
		}
		{
			p.SetState(1330)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1331)
			p.Expression()
		}
		{
			p.SetState(1332)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case pascalParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1334)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1335)
			p.Expression()
		}
		{
			p.SetState(1336)
			p.Match(pascalParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1337)
			p.TypeIdentifier()
		}
		{
			p.SetState(1338)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyDesignatorContext is an interface to support dynamic dispatch.
type IPropertyDesignatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFunctionDesignator() []IFunctionDesignatorContext
	FunctionDesignator(i int) IFunctionDesignatorContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	Identifier() IIdentifierContext
	LBRACK() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	RBRACK() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPropertyDesignatorContext differentiates from other interfaces.
	IsPropertyDesignatorContext()
}

type PropertyDesignatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDesignatorContext() *PropertyDesignatorContext {
	var p = new(PropertyDesignatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDesignator
	return p
}

func InitEmptyPropertyDesignatorContext(p *PropertyDesignatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDesignator
}

func (*PropertyDesignatorContext) IsPropertyDesignatorContext() {}

func NewPropertyDesignatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDesignatorContext {
	var p = new(PropertyDesignatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyDesignator

	return p
}

func (s *PropertyDesignatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDesignatorContext) AllFunctionDesignator() []IFunctionDesignatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionDesignatorContext); ok {
			len++
		}
	}

	tst := make([]IFunctionDesignatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionDesignatorContext); ok {
			tst[i] = t.(IFunctionDesignatorContext)
			i++
		}
	}

	return tst
}

func (s *PropertyDesignatorContext) FunctionDesignator(i int) IFunctionDesignatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDesignatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDesignatorContext)
}

func (s *PropertyDesignatorContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDOT)
}

func (s *PropertyDesignatorContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, i)
}

func (s *PropertyDesignatorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyDesignatorContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *PropertyDesignatorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PropertyDesignatorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PropertyDesignatorContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *PropertyDesignatorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *PropertyDesignatorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *PropertyDesignatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDesignatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyDesignatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyDesignator(s)
	}
}

func (s *PropertyDesignatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyDesignator(s)
	}
}

func (s *PropertyDesignatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyDesignator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyDesignator() (localctx IPropertyDesignatorContext) {
	localctx = NewPropertyDesignatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, pascalParserRULE_propertyDesignator)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1342)
		p.FunctionDesignator()
	}
	p.SetState(1347)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 143, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1343)
				p.Match(pascalParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1344)
				p.FunctionDesignator()
			}

		}
		p.SetState(1349)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 143, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1350)
		p.Match(pascalParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1351)
		p.Identifier()
	}
	p.SetState(1363)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLBRACK {
		{
			p.SetState(1352)
			p.Match(pascalParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1353)
			p.Expression()
		}
		p.SetState(1358)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == pascalParserCOMMA {
			{
				p.SetState(1354)
				p.Match(pascalParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1355)
				p.Expression()
			}

			p.SetState(1360)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1361)
			p.Match(pascalParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleExpression() ISimpleExpressionContext
	Relationaloperator() IRelationaloperatorContext
	Expression() IExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) SimpleExpression() ISimpleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExpressionContext)
}

func (s *ExpressionContext) Relationaloperator() IRelationaloperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationaloperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationaloperatorContext)
}

func (s *ExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, pascalParserRULE_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1365)
		p.SimpleExpression()
	}
	p.SetState(1369)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1366)
			p.Relationaloperator()
		}
		{
			p.SetState(1367)
			p.Expression()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationaloperatorContext is an interface to support dynamic dispatch.
type IRelationaloperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL() antlr.TerminalNode
	NOT_EQUAL() antlr.TerminalNode
	LT() antlr.TerminalNode
	LE() antlr.TerminalNode
	GE() antlr.TerminalNode
	GT() antlr.TerminalNode
	IN() antlr.TerminalNode

	// IsRelationaloperatorContext differentiates from other interfaces.
	IsRelationaloperatorContext()
}

type RelationaloperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationaloperatorContext() *RelationaloperatorContext {
	var p = new(RelationaloperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_relationaloperator
	return p
}

func InitEmptyRelationaloperatorContext(p *RelationaloperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_relationaloperator
}

func (*RelationaloperatorContext) IsRelationaloperatorContext() {}

func NewRelationaloperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationaloperatorContext {
	var p = new(RelationaloperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_relationaloperator

	return p
}

func (s *RelationaloperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationaloperatorContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *RelationaloperatorContext) NOT_EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserNOT_EQUAL, 0)
}

func (s *RelationaloperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(pascalParserLT, 0)
}

func (s *RelationaloperatorContext) LE() antlr.TerminalNode {
	return s.GetToken(pascalParserLE, 0)
}

func (s *RelationaloperatorContext) GE() antlr.TerminalNode {
	return s.GetToken(pascalParserGE, 0)
}

func (s *RelationaloperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(pascalParserGT, 0)
}

func (s *RelationaloperatorContext) IN() antlr.TerminalNode {
	return s.GetToken(pascalParserIN, 0)
}

func (s *RelationaloperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationaloperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationaloperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRelationaloperator(s)
	}
}

func (s *RelationaloperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRelationaloperator(s)
	}
}

func (s *RelationaloperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRelationaloperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Relationaloperator() (localctx IRelationaloperatorContext) {
	localctx = NewRelationaloperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, pascalParserRULE_relationaloperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1371)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&283726776526438400) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleExpressionContext is an interface to support dynamic dispatch.
type ISimpleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Term() ITermContext
	Additiveoperator() IAdditiveoperatorContext
	SimpleExpression() ISimpleExpressionContext

	// IsSimpleExpressionContext differentiates from other interfaces.
	IsSimpleExpressionContext()
}

type SimpleExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleExpressionContext() *SimpleExpressionContext {
	var p = new(SimpleExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleExpression
	return p
}

func InitEmptySimpleExpressionContext(p *SimpleExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleExpression
}

func (*SimpleExpressionContext) IsSimpleExpressionContext() {}

func NewSimpleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleExpressionContext {
	var p = new(SimpleExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_simpleExpression

	return p
}

func (s *SimpleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleExpressionContext) Term() ITermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *SimpleExpressionContext) Additiveoperator() IAdditiveoperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveoperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveoperatorContext)
}

func (s *SimpleExpressionContext) SimpleExpression() ISimpleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExpressionContext)
}

func (s *SimpleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSimpleExpression(s)
	}
}

func (s *SimpleExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSimpleExpression(s)
	}
}

func (s *SimpleExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSimpleExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SimpleExpression() (localctx ISimpleExpressionContext) {
	localctx = NewSimpleExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, pascalParserRULE_simpleExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1373)
		p.Term()
	}
	p.SetState(1377)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1374)
			p.Additiveoperator()
		}
		{
			p.SetState(1375)
			p.SimpleExpression()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdditiveoperatorContext is an interface to support dynamic dispatch.
type IAdditiveoperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	OR() antlr.TerminalNode

	// IsAdditiveoperatorContext differentiates from other interfaces.
	IsAdditiveoperatorContext()
}

type AdditiveoperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveoperatorContext() *AdditiveoperatorContext {
	var p = new(AdditiveoperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_additiveoperator
	return p
}

func InitEmptyAdditiveoperatorContext(p *AdditiveoperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_additiveoperator
}

func (*AdditiveoperatorContext) IsAdditiveoperatorContext() {}

func NewAdditiveoperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveoperatorContext {
	var p = new(AdditiveoperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_additiveoperator

	return p
}

func (s *AdditiveoperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveoperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(pascalParserPLUS, 0)
}

func (s *AdditiveoperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(pascalParserMINUS, 0)
}

func (s *AdditiveoperatorContext) OR() antlr.TerminalNode {
	return s.GetToken(pascalParserOR, 0)
}

func (s *AdditiveoperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveoperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveoperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAdditiveoperator(s)
	}
}

func (s *AdditiveoperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAdditiveoperator(s)
	}
}

func (s *AdditiveoperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAdditiveoperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Additiveoperator() (localctx IAdditiveoperatorContext) {
	localctx = NewAdditiveoperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, pascalParserRULE_additiveoperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1379)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&52776826568704) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SignedFactor() ISignedFactorContext
	Multiplicativeoperator() IMultiplicativeoperatorContext
	Term() ITermContext

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_term
	return p
}

func InitEmptyTermContext(p *TermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_term
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) SignedFactor() ISignedFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignedFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignedFactorContext)
}

func (s *TermContext) Multiplicativeoperator() IMultiplicativeoperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeoperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeoperatorContext)
}

func (s *TermContext) Term() ITermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTerm(s)
	}
}

func (s *TermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTerm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, pascalParserRULE_term)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1381)
		p.SignedFactor()
	}
	p.SetState(1385)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1382)
			p.Multiplicativeoperator()
		}
		{
			p.SetState(1383)
			p.Term()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplicativeoperatorContext is an interface to support dynamic dispatch.
type IMultiplicativeoperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	SLASH() antlr.TerminalNode
	DIV() antlr.TerminalNode
	MOD() antlr.TerminalNode
	AND() antlr.TerminalNode
	SHR() antlr.TerminalNode
	SHL() antlr.TerminalNode
	XOR() antlr.TerminalNode

	// IsMultiplicativeoperatorContext differentiates from other interfaces.
	IsMultiplicativeoperatorContext()
}

type MultiplicativeoperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeoperatorContext() *MultiplicativeoperatorContext {
	var p = new(MultiplicativeoperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_multiplicativeoperator
	return p
}

func InitEmptyMultiplicativeoperatorContext(p *MultiplicativeoperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_multiplicativeoperator
}

func (*MultiplicativeoperatorContext) IsMultiplicativeoperatorContext() {}

func NewMultiplicativeoperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeoperatorContext {
	var p = new(MultiplicativeoperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_multiplicativeoperator

	return p
}

func (s *MultiplicativeoperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeoperatorContext) STAR() antlr.TerminalNode {
	return s.GetToken(pascalParserSTAR, 0)
}

func (s *MultiplicativeoperatorContext) SLASH() antlr.TerminalNode {
	return s.GetToken(pascalParserSLASH, 0)
}

func (s *MultiplicativeoperatorContext) DIV() antlr.TerminalNode {
	return s.GetToken(pascalParserDIV, 0)
}

func (s *MultiplicativeoperatorContext) MOD() antlr.TerminalNode {
	return s.GetToken(pascalParserMOD, 0)
}

func (s *MultiplicativeoperatorContext) AND() antlr.TerminalNode {
	return s.GetToken(pascalParserAND, 0)
}

func (s *MultiplicativeoperatorContext) SHR() antlr.TerminalNode {
	return s.GetToken(pascalParserSHR, 0)
}

func (s *MultiplicativeoperatorContext) SHL() antlr.TerminalNode {
	return s.GetToken(pascalParserSHL, 0)
}

func (s *MultiplicativeoperatorContext) XOR() antlr.TerminalNode {
	return s.GetToken(pascalParserXOR, 0)
}

func (s *MultiplicativeoperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeoperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeoperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterMultiplicativeoperator(s)
	}
}

func (s *MultiplicativeoperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitMultiplicativeoperator(s)
	}
}

func (s *MultiplicativeoperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitMultiplicativeoperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Multiplicativeoperator() (localctx IMultiplicativeoperatorContext) {
	localctx = NewMultiplicativeoperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, pascalParserRULE_multiplicativeoperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1387)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&211106249311236) != 0) || ((int64((_la-111)) & ^0x3f) == 0 && ((int64(1)<<(_la-111))&7) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignedFactorContext is an interface to support dynamic dispatch.
type ISignedFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Factor() IFactorContext
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsSignedFactorContext differentiates from other interfaces.
	IsSignedFactorContext()
}

type SignedFactorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignedFactorContext() *SignedFactorContext {
	var p = new(SignedFactorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_signedFactor
	return p
}

func InitEmptySignedFactorContext(p *SignedFactorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_signedFactor
}

func (*SignedFactorContext) IsSignedFactorContext() {}

func NewSignedFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignedFactorContext {
	var p = new(SignedFactorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_signedFactor

	return p
}

func (s *SignedFactorContext) GetParser() antlr.Parser { return s.parser }

func (s *SignedFactorContext) Factor() IFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *SignedFactorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(pascalParserPLUS, 0)
}

func (s *SignedFactorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(pascalParserMINUS, 0)
}

func (s *SignedFactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignedFactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignedFactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSignedFactor(s)
	}
}

func (s *SignedFactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSignedFactor(s)
	}
}

func (s *SignedFactorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSignedFactor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SignedFactor() (localctx ISignedFactorContext) {
	localctx = NewSignedFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, pascalParserRULE_signedFactor)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1390)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserPLUS || _la == pascalParserMINUS {
		{
			p.SetState(1389)
			_la = p.GetTokenStream().LA(1)

			if !(_la == pascalParserPLUS || _la == pascalParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1392)
		p.factor(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFactorContext is an interface to support dynamic dispatch.
type IFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionDesignator() IFunctionDesignatorContext
	INHERITED() antlr.TerminalNode
	VariableDesignator() IVariableDesignatorContext
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	RPAREN() antlr.TerminalNode
	UnsignedConstant() IUnsignedConstantContext
	Set_() ISet_Context
	NOT() antlr.TerminalNode
	Factor() IFactorContext
	Bool_() IBool_Context
	TypeIdentifier() ITypeIdentifierContext
	AT() antlr.TerminalNode
	AllDEREFERENCE() []antlr.TerminalNode
	DEREFERENCE(i int) antlr.TerminalNode
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsFactorContext differentiates from other interfaces.
	IsFactorContext()
}

type FactorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFactorContext() *FactorContext {
	var p = new(FactorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_factor
	return p
}

func InitEmptyFactorContext(p *FactorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_factor
}

func (*FactorContext) IsFactorContext() {}

func NewFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FactorContext {
	var p = new(FactorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_factor

	return p
}

func (s *FactorContext) GetParser() antlr.Parser { return s.parser }

func (s *FactorContext) FunctionDesignator() IFunctionDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDesignatorContext)
}

func (s *FactorContext) INHERITED() antlr.TerminalNode {
	return s.GetToken(pascalParserINHERITED, 0)
}

func (s *FactorContext) VariableDesignator() IVariableDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDesignatorContext)
}

func (s *FactorContext) AS() antlr.TerminalNode {
	return s.GetToken(pascalParserAS, 0)
}

func (s *FactorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FactorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *FactorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *FactorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FactorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *FactorContext) UnsignedConstant() IUnsignedConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedConstantContext)
}

func (s *FactorContext) Set_() ISet_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_Context)
}

func (s *FactorContext) NOT() antlr.TerminalNode {
	return s.GetToken(pascalParserNOT, 0)
}

func (s *FactorContext) Factor() IFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *FactorContext) Bool_() IBool_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_Context)
}

func (s *FactorContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *FactorContext) AT() antlr.TerminalNode {
	return s.GetToken(pascalParserAT, 0)
}

func (s *FactorContext) AllDEREFERENCE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDEREFERENCE)
}

func (s *FactorContext) DEREFERENCE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDEREFERENCE, i)
}

func (s *FactorContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *FactorContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *FactorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *FactorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *FactorContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDOT)
}

func (s *FactorContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, i)
}

func (s *FactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFactor(s)
	}
}

func (s *FactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFactor(s)
	}
}

func (s *FactorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFactor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Factor() (localctx IFactorContext) {
	return p.factor(0)
}

func (p *pascalParser) factor(_p int) (localctx IFactorContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewFactorContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IFactorContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 252
	p.EnterRecursionRule(localctx, 252, pascalParserRULE_factor, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1429)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 155, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1396)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserINHERITED {
			{
				p.SetState(1395)
				p.Match(pascalParserINHERITED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1398)
			p.FunctionDesignator()
		}

	case 2:
		{
			p.SetState(1399)
			p.VariableDesignator()
		}
		p.SetState(1402)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 151, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1400)
				p.Match(pascalParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1401)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		{
			p.SetState(1404)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1405)
			p.Expression()
		}
		{
			p.SetState(1406)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(1408)
			p.UnsignedConstant()
		}

	case 5:
		{
			p.SetState(1409)
			p.Set_()
		}

	case 6:
		{
			p.SetState(1410)
			p.Match(pascalParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1411)
			p.factor(5)
		}

	case 7:
		{
			p.SetState(1412)
			p.Bool_()
		}

	case 8:
		p.SetState(1414)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserAT {
			{
				p.SetState(1413)
				p.Match(pascalParserAT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1416)
			p.TypeIdentifier()
		}
		p.SetState(1421)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 153, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1417)
				p.Match(pascalParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1418)
				p.Expression()
			}
			{
				p.SetState(1419)
				p.Match(pascalParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1426)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 154, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1423)
					p.Match(pascalParserDEREFERENCE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1428)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 154, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1452)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1450)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 158, p.GetParserRuleContext()) {
			case 1:
				localctx = NewFactorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, pascalParserRULE_factor)
				p.SetState(1431)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(1432)
					p.Match(pascalParserLBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1433)
					p.Expression()
				}
				p.SetState(1438)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == pascalParserCOMMA {
					{
						p.SetState(1434)
						p.Match(pascalParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1435)
						p.Expression()
					}

					p.SetState(1440)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1441)
					p.Match(pascalParserRBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				localctx = NewFactorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, pascalParserRULE_factor)
				p.SetState(1443)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				p.SetState(1446)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = 1
				for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					switch _alt {
					case 1:
						{
							p.SetState(1444)
							p.Match(pascalParserDOT)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(1445)
							p.Expression()
						}

					default:
						p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
						goto errorExit
					}

					p.SetState(1448)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 157, p.GetParserRuleContext())
					if p.HasError() {
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1454)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedConstantContext is an interface to support dynamic dispatch.
type IUnsignedConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedNumber() IUnsignedNumberContext
	ConstantChr() IConstantChrContext
	HexConstant() IHexConstantContext
	String_() IStringContext
	NIL() antlr.TerminalNode

	// IsUnsignedConstantContext differentiates from other interfaces.
	IsUnsignedConstantContext()
}

type UnsignedConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedConstantContext() *UnsignedConstantContext {
	var p = new(UnsignedConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedConstant
	return p
}

func InitEmptyUnsignedConstantContext(p *UnsignedConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedConstant
}

func (*UnsignedConstantContext) IsUnsignedConstantContext() {}

func NewUnsignedConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedConstantContext {
	var p = new(UnsignedConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unsignedConstant

	return p
}

func (s *UnsignedConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedConstantContext) UnsignedNumber() IUnsignedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedNumberContext)
}

func (s *UnsignedConstantContext) ConstantChr() IConstantChrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantChrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantChrContext)
}

func (s *UnsignedConstantContext) HexConstant() IHexConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexConstantContext)
}

func (s *UnsignedConstantContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *UnsignedConstantContext) NIL() antlr.TerminalNode {
	return s.GetToken(pascalParserNIL, 0)
}

func (s *UnsignedConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnsignedConstant(s)
	}
}

func (s *UnsignedConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnsignedConstant(s)
	}
}

func (s *UnsignedConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnsignedConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnsignedConstant() (localctx IUnsignedConstantContext) {
	localctx = NewUnsignedConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, pascalParserRULE_unsignedConstant)
	p.SetState(1460)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserNUM_INT, pascalParserNUM_REAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1455)
			p.UnsignedNumber()
		}

	case pascalParserCHR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1456)
			p.ConstantChr()
		}

	case pascalParserHEX_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1457)
			p.HexConstant()
		}

	case pascalParserSTRING_LITERAL, pascalParserSTRING_CROSSHATCH_LITERAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1458)
			p.String_()
		}

	case pascalParserNIL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1459)
			p.Match(pascalParserNIL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDesignatorContext is an interface to support dynamic dispatch.
type IFunctionDesignatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LT() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	GT() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext
	RPAREN() antlr.TerminalNode

	// IsFunctionDesignatorContext differentiates from other interfaces.
	IsFunctionDesignatorContext()
}

type FunctionDesignatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDesignatorContext() *FunctionDesignatorContext {
	var p = new(FunctionDesignatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionDesignator
	return p
}

func InitEmptyFunctionDesignatorContext(p *FunctionDesignatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionDesignator
}

func (*FunctionDesignatorContext) IsFunctionDesignatorContext() {}

func NewFunctionDesignatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDesignatorContext {
	var p = new(FunctionDesignatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_functionDesignator

	return p
}

func (s *FunctionDesignatorContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDesignatorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionDesignatorContext) LT() antlr.TerminalNode {
	return s.GetToken(pascalParserLT, 0)
}

func (s *FunctionDesignatorContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *FunctionDesignatorContext) GT() antlr.TerminalNode {
	return s.GetToken(pascalParserGT, 0)
}

func (s *FunctionDesignatorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *FunctionDesignatorContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *FunctionDesignatorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *FunctionDesignatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDesignatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDesignatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFunctionDesignator(s)
	}
}

func (s *FunctionDesignatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFunctionDesignator(s)
	}
}

func (s *FunctionDesignatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFunctionDesignator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FunctionDesignator() (localctx IFunctionDesignatorContext) {
	localctx = NewFunctionDesignatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, pascalParserRULE_functionDesignator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1462)
		p.Identifier()
	}

	p.SetState(1467)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 161, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1463)
			p.Match(pascalParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1464)
			p.TypeIdentifier()
		}
		{
			p.SetState(1465)
			p.Match(pascalParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1473)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 162, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1469)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1470)
			p.ParameterList()
		}
		{
			p.SetState(1471)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterListContext is an interface to support dynamic dispatch.
type IParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllActualParameter() []IActualParameterContext
	ActualParameter(i int) IActualParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsParameterListContext differentiates from other interfaces.
	IsParameterListContext()
}

type ParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterListContext() *ParameterListContext {
	var p = new(ParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterList
	return p
}

func InitEmptyParameterListContext(p *ParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterList
}

func (*ParameterListContext) IsParameterListContext() {}

func NewParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterListContext {
	var p = new(ParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_parameterList

	return p
}

func (s *ParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterListContext) AllActualParameter() []IActualParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IActualParameterContext); ok {
			len++
		}
	}

	tst := make([]IActualParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IActualParameterContext); ok {
			tst[i] = t.(IActualParameterContext)
			i++
		}
	}

	return tst
}

func (s *ParameterListContext) ActualParameter(i int) IActualParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IActualParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IActualParameterContext)
}

func (s *ParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterParameterList(s)
	}
}

func (s *ParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitParameterList(s)
	}
}

func (s *ParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ParameterList() (localctx IParameterListContext) {
	localctx = NewParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, pascalParserRULE_parameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1475)
		p.ActualParameter()
	}
	p.SetState(1480)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(1476)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1477)
			p.ActualParameter()
		}

		p.SetState(1482)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_Context is an interface to support dynamic dispatch.
type ISet_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	ElementList() IElementListContext
	RBRACK() antlr.TerminalNode
	LBRACK2() antlr.TerminalNode
	RBRACK2() antlr.TerminalNode

	// IsSet_Context differentiates from other interfaces.
	IsSet_Context()
}

type Set_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_Context() *Set_Context {
	var p = new(Set_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_set_
	return p
}

func InitEmptySet_Context(p *Set_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_set_
}

func (*Set_Context) IsSet_Context() {}

func NewSet_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_Context {
	var p = new(Set_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_set_

	return p
}

func (s *Set_Context) GetParser() antlr.Parser { return s.parser }

func (s *Set_Context) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *Set_Context) ElementList() IElementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementListContext)
}

func (s *Set_Context) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *Set_Context) LBRACK2() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK2, 0)
}

func (s *Set_Context) RBRACK2() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK2, 0)
}

func (s *Set_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSet_(s)
	}
}

func (s *Set_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSet_(s)
	}
}

func (s *Set_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSet_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Set_() (localctx ISet_Context) {
	localctx = NewSet_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, pascalParserRULE_set_)
	p.SetState(1491)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserLBRACK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1483)
			p.Match(pascalParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1484)
			p.ElementList()
		}
		{
			p.SetState(1485)
			p.Match(pascalParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case pascalParserLBRACK2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1487)
			p.Match(pascalParserLBRACK2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1488)
			p.ElementList()
		}
		{
			p.SetState(1489)
			p.Match(pascalParserRBRACK2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementListContext is an interface to support dynamic dispatch.
type IElementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllElement() []IElementContext
	Element(i int) IElementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsElementListContext differentiates from other interfaces.
	IsElementListContext()
}

type ElementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementListContext() *ElementListContext {
	var p = new(ElementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_elementList
	return p
}

func InitEmptyElementListContext(p *ElementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_elementList
}

func (*ElementListContext) IsElementListContext() {}

func NewElementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementListContext {
	var p = new(ElementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_elementList

	return p
}

func (s *ElementListContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementListContext) AllElement() []IElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElementContext); ok {
			len++
		}
	}

	tst := make([]IElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElementContext); ok {
			tst[i] = t.(IElementContext)
			i++
		}
	}

	return tst
}

func (s *ElementListContext) Element(i int) IElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementContext)
}

func (s *ElementListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ElementListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ElementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterElementList(s)
	}
}

func (s *ElementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitElementList(s)
	}
}

func (s *ElementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitElementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ElementList() (localctx IElementListContext) {
	localctx = NewElementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, pascalParserRULE_elementList)
	var _la int

	p.SetState(1502)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserARRAY, pascalParserBOOLEAN, pascalParserCHAR, pascalParserCHR, pascalParserINTEGER, pascalParserNIL, pascalParserNOT, pascalParserREAL, pascalParserPLUS, pascalParserMINUS, pascalParserLPAREN, pascalParserLBRACK, pascalParserLBRACK2, pascalParserAT, pascalParserSTRING, pascalParserTRUE, pascalParserFALSE, pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserINHERITED, pascalParserCARDINAL, pascalParserLONGBOOL, pascalParserLONGINT, pascalParserIDENT, pascalParserHEX_LITERAL, pascalParserSTRING_LITERAL, pascalParserSTRING_CROSSHATCH_LITERAL, pascalParserNUM_INT, pascalParserNUM_REAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1493)
			p.Element()
		}
		p.SetState(1498)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == pascalParserCOMMA {
			{
				p.SetState(1494)
				p.Match(pascalParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1495)
				p.Element()
			}

			p.SetState(1500)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case pascalParserRBRACK, pascalParserRBRACK2:
		p.EnterOuterAlt(localctx, 2)

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementContext is an interface to support dynamic dispatch.
type IElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	DOTDOT() antlr.TerminalNode

	// IsElementContext differentiates from other interfaces.
	IsElementContext()
}

type ElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementContext() *ElementContext {
	var p = new(ElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_element
	return p
}

func InitEmptyElementContext(p *ElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_element
}

func (*ElementContext) IsElementContext() {}

func NewElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementContext {
	var p = new(ElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_element

	return p
}

func (s *ElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ElementContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ElementContext) DOTDOT() antlr.TerminalNode {
	return s.GetToken(pascalParserDOTDOT, 0)
}

func (s *ElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterElement(s)
	}
}

func (s *ElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitElement(s)
	}
}

func (s *ElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Element() (localctx IElementContext) {
	localctx = NewElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, pascalParserRULE_element)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1504)
		p.Expression()
	}
	p.SetState(1507)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserDOTDOT {
		{
			p.SetState(1505)
			p.Match(pascalParserDOTDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1506)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureStatementContext is an interface to support dynamic dispatch.
type IProcedureStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext
	RPAREN() antlr.TerminalNode

	// IsProcedureStatementContext differentiates from other interfaces.
	IsProcedureStatementContext()
}

type ProcedureStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureStatementContext() *ProcedureStatementContext {
	var p = new(ProcedureStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureStatement
	return p
}

func InitEmptyProcedureStatementContext(p *ProcedureStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureStatement
}

func (*ProcedureStatementContext) IsProcedureStatementContext() {}

func NewProcedureStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureStatementContext {
	var p = new(ProcedureStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureStatement

	return p
}

func (s *ProcedureStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ProcedureStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ProcedureStatementContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *ProcedureStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ProcedureStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureStatement(s)
	}
}

func (s *ProcedureStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureStatement(s)
	}
}

func (s *ProcedureStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureStatement() (localctx IProcedureStatementContext) {
	localctx = NewProcedureStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, pascalParserRULE_procedureStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1509)
		p.Identifier()
	}
	p.SetState(1514)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1510)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1511)
			p.ParameterList()
		}
		{
			p.SetState(1512)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodCallStatementContext is an interface to support dynamic dispatch.
type IMethodCallStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariableDesignator() []IVariableDesignatorContext
	VariableDesignator(i int) IVariableDesignatorContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext
	RPAREN() antlr.TerminalNode

	// IsMethodCallStatementContext differentiates from other interfaces.
	IsMethodCallStatementContext()
}

type MethodCallStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodCallStatementContext() *MethodCallStatementContext {
	var p = new(MethodCallStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_methodCallStatement
	return p
}

func InitEmptyMethodCallStatementContext(p *MethodCallStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_methodCallStatement
}

func (*MethodCallStatementContext) IsMethodCallStatementContext() {}

func NewMethodCallStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodCallStatementContext {
	var p = new(MethodCallStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_methodCallStatement

	return p
}

func (s *MethodCallStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodCallStatementContext) AllVariableDesignator() []IVariableDesignatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDesignatorContext); ok {
			len++
		}
	}

	tst := make([]IVariableDesignatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDesignatorContext); ok {
			tst[i] = t.(IVariableDesignatorContext)
			i++
		}
	}

	return tst
}

func (s *MethodCallStatementContext) VariableDesignator(i int) IVariableDesignatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDesignatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDesignatorContext)
}

func (s *MethodCallStatementContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDOT)
}

func (s *MethodCallStatementContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, i)
}

func (s *MethodCallStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MethodCallStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *MethodCallStatementContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *MethodCallStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *MethodCallStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodCallStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodCallStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterMethodCallStatement(s)
	}
}

func (s *MethodCallStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitMethodCallStatement(s)
	}
}

func (s *MethodCallStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitMethodCallStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) MethodCallStatement() (localctx IMethodCallStatementContext) {
	localctx = NewMethodCallStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, pascalParserRULE_methodCallStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1516)
		p.VariableDesignator()
	}
	p.SetState(1521)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 169, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1517)
				p.Match(pascalParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1518)
				p.VariableDesignator()
			}

		}
		p.SetState(1523)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 169, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1524)
		p.Match(pascalParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1525)
		p.Identifier()
	}
	p.SetState(1530)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1526)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1527)
			p.ParameterList()
		}
		{
			p.SetState(1528)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IActualParameterContext is an interface to support dynamic dispatch.
type IActualParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	AllParameterwidth() []IParameterwidthContext
	Parameterwidth(i int) IParameterwidthContext
	ProcedureLambdaDeclaration() IProcedureLambdaDeclarationContext
	FunctionLambdaDeclaration() IFunctionLambdaDeclarationContext

	// IsActualParameterContext differentiates from other interfaces.
	IsActualParameterContext()
}

type ActualParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActualParameterContext() *ActualParameterContext {
	var p = new(ActualParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_actualParameter
	return p
}

func InitEmptyActualParameterContext(p *ActualParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_actualParameter
}

func (*ActualParameterContext) IsActualParameterContext() {}

func NewActualParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ActualParameterContext {
	var p = new(ActualParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_actualParameter

	return p
}

func (s *ActualParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ActualParameterContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ActualParameterContext) AllParameterwidth() []IParameterwidthContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterwidthContext); ok {
			len++
		}
	}

	tst := make([]IParameterwidthContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterwidthContext); ok {
			tst[i] = t.(IParameterwidthContext)
			i++
		}
	}

	return tst
}

func (s *ActualParameterContext) Parameterwidth(i int) IParameterwidthContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterwidthContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterwidthContext)
}

func (s *ActualParameterContext) ProcedureLambdaDeclaration() IProcedureLambdaDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureLambdaDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureLambdaDeclarationContext)
}

func (s *ActualParameterContext) FunctionLambdaDeclaration() IFunctionLambdaDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionLambdaDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionLambdaDeclarationContext)
}

func (s *ActualParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ActualParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ActualParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterActualParameter(s)
	}
}

func (s *ActualParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitActualParameter(s)
	}
}

func (s *ActualParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitActualParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ActualParameter() (localctx IActualParameterContext) {
	localctx = NewActualParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, pascalParserRULE_actualParameter)
	var _la int

	p.SetState(1541)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserARRAY, pascalParserBOOLEAN, pascalParserCHAR, pascalParserCHR, pascalParserINTEGER, pascalParserNIL, pascalParserNOT, pascalParserREAL, pascalParserPLUS, pascalParserMINUS, pascalParserLPAREN, pascalParserLBRACK, pascalParserLBRACK2, pascalParserAT, pascalParserSTRING, pascalParserTRUE, pascalParserFALSE, pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserINHERITED, pascalParserCARDINAL, pascalParserLONGBOOL, pascalParserLONGINT, pascalParserIDENT, pascalParserHEX_LITERAL, pascalParserSTRING_LITERAL, pascalParserSTRING_CROSSHATCH_LITERAL, pascalParserNUM_INT, pascalParserNUM_REAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1532)
			p.Expression()
		}
		p.SetState(1536)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == pascalParserCOLON {
			{
				p.SetState(1533)
				p.Parameterwidth()
			}

			p.SetState(1538)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case pascalParserPROCEDURE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1539)
			p.ProcedureLambdaDeclaration()
		}

	case pascalParserFUNCTION:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1540)
			p.FunctionLambdaDeclaration()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterwidthContext is an interface to support dynamic dispatch.
type IParameterwidthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode
	Expression() IExpressionContext

	// IsParameterwidthContext differentiates from other interfaces.
	IsParameterwidthContext()
}

type ParameterwidthContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterwidthContext() *ParameterwidthContext {
	var p = new(ParameterwidthContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterwidth
	return p
}

func InitEmptyParameterwidthContext(p *ParameterwidthContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterwidth
}

func (*ParameterwidthContext) IsParameterwidthContext() {}

func NewParameterwidthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterwidthContext {
	var p = new(ParameterwidthContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_parameterwidth

	return p
}

func (s *ParameterwidthContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterwidthContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *ParameterwidthContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParameterwidthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterwidthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterwidthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterParameterwidth(s)
	}
}

func (s *ParameterwidthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitParameterwidth(s)
	}
}

func (s *ParameterwidthContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitParameterwidth(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Parameterwidth() (localctx IParameterwidthContext) {
	localctx = NewParameterwidthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, pascalParserRULE_parameterwidth)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1543)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1544)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGotoStatementContext is an interface to support dynamic dispatch.
type IGotoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GOTO() antlr.TerminalNode
	Label() ILabelContext

	// IsGotoStatementContext differentiates from other interfaces.
	IsGotoStatementContext()
}

type GotoStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGotoStatementContext() *GotoStatementContext {
	var p = new(GotoStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_gotoStatement
	return p
}

func InitEmptyGotoStatementContext(p *GotoStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_gotoStatement
}

func (*GotoStatementContext) IsGotoStatementContext() {}

func NewGotoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GotoStatementContext {
	var p = new(GotoStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_gotoStatement

	return p
}

func (s *GotoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GotoStatementContext) GOTO() antlr.TerminalNode {
	return s.GetToken(pascalParserGOTO, 0)
}

func (s *GotoStatementContext) Label() ILabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *GotoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GotoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GotoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterGotoStatement(s)
	}
}

func (s *GotoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitGotoStatement(s)
	}
}

func (s *GotoStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitGotoStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) GotoStatement() (localctx IGotoStatementContext) {
	localctx = NewGotoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, pascalParserRULE_gotoStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1546)
		p.Match(pascalParserGOTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1547)
		p.Label()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInheritedStatementContext is an interface to support dynamic dispatch.
type IInheritedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INHERITED() antlr.TerminalNode
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext
	RPAREN() antlr.TerminalNode

	// IsInheritedStatementContext differentiates from other interfaces.
	IsInheritedStatementContext()
}

type InheritedStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInheritedStatementContext() *InheritedStatementContext {
	var p = new(InheritedStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_inheritedStatement
	return p
}

func InitEmptyInheritedStatementContext(p *InheritedStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_inheritedStatement
}

func (*InheritedStatementContext) IsInheritedStatementContext() {}

func NewInheritedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InheritedStatementContext {
	var p = new(InheritedStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_inheritedStatement

	return p
}

func (s *InheritedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InheritedStatementContext) INHERITED() antlr.TerminalNode {
	return s.GetToken(pascalParserINHERITED, 0)
}

func (s *InheritedStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InheritedStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *InheritedStatementContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *InheritedStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *InheritedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InheritedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InheritedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInheritedStatement(s)
	}
}

func (s *InheritedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInheritedStatement(s)
	}
}

func (s *InheritedStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInheritedStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InheritedStatement() (localctx IInheritedStatementContext) {
	localctx = NewInheritedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, pascalParserRULE_inheritedStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1549)
		p.Match(pascalParserINHERITED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1557)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-85)) & ^0x3f) == 0 && ((int64(1)<<(_la-85))&137438953483) != 0 {
		{
			p.SetState(1550)
			p.Identifier()
		}
		p.SetState(1555)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLPAREN {
			{
				p.SetState(1551)
				p.Match(pascalParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1552)
				p.ParameterList()
			}
			{
				p.SetState(1553)
				p.Match(pascalParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmptyStatement_Context is an interface to support dynamic dispatch.
type IEmptyStatement_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsEmptyStatement_Context differentiates from other interfaces.
	IsEmptyStatement_Context()
}

type EmptyStatement_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatement_Context() *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_emptyStatement_
	return p
}

func InitEmptyEmptyStatement_Context(p *EmptyStatement_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_emptyStatement_
}

func (*EmptyStatement_Context) IsEmptyStatement_Context() {}

func NewEmptyStatement_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_emptyStatement_

	return p
}

func (s *EmptyStatement_Context) GetParser() antlr.Parser { return s.parser }
func (s *EmptyStatement_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatement_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatement_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitEmptyStatement_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) EmptyStatement_() (localctx IEmptyStatement_Context) {
	localctx = NewEmptyStatement_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, pascalParserRULE_emptyStatement_)
	p.EnterOuterAlt(localctx, 1)

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmpty_Context is an interface to support dynamic dispatch.
type IEmpty_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsEmpty_Context differentiates from other interfaces.
	IsEmpty_Context()
}

type Empty_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmpty_Context() *Empty_Context {
	var p = new(Empty_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_empty_
	return p
}

func InitEmptyEmpty_Context(p *Empty_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_empty_
}

func (*Empty_Context) IsEmpty_Context() {}

func NewEmpty_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Empty_Context {
	var p = new(Empty_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_empty_

	return p
}

func (s *Empty_Context) GetParser() antlr.Parser { return s.parser }
func (s *Empty_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Empty_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Empty_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterEmpty_(s)
	}
}

func (s *Empty_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitEmpty_(s)
	}
}

func (s *Empty_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitEmpty_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Empty_() (localctx IEmpty_Context) {
	localctx = NewEmpty_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, pascalParserRULE_empty_)
	p.EnterOuterAlt(localctx, 1)

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructuredStatementContext is an interface to support dynamic dispatch.
type IStructuredStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CompoundStatement() ICompoundStatementContext
	ConditionalStatement() IConditionalStatementContext
	RepetetiveStatement() IRepetetiveStatementContext
	WithStatement() IWithStatementContext
	TryExceptStatement() ITryExceptStatementContext
	TryFinallyStatement() ITryFinallyStatementContext

	// IsStructuredStatementContext differentiates from other interfaces.
	IsStructuredStatementContext()
}

type StructuredStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructuredStatementContext() *StructuredStatementContext {
	var p = new(StructuredStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_structuredStatement
	return p
}

func InitEmptyStructuredStatementContext(p *StructuredStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_structuredStatement
}

func (*StructuredStatementContext) IsStructuredStatementContext() {}

func NewStructuredStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructuredStatementContext {
	var p = new(StructuredStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_structuredStatement

	return p
}

func (s *StructuredStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StructuredStatementContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *StructuredStatementContext) ConditionalStatement() IConditionalStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalStatementContext)
}

func (s *StructuredStatementContext) RepetetiveStatement() IRepetetiveStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepetetiveStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepetetiveStatementContext)
}

func (s *StructuredStatementContext) WithStatement() IWithStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithStatementContext)
}

func (s *StructuredStatementContext) TryExceptStatement() ITryExceptStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryExceptStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryExceptStatementContext)
}

func (s *StructuredStatementContext) TryFinallyStatement() ITryFinallyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryFinallyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryFinallyStatementContext)
}

func (s *StructuredStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructuredStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructuredStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStructuredStatement(s)
	}
}

func (s *StructuredStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStructuredStatement(s)
	}
}

func (s *StructuredStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStructuredStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) StructuredStatement() (localctx IStructuredStatementContext) {
	localctx = NewStructuredStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, pascalParserRULE_structuredStatement)
	p.SetState(1569)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 175, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1563)
			p.CompoundStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1564)
			p.ConditionalStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1565)
			p.RepetetiveStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1566)
			p.WithStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1567)
			p.TryExceptStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1568)
			p.TryFinallyStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompoundStatementContext is an interface to support dynamic dispatch.
type ICompoundStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEGIN() antlr.TerminalNode
	Statements() IStatementsContext
	END() antlr.TerminalNode

	// IsCompoundStatementContext differentiates from other interfaces.
	IsCompoundStatementContext()
}

type CompoundStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundStatementContext() *CompoundStatementContext {
	var p = new(CompoundStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_compoundStatement
	return p
}

func InitEmptyCompoundStatementContext(p *CompoundStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_compoundStatement
}

func (*CompoundStatementContext) IsCompoundStatementContext() {}

func NewCompoundStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundStatementContext {
	var p = new(CompoundStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_compoundStatement

	return p
}

func (s *CompoundStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundStatementContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(pascalParserBEGIN, 0)
}

func (s *CompoundStatementContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *CompoundStatementContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *CompoundStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitCompoundStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) CompoundStatement() (localctx ICompoundStatementContext) {
	localctx = NewCompoundStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, pascalParserRULE_compoundStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1571)
		p.Match(pascalParserBEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1572)
		p.Statements()
	}
	{
		p.SetState(1573)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementsContext is an interface to support dynamic dispatch.
type IStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsStatementsContext differentiates from other interfaces.
	IsStatementsContext()
}

type StatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsContext() *StatementsContext {
	var p = new(StatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_statements
	return p
}

func InitEmptyStatementsContext(p *StatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_statements
}

func (*StatementsContext) IsStatementsContext() {}

func NewStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsContext {
	var p = new(StatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_statements

	return p
}

func (s *StatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementsContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementsContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *StatementsContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *StatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStatements(s)
	}
}

func (s *StatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStatements(s)
	}
}

func (s *StatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Statements() (localctx IStatementsContext) {
	localctx = NewStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, pascalParserRULE_statements)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1575)
		p.Statement()
	}
	p.SetState(1580)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 176, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1576)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1577)
				p.Statement()
			}

		}
		p.SetState(1582)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 176, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionalStatementContext is an interface to support dynamic dispatch.
type IConditionalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IfStatement() IIfStatementContext
	CaseStatement() ICaseStatementContext

	// IsConditionalStatementContext differentiates from other interfaces.
	IsConditionalStatementContext()
}

type ConditionalStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalStatementContext() *ConditionalStatementContext {
	var p = new(ConditionalStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_conditionalStatement
	return p
}

func InitEmptyConditionalStatementContext(p *ConditionalStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_conditionalStatement
}

func (*ConditionalStatementContext) IsConditionalStatementContext() {}

func NewConditionalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalStatementContext {
	var p = new(ConditionalStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_conditionalStatement

	return p
}

func (s *ConditionalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalStatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *ConditionalStatementContext) CaseStatement() ICaseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseStatementContext)
}

func (s *ConditionalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConditionalStatement(s)
	}
}

func (s *ConditionalStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConditionalStatement(s)
	}
}

func (s *ConditionalStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConditionalStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConditionalStatement() (localctx IConditionalStatementContext) {
	localctx = NewConditionalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, pascalParserRULE_conditionalStatement)
	p.SetState(1585)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserIF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1583)
			p.IfStatement()
		}

	case pascalParserCASE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1584)
			p.CaseStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	Expression() IExpressionContext
	THEN() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	ELSE() antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_ifStatement
	return p
}

func InitEmptyIfStatementContext(p *IfStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_ifStatement
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(pascalParserIF, 0)
}

func (s *IfStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfStatementContext) THEN() antlr.TerminalNode {
	return s.GetToken(pascalParserTHEN, 0)
}

func (s *IfStatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(pascalParserELSE, 0)
}

func (s *IfStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, pascalParserRULE_ifStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1587)
		p.Match(pascalParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1588)
		p.Expression()
	}
	{
		p.SetState(1589)
		p.Match(pascalParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1590)
		p.Statement()
	}
	p.SetState(1593)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 178, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1591)
			p.Match(pascalParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1592)
			p.Statement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1596)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1595)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseStatementContext is an interface to support dynamic dispatch.
type ICaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	Expression() IExpressionContext
	OF() antlr.TerminalNode
	AllCaseListElement() []ICaseListElementContext
	CaseListElement(i int) ICaseListElementContext
	END() antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	ELSE() antlr.TerminalNode
	Statements() IStatementsContext

	// IsCaseStatementContext differentiates from other interfaces.
	IsCaseStatementContext()
}

type CaseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseStatementContext() *CaseStatementContext {
	var p = new(CaseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_caseStatement
	return p
}

func InitEmptyCaseStatementContext(p *CaseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_caseStatement
}

func (*CaseStatementContext) IsCaseStatementContext() {}

func NewCaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseStatementContext {
	var p = new(CaseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_caseStatement

	return p
}

func (s *CaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseStatementContext) CASE() antlr.TerminalNode {
	return s.GetToken(pascalParserCASE, 0)
}

func (s *CaseStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseStatementContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *CaseStatementContext) AllCaseListElement() []ICaseListElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseListElementContext); ok {
			len++
		}
	}

	tst := make([]ICaseListElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseListElementContext); ok {
			tst[i] = t.(ICaseListElementContext)
			i++
		}
	}

	return tst
}

func (s *CaseStatementContext) CaseListElement(i int) ICaseListElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseListElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseListElementContext)
}

func (s *CaseStatementContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *CaseStatementContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *CaseStatementContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *CaseStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(pascalParserELSE, 0)
}

func (s *CaseStatementContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *CaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterCaseStatement(s)
	}
}

func (s *CaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitCaseStatement(s)
	}
}

func (s *CaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitCaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) CaseStatement() (localctx ICaseStatementContext) {
	localctx = NewCaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, pascalParserRULE_caseStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1598)
		p.Match(pascalParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1599)
		p.Expression()
	}
	{
		p.SetState(1600)
		p.Match(pascalParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1601)
		p.CaseListElement()
	}
	p.SetState(1606)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 180, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1602)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1603)
				p.CaseListElement()
			}

		}
		p.SetState(1608)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 180, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1612)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 181, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1609)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1610)
			p.Match(pascalParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1611)
			p.Statements()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1615)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserSEMI {
		{
			p.SetState(1614)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1617)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseListElementContext is an interface to support dynamic dispatch.
type ICaseListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConstList() IConstListContext
	COLON() antlr.TerminalNode
	Statement() IStatementContext

	// IsCaseListElementContext differentiates from other interfaces.
	IsCaseListElementContext()
}

type CaseListElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseListElementContext() *CaseListElementContext {
	var p = new(CaseListElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_caseListElement
	return p
}

func InitEmptyCaseListElementContext(p *CaseListElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_caseListElement
}

func (*CaseListElementContext) IsCaseListElementContext() {}

func NewCaseListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseListElementContext {
	var p = new(CaseListElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_caseListElement

	return p
}

func (s *CaseListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseListElementContext) ConstList() IConstListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstListContext)
}

func (s *CaseListElementContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *CaseListElementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *CaseListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseListElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterCaseListElement(s)
	}
}

func (s *CaseListElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitCaseListElement(s)
	}
}

func (s *CaseListElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitCaseListElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) CaseListElement() (localctx ICaseListElementContext) {
	localctx = NewCaseListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, pascalParserRULE_caseListElement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1619)
		p.ConstList()
	}
	{
		p.SetState(1620)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1621)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRepetetiveStatementContext is an interface to support dynamic dispatch.
type IRepetetiveStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WhileStatement() IWhileStatementContext
	RepeatStatement() IRepeatStatementContext
	ForStatement() IForStatementContext

	// IsRepetetiveStatementContext differentiates from other interfaces.
	IsRepetetiveStatementContext()
}

type RepetetiveStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepetetiveStatementContext() *RepetetiveStatementContext {
	var p = new(RepetetiveStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_repetetiveStatement
	return p
}

func InitEmptyRepetetiveStatementContext(p *RepetetiveStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_repetetiveStatement
}

func (*RepetetiveStatementContext) IsRepetetiveStatementContext() {}

func NewRepetetiveStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RepetetiveStatementContext {
	var p = new(RepetetiveStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_repetetiveStatement

	return p
}

func (s *RepetetiveStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RepetetiveStatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *RepetetiveStatementContext) RepeatStatement() IRepeatStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepeatStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepeatStatementContext)
}

func (s *RepetetiveStatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *RepetetiveStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepetetiveStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RepetetiveStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRepetetiveStatement(s)
	}
}

func (s *RepetetiveStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRepetetiveStatement(s)
	}
}

func (s *RepetetiveStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRepetetiveStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RepetetiveStatement() (localctx IRepetetiveStatementContext) {
	localctx = NewRepetetiveStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, pascalParserRULE_repetetiveStatement)
	p.SetState(1626)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserWHILE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1623)
			p.WhileStatement()
		}

	case pascalParserREPEAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1624)
			p.RepeatStatement()
		}

	case pascalParserFOR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1625)
			p.ForStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHILE() antlr.TerminalNode
	Expression() IExpressionContext
	DO() antlr.TerminalNode
	Statement() IStatementContext

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_whileStatement
	return p
}

func InitEmptyWhileStatementContext(p *WhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_whileStatement
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(pascalParserWHILE, 0)
}

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(pascalParserDO, 0)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (s *WhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, pascalParserRULE_whileStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1628)
		p.Match(pascalParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1629)
		p.Expression()
	}
	{
		p.SetState(1630)
		p.Match(pascalParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1631)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRepeatStatementContext is an interface to support dynamic dispatch.
type IRepeatStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPEAT() antlr.TerminalNode
	Statements() IStatementsContext
	UNTIL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsRepeatStatementContext differentiates from other interfaces.
	IsRepeatStatementContext()
}

type RepeatStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepeatStatementContext() *RepeatStatementContext {
	var p = new(RepeatStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_repeatStatement
	return p
}

func InitEmptyRepeatStatementContext(p *RepeatStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_repeatStatement
}

func (*RepeatStatementContext) IsRepeatStatementContext() {}

func NewRepeatStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RepeatStatementContext {
	var p = new(RepeatStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_repeatStatement

	return p
}

func (s *RepeatStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RepeatStatementContext) REPEAT() antlr.TerminalNode {
	return s.GetToken(pascalParserREPEAT, 0)
}

func (s *RepeatStatementContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *RepeatStatementContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(pascalParserUNTIL, 0)
}

func (s *RepeatStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RepeatStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepeatStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RepeatStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRepeatStatement(s)
	}
}

func (s *RepeatStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRepeatStatement(s)
	}
}

func (s *RepeatStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRepeatStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RepeatStatement() (localctx IRepeatStatementContext) {
	localctx = NewRepeatStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, pascalParserRULE_repeatStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1633)
		p.Match(pascalParserREPEAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1634)
		p.Statements()
	}
	{
		p.SetState(1635)
		p.Match(pascalParserUNTIL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1636)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode
	ForList() IForListContext
	DO() antlr.TerminalNode
	Statement() IStatementContext

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forStatement
	return p
}

func InitEmptyForStatementContext(p *ForStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forStatement
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(pascalParserFOR, 0)
}

func (s *ForStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ForStatementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(pascalParserASSIGN, 0)
}

func (s *ForStatementContext) ForList() IForListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForListContext)
}

func (s *ForStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(pascalParserDO, 0)
}

func (s *ForStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (s *ForStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitForStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ForStatement() (localctx IForStatementContext) {
	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, pascalParserRULE_forStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1638)
		p.Match(pascalParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1639)
		p.Identifier()
	}
	{
		p.SetState(1640)
		p.Match(pascalParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1641)
		p.ForList()
	}
	{
		p.SetState(1642)
		p.Match(pascalParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1643)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForListContext is an interface to support dynamic dispatch.
type IForListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InitialValue() IInitialValueContext
	FinalValue() IFinalValueContext
	TO() antlr.TerminalNode
	DOWNTO() antlr.TerminalNode

	// IsForListContext differentiates from other interfaces.
	IsForListContext()
}

type ForListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForListContext() *ForListContext {
	var p = new(ForListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forList
	return p
}

func InitEmptyForListContext(p *ForListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forList
}

func (*ForListContext) IsForListContext() {}

func NewForListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForListContext {
	var p = new(ForListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_forList

	return p
}

func (s *ForListContext) GetParser() antlr.Parser { return s.parser }

func (s *ForListContext) InitialValue() IInitialValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitialValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitialValueContext)
}

func (s *ForListContext) FinalValue() IFinalValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinalValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinalValueContext)
}

func (s *ForListContext) TO() antlr.TerminalNode {
	return s.GetToken(pascalParserTO, 0)
}

func (s *ForListContext) DOWNTO() antlr.TerminalNode {
	return s.GetToken(pascalParserDOWNTO, 0)
}

func (s *ForListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterForList(s)
	}
}

func (s *ForListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitForList(s)
	}
}

func (s *ForListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitForList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ForList() (localctx IForListContext) {
	localctx = NewForListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, pascalParserRULE_forList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1645)
		p.InitialValue()
	}
	{
		p.SetState(1646)
		_la = p.GetTokenStream().LA(1)

		if !(_la == pascalParserDOWNTO || _la == pascalParserTO) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1647)
		p.FinalValue()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitialValueContext is an interface to support dynamic dispatch.
type IInitialValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsInitialValueContext differentiates from other interfaces.
	IsInitialValueContext()
}

type InitialValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitialValueContext() *InitialValueContext {
	var p = new(InitialValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_initialValue
	return p
}

func InitEmptyInitialValueContext(p *InitialValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_initialValue
}

func (*InitialValueContext) IsInitialValueContext() {}

func NewInitialValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitialValueContext {
	var p = new(InitialValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_initialValue

	return p
}

func (s *InitialValueContext) GetParser() antlr.Parser { return s.parser }

func (s *InitialValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InitialValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitialValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitialValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInitialValue(s)
	}
}

func (s *InitialValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInitialValue(s)
	}
}

func (s *InitialValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInitialValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InitialValue() (localctx IInitialValueContext) {
	localctx = NewInitialValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, pascalParserRULE_initialValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1649)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFinalValueContext is an interface to support dynamic dispatch.
type IFinalValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsFinalValueContext differentiates from other interfaces.
	IsFinalValueContext()
}

type FinalValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinalValueContext() *FinalValueContext {
	var p = new(FinalValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_finalValue
	return p
}

func InitEmptyFinalValueContext(p *FinalValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_finalValue
}

func (*FinalValueContext) IsFinalValueContext() {}

func NewFinalValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinalValueContext {
	var p = new(FinalValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_finalValue

	return p
}

func (s *FinalValueContext) GetParser() antlr.Parser { return s.parser }

func (s *FinalValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FinalValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinalValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinalValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFinalValue(s)
	}
}

func (s *FinalValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFinalValue(s)
	}
}

func (s *FinalValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFinalValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FinalValue() (localctx IFinalValueContext) {
	localctx = NewFinalValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, pascalParserRULE_finalValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1651)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithStatementContext is an interface to support dynamic dispatch.
type IWithStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	WithStatementVariableList() IWithStatementVariableListContext
	DO() antlr.TerminalNode
	Statement() IStatementContext
	Expression() IExpressionContext

	// IsWithStatementContext differentiates from other interfaces.
	IsWithStatementContext()
}

type WithStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithStatementContext() *WithStatementContext {
	var p = new(WithStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_withStatement
	return p
}

func InitEmptyWithStatementContext(p *WithStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_withStatement
}

func (*WithStatementContext) IsWithStatementContext() {}

func NewWithStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithStatementContext {
	var p = new(WithStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_withStatement

	return p
}

func (s *WithStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WithStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(pascalParserWITH, 0)
}

func (s *WithStatementContext) WithStatementVariableList() IWithStatementVariableListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithStatementVariableListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithStatementVariableListContext)
}

func (s *WithStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(pascalParserDO, 0)
}

func (s *WithStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WithStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WithStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterWithStatement(s)
	}
}

func (s *WithStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitWithStatement(s)
	}
}

func (s *WithStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitWithStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) WithStatement() (localctx IWithStatementContext) {
	localctx = NewWithStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, pascalParserRULE_withStatement)
	p.SetState(1663)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 184, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1653)
			p.Match(pascalParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1654)
			p.WithStatementVariableList()
		}
		{
			p.SetState(1655)
			p.Match(pascalParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1656)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1658)
			p.Match(pascalParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1659)
			p.Expression()
		}
		{
			p.SetState(1660)
			p.Match(pascalParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1661)
			p.Statement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryExceptStatementContext is an interface to support dynamic dispatch.
type ITryExceptStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRY() antlr.TerminalNode
	AllStatements() []IStatementsContext
	Statements(i int) IStatementsContext
	EXCEPT() antlr.TerminalNode
	END() antlr.TerminalNode

	// IsTryExceptStatementContext differentiates from other interfaces.
	IsTryExceptStatementContext()
}

type TryExceptStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryExceptStatementContext() *TryExceptStatementContext {
	var p = new(TryExceptStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tryExceptStatement
	return p
}

func InitEmptyTryExceptStatementContext(p *TryExceptStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tryExceptStatement
}

func (*TryExceptStatementContext) IsTryExceptStatementContext() {}

func NewTryExceptStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryExceptStatementContext {
	var p = new(TryExceptStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_tryExceptStatement

	return p
}

func (s *TryExceptStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryExceptStatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(pascalParserTRY, 0)
}

func (s *TryExceptStatementContext) AllStatements() []IStatementsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementsContext); ok {
			len++
		}
	}

	tst := make([]IStatementsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementsContext); ok {
			tst[i] = t.(IStatementsContext)
			i++
		}
	}

	return tst
}

func (s *TryExceptStatementContext) Statements(i int) IStatementsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *TryExceptStatementContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(pascalParserEXCEPT, 0)
}

func (s *TryExceptStatementContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *TryExceptStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryExceptStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryExceptStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTryExceptStatement(s)
	}
}

func (s *TryExceptStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTryExceptStatement(s)
	}
}

func (s *TryExceptStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTryExceptStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TryExceptStatement() (localctx ITryExceptStatementContext) {
	localctx = NewTryExceptStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, pascalParserRULE_tryExceptStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1665)
		p.Match(pascalParserTRY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1666)
		p.Statements()
	}
	{
		p.SetState(1667)
		p.Match(pascalParserEXCEPT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1668)
		p.Statements()
	}
	{
		p.SetState(1669)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryFinallyStatementContext is an interface to support dynamic dispatch.
type ITryFinallyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRY() antlr.TerminalNode
	AllStatements() []IStatementsContext
	Statements(i int) IStatementsContext
	FINALLY() antlr.TerminalNode
	END() antlr.TerminalNode

	// IsTryFinallyStatementContext differentiates from other interfaces.
	IsTryFinallyStatementContext()
}

type TryFinallyStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryFinallyStatementContext() *TryFinallyStatementContext {
	var p = new(TryFinallyStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tryFinallyStatement
	return p
}

func InitEmptyTryFinallyStatementContext(p *TryFinallyStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tryFinallyStatement
}

func (*TryFinallyStatementContext) IsTryFinallyStatementContext() {}

func NewTryFinallyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryFinallyStatementContext {
	var p = new(TryFinallyStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_tryFinallyStatement

	return p
}

func (s *TryFinallyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryFinallyStatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(pascalParserTRY, 0)
}

func (s *TryFinallyStatementContext) AllStatements() []IStatementsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementsContext); ok {
			len++
		}
	}

	tst := make([]IStatementsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementsContext); ok {
			tst[i] = t.(IStatementsContext)
			i++
		}
	}

	return tst
}

func (s *TryFinallyStatementContext) Statements(i int) IStatementsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *TryFinallyStatementContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(pascalParserFINALLY, 0)
}

func (s *TryFinallyStatementContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *TryFinallyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryFinallyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryFinallyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTryFinallyStatement(s)
	}
}

func (s *TryFinallyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTryFinallyStatement(s)
	}
}

func (s *TryFinallyStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTryFinallyStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TryFinallyStatement() (localctx ITryFinallyStatementContext) {
	localctx = NewTryFinallyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, pascalParserRULE_tryFinallyStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1671)
		p.Match(pascalParserTRY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1672)
		p.Statements()
	}
	{
		p.SetState(1673)
		p.Match(pascalParserFINALLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1674)
		p.Statements()
	}
	{
		p.SetState(1675)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithStatementVariableListContext is an interface to support dynamic dispatch.
type IWithStatementVariableListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariableDesignator() []IVariableDesignatorContext
	VariableDesignator(i int) IVariableDesignatorContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWithStatementVariableListContext differentiates from other interfaces.
	IsWithStatementVariableListContext()
}

type WithStatementVariableListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithStatementVariableListContext() *WithStatementVariableListContext {
	var p = new(WithStatementVariableListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_withStatementVariableList
	return p
}

func InitEmptyWithStatementVariableListContext(p *WithStatementVariableListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_withStatementVariableList
}

func (*WithStatementVariableListContext) IsWithStatementVariableListContext() {}

func NewWithStatementVariableListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithStatementVariableListContext {
	var p = new(WithStatementVariableListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_withStatementVariableList

	return p
}

func (s *WithStatementVariableListContext) GetParser() antlr.Parser { return s.parser }

func (s *WithStatementVariableListContext) AllVariableDesignator() []IVariableDesignatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDesignatorContext); ok {
			len++
		}
	}

	tst := make([]IVariableDesignatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDesignatorContext); ok {
			tst[i] = t.(IVariableDesignatorContext)
			i++
		}
	}

	return tst
}

func (s *WithStatementVariableListContext) VariableDesignator(i int) IVariableDesignatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDesignatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDesignatorContext)
}

func (s *WithStatementVariableListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *WithStatementVariableListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *WithStatementVariableListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithStatementVariableListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithStatementVariableListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterWithStatementVariableList(s)
	}
}

func (s *WithStatementVariableListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitWithStatementVariableList(s)
	}
}

func (s *WithStatementVariableListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitWithStatementVariableList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) WithStatementVariableList() (localctx IWithStatementVariableListContext) {
	localctx = NewWithStatementVariableListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, pascalParserRULE_withStatementVariableList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1677)
		p.VariableDesignator()
	}
	p.SetState(1682)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(1678)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1679)
			p.VariableDesignator()
		}

		p.SetState(1684)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeSectionContext is an interface to support dynamic dispatch.
type IAttributeSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	AttributeList() IAttributeListContext
	RBRACK() antlr.TerminalNode

	// IsAttributeSectionContext differentiates from other interfaces.
	IsAttributeSectionContext()
}

type AttributeSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeSectionContext() *AttributeSectionContext {
	var p = new(AttributeSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_attributeSection
	return p
}

func InitEmptyAttributeSectionContext(p *AttributeSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_attributeSection
}

func (*AttributeSectionContext) IsAttributeSectionContext() {}

func NewAttributeSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeSectionContext {
	var p = new(AttributeSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_attributeSection

	return p
}

func (s *AttributeSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeSectionContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *AttributeSectionContext) AttributeList() IAttributeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeListContext)
}

func (s *AttributeSectionContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *AttributeSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAttributeSection(s)
	}
}

func (s *AttributeSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAttributeSection(s)
	}
}

func (s *AttributeSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAttributeSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) AttributeSection() (localctx IAttributeSectionContext) {
	localctx = NewAttributeSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, pascalParserRULE_attributeSection)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1685)
		p.Match(pascalParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1686)
		p.AttributeList()
	}
	{
		p.SetState(1687)
		p.Match(pascalParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeListContext is an interface to support dynamic dispatch.
type IAttributeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAttributeItem() []IAttributeItemContext
	AttributeItem(i int) IAttributeItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAttributeListContext differentiates from other interfaces.
	IsAttributeListContext()
}

type AttributeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeListContext() *AttributeListContext {
	var p = new(AttributeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_attributeList
	return p
}

func InitEmptyAttributeListContext(p *AttributeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_attributeList
}

func (*AttributeListContext) IsAttributeListContext() {}

func NewAttributeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeListContext {
	var p = new(AttributeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_attributeList

	return p
}

func (s *AttributeListContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeListContext) AllAttributeItem() []IAttributeItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeItemContext); ok {
			len++
		}
	}

	tst := make([]IAttributeItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeItemContext); ok {
			tst[i] = t.(IAttributeItemContext)
			i++
		}
	}

	return tst
}

func (s *AttributeListContext) AttributeItem(i int) IAttributeItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeItemContext)
}

func (s *AttributeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *AttributeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *AttributeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAttributeList(s)
	}
}

func (s *AttributeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAttributeList(s)
	}
}

func (s *AttributeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAttributeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) AttributeList() (localctx IAttributeListContext) {
	localctx = NewAttributeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, pascalParserRULE_attributeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1689)
		p.AttributeItem()
	}
	p.SetState(1694)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(1690)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1691)
			p.AttributeItem()
		}

		p.SetState(1696)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeItemContext is an interface to support dynamic dispatch.
type IAttributeItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext
	RPAREN() antlr.TerminalNode

	// IsAttributeItemContext differentiates from other interfaces.
	IsAttributeItemContext()
}

type AttributeItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeItemContext() *AttributeItemContext {
	var p = new(AttributeItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_attributeItem
	return p
}

func InitEmptyAttributeItemContext(p *AttributeItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_attributeItem
}

func (*AttributeItemContext) IsAttributeItemContext() {}

func NewAttributeItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeItemContext {
	var p = new(AttributeItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_attributeItem

	return p
}

func (s *AttributeItemContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AttributeItemContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *AttributeItemContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *AttributeItemContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *AttributeItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAttributeItem(s)
	}
}

func (s *AttributeItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAttributeItem(s)
	}
}

func (s *AttributeItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAttributeItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) AttributeItem() (localctx IAttributeItemContext) {
	localctx = NewAttributeItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, pascalParserRULE_attributeItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1697)
		p.Identifier()
	}
	p.SetState(1702)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1698)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1699)
			p.ParameterList()
		}
		{
			p.SetState(1700)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *pascalParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 126:
		var t *FactorContext = nil
		if localctx != nil {
			t = localctx.(*FactorContext)
		}
		return p.Factor_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *pascalParser) Factor_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
