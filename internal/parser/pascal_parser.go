// Code generated from /home/tomas/development/tomas303/projects/pascallsp/palsp/internal/pascal.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // pascal

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type pascalParser struct {
	*antlr.BaseParser
}

var PascalParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func pascalParserInit() {
	staticData := &PascalParserStaticData
	staticData.LiteralNames = []string{
		"", "", "'AND'", "'ARRAY'", "'BEGIN'", "'BOOLEAN'", "'CASE'", "'CHAR'",
		"'CHR'", "'CONST'", "'DEPRECATED'", "'DIV'", "'DO'", "'DOWNTO'", "'ELSE'",
		"'END'", "'FILE'", "'FOR'", "'FUNCTION'", "'GOTO'", "'HELPER'", "'IF'",
		"'IN'", "'INTEGER'", "'LABEL'", "'MOD'", "'NIL'", "'NOT'", "'OF'", "'OR'",
		"'PACKED'", "'PROCEDURE'", "'PROGRAM'", "'REAL'", "'RECORD'", "'REFERENCE'",
		"'REPEAT'", "'SET'", "'THEN'", "'TO'", "'TYPE'", "'UNTIL'", "'VAR'",
		"'WHILE'", "'WITH'", "'+'", "'-'", "'*'", "'/'", "':='", "','", "';'",
		"':'", "'='", "'<>'", "'<'", "'<='", "'>='", "'>'", "'('", "')'", "'['",
		"'(.'", "']'", "'.)'", "'^'", "'@'", "'.'", "'..'", "'{'", "'}'", "'UNIT'",
		"'INTERFACE'", "'USES'", "'STRING'", "'IMPLEMENTATION'", "'TRUE'", "'FALSE'",
		"'CLASS'", "'PRIVATE'", "'PROTECTED'", "'PUBLIC'", "'PUBLISHED'", "'STRICT'",
		"'OUT'", "'PROPERTY'", "'READ'", "'WRITE'", "'DEFAULT'", "'INDEX'",
		"'AS'", "'TRY'", "'FINALLY'", "'EXCEPT'", "'INITIALIZATION'", "'FINALIZATION'",
		"'OBJECT'", "'INHERITED'", "'ABSTRACT'", "'REINTRODUCE'", "'VIRTUAL'",
		"'OVERRIDE'", "'OVERLOAD'", "'INLINE'", "'CDECL'", "'stdcall'", "'STATIC'",
		"'CONSTRUCTOR'", "'DESTRUCTOR'", "'resourcestring'", "'FORWARD'", "'RAISE'",
		"'SHR'", "'SHL'", "'XOR'", "'Cardinal'", "'LONGBOOL'", "'LONGINT'",
		"'LONGWORD'", "'WORD'", "'operator'", "'ON'", "", "", "", "", "", "",
		"", "", "", "", "'\\uFEFF'", "'BYTE'", "'SHORTINT'", "'SMALLINT'", "'INT64'",
		"'UINT64'", "'SINGLE'", "'DOUBLE'", "'EXTENDED'", "'COMP'", "'CURRENCY'",
		"'ANSICHAR'", "'WIDECHAR'", "'ANSISTRING'", "'WIDESTRING'", "'UNICODESTRING'",
		"'RAWBYTESTRING'", "'UTF8STRING'", "'VARIANT'", "'OLEVARIANT'", "'POINTER'",
		"'PCHAR'", "'PANSICHAR'", "'PWIDECHAR'", "'PUNICODECHAR'", "'THANDLE'",
		"'HWND'", "'HDC'", "'HICON'", "'HBITMAP'", "'HMENU'", "'HINSTANCE'",
		"'HMODULE'", "'HKEY'", "'DWORD'", "'QWORD'", "'NATIVEINT'", "'NATIVEUINT'",
		"'CODEPAGE'", "'TGUID'", "'PGUID'", "'TEXTFILE'", "'TEXT'", "'SHORTSTRING'",
		"'OPENSTRING'",
	}
	staticData.SymbolicNames = []string{
		"", "GUID_LITERAL", "AND", "ARRAY", "BEGIN", "BOOLEAN", "CASE", "CHAR",
		"CHR", "CONST", "DEPRECATED", "DIV", "DO", "DOWNTO", "ELSE", "END",
		"FILE", "FOR", "FUNCTION", "GOTO", "HELPER", "IF", "IN", "INTEGER",
		"LABEL", "MOD", "NIL", "NOT", "OF", "OR", "PACKED", "PROCEDURE", "PROGRAM",
		"REAL", "RECORD", "REFERENCE", "REPEAT", "SET", "THEN", "TO", "TYPE",
		"UNTIL", "VAR", "WHILE", "WITH", "PLUS", "MINUS", "STAR", "SLASH", "ASSIGN",
		"COMMA", "SEMI", "COLON", "EQUAL", "NOT_EQUAL", "LT", "LE", "GE", "GT",
		"LPAREN", "RPAREN", "LBRACK", "LBRACK2", "RBRACK", "RBRACK2", "DEREFERENCE",
		"AT", "DOT", "DOTDOT", "LCURLY", "RCURLY", "UNIT", "INTERFACE", "USES",
		"STRING", "IMPLEMENTATION", "TRUE", "FALSE", "CLASS", "PRIVATE", "PROTECTED",
		"PUBLIC", "PUBLISHED", "STRICT", "OUT", "PROPERTY", "READ", "WRITE",
		"DEFAULT", "INDEX", "AS", "TRY", "FINALLY", "EXCEPT", "INITIALIZATION",
		"FINALIZATION", "OBJECT", "INHERITED", "ABSTRACT", "REINTRODUCE", "VIRTUAL",
		"OVERRIDE", "OVERLOAD", "INLINE", "CDECL", "STDCALL", "STATIC", "CONSTRUCTOR",
		"DESTRUCTOR", "RESOURCESTRING", "FORWARD", "RAISE", "SHR", "SHL", "XOR",
		"CARDINAL", "LONGBOOL", "LONGINT", "LONGWORD", "WORD", "OPERATOR", "ON",
		"WS", "COMMENT_1", "COMMENT_2", "COMMENT_3", "IDENT", "HEX_LITERAL",
		"STRING_LITERAL", "STRING_CROSSHATCH_LITERAL", "NUM_INT", "NUM_REAL",
		"UTF8BOM", "BYTE", "SHORTINT", "SMALLINT", "INT64", "UINT64", "SINGLE",
		"DOUBLE", "EXTENDED", "COMP", "CURRENCY", "ANSICHAR", "WIDECHAR", "ANSISTRING",
		"WIDESTRING", "UNICODESTRING", "RAWBYTESTRING", "UTF8STRING", "VARIANT",
		"OLEVARIANT", "POINTER", "PCHAR", "PANSICHAR", "PWIDECHAR", "PUNICODECHAR",
		"THANDLE", "HWND", "HDC", "HICON", "HBITMAP", "HMENU", "HINSTANCE",
		"HMODULE", "HKEY", "DWORD", "QWORD", "NATIVEINT", "NATIVEUINT", "CODEPAGE",
		"TGUID", "PGUID", "TEXTFILE", "TEXT", "SHORTSTRING", "OPENSTRING",
	}
	staticData.RuleNames = []string{
		"source", "program", "unit", "interfaceSection", "implementationSection",
		"initializationSection", "finalizationSection", "identifier", "identifierPart",
		"interfaceBlock", "errorInterfaceBlockPart", "implementationBlock",
		"block", "usesUnits", "labelDeclarationPart", "label", "constantDefinitionPart",
		"constantDefinition", "constantChr", "hexConstant", "constant", "arrayConstant",
		"recordConstant", "recordField", "unsignedNumber", "unsignedInteger",
		"unsignedReal", "sign", "bool_", "string", "stringExpression", "resourceDefinitionPart",
		"resourceDefinition", "deprecatedHint", "typeDefinitionPart", "typeDefinition",
		"classTypeOrForward", "interfaceTypeOrForward", "forwardDeclaration",
		"classType", "interfaceType", "functionType", "procedureType", "metaClassType",
		"aliasDistinctType", "aliasType", "classImplementsInterfaces", "accessSpecifier",
		"classDeclaration", "classImplicitPublishedDeclaration", "classDeclarationPart",
		"interfaceGuidConst", "interfaceDeclaration", "interfaceDeclarationPart",
		"errorInterfaceDeclarationPart", "errorClassDeclarationPart", "propertyDeclaration",
		"propertyReadDeclaration", "propertyWriteDeclaration", "propertyDefaultValueDeclaration",
		"propertyIndexDeclaration", "propertyIndexParameters", "propertyIndexParametersList",
		"genericTemplate", "genericTemplateList", "genericTypeParameter", "genericConstraints",
		"genericConstraint", "type_", "simpleType", "scalarType", "scalerList",
		"scalerMember", "subrangeType", "typeIdentifier", "structuredType",
		"unpackedStructuredType", "stringtype", "ansistringtype", "arrayType",
		"typeList", "indexType", "recordType", "recordDeclaration", "recordImplicitPublishedDeclaration",
		"recordDeclarationPart", "errorRecordDeclarationPart", "recordParts",
		"recordFixedPart", "recordVariantPart", "tag", "recordVariant", "helperType",
		"helperDeclaration", "helperImplicitPublishedDeclaration", "helperDeclarationPart",
		"errorHelperDeclarationPart", "setType", "fileType", "pointerType",
		"variableDeclarationPart", "variableDeclaration", "procedureHeader",
		"functionHeader", "procedureOrFunctionHeader", "procedureOrFunctionHeaderModifiers",
		"procedureOrFunctionDeclaration", "procedureDeclaration", "functionDeclaration",
		"procedureLambdaDeclaration", "functionLambdaDeclaration", "resultType",
		"procedureOrFunctionBody", "classOperatorHeader", "classOperatorDeclaration",
		"formalParameterList", "formalParameterSection", "parameterGroup", "identifierList",
		"constList", "defaultValue", "typedIdentifierList", "statement", "errorStatement",
		"unlabelledStatement", "simpleStatement", "assignmentStatement", "raiseExceptionStatement",
		"variableDeclarationStatement", "variableDesignator", "typeCast", "propertyDesignator",
		"expression", "relationaloperator", "simpleExpression", "additiveoperator",
		"term", "multiplicativeoperator", "signedFactor", "factor", "unsignedConstant",
		"functionDesignator", "defaultDesignator", "parameterList", "set_",
		"elementList", "element", "procedureStatement", "methodCallStatement",
		"actualParameter", "parameterwidth", "gotoStatement", "inheritedStatement",
		"emptyStatement_", "empty_", "structuredStatement", "compoundStatement",
		"statements", "conditionalStatement", "ifStatement", "caseStatement",
		"caseListElement", "repetetiveStatement", "whileStatement", "repeatStatement",
		"forStatement", "forList", "initialValue", "finalValue", "withStatement",
		"tryExceptStatement", "exceptionCase", "exceptionElse", "tryFinallyStatement",
		"withStatementVariableList", "attributeSection", "attributeList", "attributeItem",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 176, 1955, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 1, 0, 1, 0, 3, 0, 359, 8, 0, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 3, 1, 367, 8, 1, 1, 1, 1, 1, 3, 1, 371, 8, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2,
		385, 8, 2, 1, 2, 3, 2, 388, 8, 2, 1, 2, 3, 2, 391, 8, 2, 1, 2, 1, 2, 1,
		2, 1, 2, 1, 3, 1, 3, 3, 3, 399, 8, 3, 1, 3, 1, 3, 1, 4, 1, 4, 3, 4, 405,
		8, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 1, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7,
		5, 7, 418, 8, 7, 10, 7, 12, 7, 421, 9, 7, 1, 8, 1, 8, 3, 8, 425, 8, 8,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 5, 9, 434, 8, 9, 10, 9, 12, 9,
		437, 9, 9, 1, 10, 1, 10, 4, 10, 441, 8, 10, 11, 10, 12, 10, 442, 1, 11,
		1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 5,
		11, 456, 8, 11, 10, 11, 12, 11, 459, 9, 11, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 5, 12, 466, 8, 12, 10, 12, 12, 12, 469, 9, 12, 1, 13, 1, 13, 1,
		13, 1, 13, 1, 14, 1, 14, 1, 14, 1, 14, 5, 14, 479, 8, 14, 10, 14, 12, 14,
		482, 9, 14, 1, 14, 1, 14, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 1, 16, 4,
		16, 492, 8, 16, 11, 16, 12, 16, 493, 1, 17, 1, 17, 1, 17, 3, 17, 499, 8,
		17, 1, 17, 1, 17, 1, 17, 3, 17, 504, 8, 17, 1, 17, 1, 17, 1, 17, 1, 17,
		1, 17, 1, 17, 3, 17, 512, 8, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1,
		17, 3, 17, 520, 8, 17, 3, 17, 522, 8, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 1, 19, 1, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 3, 20,
		538, 8, 20, 5, 20, 540, 8, 20, 10, 20, 12, 20, 543, 9, 20, 1, 20, 1, 20,
		3, 20, 547, 8, 20, 1, 21, 1, 21, 1, 21, 1, 21, 5, 21, 553, 8, 21, 10, 21,
		12, 21, 556, 9, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 5, 21, 564,
		8, 21, 10, 21, 12, 21, 567, 9, 21, 1, 21, 1, 21, 3, 21, 571, 8, 21, 1,
		22, 1, 22, 1, 22, 1, 22, 5, 22, 577, 8, 22, 10, 22, 12, 22, 580, 9, 22,
		1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1,
		23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 3, 23, 598, 8, 23, 1, 24, 1, 24,
		3, 24, 602, 8, 24, 1, 25, 1, 25, 1, 26, 1, 26, 1, 27, 1, 27, 1, 28, 1,
		28, 1, 29, 4, 29, 613, 8, 29, 11, 29, 12, 29, 614, 1, 30, 1, 30, 1, 30,
		1, 30, 3, 30, 621, 8, 30, 5, 30, 623, 8, 30, 10, 30, 12, 30, 626, 9, 30,
		1, 31, 1, 31, 4, 31, 630, 8, 31, 11, 31, 12, 31, 631, 1, 32, 1, 32, 1,
		32, 1, 32, 1, 32, 1, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 34, 5, 34,
		646, 8, 34, 10, 34, 12, 34, 649, 9, 34, 1, 34, 3, 34, 652, 8, 34, 1, 35,
		3, 35, 655, 8, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1,
		35, 1, 35, 1, 35, 3, 35, 667, 8, 35, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36,
		1, 36, 3, 36, 675, 8, 36, 1, 36, 3, 36, 678, 8, 36, 1, 36, 1, 36, 5, 36,
		682, 8, 36, 10, 36, 12, 36, 685, 9, 36, 1, 36, 1, 36, 3, 36, 689, 8, 36,
		1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 3, 37, 696, 8, 37, 1, 37, 3, 37, 699,
		8, 37, 1, 37, 1, 37, 1, 37, 3, 37, 704, 8, 37, 1, 38, 1, 38, 1, 39, 1,
		39, 1, 39, 1, 39, 1, 39, 1, 39, 3, 39, 714, 8, 39, 1, 39, 3, 39, 717, 8,
		39, 1, 39, 1, 39, 5, 39, 721, 8, 39, 10, 39, 12, 39, 724, 9, 39, 1, 39,
		1, 39, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 733, 8, 40, 1, 40, 3,
		40, 736, 8, 40, 1, 40, 1, 40, 1, 40, 1, 41, 1, 41, 3, 41, 743, 8, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 3, 41, 749, 8, 41, 1, 41, 1, 41, 1, 41, 1, 41,
		1, 41, 1, 41, 3, 41, 757, 8, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 763,
		8, 41, 1, 42, 1, 42, 3, 42, 767, 8, 42, 1, 42, 1, 42, 3, 42, 771, 8, 42,
		1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 778, 8, 42, 1, 42, 3, 42, 781,
		8, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1, 44, 1, 44, 1, 44, 1, 45, 1, 45, 1,
		46, 1, 46, 5, 46, 794, 8, 46, 10, 46, 12, 46, 797, 9, 46, 1, 47, 3, 47,
		800, 8, 47, 1, 47, 1, 47, 3, 47, 804, 8, 47, 1, 47, 1, 47, 1, 47, 3, 47,
		809, 8, 47, 1, 48, 1, 48, 5, 48, 813, 8, 48, 10, 48, 12, 48, 816, 9, 48,
		1, 49, 5, 49, 819, 8, 49, 10, 49, 12, 49, 822, 9, 49, 1, 50, 3, 50, 825,
		8, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1,
		50, 1, 50, 3, 50, 838, 8, 50, 1, 50, 1, 50, 1, 50, 3, 50, 843, 8, 50, 1,
		51, 1, 51, 1, 52, 5, 52, 848, 8, 52, 10, 52, 12, 52, 851, 9, 52, 1, 53,
		1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 861, 8, 53, 1,
		54, 4, 54, 864, 8, 54, 11, 54, 12, 54, 865, 1, 55, 4, 55, 869, 8, 55, 11,
		55, 12, 55, 870, 1, 56, 1, 56, 1, 56, 3, 56, 876, 8, 56, 1, 56, 1, 56,
		1, 56, 3, 56, 881, 8, 56, 1, 56, 3, 56, 884, 8, 56, 1, 56, 3, 56, 887,
		8, 56, 1, 56, 3, 56, 890, 8, 56, 1, 56, 1, 56, 3, 56, 894, 8, 56, 1, 56,
		1, 56, 1, 56, 3, 56, 899, 8, 56, 3, 56, 901, 8, 56, 1, 57, 1, 57, 1, 57,
		1, 58, 1, 58, 1, 58, 1, 59, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 1, 61, 1,
		61, 1, 61, 1, 61, 5, 61, 919, 8, 61, 10, 61, 12, 61, 922, 9, 61, 1, 61,
		1, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 5, 62, 934,
		8, 62, 10, 62, 12, 62, 937, 9, 62, 1, 63, 1, 63, 1, 63, 1, 63, 1, 64, 1,
		64, 1, 64, 5, 64, 946, 8, 64, 10, 64, 12, 64, 949, 9, 64, 1, 65, 1, 65,
		1, 65, 3, 65, 954, 8, 65, 1, 66, 1, 66, 1, 66, 5, 66, 959, 8, 66, 10, 66,
		12, 66, 962, 9, 66, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 3,
		67, 971, 8, 67, 1, 68, 1, 68, 1, 68, 3, 68, 976, 8, 68, 1, 69, 1, 69, 1,
		69, 1, 69, 1, 69, 3, 69, 983, 8, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 71,
		1, 71, 1, 71, 5, 71, 992, 8, 71, 10, 71, 12, 71, 995, 9, 71, 1, 72, 1,
		72, 1, 72, 3, 72, 1000, 8, 72, 1, 73, 1, 73, 1, 73, 1, 73, 1, 74, 1, 74,
		1, 74, 3, 74, 1009, 8, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3,
		75, 1017, 8, 75, 1, 75, 1, 75, 3, 75, 1021, 8, 75, 1, 76, 1, 76, 1, 76,
		3, 76, 1026, 8, 76, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 1032, 8, 77, 1,
		77, 1, 77, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 1040, 8, 78, 1, 78, 1, 78,
		1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 1052, 8,
		79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 1062,
		8, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 1070, 8, 79, 1,
		80, 1, 80, 1, 80, 5, 80, 1075, 8, 80, 10, 80, 12, 80, 1078, 9, 80, 1, 81,
		1, 81, 1, 82, 1, 82, 1, 82, 5, 82, 1085, 8, 82, 10, 82, 12, 82, 1088, 9,
		82, 1, 82, 1, 82, 1, 82, 1, 82, 3, 82, 1094, 8, 82, 1, 82, 3, 82, 1097,
		8, 82, 1, 83, 1, 83, 5, 83, 1101, 8, 83, 10, 83, 12, 83, 1104, 9, 83, 1,
		84, 5, 84, 1107, 8, 84, 10, 84, 12, 84, 1110, 9, 84, 1, 85, 3, 85, 1113,
		8, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1,
		85, 1, 85, 1, 85, 3, 85, 1127, 8, 85, 1, 85, 1, 85, 1, 85, 3, 85, 1132,
		8, 85, 1, 86, 4, 86, 1135, 8, 86, 11, 86, 12, 86, 1136, 1, 87, 1, 87, 1,
		87, 3, 87, 1142, 8, 87, 1, 87, 3, 87, 1145, 8, 87, 1, 88, 1, 88, 1, 88,
		5, 88, 1150, 8, 88, 10, 88, 12, 88, 1153, 9, 88, 1, 88, 3, 88, 1156, 8,
		88, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 5, 89, 1164, 8, 89, 10, 89,
		12, 89, 1167, 9, 89, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 3, 90, 1174, 8,
		90, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 92, 1, 92, 1, 92, 1, 92,
		1, 92, 1, 92, 5, 92, 1188, 8, 92, 10, 92, 12, 92, 1191, 9, 92, 1, 92, 1,
		92, 1, 93, 1, 93, 5, 93, 1197, 8, 93, 10, 93, 12, 93, 1200, 9, 93, 1, 94,
		5, 94, 1203, 8, 94, 10, 94, 12, 94, 1206, 9, 94, 1, 95, 1, 95, 1, 95, 1,
		95, 1, 95, 1, 95, 1, 95, 1, 95, 3, 95, 1216, 8, 95, 1, 95, 1, 95, 1, 95,
		3, 95, 1221, 8, 95, 1, 96, 4, 96, 1224, 8, 96, 11, 96, 12, 96, 1225, 1,
		97, 1, 97, 1, 97, 1, 97, 1, 98, 1, 98, 1, 98, 1, 98, 3, 98, 1236, 8, 98,
		1, 99, 1, 99, 1, 99, 1, 100, 1, 100, 1, 100, 1, 100, 5, 100, 1245, 8, 100,
		10, 100, 12, 100, 1248, 9, 100, 1, 100, 1, 100, 1, 101, 3, 101, 1253, 8,
		101, 1, 101, 1, 101, 1, 101, 3, 101, 1258, 8, 101, 1, 102, 3, 102, 1261,
		8, 102, 1, 102, 3, 102, 1264, 8, 102, 1, 102, 1, 102, 1, 102, 3, 102, 1269,
		8, 102, 1, 102, 1, 102, 3, 102, 1273, 8, 102, 1, 102, 1, 102, 1, 102, 1,
		102, 1, 102, 3, 102, 1280, 8, 102, 1, 103, 3, 103, 1283, 8, 103, 1, 103,
		3, 103, 1286, 8, 103, 1, 103, 1, 103, 1, 103, 3, 103, 1291, 8, 103, 1,
		103, 1, 103, 1, 103, 1, 103, 3, 103, 1297, 8, 103, 1, 103, 1, 103, 1, 103,
		1, 103, 1, 103, 3, 103, 1304, 8, 103, 1, 104, 1, 104, 3, 104, 1308, 8,
		104, 1, 105, 1, 105, 5, 105, 1312, 8, 105, 10, 105, 12, 105, 1315, 9, 105,
		1, 106, 1, 106, 3, 106, 1319, 8, 106, 1, 107, 1, 107, 1, 107, 1, 107, 1,
		108, 1, 108, 1, 108, 1, 108, 1, 109, 1, 109, 3, 109, 1331, 8, 109, 1, 109,
		1, 109, 1, 110, 1, 110, 3, 110, 1337, 8, 110, 1, 110, 1, 110, 1, 110, 1,
		110, 1, 111, 1, 111, 1, 112, 1, 112, 1, 112, 1, 113, 1, 113, 1, 113, 1,
		113, 3, 113, 1352, 8, 113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 114,
		1, 114, 1, 114, 1, 114, 1, 115, 1, 115, 1, 115, 1, 115, 5, 115, 1367, 8,
		115, 10, 115, 12, 115, 1370, 9, 115, 1, 115, 1, 115, 1, 116, 3, 116, 1375,
		8, 116, 1, 116, 1, 116, 3, 116, 1379, 8, 116, 1, 116, 1, 116, 1, 116, 3,
		116, 1384, 8, 116, 1, 116, 1, 116, 1, 116, 3, 116, 1389, 8, 116, 1, 116,
		1, 116, 1, 116, 3, 116, 1394, 8, 116, 1, 116, 1, 116, 1, 116, 3, 116, 1399,
		8, 116, 1, 116, 1, 116, 3, 116, 1403, 8, 116, 1, 117, 1, 117, 1, 117, 3,
		117, 1408, 8, 117, 1, 117, 3, 117, 1411, 8, 117, 1, 118, 1, 118, 1, 118,
		5, 118, 1416, 8, 118, 10, 118, 12, 118, 1419, 9, 118, 1, 119, 1, 119, 1,
		119, 5, 119, 1424, 8, 119, 10, 119, 12, 119, 1427, 9, 119, 1, 120, 1, 120,
		1, 120, 1, 121, 1, 121, 1, 121, 1, 121, 1, 122, 1, 122, 1, 122, 1, 122,
		1, 122, 1, 122, 3, 122, 1442, 8, 122, 1, 123, 4, 123, 1445, 8, 123, 11,
		123, 12, 123, 1446, 1, 124, 1, 124, 3, 124, 1451, 8, 124, 1, 125, 1, 125,
		1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 3, 125, 1462, 8,
		125, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 3,
		126, 1472, 8, 126, 1, 127, 1, 127, 3, 127, 1476, 8, 127, 1, 128, 1, 128,
		1, 128, 1, 128, 3, 128, 1482, 8, 128, 1, 128, 1, 128, 3, 128, 1486, 8,
		128, 1, 129, 1, 129, 1, 129, 1, 129, 3, 129, 1492, 8, 129, 1, 129, 1, 129,
		1, 129, 1, 129, 5, 129, 1498, 8, 129, 10, 129, 12, 129, 1501, 9, 129, 1,
		129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 5, 129, 1509, 8, 129, 10,
		129, 12, 129, 1512, 9, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 4,
		129, 1519, 8, 129, 11, 129, 12, 129, 1520, 5, 129, 1523, 8, 129, 10, 129,
		12, 129, 1526, 9, 129, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130,
		1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 3, 130, 1539, 8, 130, 1, 131, 1,
		131, 1, 131, 5, 131, 1544, 8, 131, 10, 131, 12, 131, 1547, 9, 131, 1, 131,
		1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 5, 131, 1555, 8, 131, 10, 131,
		12, 131, 1558, 9, 131, 1, 131, 1, 131, 3, 131, 1562, 8, 131, 1, 132, 1,
		132, 1, 132, 1, 132, 3, 132, 1568, 8, 132, 1, 133, 1, 133, 1, 134, 1, 134,
		1, 134, 1, 134, 3, 134, 1576, 8, 134, 1, 135, 1, 135, 1, 136, 1, 136, 1,
		136, 1, 136, 3, 136, 1584, 8, 136, 1, 137, 1, 137, 1, 138, 3, 138, 1589,
		8, 138, 1, 138, 1, 138, 1, 139, 1, 139, 3, 139, 1595, 8, 139, 1, 139, 1,
		139, 1, 139, 1, 139, 1, 139, 3, 139, 1602, 8, 139, 1, 139, 1, 139, 1, 139,
		1, 139, 1, 139, 1, 139, 1, 139, 1, 139, 1, 139, 1, 139, 3, 139, 1614, 8,
		139, 1, 139, 1, 139, 1, 139, 1, 139, 1, 139, 3, 139, 1621, 8, 139, 1, 139,
		5, 139, 1624, 8, 139, 10, 139, 12, 139, 1627, 9, 139, 1, 139, 1, 139, 1,
		139, 3, 139, 1632, 8, 139, 1, 139, 1, 139, 1, 139, 1, 139, 1, 139, 5, 139,
		1639, 8, 139, 10, 139, 12, 139, 1642, 9, 139, 1, 139, 1, 139, 1, 139, 1,
		139, 1, 139, 4, 139, 1649, 8, 139, 11, 139, 12, 139, 1650, 5, 139, 1653,
		8, 139, 10, 139, 12, 139, 1656, 9, 139, 1, 140, 3, 140, 1659, 8, 140, 1,
		140, 1, 140, 1, 140, 1, 140, 1, 140, 3, 140, 1666, 8, 140, 1, 141, 1, 141,
		1, 141, 3, 141, 1671, 8, 141, 1, 141, 3, 141, 1674, 8, 141, 1, 142, 1,
		142, 1, 142, 1, 142, 1, 142, 3, 142, 1681, 8, 142, 1, 143, 1, 143, 1, 143,
		5, 143, 1686, 8, 143, 10, 143, 12, 143, 1689, 9, 143, 1, 144, 1, 144, 1,
		144, 1, 144, 1, 144, 1, 144, 1, 144, 1, 144, 3, 144, 1699, 8, 144, 1, 145,
		1, 145, 1, 145, 5, 145, 1704, 8, 145, 10, 145, 12, 145, 1707, 9, 145, 1,
		145, 3, 145, 1710, 8, 145, 1, 146, 1, 146, 1, 146, 3, 146, 1715, 8, 146,
		1, 147, 1, 147, 1, 147, 3, 147, 1720, 8, 147, 1, 147, 3, 147, 1723, 8,
		147, 1, 148, 1, 148, 1, 148, 5, 148, 1728, 8, 148, 10, 148, 12, 148, 1731,
		9, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 3, 148, 1739, 8,
		148, 1, 149, 1, 149, 5, 149, 1743, 8, 149, 10, 149, 12, 149, 1746, 9, 149,
		1, 149, 1, 149, 3, 149, 1750, 8, 149, 1, 150, 1, 150, 1, 150, 1, 151, 1,
		151, 1, 151, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 3, 152, 1764,
		8, 152, 3, 152, 1766, 8, 152, 1, 153, 1, 153, 1, 154, 1, 154, 1, 155, 1,
		155, 1, 155, 1, 155, 1, 155, 1, 155, 3, 155, 1778, 8, 155, 1, 156, 1, 156,
		1, 156, 1, 156, 1, 157, 1, 157, 1, 157, 5, 157, 1787, 8, 157, 10, 157,
		12, 157, 1790, 9, 157, 1, 158, 1, 158, 3, 158, 1794, 8, 158, 1, 159, 1,
		159, 1, 159, 1, 159, 1, 159, 1, 159, 3, 159, 1802, 8, 159, 1, 159, 3, 159,
		1805, 8, 159, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 1, 160, 5, 160, 1813,
		8, 160, 10, 160, 12, 160, 1816, 9, 160, 1, 160, 1, 160, 1, 160, 3, 160,
		1821, 8, 160, 1, 160, 3, 160, 1824, 8, 160, 1, 160, 1, 160, 1, 161, 1,
		161, 1, 161, 1, 161, 1, 162, 1, 162, 1, 162, 3, 162, 1835, 8, 162, 1, 163,
		1, 163, 1, 163, 1, 163, 1, 163, 1, 164, 1, 164, 1, 164, 1, 164, 1, 164,
		1, 165, 1, 165, 3, 165, 1849, 8, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1,
		165, 1, 165, 1, 165, 1, 165, 3, 165, 1859, 8, 165, 1, 165, 1, 165, 1, 165,
		1, 165, 1, 165, 1, 165, 3, 165, 1867, 8, 165, 1, 166, 1, 166, 1, 166, 1,
		166, 1, 167, 1, 167, 1, 168, 1, 168, 1, 169, 1, 169, 1, 169, 1, 169, 1,
		169, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 3, 169, 1887, 8, 169, 1, 170,
		1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170,
		1, 170, 1, 170, 4, 170, 1901, 8, 170, 11, 170, 12, 170, 1902, 1, 170, 3,
		170, 1906, 8, 170, 1, 170, 1, 170, 3, 170, 1910, 8, 170, 1, 171, 1, 171,
		1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 172, 1, 172, 1, 172, 1, 173,
		1, 173, 1, 173, 1, 173, 1, 173, 1, 173, 1, 174, 1, 174, 1, 174, 5, 174,
		1931, 8, 174, 10, 174, 12, 174, 1934, 9, 174, 1, 175, 1, 175, 1, 175, 1,
		175, 1, 176, 1, 176, 1, 176, 5, 176, 1943, 8, 176, 10, 176, 12, 176, 1946,
		9, 176, 1, 177, 1, 177, 1, 177, 1, 177, 1, 177, 3, 177, 1953, 8, 177, 1,
		177, 0, 1, 278, 178, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26,
		28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62,
		64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98,
		100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128,
		130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158,
		160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188,
		190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218,
		220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248,
		250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278,
		280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308,
		310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 338,
		340, 342, 344, 346, 348, 350, 352, 354, 0, 16, 3, 0, 86, 87, 89, 89, 126,
		126, 3, 0, 15, 15, 75, 75, 94, 95, 1, 0, 45, 46, 1, 0, 76, 77, 1, 0, 128,
		129, 2, 0, 72, 72, 78, 78, 1, 0, 15, 15, 2, 0, 15, 15, 79, 83, 7, 0, 5,
		5, 7, 7, 23, 23, 33, 33, 74, 74, 115, 119, 133, 176, 2, 0, 31, 31, 107,
		108, 1, 0, 98, 106, 2, 0, 15, 15, 51, 51, 2, 0, 22, 22, 53, 58, 2, 0, 29,
		29, 45, 46, 5, 0, 2, 2, 11, 11, 25, 25, 47, 48, 112, 114, 2, 0, 13, 13,
		39, 39, 2094, 0, 358, 1, 0, 0, 0, 2, 360, 1, 0, 0, 0, 4, 379, 1, 0, 0,
		0, 6, 396, 1, 0, 0, 0, 8, 402, 1, 0, 0, 0, 10, 408, 1, 0, 0, 0, 12, 411,
		1, 0, 0, 0, 14, 414, 1, 0, 0, 0, 16, 422, 1, 0, 0, 0, 18, 435, 1, 0, 0,
		0, 20, 438, 1, 0, 0, 0, 22, 457, 1, 0, 0, 0, 24, 467, 1, 0, 0, 0, 26, 470,
		1, 0, 0, 0, 28, 474, 1, 0, 0, 0, 30, 485, 1, 0, 0, 0, 32, 487, 1, 0, 0,
		0, 34, 521, 1, 0, 0, 0, 36, 523, 1, 0, 0, 0, 38, 528, 1, 0, 0, 0, 40, 546,
		1, 0, 0, 0, 42, 570, 1, 0, 0, 0, 44, 572, 1, 0, 0, 0, 46, 597, 1, 0, 0,
		0, 48, 601, 1, 0, 0, 0, 50, 603, 1, 0, 0, 0, 52, 605, 1, 0, 0, 0, 54, 607,
		1, 0, 0, 0, 56, 609, 1, 0, 0, 0, 58, 612, 1, 0, 0, 0, 60, 616, 1, 0, 0,
		0, 62, 627, 1, 0, 0, 0, 64, 633, 1, 0, 0, 0, 66, 638, 1, 0, 0, 0, 68, 641,
		1, 0, 0, 0, 70, 654, 1, 0, 0, 0, 72, 668, 1, 0, 0, 0, 74, 690, 1, 0, 0,
		0, 76, 705, 1, 0, 0, 0, 78, 707, 1, 0, 0, 0, 80, 727, 1, 0, 0, 0, 82, 762,
		1, 0, 0, 0, 84, 780, 1, 0, 0, 0, 86, 782, 1, 0, 0, 0, 88, 786, 1, 0, 0,
		0, 90, 789, 1, 0, 0, 0, 92, 795, 1, 0, 0, 0, 94, 808, 1, 0, 0, 0, 96, 810,
		1, 0, 0, 0, 98, 820, 1, 0, 0, 0, 100, 842, 1, 0, 0, 0, 102, 844, 1, 0,
		0, 0, 104, 849, 1, 0, 0, 0, 106, 860, 1, 0, 0, 0, 108, 863, 1, 0, 0, 0,
		110, 868, 1, 0, 0, 0, 112, 900, 1, 0, 0, 0, 114, 902, 1, 0, 0, 0, 116,
		905, 1, 0, 0, 0, 118, 908, 1, 0, 0, 0, 120, 911, 1, 0, 0, 0, 122, 914,
		1, 0, 0, 0, 124, 925, 1, 0, 0, 0, 126, 938, 1, 0, 0, 0, 128, 942, 1, 0,
		0, 0, 130, 950, 1, 0, 0, 0, 132, 955, 1, 0, 0, 0, 134, 970, 1, 0, 0, 0,
		136, 975, 1, 0, 0, 0, 138, 982, 1, 0, 0, 0, 140, 984, 1, 0, 0, 0, 142,
		988, 1, 0, 0, 0, 144, 996, 1, 0, 0, 0, 146, 1001, 1, 0, 0, 0, 148, 1008,
		1, 0, 0, 0, 150, 1020, 1, 0, 0, 0, 152, 1025, 1, 0, 0, 0, 154, 1027, 1,
		0, 0, 0, 156, 1035, 1, 0, 0, 0, 158, 1069, 1, 0, 0, 0, 160, 1071, 1, 0,
		0, 0, 162, 1079, 1, 0, 0, 0, 164, 1096, 1, 0, 0, 0, 166, 1098, 1, 0, 0,
		0, 168, 1108, 1, 0, 0, 0, 170, 1131, 1, 0, 0, 0, 172, 1134, 1, 0, 0, 0,
		174, 1144, 1, 0, 0, 0, 176, 1146, 1, 0, 0, 0, 178, 1157, 1, 0, 0, 0, 180,
		1173, 1, 0, 0, 0, 182, 1175, 1, 0, 0, 0, 184, 1181, 1, 0, 0, 0, 186, 1194,
		1, 0, 0, 0, 188, 1204, 1, 0, 0, 0, 190, 1220, 1, 0, 0, 0, 192, 1223, 1,
		0, 0, 0, 194, 1227, 1, 0, 0, 0, 196, 1235, 1, 0, 0, 0, 198, 1237, 1, 0,
		0, 0, 200, 1240, 1, 0, 0, 0, 202, 1252, 1, 0, 0, 0, 204, 1260, 1, 0, 0,
		0, 206, 1282, 1, 0, 0, 0, 208, 1307, 1, 0, 0, 0, 210, 1313, 1, 0, 0, 0,
		212, 1318, 1, 0, 0, 0, 214, 1320, 1, 0, 0, 0, 216, 1324, 1, 0, 0, 0, 218,
		1328, 1, 0, 0, 0, 220, 1334, 1, 0, 0, 0, 222, 1342, 1, 0, 0, 0, 224, 1344,
		1, 0, 0, 0, 226, 1347, 1, 0, 0, 0, 228, 1358, 1, 0, 0, 0, 230, 1362, 1,
		0, 0, 0, 232, 1402, 1, 0, 0, 0, 234, 1404, 1, 0, 0, 0, 236, 1412, 1, 0,
		0, 0, 238, 1420, 1, 0, 0, 0, 240, 1428, 1, 0, 0, 0, 242, 1431, 1, 0, 0,
		0, 244, 1441, 1, 0, 0, 0, 246, 1444, 1, 0, 0, 0, 248, 1450, 1, 0, 0, 0,
		250, 1461, 1, 0, 0, 0, 252, 1471, 1, 0, 0, 0, 254, 1473, 1, 0, 0, 0, 256,
		1477, 1, 0, 0, 0, 258, 1491, 1, 0, 0, 0, 260, 1538, 1, 0, 0, 0, 262, 1540,
		1, 0, 0, 0, 264, 1563, 1, 0, 0, 0, 266, 1569, 1, 0, 0, 0, 268, 1571, 1,
		0, 0, 0, 270, 1577, 1, 0, 0, 0, 272, 1579, 1, 0, 0, 0, 274, 1585, 1, 0,
		0, 0, 276, 1588, 1, 0, 0, 0, 278, 1631, 1, 0, 0, 0, 280, 1665, 1, 0, 0,
		0, 282, 1667, 1, 0, 0, 0, 284, 1675, 1, 0, 0, 0, 286, 1682, 1, 0, 0, 0,
		288, 1698, 1, 0, 0, 0, 290, 1709, 1, 0, 0, 0, 292, 1711, 1, 0, 0, 0, 294,
		1716, 1, 0, 0, 0, 296, 1724, 1, 0, 0, 0, 298, 1749, 1, 0, 0, 0, 300, 1751,
		1, 0, 0, 0, 302, 1754, 1, 0, 0, 0, 304, 1757, 1, 0, 0, 0, 306, 1767, 1,
		0, 0, 0, 308, 1769, 1, 0, 0, 0, 310, 1777, 1, 0, 0, 0, 312, 1779, 1, 0,
		0, 0, 314, 1783, 1, 0, 0, 0, 316, 1793, 1, 0, 0, 0, 318, 1795, 1, 0, 0,
		0, 320, 1806, 1, 0, 0, 0, 322, 1827, 1, 0, 0, 0, 324, 1834, 1, 0, 0, 0,
		326, 1836, 1, 0, 0, 0, 328, 1841, 1, 0, 0, 0, 330, 1866, 1, 0, 0, 0, 332,
		1868, 1, 0, 0, 0, 334, 1872, 1, 0, 0, 0, 336, 1874, 1, 0, 0, 0, 338, 1886,
		1, 0, 0, 0, 340, 1909, 1, 0, 0, 0, 342, 1911, 1, 0, 0, 0, 344, 1918, 1,
		0, 0, 0, 346, 1921, 1, 0, 0, 0, 348, 1927, 1, 0, 0, 0, 350, 1935, 1, 0,
		0, 0, 352, 1939, 1, 0, 0, 0, 354, 1947, 1, 0, 0, 0, 356, 359, 3, 2, 1,
		0, 357, 359, 3, 4, 2, 0, 358, 356, 1, 0, 0, 0, 358, 357, 1, 0, 0, 0, 359,
		1, 1, 0, 0, 0, 360, 361, 5, 32, 0, 0, 361, 366, 3, 14, 7, 0, 362, 363,
		5, 59, 0, 0, 363, 364, 3, 236, 118, 0, 364, 365, 5, 60, 0, 0, 365, 367,
		1, 0, 0, 0, 366, 362, 1, 0, 0, 0, 366, 367, 1, 0, 0, 0, 367, 368, 1, 0,
		0, 0, 368, 370, 5, 51, 0, 0, 369, 371, 3, 26, 13, 0, 370, 369, 1, 0, 0,
		0, 370, 371, 1, 0, 0, 0, 371, 372, 1, 0, 0, 0, 372, 373, 3, 22, 11, 0,
		373, 374, 5, 4, 0, 0, 374, 375, 3, 314, 157, 0, 375, 376, 5, 15, 0, 0,
		376, 377, 5, 67, 0, 0, 377, 378, 5, 0, 0, 1, 378, 3, 1, 0, 0, 0, 379, 380,
		5, 71, 0, 0, 380, 381, 3, 14, 7, 0, 381, 382, 5, 51, 0, 0, 382, 384, 3,
		6, 3, 0, 383, 385, 3, 8, 4, 0, 384, 383, 1, 0, 0, 0, 384, 385, 1, 0, 0,
		0, 385, 387, 1, 0, 0, 0, 386, 388, 3, 10, 5, 0, 387, 386, 1, 0, 0, 0, 387,
		388, 1, 0, 0, 0, 388, 390, 1, 0, 0, 0, 389, 391, 3, 12, 6, 0, 390, 389,
		1, 0, 0, 0, 390, 391, 1, 0, 0, 0, 391, 392, 1, 0, 0, 0, 392, 393, 5, 15,
		0, 0, 393, 394, 5, 67, 0, 0, 394, 395, 5, 0, 0, 1, 395, 5, 1, 0, 0, 0,
		396, 398, 5, 72, 0, 0, 397, 399, 3, 26, 13, 0, 398, 397, 1, 0, 0, 0, 398,
		399, 1, 0, 0, 0, 399, 400, 1, 0, 0, 0, 400, 401, 3, 18, 9, 0, 401, 7, 1,
		0, 0, 0, 402, 404, 5, 75, 0, 0, 403, 405, 3, 26, 13, 0, 404, 403, 1, 0,
		0, 0, 404, 405, 1, 0, 0, 0, 405, 406, 1, 0, 0, 0, 406, 407, 3, 22, 11,
		0, 407, 9, 1, 0, 0, 0, 408, 409, 5, 94, 0, 0, 409, 410, 3, 314, 157, 0,
		410, 11, 1, 0, 0, 0, 411, 412, 5, 95, 0, 0, 412, 413, 3, 314, 157, 0, 413,
		13, 1, 0, 0, 0, 414, 419, 3, 16, 8, 0, 415, 416, 5, 67, 0, 0, 416, 418,
		3, 16, 8, 0, 417, 415, 1, 0, 0, 0, 418, 421, 1, 0, 0, 0, 419, 417, 1, 0,
		0, 0, 419, 420, 1, 0, 0, 0, 420, 15, 1, 0, 0, 0, 421, 419, 1, 0, 0, 0,
		422, 424, 7, 0, 0, 0, 423, 425, 3, 126, 63, 0, 424, 423, 1, 0, 0, 0, 424,
		425, 1, 0, 0, 0, 425, 17, 1, 0, 0, 0, 426, 434, 3, 28, 14, 0, 427, 434,
		3, 32, 16, 0, 428, 434, 3, 62, 31, 0, 429, 434, 3, 68, 34, 0, 430, 434,
		3, 200, 100, 0, 431, 434, 3, 208, 104, 0, 432, 434, 3, 20, 10, 0, 433,
		426, 1, 0, 0, 0, 433, 427, 1, 0, 0, 0, 433, 428, 1, 0, 0, 0, 433, 429,
		1, 0, 0, 0, 433, 430, 1, 0, 0, 0, 433, 431, 1, 0, 0, 0, 433, 432, 1, 0,
		0, 0, 434, 437, 1, 0, 0, 0, 435, 433, 1, 0, 0, 0, 435, 436, 1, 0, 0, 0,
		436, 19, 1, 0, 0, 0, 437, 435, 1, 0, 0, 0, 438, 440, 5, 40, 0, 0, 439,
		441, 8, 1, 0, 0, 440, 439, 1, 0, 0, 0, 441, 442, 1, 0, 0, 0, 442, 440,
		1, 0, 0, 0, 442, 443, 1, 0, 0, 0, 443, 21, 1, 0, 0, 0, 444, 456, 3, 28,
		14, 0, 445, 456, 3, 32, 16, 0, 446, 456, 3, 62, 31, 0, 447, 456, 3, 68,
		34, 0, 448, 456, 3, 200, 100, 0, 449, 456, 3, 212, 106, 0, 450, 451, 3,
		208, 104, 0, 451, 452, 5, 110, 0, 0, 452, 453, 5, 51, 0, 0, 453, 456, 1,
		0, 0, 0, 454, 456, 3, 228, 114, 0, 455, 444, 1, 0, 0, 0, 455, 445, 1, 0,
		0, 0, 455, 446, 1, 0, 0, 0, 455, 447, 1, 0, 0, 0, 455, 448, 1, 0, 0, 0,
		455, 449, 1, 0, 0, 0, 455, 450, 1, 0, 0, 0, 455, 454, 1, 0, 0, 0, 456,
		459, 1, 0, 0, 0, 457, 455, 1, 0, 0, 0, 457, 458, 1, 0, 0, 0, 458, 23, 1,
		0, 0, 0, 459, 457, 1, 0, 0, 0, 460, 466, 3, 28, 14, 0, 461, 466, 3, 32,
		16, 0, 462, 466, 3, 200, 100, 0, 463, 466, 3, 212, 106, 0, 464, 466, 3,
		228, 114, 0, 465, 460, 1, 0, 0, 0, 465, 461, 1, 0, 0, 0, 465, 462, 1, 0,
		0, 0, 465, 463, 1, 0, 0, 0, 465, 464, 1, 0, 0, 0, 466, 469, 1, 0, 0, 0,
		467, 465, 1, 0, 0, 0, 467, 468, 1, 0, 0, 0, 468, 25, 1, 0, 0, 0, 469, 467,
		1, 0, 0, 0, 470, 471, 5, 73, 0, 0, 471, 472, 3, 236, 118, 0, 472, 473,
		5, 51, 0, 0, 473, 27, 1, 0, 0, 0, 474, 475, 5, 24, 0, 0, 475, 480, 3, 30,
		15, 0, 476, 477, 5, 50, 0, 0, 477, 479, 3, 30, 15, 0, 478, 476, 1, 0, 0,
		0, 479, 482, 1, 0, 0, 0, 480, 478, 1, 0, 0, 0, 480, 481, 1, 0, 0, 0, 481,
		483, 1, 0, 0, 0, 482, 480, 1, 0, 0, 0, 483, 484, 5, 51, 0, 0, 484, 29,
		1, 0, 0, 0, 485, 486, 3, 50, 25, 0, 486, 31, 1, 0, 0, 0, 487, 491, 5, 9,
		0, 0, 488, 489, 3, 34, 17, 0, 489, 490, 5, 51, 0, 0, 490, 492, 1, 0, 0,
		0, 491, 488, 1, 0, 0, 0, 492, 493, 1, 0, 0, 0, 493, 491, 1, 0, 0, 0, 493,
		494, 1, 0, 0, 0, 494, 33, 1, 0, 0, 0, 495, 498, 3, 14, 7, 0, 496, 497,
		5, 52, 0, 0, 497, 499, 3, 148, 74, 0, 498, 496, 1, 0, 0, 0, 498, 499, 1,
		0, 0, 0, 499, 500, 1, 0, 0, 0, 500, 501, 5, 53, 0, 0, 501, 503, 3, 40,
		20, 0, 502, 504, 3, 66, 33, 0, 503, 502, 1, 0, 0, 0, 503, 504, 1, 0, 0,
		0, 504, 522, 1, 0, 0, 0, 505, 506, 3, 14, 7, 0, 506, 507, 5, 52, 0, 0,
		507, 508, 3, 158, 79, 0, 508, 509, 5, 53, 0, 0, 509, 511, 3, 40, 20, 0,
		510, 512, 3, 66, 33, 0, 511, 510, 1, 0, 0, 0, 511, 512, 1, 0, 0, 0, 512,
		522, 1, 0, 0, 0, 513, 514, 3, 14, 7, 0, 514, 515, 5, 52, 0, 0, 515, 516,
		3, 194, 97, 0, 516, 517, 5, 53, 0, 0, 517, 519, 3, 40, 20, 0, 518, 520,
		3, 66, 33, 0, 519, 518, 1, 0, 0, 0, 519, 520, 1, 0, 0, 0, 520, 522, 1,
		0, 0, 0, 521, 495, 1, 0, 0, 0, 521, 505, 1, 0, 0, 0, 521, 513, 1, 0, 0,
		0, 522, 35, 1, 0, 0, 0, 523, 524, 5, 8, 0, 0, 524, 525, 5, 59, 0, 0, 525,
		526, 3, 50, 25, 0, 526, 527, 5, 60, 0, 0, 527, 37, 1, 0, 0, 0, 528, 529,
		5, 127, 0, 0, 529, 39, 1, 0, 0, 0, 530, 547, 3, 280, 140, 0, 531, 547,
		3, 14, 7, 0, 532, 547, 3, 140, 70, 0, 533, 541, 3, 42, 21, 0, 534, 537,
		5, 45, 0, 0, 535, 538, 3, 42, 21, 0, 536, 538, 3, 14, 7, 0, 537, 535, 1,
		0, 0, 0, 537, 536, 1, 0, 0, 0, 538, 540, 1, 0, 0, 0, 539, 534, 1, 0, 0,
		0, 540, 543, 1, 0, 0, 0, 541, 539, 1, 0, 0, 0, 541, 542, 1, 0, 0, 0, 542,
		547, 1, 0, 0, 0, 543, 541, 1, 0, 0, 0, 544, 547, 3, 44, 22, 0, 545, 547,
		3, 268, 134, 0, 546, 530, 1, 0, 0, 0, 546, 531, 1, 0, 0, 0, 546, 532, 1,
		0, 0, 0, 546, 533, 1, 0, 0, 0, 546, 544, 1, 0, 0, 0, 546, 545, 1, 0, 0,
		0, 547, 41, 1, 0, 0, 0, 548, 549, 5, 61, 0, 0, 549, 554, 3, 40, 20, 0,
		550, 551, 5, 50, 0, 0, 551, 553, 3, 40, 20, 0, 552, 550, 1, 0, 0, 0, 553,
		556, 1, 0, 0, 0, 554, 552, 1, 0, 0, 0, 554, 555, 1, 0, 0, 0, 555, 557,
		1, 0, 0, 0, 556, 554, 1, 0, 0, 0, 557, 558, 5, 63, 0, 0, 558, 571, 1, 0,
		0, 0, 559, 560, 5, 59, 0, 0, 560, 565, 3, 40, 20, 0, 561, 562, 5, 50, 0,
		0, 562, 564, 3, 40, 20, 0, 563, 561, 1, 0, 0, 0, 564, 567, 1, 0, 0, 0,
		565, 563, 1, 0, 0, 0, 565, 566, 1, 0, 0, 0, 566, 568, 1, 0, 0, 0, 567,
		565, 1, 0, 0, 0, 568, 569, 5, 60, 0, 0, 569, 571, 1, 0, 0, 0, 570, 548,
		1, 0, 0, 0, 570, 559, 1, 0, 0, 0, 571, 43, 1, 0, 0, 0, 572, 573, 5, 59,
		0, 0, 573, 578, 3, 46, 23, 0, 574, 575, 5, 51, 0, 0, 575, 577, 3, 46, 23,
		0, 576, 574, 1, 0, 0, 0, 577, 580, 1, 0, 0, 0, 578, 576, 1, 0, 0, 0, 578,
		579, 1, 0, 0, 0, 579, 581, 1, 0, 0, 0, 580, 578, 1, 0, 0, 0, 581, 582,
		5, 60, 0, 0, 582, 45, 1, 0, 0, 0, 583, 584, 3, 14, 7, 0, 584, 585, 5, 52,
		0, 0, 585, 586, 3, 40, 20, 0, 586, 598, 1, 0, 0, 0, 587, 588, 3, 14, 7,
		0, 588, 589, 5, 52, 0, 0, 589, 590, 3, 40, 20, 0, 590, 591, 5, 68, 0, 0,
		591, 592, 3, 40, 20, 0, 592, 598, 1, 0, 0, 0, 593, 594, 3, 14, 7, 0, 594,
		595, 5, 52, 0, 0, 595, 596, 3, 42, 21, 0, 596, 598, 1, 0, 0, 0, 597, 583,
		1, 0, 0, 0, 597, 587, 1, 0, 0, 0, 597, 593, 1, 0, 0, 0, 598, 47, 1, 0,
		0, 0, 599, 602, 3, 50, 25, 0, 600, 602, 3, 52, 26, 0, 601, 599, 1, 0, 0,
		0, 601, 600, 1, 0, 0, 0, 602, 49, 1, 0, 0, 0, 603, 604, 5, 130, 0, 0, 604,
		51, 1, 0, 0, 0, 605, 606, 5, 131, 0, 0, 606, 53, 1, 0, 0, 0, 607, 608,
		7, 2, 0, 0, 608, 55, 1, 0, 0, 0, 609, 610, 7, 3, 0, 0, 610, 57, 1, 0, 0,
		0, 611, 613, 7, 4, 0, 0, 612, 611, 1, 0, 0, 0, 613, 614, 1, 0, 0, 0, 614,
		612, 1, 0, 0, 0, 614, 615, 1, 0, 0, 0, 615, 59, 1, 0, 0, 0, 616, 624, 3,
		58, 29, 0, 617, 620, 5, 45, 0, 0, 618, 621, 3, 58, 29, 0, 619, 621, 3,
		14, 7, 0, 620, 618, 1, 0, 0, 0, 620, 619, 1, 0, 0, 0, 621, 623, 1, 0, 0,
		0, 622, 617, 1, 0, 0, 0, 623, 626, 1, 0, 0, 0, 624, 622, 1, 0, 0, 0, 624,
		625, 1, 0, 0, 0, 625, 61, 1, 0, 0, 0, 626, 624, 1, 0, 0, 0, 627, 629, 5,
		109, 0, 0, 628, 630, 3, 64, 32, 0, 629, 628, 1, 0, 0, 0, 630, 631, 1, 0,
		0, 0, 631, 629, 1, 0, 0, 0, 631, 632, 1, 0, 0, 0, 632, 63, 1, 0, 0, 0,
		633, 634, 3, 14, 7, 0, 634, 635, 5, 53, 0, 0, 635, 636, 3, 60, 30, 0, 636,
		637, 5, 51, 0, 0, 637, 65, 1, 0, 0, 0, 638, 639, 5, 10, 0, 0, 639, 640,
		3, 60, 30, 0, 640, 67, 1, 0, 0, 0, 641, 642, 5, 40, 0, 0, 642, 647, 3,
		70, 35, 0, 643, 644, 5, 51, 0, 0, 644, 646, 3, 70, 35, 0, 645, 643, 1,
		0, 0, 0, 646, 649, 1, 0, 0, 0, 647, 645, 1, 0, 0, 0, 647, 648, 1, 0, 0,
		0, 648, 651, 1, 0, 0, 0, 649, 647, 1, 0, 0, 0, 650, 652, 5, 51, 0, 0, 651,
		650, 1, 0, 0, 0, 651, 652, 1, 0, 0, 0, 652, 69, 1, 0, 0, 0, 653, 655, 3,
		350, 175, 0, 654, 653, 1, 0, 0, 0, 654, 655, 1, 0, 0, 0, 655, 656, 1, 0,
		0, 0, 656, 657, 3, 14, 7, 0, 657, 666, 5, 53, 0, 0, 658, 667, 3, 72, 36,
		0, 659, 667, 3, 74, 37, 0, 660, 667, 3, 82, 41, 0, 661, 667, 3, 84, 42,
		0, 662, 667, 3, 86, 43, 0, 663, 667, 3, 88, 44, 0, 664, 667, 3, 90, 45,
		0, 665, 667, 3, 136, 68, 0, 666, 658, 1, 0, 0, 0, 666, 659, 1, 0, 0, 0,
		666, 660, 1, 0, 0, 0, 666, 661, 1, 0, 0, 0, 666, 662, 1, 0, 0, 0, 666,
		663, 1, 0, 0, 0, 666, 664, 1, 0, 0, 0, 666, 665, 1, 0, 0, 0, 667, 71, 1,
		0, 0, 0, 668, 674, 5, 78, 0, 0, 669, 670, 5, 59, 0, 0, 670, 671, 3, 14,
		7, 0, 671, 672, 3, 92, 46, 0, 672, 673, 5, 60, 0, 0, 673, 675, 1, 0, 0,
		0, 674, 669, 1, 0, 0, 0, 674, 675, 1, 0, 0, 0, 675, 677, 1, 0, 0, 0, 676,
		678, 5, 98, 0, 0, 677, 676, 1, 0, 0, 0, 677, 678, 1, 0, 0, 0, 678, 688,
		1, 0, 0, 0, 679, 683, 3, 98, 49, 0, 680, 682, 3, 96, 48, 0, 681, 680, 1,
		0, 0, 0, 682, 685, 1, 0, 0, 0, 683, 681, 1, 0, 0, 0, 683, 684, 1, 0, 0,
		0, 684, 686, 1, 0, 0, 0, 685, 683, 1, 0, 0, 0, 686, 687, 5, 15, 0, 0, 687,
		689, 1, 0, 0, 0, 688, 679, 1, 0, 0, 0, 688, 689, 1, 0, 0, 0, 689, 73, 1,
		0, 0, 0, 690, 695, 5, 72, 0, 0, 691, 692, 5, 59, 0, 0, 692, 693, 3, 14,
		7, 0, 693, 694, 5, 60, 0, 0, 694, 696, 1, 0, 0, 0, 695, 691, 1, 0, 0, 0,
		695, 696, 1, 0, 0, 0, 696, 698, 1, 0, 0, 0, 697, 699, 5, 1, 0, 0, 698,
		697, 1, 0, 0, 0, 698, 699, 1, 0, 0, 0, 699, 703, 1, 0, 0, 0, 700, 701,
		3, 104, 52, 0, 701, 702, 5, 15, 0, 0, 702, 704, 1, 0, 0, 0, 703, 700, 1,
		0, 0, 0, 703, 704, 1, 0, 0, 0, 704, 75, 1, 0, 0, 0, 705, 706, 7, 5, 0,
		0, 706, 77, 1, 0, 0, 0, 707, 713, 5, 78, 0, 0, 708, 709, 5, 59, 0, 0, 709,
		710, 3, 14, 7, 0, 710, 711, 3, 92, 46, 0, 711, 712, 5, 60, 0, 0, 712, 714,
		1, 0, 0, 0, 713, 708, 1, 0, 0, 0, 713, 714, 1, 0, 0, 0, 714, 716, 1, 0,
		0, 0, 715, 717, 5, 98, 0, 0, 716, 715, 1, 0, 0, 0, 716, 717, 1, 0, 0, 0,
		717, 718, 1, 0, 0, 0, 718, 722, 3, 98, 49, 0, 719, 721, 3, 96, 48, 0, 720,
		719, 1, 0, 0, 0, 721, 724, 1, 0, 0, 0, 722, 720, 1, 0, 0, 0, 722, 723,
		1, 0, 0, 0, 723, 725, 1, 0, 0, 0, 724, 722, 1, 0, 0, 0, 725, 726, 5, 15,
		0, 0, 726, 79, 1, 0, 0, 0, 727, 732, 5, 72, 0, 0, 728, 729, 5, 59, 0, 0,
		729, 730, 3, 14, 7, 0, 730, 731, 5, 60, 0, 0, 731, 733, 1, 0, 0, 0, 732,
		728, 1, 0, 0, 0, 732, 733, 1, 0, 0, 0, 733, 735, 1, 0, 0, 0, 734, 736,
		5, 1, 0, 0, 735, 734, 1, 0, 0, 0, 735, 736, 1, 0, 0, 0, 736, 737, 1, 0,
		0, 0, 737, 738, 3, 104, 52, 0, 738, 739, 5, 15, 0, 0, 739, 81, 1, 0, 0,
		0, 740, 742, 5, 18, 0, 0, 741, 743, 3, 230, 115, 0, 742, 741, 1, 0, 0,
		0, 742, 743, 1, 0, 0, 0, 743, 744, 1, 0, 0, 0, 744, 745, 5, 52, 0, 0, 745,
		748, 3, 222, 111, 0, 746, 747, 5, 28, 0, 0, 747, 749, 5, 96, 0, 0, 748,
		746, 1, 0, 0, 0, 748, 749, 1, 0, 0, 0, 749, 750, 1, 0, 0, 0, 750, 751,
		3, 210, 105, 0, 751, 763, 1, 0, 0, 0, 752, 753, 5, 35, 0, 0, 753, 754,
		5, 39, 0, 0, 754, 756, 5, 18, 0, 0, 755, 757, 3, 230, 115, 0, 756, 755,
		1, 0, 0, 0, 756, 757, 1, 0, 0, 0, 757, 758, 1, 0, 0, 0, 758, 759, 5, 52,
		0, 0, 759, 760, 3, 222, 111, 0, 760, 761, 3, 210, 105, 0, 761, 763, 1,
		0, 0, 0, 762, 740, 1, 0, 0, 0, 762, 752, 1, 0, 0, 0, 763, 83, 1, 0, 0,
		0, 764, 766, 5, 31, 0, 0, 765, 767, 3, 230, 115, 0, 766, 765, 1, 0, 0,
		0, 766, 767, 1, 0, 0, 0, 767, 770, 1, 0, 0, 0, 768, 769, 5, 28, 0, 0, 769,
		771, 5, 96, 0, 0, 770, 768, 1, 0, 0, 0, 770, 771, 1, 0, 0, 0, 771, 772,
		1, 0, 0, 0, 772, 781, 3, 210, 105, 0, 773, 774, 5, 35, 0, 0, 774, 775,
		5, 39, 0, 0, 775, 777, 5, 31, 0, 0, 776, 778, 3, 230, 115, 0, 777, 776,
		1, 0, 0, 0, 777, 778, 1, 0, 0, 0, 778, 779, 1, 0, 0, 0, 779, 781, 3, 210,
		105, 0, 780, 764, 1, 0, 0, 0, 780, 773, 1, 0, 0, 0, 781, 85, 1, 0, 0, 0,
		782, 783, 5, 78, 0, 0, 783, 784, 5, 28, 0, 0, 784, 785, 3, 148, 74, 0,
		785, 87, 1, 0, 0, 0, 786, 787, 5, 40, 0, 0, 787, 788, 3, 148, 74, 0, 788,
		89, 1, 0, 0, 0, 789, 790, 3, 148, 74, 0, 790, 91, 1, 0, 0, 0, 791, 792,
		5, 50, 0, 0, 792, 794, 3, 148, 74, 0, 793, 791, 1, 0, 0, 0, 794, 797, 1,
		0, 0, 0, 795, 793, 1, 0, 0, 0, 795, 796, 1, 0, 0, 0, 796, 93, 1, 0, 0,
		0, 797, 795, 1, 0, 0, 0, 798, 800, 5, 83, 0, 0, 799, 798, 1, 0, 0, 0, 799,
		800, 1, 0, 0, 0, 800, 801, 1, 0, 0, 0, 801, 809, 5, 79, 0, 0, 802, 804,
		5, 83, 0, 0, 803, 802, 1, 0, 0, 0, 803, 804, 1, 0, 0, 0, 804, 805, 1, 0,
		0, 0, 805, 809, 5, 80, 0, 0, 806, 809, 5, 81, 0, 0, 807, 809, 5, 82, 0,
		0, 808, 799, 1, 0, 0, 0, 808, 803, 1, 0, 0, 0, 808, 806, 1, 0, 0, 0, 808,
		807, 1, 0, 0, 0, 809, 95, 1, 0, 0, 0, 810, 814, 3, 94, 47, 0, 811, 813,
		3, 100, 50, 0, 812, 811, 1, 0, 0, 0, 813, 816, 1, 0, 0, 0, 814, 812, 1,
		0, 0, 0, 814, 815, 1, 0, 0, 0, 815, 97, 1, 0, 0, 0, 816, 814, 1, 0, 0,
		0, 817, 819, 3, 100, 50, 0, 818, 817, 1, 0, 0, 0, 819, 822, 1, 0, 0, 0,
		820, 818, 1, 0, 0, 0, 820, 821, 1, 0, 0, 0, 821, 99, 1, 0, 0, 0, 822, 820,
		1, 0, 0, 0, 823, 825, 3, 350, 175, 0, 824, 823, 1, 0, 0, 0, 824, 825, 1,
		0, 0, 0, 825, 826, 1, 0, 0, 0, 826, 827, 3, 242, 121, 0, 827, 828, 5, 51,
		0, 0, 828, 843, 1, 0, 0, 0, 829, 843, 3, 68, 34, 0, 830, 843, 3, 32, 16,
		0, 831, 843, 3, 206, 103, 0, 832, 843, 3, 204, 102, 0, 833, 834, 3, 112,
		56, 0, 834, 837, 5, 51, 0, 0, 835, 836, 5, 88, 0, 0, 836, 838, 5, 51, 0,
		0, 837, 835, 1, 0, 0, 0, 837, 838, 1, 0, 0, 0, 838, 843, 1, 0, 0, 0, 839,
		840, 3, 110, 55, 0, 840, 841, 5, 51, 0, 0, 841, 843, 1, 0, 0, 0, 842, 824,
		1, 0, 0, 0, 842, 829, 1, 0, 0, 0, 842, 830, 1, 0, 0, 0, 842, 831, 1, 0,
		0, 0, 842, 832, 1, 0, 0, 0, 842, 833, 1, 0, 0, 0, 842, 839, 1, 0, 0, 0,
		843, 101, 1, 0, 0, 0, 844, 845, 5, 1, 0, 0, 845, 103, 1, 0, 0, 0, 846,
		848, 3, 106, 53, 0, 847, 846, 1, 0, 0, 0, 848, 851, 1, 0, 0, 0, 849, 847,
		1, 0, 0, 0, 849, 850, 1, 0, 0, 0, 850, 105, 1, 0, 0, 0, 851, 849, 1, 0,
		0, 0, 852, 861, 3, 206, 103, 0, 853, 861, 3, 204, 102, 0, 854, 855, 3,
		112, 56, 0, 855, 856, 5, 51, 0, 0, 856, 861, 1, 0, 0, 0, 857, 858, 3, 108,
		54, 0, 858, 859, 5, 51, 0, 0, 859, 861, 1, 0, 0, 0, 860, 852, 1, 0, 0,
		0, 860, 853, 1, 0, 0, 0, 860, 854, 1, 0, 0, 0, 860, 857, 1, 0, 0, 0, 861,
		107, 1, 0, 0, 0, 862, 864, 8, 6, 0, 0, 863, 862, 1, 0, 0, 0, 864, 865,
		1, 0, 0, 0, 865, 863, 1, 0, 0, 0, 865, 866, 1, 0, 0, 0, 866, 109, 1, 0,
		0, 0, 867, 869, 8, 7, 0, 0, 868, 867, 1, 0, 0, 0, 869, 870, 1, 0, 0, 0,
		870, 868, 1, 0, 0, 0, 870, 871, 1, 0, 0, 0, 871, 111, 1, 0, 0, 0, 872,
		873, 5, 85, 0, 0, 873, 875, 3, 14, 7, 0, 874, 876, 3, 122, 61, 0, 875,
		874, 1, 0, 0, 0, 875, 876, 1, 0, 0, 0, 876, 877, 1, 0, 0, 0, 877, 878,
		5, 52, 0, 0, 878, 880, 3, 148, 74, 0, 879, 881, 3, 114, 57, 0, 880, 879,
		1, 0, 0, 0, 880, 881, 1, 0, 0, 0, 881, 883, 1, 0, 0, 0, 882, 884, 3, 116,
		58, 0, 883, 882, 1, 0, 0, 0, 883, 884, 1, 0, 0, 0, 884, 886, 1, 0, 0, 0,
		885, 887, 3, 118, 59, 0, 886, 885, 1, 0, 0, 0, 886, 887, 1, 0, 0, 0, 887,
		889, 1, 0, 0, 0, 888, 890, 3, 120, 60, 0, 889, 888, 1, 0, 0, 0, 889, 890,
		1, 0, 0, 0, 890, 893, 1, 0, 0, 0, 891, 892, 5, 51, 0, 0, 892, 894, 5, 88,
		0, 0, 893, 891, 1, 0, 0, 0, 893, 894, 1, 0, 0, 0, 894, 901, 1, 0, 0, 0,
		895, 896, 5, 85, 0, 0, 896, 898, 3, 14, 7, 0, 897, 899, 3, 118, 59, 0,
		898, 897, 1, 0, 0, 0, 898, 899, 1, 0, 0, 0, 899, 901, 1, 0, 0, 0, 900,
		872, 1, 0, 0, 0, 900, 895, 1, 0, 0, 0, 901, 113, 1, 0, 0, 0, 902, 903,
		5, 86, 0, 0, 903, 904, 3, 14, 7, 0, 904, 115, 1, 0, 0, 0, 905, 906, 5,
		87, 0, 0, 906, 907, 3, 14, 7, 0, 907, 117, 1, 0, 0, 0, 908, 909, 5, 88,
		0, 0, 909, 910, 3, 264, 132, 0, 910, 119, 1, 0, 0, 0, 911, 912, 5, 89,
		0, 0, 912, 913, 3, 48, 24, 0, 913, 121, 1, 0, 0, 0, 914, 915, 5, 61, 0,
		0, 915, 920, 3, 232, 116, 0, 916, 917, 5, 50, 0, 0, 917, 919, 3, 232, 116,
		0, 918, 916, 1, 0, 0, 0, 919, 922, 1, 0, 0, 0, 920, 918, 1, 0, 0, 0, 920,
		921, 1, 0, 0, 0, 921, 923, 1, 0, 0, 0, 922, 920, 1, 0, 0, 0, 923, 924,
		5, 63, 0, 0, 924, 123, 1, 0, 0, 0, 925, 926, 3, 236, 118, 0, 926, 927,
		5, 52, 0, 0, 927, 935, 3, 162, 81, 0, 928, 929, 5, 51, 0, 0, 929, 930,
		3, 236, 118, 0, 930, 931, 5, 52, 0, 0, 931, 932, 3, 162, 81, 0, 932, 934,
		1, 0, 0, 0, 933, 928, 1, 0, 0, 0, 934, 937, 1, 0, 0, 0, 935, 933, 1, 0,
		0, 0, 935, 936, 1, 0, 0, 0, 936, 125, 1, 0, 0, 0, 937, 935, 1, 0, 0, 0,
		938, 939, 5, 55, 0, 0, 939, 940, 3, 128, 64, 0, 940, 941, 5, 58, 0, 0,
		941, 127, 1, 0, 0, 0, 942, 947, 3, 130, 65, 0, 943, 944, 5, 50, 0, 0, 944,
		946, 3, 130, 65, 0, 945, 943, 1, 0, 0, 0, 946, 949, 1, 0, 0, 0, 947, 945,
		1, 0, 0, 0, 947, 948, 1, 0, 0, 0, 948, 129, 1, 0, 0, 0, 949, 947, 1, 0,
		0, 0, 950, 953, 3, 148, 74, 0, 951, 952, 5, 52, 0, 0, 952, 954, 3, 132,
		66, 0, 953, 951, 1, 0, 0, 0, 953, 954, 1, 0, 0, 0, 954, 131, 1, 0, 0, 0,
		955, 960, 3, 134, 67, 0, 956, 957, 5, 50, 0, 0, 957, 959, 3, 134, 67, 0,
		958, 956, 1, 0, 0, 0, 959, 962, 1, 0, 0, 0, 960, 958, 1, 0, 0, 0, 960,
		961, 1, 0, 0, 0, 961, 133, 1, 0, 0, 0, 962, 960, 1, 0, 0, 0, 963, 971,
		5, 107, 0, 0, 964, 971, 5, 78, 0, 0, 965, 971, 5, 34, 0, 0, 966, 967, 5,
		78, 0, 0, 967, 968, 5, 28, 0, 0, 968, 971, 3, 148, 74, 0, 969, 971, 3,
		148, 74, 0, 970, 963, 1, 0, 0, 0, 970, 964, 1, 0, 0, 0, 970, 965, 1, 0,
		0, 0, 970, 966, 1, 0, 0, 0, 970, 969, 1, 0, 0, 0, 971, 135, 1, 0, 0, 0,
		972, 976, 3, 138, 69, 0, 973, 976, 3, 150, 75, 0, 974, 976, 3, 198, 99,
		0, 975, 972, 1, 0, 0, 0, 975, 973, 1, 0, 0, 0, 975, 974, 1, 0, 0, 0, 976,
		137, 1, 0, 0, 0, 977, 983, 3, 140, 70, 0, 978, 983, 3, 146, 73, 0, 979,
		983, 3, 148, 74, 0, 980, 983, 3, 154, 77, 0, 981, 983, 3, 156, 78, 0, 982,
		977, 1, 0, 0, 0, 982, 978, 1, 0, 0, 0, 982, 979, 1, 0, 0, 0, 982, 980,
		1, 0, 0, 0, 982, 981, 1, 0, 0, 0, 983, 139, 1, 0, 0, 0, 984, 985, 5, 59,
		0, 0, 985, 986, 3, 142, 71, 0, 986, 987, 5, 60, 0, 0, 987, 141, 1, 0, 0,
		0, 988, 993, 3, 144, 72, 0, 989, 990, 5, 50, 0, 0, 990, 992, 3, 144, 72,
		0, 991, 989, 1, 0, 0, 0, 992, 995, 1, 0, 0, 0, 993, 991, 1, 0, 0, 0, 993,
		994, 1, 0, 0, 0, 994, 143, 1, 0, 0, 0, 995, 993, 1, 0, 0, 0, 996, 999,
		3, 14, 7, 0, 997, 998, 5, 53, 0, 0, 998, 1000, 3, 264, 132, 0, 999, 997,
		1, 0, 0, 0, 999, 1000, 1, 0, 0, 0, 1000, 145, 1, 0, 0, 0, 1001, 1002, 3,
		268, 134, 0, 1002, 1003, 5, 68, 0, 0, 1003, 1004, 3, 268, 134, 0, 1004,
		147, 1, 0, 0, 0, 1005, 1009, 3, 14, 7, 0, 1006, 1009, 7, 8, 0, 0, 1007,
		1009, 3, 158, 79, 0, 1008, 1005, 1, 0, 0, 0, 1008, 1006, 1, 0, 0, 0, 1008,
		1007, 1, 0, 0, 0, 1009, 149, 1, 0, 0, 0, 1010, 1011, 5, 30, 0, 0, 1011,
		1021, 3, 152, 76, 0, 1012, 1021, 3, 152, 76, 0, 1013, 1021, 3, 184, 92,
		0, 1014, 1021, 3, 78, 39, 0, 1015, 1017, 5, 30, 0, 0, 1016, 1015, 1, 0,
		0, 0, 1016, 1017, 1, 0, 0, 0, 1017, 1018, 1, 0, 0, 0, 1018, 1021, 3, 164,
		82, 0, 1019, 1021, 3, 80, 40, 0, 1020, 1010, 1, 0, 0, 0, 1020, 1012, 1,
		0, 0, 0, 1020, 1013, 1, 0, 0, 0, 1020, 1014, 1, 0, 0, 0, 1020, 1016, 1,
		0, 0, 0, 1020, 1019, 1, 0, 0, 0, 1021, 151, 1, 0, 0, 0, 1022, 1026, 3,
		158, 79, 0, 1023, 1026, 3, 194, 97, 0, 1024, 1026, 3, 196, 98, 0, 1025,
		1022, 1, 0, 0, 0, 1025, 1023, 1, 0, 0, 0, 1025, 1024, 1, 0, 0, 0, 1026,
		153, 1, 0, 0, 0, 1027, 1028, 5, 74, 0, 0, 1028, 1031, 5, 61, 0, 0, 1029,
		1032, 3, 14, 7, 0, 1030, 1032, 3, 48, 24, 0, 1031, 1029, 1, 0, 0, 0, 1031,
		1030, 1, 0, 0, 0, 1032, 1033, 1, 0, 0, 0, 1033, 1034, 5, 63, 0, 0, 1034,
		155, 1, 0, 0, 0, 1035, 1036, 5, 145, 0, 0, 1036, 1039, 5, 61, 0, 0, 1037,
		1040, 3, 14, 7, 0, 1038, 1040, 3, 48, 24, 0, 1039, 1037, 1, 0, 0, 0, 1039,
		1038, 1, 0, 0, 0, 1040, 1041, 1, 0, 0, 0, 1041, 1042, 5, 63, 0, 0, 1042,
		157, 1, 0, 0, 0, 1043, 1044, 5, 3, 0, 0, 1044, 1045, 5, 61, 0, 0, 1045,
		1046, 3, 160, 80, 0, 1046, 1047, 5, 63, 0, 0, 1047, 1048, 5, 28, 0, 0,
		1048, 1051, 3, 136, 68, 0, 1049, 1050, 5, 53, 0, 0, 1050, 1052, 3, 140,
		70, 0, 1051, 1049, 1, 0, 0, 0, 1051, 1052, 1, 0, 0, 0, 1052, 1070, 1, 0,
		0, 0, 1053, 1054, 5, 3, 0, 0, 1054, 1055, 5, 62, 0, 0, 1055, 1056, 3, 160,
		80, 0, 1056, 1057, 5, 64, 0, 0, 1057, 1058, 5, 28, 0, 0, 1058, 1061, 3,
		136, 68, 0, 1059, 1060, 5, 53, 0, 0, 1060, 1062, 3, 140, 70, 0, 1061, 1059,
		1, 0, 0, 0, 1061, 1062, 1, 0, 0, 0, 1062, 1070, 1, 0, 0, 0, 1063, 1064,
		5, 3, 0, 0, 1064, 1065, 5, 28, 0, 0, 1065, 1070, 5, 9, 0, 0, 1066, 1067,
		5, 3, 0, 0, 1067, 1068, 5, 28, 0, 0, 1068, 1070, 3, 136, 68, 0, 1069, 1043,
		1, 0, 0, 0, 1069, 1053, 1, 0, 0, 0, 1069, 1063, 1, 0, 0, 0, 1069, 1066,
		1, 0, 0, 0, 1070, 159, 1, 0, 0, 0, 1071, 1076, 3, 162, 81, 0, 1072, 1073,
		5, 50, 0, 0, 1073, 1075, 3, 162, 81, 0, 1074, 1072, 1, 0, 0, 0, 1075, 1078,
		1, 0, 0, 0, 1076, 1074, 1, 0, 0, 0, 1076, 1077, 1, 0, 0, 0, 1077, 161,
		1, 0, 0, 0, 1078, 1076, 1, 0, 0, 0, 1079, 1080, 3, 138, 69, 0, 1080, 163,
		1, 0, 0, 0, 1081, 1082, 5, 34, 0, 0, 1082, 1086, 3, 168, 84, 0, 1083, 1085,
		3, 166, 83, 0, 1084, 1083, 1, 0, 0, 0, 1085, 1088, 1, 0, 0, 0, 1086, 1084,
		1, 0, 0, 0, 1086, 1087, 1, 0, 0, 0, 1087, 1089, 1, 0, 0, 0, 1088, 1086,
		1, 0, 0, 0, 1089, 1090, 5, 15, 0, 0, 1090, 1097, 1, 0, 0, 0, 1091, 1093,
		5, 34, 0, 0, 1092, 1094, 3, 174, 87, 0, 1093, 1092, 1, 0, 0, 0, 1093, 1094,
		1, 0, 0, 0, 1094, 1095, 1, 0, 0, 0, 1095, 1097, 5, 15, 0, 0, 1096, 1081,
		1, 0, 0, 0, 1096, 1091, 1, 0, 0, 0, 1097, 165, 1, 0, 0, 0, 1098, 1102,
		3, 94, 47, 0, 1099, 1101, 3, 170, 85, 0, 1100, 1099, 1, 0, 0, 0, 1101,
		1104, 1, 0, 0, 0, 1102, 1100, 1, 0, 0, 0, 1102, 1103, 1, 0, 0, 0, 1103,
		167, 1, 0, 0, 0, 1104, 1102, 1, 0, 0, 0, 1105, 1107, 3, 170, 85, 0, 1106,
		1105, 1, 0, 0, 0, 1107, 1110, 1, 0, 0, 0, 1108, 1106, 1, 0, 0, 0, 1108,
		1109, 1, 0, 0, 0, 1109, 169, 1, 0, 0, 0, 1110, 1108, 1, 0, 0, 0, 1111,
		1113, 3, 350, 175, 0, 1112, 1111, 1, 0, 0, 0, 1112, 1113, 1, 0, 0, 0, 1113,
		1114, 1, 0, 0, 0, 1114, 1115, 3, 242, 121, 0, 1115, 1116, 5, 51, 0, 0,
		1116, 1132, 1, 0, 0, 0, 1117, 1132, 3, 68, 34, 0, 1118, 1132, 3, 32, 16,
		0, 1119, 1132, 3, 206, 103, 0, 1120, 1132, 3, 204, 102, 0, 1121, 1132,
		3, 226, 113, 0, 1122, 1123, 3, 112, 56, 0, 1123, 1126, 5, 51, 0, 0, 1124,
		1125, 5, 88, 0, 0, 1125, 1127, 5, 51, 0, 0, 1126, 1124, 1, 0, 0, 0, 1126,
		1127, 1, 0, 0, 0, 1127, 1132, 1, 0, 0, 0, 1128, 1129, 3, 172, 86, 0, 1129,
		1130, 5, 51, 0, 0, 1130, 1132, 1, 0, 0, 0, 1131, 1112, 1, 0, 0, 0, 1131,
		1117, 1, 0, 0, 0, 1131, 1118, 1, 0, 0, 0, 1131, 1119, 1, 0, 0, 0, 1131,
		1120, 1, 0, 0, 0, 1131, 1121, 1, 0, 0, 0, 1131, 1122, 1, 0, 0, 0, 1131,
		1128, 1, 0, 0, 0, 1132, 171, 1, 0, 0, 0, 1133, 1135, 8, 7, 0, 0, 1134,
		1133, 1, 0, 0, 0, 1135, 1136, 1, 0, 0, 0, 1136, 1134, 1, 0, 0, 0, 1136,
		1137, 1, 0, 0, 0, 1137, 173, 1, 0, 0, 0, 1138, 1141, 3, 176, 88, 0, 1139,
		1140, 5, 51, 0, 0, 1140, 1142, 3, 178, 89, 0, 1141, 1139, 1, 0, 0, 0, 1141,
		1142, 1, 0, 0, 0, 1142, 1145, 1, 0, 0, 0, 1143, 1145, 3, 178, 89, 0, 1144,
		1138, 1, 0, 0, 0, 1144, 1143, 1, 0, 0, 0, 1145, 175, 1, 0, 0, 0, 1146,
		1151, 3, 242, 121, 0, 1147, 1148, 5, 51, 0, 0, 1148, 1150, 3, 242, 121,
		0, 1149, 1147, 1, 0, 0, 0, 1150, 1153, 1, 0, 0, 0, 1151, 1149, 1, 0, 0,
		0, 1151, 1152, 1, 0, 0, 0, 1152, 1155, 1, 0, 0, 0, 1153, 1151, 1, 0, 0,
		0, 1154, 1156, 5, 51, 0, 0, 1155, 1154, 1, 0, 0, 0, 1155, 1156, 1, 0, 0,
		0, 1156, 177, 1, 0, 0, 0, 1157, 1158, 5, 6, 0, 0, 1158, 1159, 3, 180, 90,
		0, 1159, 1160, 5, 28, 0, 0, 1160, 1165, 3, 182, 91, 0, 1161, 1162, 5, 51,
		0, 0, 1162, 1164, 3, 182, 91, 0, 1163, 1161, 1, 0, 0, 0, 1164, 1167, 1,
		0, 0, 0, 1165, 1163, 1, 0, 0, 0, 1165, 1166, 1, 0, 0, 0, 1166, 179, 1,
		0, 0, 0, 1167, 1165, 1, 0, 0, 0, 1168, 1169, 3, 14, 7, 0, 1169, 1170, 5,
		52, 0, 0, 1170, 1171, 3, 148, 74, 0, 1171, 1174, 1, 0, 0, 0, 1172, 1174,
		3, 148, 74, 0, 1173, 1168, 1, 0, 0, 0, 1173, 1172, 1, 0, 0, 0, 1174, 181,
		1, 0, 0, 0, 1175, 1176, 3, 238, 119, 0, 1176, 1177, 5, 52, 0, 0, 1177,
		1178, 5, 59, 0, 0, 1178, 1179, 3, 174, 87, 0, 1179, 1180, 5, 60, 0, 0,
		1180, 183, 1, 0, 0, 0, 1181, 1182, 5, 78, 0, 0, 1182, 1183, 5, 20, 0, 0,
		1183, 1184, 5, 17, 0, 0, 1184, 1185, 3, 148, 74, 0, 1185, 1189, 3, 188,
		94, 0, 1186, 1188, 3, 186, 93, 0, 1187, 1186, 1, 0, 0, 0, 1188, 1191, 1,
		0, 0, 0, 1189, 1187, 1, 0, 0, 0, 1189, 1190, 1, 0, 0, 0, 1190, 1192, 1,
		0, 0, 0, 1191, 1189, 1, 0, 0, 0, 1192, 1193, 5, 15, 0, 0, 1193, 185, 1,
		0, 0, 0, 1194, 1198, 3, 94, 47, 0, 1195, 1197, 3, 190, 95, 0, 1196, 1195,
		1, 0, 0, 0, 1197, 1200, 1, 0, 0, 0, 1198, 1196, 1, 0, 0, 0, 1198, 1199,
		1, 0, 0, 0, 1199, 187, 1, 0, 0, 0, 1200, 1198, 1, 0, 0, 0, 1201, 1203,
		3, 190, 95, 0, 1202, 1201, 1, 0, 0, 0, 1203, 1206, 1, 0, 0, 0, 1204, 1202,
		1, 0, 0, 0, 1204, 1205, 1, 0, 0, 0, 1205, 189, 1, 0, 0, 0, 1206, 1204,
		1, 0, 0, 0, 1207, 1221, 3, 68, 34, 0, 1208, 1221, 3, 32, 16, 0, 1209, 1221,
		3, 206, 103, 0, 1210, 1221, 3, 204, 102, 0, 1211, 1212, 3, 112, 56, 0,
		1212, 1215, 5, 51, 0, 0, 1213, 1214, 5, 88, 0, 0, 1214, 1216, 5, 51, 0,
		0, 1215, 1213, 1, 0, 0, 0, 1215, 1216, 1, 0, 0, 0, 1216, 1221, 1, 0, 0,
		0, 1217, 1218, 3, 192, 96, 0, 1218, 1219, 5, 51, 0, 0, 1219, 1221, 1, 0,
		0, 0, 1220, 1207, 1, 0, 0, 0, 1220, 1208, 1, 0, 0, 0, 1220, 1209, 1, 0,
		0, 0, 1220, 1210, 1, 0, 0, 0, 1220, 1211, 1, 0, 0, 0, 1220, 1217, 1, 0,
		0, 0, 1221, 191, 1, 0, 0, 0, 1222, 1224, 8, 7, 0, 0, 1223, 1222, 1, 0,
		0, 0, 1224, 1225, 1, 0, 0, 0, 1225, 1223, 1, 0, 0, 0, 1225, 1226, 1, 0,
		0, 0, 1226, 193, 1, 0, 0, 0, 1227, 1228, 5, 37, 0, 0, 1228, 1229, 5, 28,
		0, 0, 1229, 1230, 3, 138, 69, 0, 1230, 195, 1, 0, 0, 0, 1231, 1232, 5,
		16, 0, 0, 1232, 1233, 5, 28, 0, 0, 1233, 1236, 3, 136, 68, 0, 1234, 1236,
		5, 16, 0, 0, 1235, 1231, 1, 0, 0, 0, 1235, 1234, 1, 0, 0, 0, 1236, 197,
		1, 0, 0, 0, 1237, 1238, 5, 65, 0, 0, 1238, 1239, 3, 148, 74, 0, 1239, 199,
		1, 0, 0, 0, 1240, 1241, 5, 42, 0, 0, 1241, 1246, 3, 202, 101, 0, 1242,
		1243, 5, 51, 0, 0, 1243, 1245, 3, 202, 101, 0, 1244, 1242, 1, 0, 0, 0,
		1245, 1248, 1, 0, 0, 0, 1246, 1244, 1, 0, 0, 0, 1246, 1247, 1, 0, 0, 0,
		1247, 1249, 1, 0, 0, 0, 1248, 1246, 1, 0, 0, 0, 1249, 1250, 5, 51, 0, 0,
		1250, 201, 1, 0, 0, 0, 1251, 1253, 3, 350, 175, 0, 1252, 1251, 1, 0, 0,
		0, 1252, 1253, 1, 0, 0, 0, 1253, 1254, 1, 0, 0, 0, 1254, 1257, 3, 242,
		121, 0, 1255, 1256, 5, 53, 0, 0, 1256, 1258, 3, 268, 134, 0, 1257, 1255,
		1, 0, 0, 0, 1257, 1258, 1, 0, 0, 0, 1258, 203, 1, 0, 0, 0, 1259, 1261,
		3, 350, 175, 0, 1260, 1259, 1, 0, 0, 0, 1260, 1261, 1, 0, 0, 0, 1261, 1263,
		1, 0, 0, 0, 1262, 1264, 5, 78, 0, 0, 1263, 1262, 1, 0, 0, 0, 1263, 1264,
		1, 0, 0, 0, 1264, 1265, 1, 0, 0, 0, 1265, 1266, 7, 9, 0, 0, 1266, 1268,
		3, 14, 7, 0, 1267, 1269, 3, 230, 115, 0, 1268, 1267, 1, 0, 0, 0, 1268,
		1269, 1, 0, 0, 0, 1269, 1272, 1, 0, 0, 0, 1270, 1271, 5, 51, 0, 0, 1271,
		1273, 3, 66, 33, 0, 1272, 1270, 1, 0, 0, 0, 1272, 1273, 1, 0, 0, 0, 1273,
		1274, 1, 0, 0, 0, 1274, 1275, 3, 210, 105, 0, 1275, 1279, 5, 51, 0, 0,
		1276, 1277, 3, 66, 33, 0, 1277, 1278, 5, 51, 0, 0, 1278, 1280, 1, 0, 0,
		0, 1279, 1276, 1, 0, 0, 0, 1279, 1280, 1, 0, 0, 0, 1280, 205, 1, 0, 0,
		0, 1281, 1283, 3, 350, 175, 0, 1282, 1281, 1, 0, 0, 0, 1282, 1283, 1, 0,
		0, 0, 1283, 1285, 1, 0, 0, 0, 1284, 1286, 5, 78, 0, 0, 1285, 1284, 1, 0,
		0, 0, 1285, 1286, 1, 0, 0, 0, 1286, 1287, 1, 0, 0, 0, 1287, 1288, 5, 18,
		0, 0, 1288, 1290, 3, 14, 7, 0, 1289, 1291, 3, 230, 115, 0, 1290, 1289,
		1, 0, 0, 0, 1290, 1291, 1, 0, 0, 0, 1291, 1292, 1, 0, 0, 0, 1292, 1293,
		5, 52, 0, 0, 1293, 1296, 3, 222, 111, 0, 1294, 1295, 5, 51, 0, 0, 1295,
		1297, 3, 66, 33, 0, 1296, 1294, 1, 0, 0, 0, 1296, 1297, 1, 0, 0, 0, 1297,
		1298, 1, 0, 0, 0, 1298, 1299, 3, 210, 105, 0, 1299, 1303, 5, 51, 0, 0,
		1300, 1301, 3, 66, 33, 0, 1301, 1302, 5, 51, 0, 0, 1302, 1304, 1, 0, 0,
		0, 1303, 1300, 1, 0, 0, 0, 1303, 1304, 1, 0, 0, 0, 1304, 207, 1, 0, 0,
		0, 1305, 1308, 3, 204, 102, 0, 1306, 1308, 3, 206, 103, 0, 1307, 1305,
		1, 0, 0, 0, 1307, 1306, 1, 0, 0, 0, 1308, 209, 1, 0, 0, 0, 1309, 1310,
		5, 51, 0, 0, 1310, 1312, 7, 10, 0, 0, 1311, 1309, 1, 0, 0, 0, 1312, 1315,
		1, 0, 0, 0, 1313, 1311, 1, 0, 0, 0, 1313, 1314, 1, 0, 0, 0, 1314, 211,
		1, 0, 0, 0, 1315, 1313, 1, 0, 0, 0, 1316, 1319, 3, 214, 107, 0, 1317, 1319,
		3, 216, 108, 0, 1318, 1316, 1, 0, 0, 0, 1318, 1317, 1, 0, 0, 0, 1319, 213,
		1, 0, 0, 0, 1320, 1321, 3, 204, 102, 0, 1321, 1322, 3, 224, 112, 0, 1322,
		1323, 5, 51, 0, 0, 1323, 215, 1, 0, 0, 0, 1324, 1325, 3, 206, 103, 0, 1325,
		1326, 3, 224, 112, 0, 1326, 1327, 5, 51, 0, 0, 1327, 217, 1, 0, 0, 0, 1328,
		1330, 5, 31, 0, 0, 1329, 1331, 3, 230, 115, 0, 1330, 1329, 1, 0, 0, 0,
		1330, 1331, 1, 0, 0, 0, 1331, 1332, 1, 0, 0, 0, 1332, 1333, 3, 224, 112,
		0, 1333, 219, 1, 0, 0, 0, 1334, 1336, 5, 18, 0, 0, 1335, 1337, 3, 230,
		115, 0, 1336, 1335, 1, 0, 0, 0, 1336, 1337, 1, 0, 0, 0, 1337, 1338, 1,
		0, 0, 0, 1338, 1339, 5, 52, 0, 0, 1339, 1340, 3, 222, 111, 0, 1340, 1341,
		3, 224, 112, 0, 1341, 221, 1, 0, 0, 0, 1342, 1343, 3, 148, 74, 0, 1343,
		223, 1, 0, 0, 0, 1344, 1345, 3, 24, 12, 0, 1345, 1346, 3, 312, 156, 0,
		1346, 225, 1, 0, 0, 0, 1347, 1348, 5, 78, 0, 0, 1348, 1349, 5, 120, 0,
		0, 1349, 1351, 3, 14, 7, 0, 1350, 1352, 3, 230, 115, 0, 1351, 1350, 1,
		0, 0, 0, 1351, 1352, 1, 0, 0, 0, 1352, 1353, 1, 0, 0, 0, 1353, 1354, 5,
		52, 0, 0, 1354, 1355, 3, 222, 111, 0, 1355, 1356, 3, 210, 105, 0, 1356,
		1357, 5, 51, 0, 0, 1357, 227, 1, 0, 0, 0, 1358, 1359, 3, 226, 113, 0, 1359,
		1360, 3, 224, 112, 0, 1360, 1361, 5, 51, 0, 0, 1361, 229, 1, 0, 0, 0, 1362,
		1363, 5, 59, 0, 0, 1363, 1368, 3, 232, 116, 0, 1364, 1365, 5, 51, 0, 0,
		1365, 1367, 3, 232, 116, 0, 1366, 1364, 1, 0, 0, 0, 1367, 1370, 1, 0, 0,
		0, 1368, 1366, 1, 0, 0, 0, 1368, 1369, 1, 0, 0, 0, 1369, 1371, 1, 0, 0,
		0, 1370, 1368, 1, 0, 0, 0, 1371, 1372, 5, 60, 0, 0, 1372, 231, 1, 0, 0,
		0, 1373, 1375, 3, 350, 175, 0, 1374, 1373, 1, 0, 0, 0, 1374, 1375, 1, 0,
		0, 0, 1375, 1376, 1, 0, 0, 0, 1376, 1403, 3, 234, 117, 0, 1377, 1379, 3,
		350, 175, 0, 1378, 1377, 1, 0, 0, 0, 1378, 1379, 1, 0, 0, 0, 1379, 1380,
		1, 0, 0, 0, 1380, 1381, 5, 42, 0, 0, 1381, 1403, 3, 234, 117, 0, 1382,
		1384, 3, 350, 175, 0, 1383, 1382, 1, 0, 0, 0, 1383, 1384, 1, 0, 0, 0, 1384,
		1385, 1, 0, 0, 0, 1385, 1386, 5, 9, 0, 0, 1386, 1403, 3, 234, 117, 0, 1387,
		1389, 3, 350, 175, 0, 1388, 1387, 1, 0, 0, 0, 1388, 1389, 1, 0, 0, 0, 1389,
		1390, 1, 0, 0, 0, 1390, 1391, 5, 84, 0, 0, 1391, 1403, 3, 234, 117, 0,
		1392, 1394, 3, 350, 175, 0, 1393, 1392, 1, 0, 0, 0, 1393, 1394, 1, 0, 0,
		0, 1394, 1395, 1, 0, 0, 0, 1395, 1396, 5, 18, 0, 0, 1396, 1403, 3, 234,
		117, 0, 1397, 1399, 3, 350, 175, 0, 1398, 1397, 1, 0, 0, 0, 1398, 1399,
		1, 0, 0, 0, 1399, 1400, 1, 0, 0, 0, 1400, 1401, 5, 31, 0, 0, 1401, 1403,
		3, 234, 117, 0, 1402, 1374, 1, 0, 0, 0, 1402, 1378, 1, 0, 0, 0, 1402, 1383,
		1, 0, 0, 0, 1402, 1388, 1, 0, 0, 0, 1402, 1393, 1, 0, 0, 0, 1402, 1398,
		1, 0, 0, 0, 1403, 233, 1, 0, 0, 0, 1404, 1407, 3, 236, 118, 0, 1405, 1406,
		5, 52, 0, 0, 1406, 1408, 3, 148, 74, 0, 1407, 1405, 1, 0, 0, 0, 1407, 1408,
		1, 0, 0, 0, 1408, 1410, 1, 0, 0, 0, 1409, 1411, 3, 240, 120, 0, 1410, 1409,
		1, 0, 0, 0, 1410, 1411, 1, 0, 0, 0, 1411, 235, 1, 0, 0, 0, 1412, 1417,
		3, 14, 7, 0, 1413, 1414, 5, 50, 0, 0, 1414, 1416, 3, 14, 7, 0, 1415, 1413,
		1, 0, 0, 0, 1416, 1419, 1, 0, 0, 0, 1417, 1415, 1, 0, 0, 0, 1417, 1418,
		1, 0, 0, 0, 1418, 237, 1, 0, 0, 0, 1419, 1417, 1, 0, 0, 0, 1420, 1425,
		3, 40, 20, 0, 1421, 1422, 5, 50, 0, 0, 1422, 1424, 3, 40, 20, 0, 1423,
		1421, 1, 0, 0, 0, 1424, 1427, 1, 0, 0, 0, 1425, 1423, 1, 0, 0, 0, 1425,
		1426, 1, 0, 0, 0, 1426, 239, 1, 0, 0, 0, 1427, 1425, 1, 0, 0, 0, 1428,
		1429, 5, 53, 0, 0, 1429, 1430, 3, 264, 132, 0, 1430, 241, 1, 0, 0, 0, 1431,
		1432, 3, 236, 118, 0, 1432, 1433, 5, 52, 0, 0, 1433, 1434, 3, 136, 68,
		0, 1434, 243, 1, 0, 0, 0, 1435, 1436, 3, 30, 15, 0, 1436, 1437, 5, 52,
		0, 0, 1437, 1438, 3, 248, 124, 0, 1438, 1442, 1, 0, 0, 0, 1439, 1442, 3,
		248, 124, 0, 1440, 1442, 3, 246, 123, 0, 1441, 1435, 1, 0, 0, 0, 1441,
		1439, 1, 0, 0, 0, 1441, 1440, 1, 0, 0, 0, 1442, 245, 1, 0, 0, 0, 1443,
		1445, 8, 11, 0, 0, 1444, 1443, 1, 0, 0, 0, 1445, 1446, 1, 0, 0, 0, 1446,
		1444, 1, 0, 0, 0, 1446, 1447, 1, 0, 0, 0, 1447, 247, 1, 0, 0, 0, 1448,
		1451, 3, 250, 125, 0, 1449, 1451, 3, 310, 155, 0, 1450, 1448, 1, 0, 0,
		0, 1450, 1449, 1, 0, 0, 0, 1451, 249, 1, 0, 0, 0, 1452, 1462, 3, 252, 126,
		0, 1453, 1462, 3, 296, 148, 0, 1454, 1462, 3, 294, 147, 0, 1455, 1462,
		3, 302, 151, 0, 1456, 1462, 3, 304, 152, 0, 1457, 1462, 3, 260, 130, 0,
		1458, 1462, 3, 306, 153, 0, 1459, 1462, 3, 254, 127, 0, 1460, 1462, 3,
		256, 128, 0, 1461, 1452, 1, 0, 0, 0, 1461, 1453, 1, 0, 0, 0, 1461, 1454,
		1, 0, 0, 0, 1461, 1455, 1, 0, 0, 0, 1461, 1456, 1, 0, 0, 0, 1461, 1457,
		1, 0, 0, 0, 1461, 1458, 1, 0, 0, 0, 1461, 1459, 1, 0, 0, 0, 1461, 1460,
		1, 0, 0, 0, 1462, 251, 1, 0, 0, 0, 1463, 1464, 3, 258, 129, 0, 1464, 1465,
		5, 49, 0, 0, 1465, 1466, 3, 264, 132, 0, 1466, 1472, 1, 0, 0, 0, 1467,
		1468, 3, 262, 131, 0, 1468, 1469, 5, 49, 0, 0, 1469, 1470, 3, 264, 132,
		0, 1470, 1472, 1, 0, 0, 0, 1471, 1463, 1, 0, 0, 0, 1471, 1467, 1, 0, 0,
		0, 1472, 253, 1, 0, 0, 0, 1473, 1475, 5, 111, 0, 0, 1474, 1476, 3, 264,
		132, 0, 1475, 1474, 1, 0, 0, 0, 1475, 1476, 1, 0, 0, 0, 1476, 255, 1, 0,
		0, 0, 1477, 1478, 5, 42, 0, 0, 1478, 1481, 3, 236, 118, 0, 1479, 1480,
		5, 52, 0, 0, 1480, 1482, 3, 136, 68, 0, 1481, 1479, 1, 0, 0, 0, 1481, 1482,
		1, 0, 0, 0, 1482, 1485, 1, 0, 0, 0, 1483, 1484, 5, 49, 0, 0, 1484, 1486,
		3, 264, 132, 0, 1485, 1483, 1, 0, 0, 0, 1485, 1486, 1, 0, 0, 0, 1486, 257,
		1, 0, 0, 0, 1487, 1492, 3, 260, 130, 0, 1488, 1489, 5, 66, 0, 0, 1489,
		1492, 3, 14, 7, 0, 1490, 1492, 3, 282, 141, 0, 1491, 1487, 1, 0, 0, 0,
		1491, 1488, 1, 0, 0, 0, 1491, 1490, 1, 0, 0, 0, 1492, 1524, 1, 0, 0, 0,
		1493, 1494, 5, 61, 0, 0, 1494, 1499, 3, 264, 132, 0, 1495, 1496, 5, 50,
		0, 0, 1496, 1498, 3, 264, 132, 0, 1497, 1495, 1, 0, 0, 0, 1498, 1501, 1,
		0, 0, 0, 1499, 1497, 1, 0, 0, 0, 1499, 1500, 1, 0, 0, 0, 1500, 1502, 1,
		0, 0, 0, 1501, 1499, 1, 0, 0, 0, 1502, 1503, 5, 63, 0, 0, 1503, 1523, 1,
		0, 0, 0, 1504, 1505, 5, 62, 0, 0, 1505, 1510, 3, 264, 132, 0, 1506, 1507,
		5, 50, 0, 0, 1507, 1509, 3, 264, 132, 0, 1508, 1506, 1, 0, 0, 0, 1509,
		1512, 1, 0, 0, 0, 1510, 1508, 1, 0, 0, 0, 1510, 1511, 1, 0, 0, 0, 1511,
		1513, 1, 0, 0, 0, 1512, 1510, 1, 0, 0, 0, 1513, 1514, 5, 64, 0, 0, 1514,
		1523, 1, 0, 0, 0, 1515, 1516, 5, 67, 0, 0, 1516, 1523, 3, 282, 141, 0,
		1517, 1519, 5, 65, 0, 0, 1518, 1517, 1, 0, 0, 0, 1519, 1520, 1, 0, 0, 0,
		1520, 1518, 1, 0, 0, 0, 1520, 1521, 1, 0, 0, 0, 1521, 1523, 1, 0, 0, 0,
		1522, 1493, 1, 0, 0, 0, 1522, 1504, 1, 0, 0, 0, 1522, 1515, 1, 0, 0, 0,
		1522, 1518, 1, 0, 0, 0, 1523, 1526, 1, 0, 0, 0, 1524, 1522, 1, 0, 0, 0,
		1524, 1525, 1, 0, 0, 0, 1525, 259, 1, 0, 0, 0, 1526, 1524, 1, 0, 0, 0,
		1527, 1528, 3, 148, 74, 0, 1528, 1529, 5, 59, 0, 0, 1529, 1530, 3, 264,
		132, 0, 1530, 1531, 5, 60, 0, 0, 1531, 1539, 1, 0, 0, 0, 1532, 1533, 5,
		59, 0, 0, 1533, 1534, 3, 264, 132, 0, 1534, 1535, 5, 90, 0, 0, 1535, 1536,
		3, 148, 74, 0, 1536, 1537, 5, 60, 0, 0, 1537, 1539, 1, 0, 0, 0, 1538, 1527,
		1, 0, 0, 0, 1538, 1532, 1, 0, 0, 0, 1539, 261, 1, 0, 0, 0, 1540, 1545,
		3, 282, 141, 0, 1541, 1542, 5, 67, 0, 0, 1542, 1544, 3, 282, 141, 0, 1543,
		1541, 1, 0, 0, 0, 1544, 1547, 1, 0, 0, 0, 1545, 1543, 1, 0, 0, 0, 1545,
		1546, 1, 0, 0, 0, 1546, 1548, 1, 0, 0, 0, 1547, 1545, 1, 0, 0, 0, 1548,
		1549, 5, 67, 0, 0, 1549, 1561, 3, 14, 7, 0, 1550, 1551, 5, 61, 0, 0, 1551,
		1556, 3, 264, 132, 0, 1552, 1553, 5, 50, 0, 0, 1553, 1555, 3, 264, 132,
		0, 1554, 1552, 1, 0, 0, 0, 1555, 1558, 1, 0, 0, 0, 1556, 1554, 1, 0, 0,
		0, 1556, 1557, 1, 0, 0, 0, 1557, 1559, 1, 0, 0, 0, 1558, 1556, 1, 0, 0,
		0, 1559, 1560, 5, 63, 0, 0, 1560, 1562, 1, 0, 0, 0, 1561, 1550, 1, 0, 0,
		0, 1561, 1562, 1, 0, 0, 0, 1562, 263, 1, 0, 0, 0, 1563, 1567, 3, 268, 134,
		0, 1564, 1565, 3, 266, 133, 0, 1565, 1566, 3, 264, 132, 0, 1566, 1568,
		1, 0, 0, 0, 1567, 1564, 1, 0, 0, 0, 1567, 1568, 1, 0, 0, 0, 1568, 265,
		1, 0, 0, 0, 1569, 1570, 7, 12, 0, 0, 1570, 267, 1, 0, 0, 0, 1571, 1575,
		3, 272, 136, 0, 1572, 1573, 3, 270, 135, 0, 1573, 1574, 3, 268, 134, 0,
		1574, 1576, 1, 0, 0, 0, 1575, 1572, 1, 0, 0, 0, 1575, 1576, 1, 0, 0, 0,
		1576, 269, 1, 0, 0, 0, 1577, 1578, 7, 13, 0, 0, 1578, 271, 1, 0, 0, 0,
		1579, 1583, 3, 276, 138, 0, 1580, 1581, 3, 274, 137, 0, 1581, 1582, 3,
		272, 136, 0, 1582, 1584, 1, 0, 0, 0, 1583, 1580, 1, 0, 0, 0, 1583, 1584,
		1, 0, 0, 0, 1584, 273, 1, 0, 0, 0, 1585, 1586, 7, 14, 0, 0, 1586, 275,
		1, 0, 0, 0, 1587, 1589, 7, 2, 0, 0, 1588, 1587, 1, 0, 0, 0, 1588, 1589,
		1, 0, 0, 0, 1589, 1590, 1, 0, 0, 0, 1590, 1591, 3, 278, 139, 0, 1591, 277,
		1, 0, 0, 0, 1592, 1594, 6, 139, -1, 0, 1593, 1595, 5, 97, 0, 0, 1594, 1593,
		1, 0, 0, 0, 1594, 1595, 1, 0, 0, 0, 1595, 1596, 1, 0, 0, 0, 1596, 1632,
		3, 282, 141, 0, 1597, 1632, 3, 284, 142, 0, 1598, 1601, 3, 258, 129, 0,
		1599, 1600, 5, 90, 0, 0, 1600, 1602, 3, 14, 7, 0, 1601, 1599, 1, 0, 0,
		0, 1601, 1602, 1, 0, 0, 0, 1602, 1632, 1, 0, 0, 0, 1603, 1604, 5, 59, 0,
		0, 1604, 1605, 3, 264, 132, 0, 1605, 1606, 5, 60, 0, 0, 1606, 1632, 1,
		0, 0, 0, 1607, 1632, 3, 280, 140, 0, 1608, 1632, 3, 288, 144, 0, 1609,
		1610, 5, 27, 0, 0, 1610, 1632, 3, 278, 139, 8, 1611, 1632, 3, 56, 28, 0,
		1612, 1614, 5, 66, 0, 0, 1613, 1612, 1, 0, 0, 0, 1613, 1614, 1, 0, 0, 0,
		1614, 1615, 1, 0, 0, 0, 1615, 1620, 3, 148, 74, 0, 1616, 1617, 5, 59, 0,
		0, 1617, 1618, 3, 264, 132, 0, 1618, 1619, 5, 60, 0, 0, 1619, 1621, 1,
		0, 0, 0, 1620, 1616, 1, 0, 0, 0, 1620, 1621, 1, 0, 0, 0, 1621, 1625, 1,
		0, 0, 0, 1622, 1624, 5, 65, 0, 0, 1623, 1622, 1, 0, 0, 0, 1624, 1627, 1,
		0, 0, 0, 1625, 1623, 1, 0, 0, 0, 1625, 1626, 1, 0, 0, 0, 1626, 1632, 1,
		0, 0, 0, 1627, 1625, 1, 0, 0, 0, 1628, 1632, 3, 14, 7, 0, 1629, 1632, 3,
		220, 110, 0, 1630, 1632, 3, 218, 109, 0, 1631, 1592, 1, 0, 0, 0, 1631,
		1597, 1, 0, 0, 0, 1631, 1598, 1, 0, 0, 0, 1631, 1603, 1, 0, 0, 0, 1631,
		1607, 1, 0, 0, 0, 1631, 1608, 1, 0, 0, 0, 1631, 1609, 1, 0, 0, 0, 1631,
		1611, 1, 0, 0, 0, 1631, 1613, 1, 0, 0, 0, 1631, 1628, 1, 0, 0, 0, 1631,
		1629, 1, 0, 0, 0, 1631, 1630, 1, 0, 0, 0, 1632, 1654, 1, 0, 0, 0, 1633,
		1634, 10, 6, 0, 0, 1634, 1635, 5, 61, 0, 0, 1635, 1640, 3, 264, 132, 0,
		1636, 1637, 5, 50, 0, 0, 1637, 1639, 3, 264, 132, 0, 1638, 1636, 1, 0,
		0, 0, 1639, 1642, 1, 0, 0, 0, 1640, 1638, 1, 0, 0, 0, 1640, 1641, 1, 0,
		0, 0, 1641, 1643, 1, 0, 0, 0, 1642, 1640, 1, 0, 0, 0, 1643, 1644, 5, 63,
		0, 0, 1644, 1653, 1, 0, 0, 0, 1645, 1648, 10, 4, 0, 0, 1646, 1647, 5, 67,
		0, 0, 1647, 1649, 3, 264, 132, 0, 1648, 1646, 1, 0, 0, 0, 1649, 1650, 1,
		0, 0, 0, 1650, 1648, 1, 0, 0, 0, 1650, 1651, 1, 0, 0, 0, 1651, 1653, 1,
		0, 0, 0, 1652, 1633, 1, 0, 0, 0, 1652, 1645, 1, 0, 0, 0, 1653, 1656, 1,
		0, 0, 0, 1654, 1652, 1, 0, 0, 0, 1654, 1655, 1, 0, 0, 0, 1655, 279, 1,
		0, 0, 0, 1656, 1654, 1, 0, 0, 0, 1657, 1659, 3, 54, 27, 0, 1658, 1657,
		1, 0, 0, 0, 1658, 1659, 1, 0, 0, 0, 1659, 1660, 1, 0, 0, 0, 1660, 1666,
		3, 48, 24, 0, 1661, 1666, 3, 36, 18, 0, 1662, 1666, 3, 38, 19, 0, 1663,
		1666, 3, 58, 29, 0, 1664, 1666, 5, 26, 0, 0, 1665, 1658, 1, 0, 0, 0, 1665,
		1661, 1, 0, 0, 0, 1665, 1662, 1, 0, 0, 0, 1665, 1663, 1, 0, 0, 0, 1665,
		1664, 1, 0, 0, 0, 1666, 281, 1, 0, 0, 0, 1667, 1673, 3, 14, 7, 0, 1668,
		1670, 5, 59, 0, 0, 1669, 1671, 3, 286, 143, 0, 1670, 1669, 1, 0, 0, 0,
		1670, 1671, 1, 0, 0, 0, 1671, 1672, 1, 0, 0, 0, 1672, 1674, 5, 60, 0, 0,
		1673, 1668, 1, 0, 0, 0, 1673, 1674, 1, 0, 0, 0, 1674, 283, 1, 0, 0, 0,
		1675, 1680, 5, 88, 0, 0, 1676, 1677, 5, 59, 0, 0, 1677, 1678, 3, 286, 143,
		0, 1678, 1679, 5, 60, 0, 0, 1679, 1681, 1, 0, 0, 0, 1680, 1676, 1, 0, 0,
		0, 1680, 1681, 1, 0, 0, 0, 1681, 285, 1, 0, 0, 0, 1682, 1687, 3, 298, 149,
		0, 1683, 1684, 5, 50, 0, 0, 1684, 1686, 3, 298, 149, 0, 1685, 1683, 1,
		0, 0, 0, 1686, 1689, 1, 0, 0, 0, 1687, 1685, 1, 0, 0, 0, 1687, 1688, 1,
		0, 0, 0, 1688, 287, 1, 0, 0, 0, 1689, 1687, 1, 0, 0, 0, 1690, 1691, 5,
		61, 0, 0, 1691, 1692, 3, 290, 145, 0, 1692, 1693, 5, 63, 0, 0, 1693, 1699,
		1, 0, 0, 0, 1694, 1695, 5, 62, 0, 0, 1695, 1696, 3, 290, 145, 0, 1696,
		1697, 5, 64, 0, 0, 1697, 1699, 1, 0, 0, 0, 1698, 1690, 1, 0, 0, 0, 1698,
		1694, 1, 0, 0, 0, 1699, 289, 1, 0, 0, 0, 1700, 1705, 3, 292, 146, 0, 1701,
		1702, 5, 50, 0, 0, 1702, 1704, 3, 292, 146, 0, 1703, 1701, 1, 0, 0, 0,
		1704, 1707, 1, 0, 0, 0, 1705, 1703, 1, 0, 0, 0, 1705, 1706, 1, 0, 0, 0,
		1706, 1710, 1, 0, 0, 0, 1707, 1705, 1, 0, 0, 0, 1708, 1710, 1, 0, 0, 0,
		1709, 1700, 1, 0, 0, 0, 1709, 1708, 1, 0, 0, 0, 1710, 291, 1, 0, 0, 0,
		1711, 1714, 3, 264, 132, 0, 1712, 1713, 5, 68, 0, 0, 1713, 1715, 3, 264,
		132, 0, 1714, 1712, 1, 0, 0, 0, 1714, 1715, 1, 0, 0, 0, 1715, 293, 1, 0,
		0, 0, 1716, 1722, 3, 14, 7, 0, 1717, 1719, 5, 59, 0, 0, 1718, 1720, 3,
		286, 143, 0, 1719, 1718, 1, 0, 0, 0, 1719, 1720, 1, 0, 0, 0, 1720, 1721,
		1, 0, 0, 0, 1721, 1723, 5, 60, 0, 0, 1722, 1717, 1, 0, 0, 0, 1722, 1723,
		1, 0, 0, 0, 1723, 295, 1, 0, 0, 0, 1724, 1729, 3, 258, 129, 0, 1725, 1726,
		5, 67, 0, 0, 1726, 1728, 3, 258, 129, 0, 1727, 1725, 1, 0, 0, 0, 1728,
		1731, 1, 0, 0, 0, 1729, 1727, 1, 0, 0, 0, 1729, 1730, 1, 0, 0, 0, 1730,
		1732, 1, 0, 0, 0, 1731, 1729, 1, 0, 0, 0, 1732, 1733, 5, 67, 0, 0, 1733,
		1738, 3, 14, 7, 0, 1734, 1735, 5, 59, 0, 0, 1735, 1736, 3, 286, 143, 0,
		1736, 1737, 5, 60, 0, 0, 1737, 1739, 1, 0, 0, 0, 1738, 1734, 1, 0, 0, 0,
		1738, 1739, 1, 0, 0, 0, 1739, 297, 1, 0, 0, 0, 1740, 1744, 3, 264, 132,
		0, 1741, 1743, 3, 300, 150, 0, 1742, 1741, 1, 0, 0, 0, 1743, 1746, 1, 0,
		0, 0, 1744, 1742, 1, 0, 0, 0, 1744, 1745, 1, 0, 0, 0, 1745, 1750, 1, 0,
		0, 0, 1746, 1744, 1, 0, 0, 0, 1747, 1750, 3, 218, 109, 0, 1748, 1750, 3,
		220, 110, 0, 1749, 1740, 1, 0, 0, 0, 1749, 1747, 1, 0, 0, 0, 1749, 1748,
		1, 0, 0, 0, 1750, 299, 1, 0, 0, 0, 1751, 1752, 5, 52, 0, 0, 1752, 1753,
		3, 264, 132, 0, 1753, 301, 1, 0, 0, 0, 1754, 1755, 5, 19, 0, 0, 1755, 1756,
		3, 30, 15, 0, 1756, 303, 1, 0, 0, 0, 1757, 1765, 5, 97, 0, 0, 1758, 1763,
		3, 14, 7, 0, 1759, 1760, 5, 59, 0, 0, 1760, 1761, 3, 286, 143, 0, 1761,
		1762, 5, 60, 0, 0, 1762, 1764, 1, 0, 0, 0, 1763, 1759, 1, 0, 0, 0, 1763,
		1764, 1, 0, 0, 0, 1764, 1766, 1, 0, 0, 0, 1765, 1758, 1, 0, 0, 0, 1765,
		1766, 1, 0, 0, 0, 1766, 305, 1, 0, 0, 0, 1767, 1768, 1, 0, 0, 0, 1768,
		307, 1, 0, 0, 0, 1769, 1770, 1, 0, 0, 0, 1770, 309, 1, 0, 0, 0, 1771, 1778,
		3, 312, 156, 0, 1772, 1778, 3, 316, 158, 0, 1773, 1778, 3, 324, 162, 0,
		1774, 1778, 3, 338, 169, 0, 1775, 1778, 3, 340, 170, 0, 1776, 1778, 3,
		346, 173, 0, 1777, 1771, 1, 0, 0, 0, 1777, 1772, 1, 0, 0, 0, 1777, 1773,
		1, 0, 0, 0, 1777, 1774, 1, 0, 0, 0, 1777, 1775, 1, 0, 0, 0, 1777, 1776,
		1, 0, 0, 0, 1778, 311, 1, 0, 0, 0, 1779, 1780, 5, 4, 0, 0, 1780, 1781,
		3, 314, 157, 0, 1781, 1782, 5, 15, 0, 0, 1782, 313, 1, 0, 0, 0, 1783, 1788,
		3, 244, 122, 0, 1784, 1785, 5, 51, 0, 0, 1785, 1787, 3, 244, 122, 0, 1786,
		1784, 1, 0, 0, 0, 1787, 1790, 1, 0, 0, 0, 1788, 1786, 1, 0, 0, 0, 1788,
		1789, 1, 0, 0, 0, 1789, 315, 1, 0, 0, 0, 1790, 1788, 1, 0, 0, 0, 1791,
		1794, 3, 318, 159, 0, 1792, 1794, 3, 320, 160, 0, 1793, 1791, 1, 0, 0,
		0, 1793, 1792, 1, 0, 0, 0, 1794, 317, 1, 0, 0, 0, 1795, 1796, 5, 21, 0,
		0, 1796, 1797, 3, 264, 132, 0, 1797, 1798, 5, 38, 0, 0, 1798, 1801, 3,
		244, 122, 0, 1799, 1800, 5, 14, 0, 0, 1800, 1802, 3, 244, 122, 0, 1801,
		1799, 1, 0, 0, 0, 1801, 1802, 1, 0, 0, 0, 1802, 1804, 1, 0, 0, 0, 1803,
		1805, 5, 51, 0, 0, 1804, 1803, 1, 0, 0, 0, 1804, 1805, 1, 0, 0, 0, 1805,
		319, 1, 0, 0, 0, 1806, 1807, 5, 6, 0, 0, 1807, 1808, 3, 264, 132, 0, 1808,
		1809, 5, 28, 0, 0, 1809, 1814, 3, 322, 161, 0, 1810, 1811, 5, 51, 0, 0,
		1811, 1813, 3, 322, 161, 0, 1812, 1810, 1, 0, 0, 0, 1813, 1816, 1, 0, 0,
		0, 1814, 1812, 1, 0, 0, 0, 1814, 1815, 1, 0, 0, 0, 1815, 1820, 1, 0, 0,
		0, 1816, 1814, 1, 0, 0, 0, 1817, 1818, 5, 51, 0, 0, 1818, 1819, 5, 14,
		0, 0, 1819, 1821, 3, 314, 157, 0, 1820, 1817, 1, 0, 0, 0, 1820, 1821, 1,
		0, 0, 0, 1821, 1823, 1, 0, 0, 0, 1822, 1824, 5, 51, 0, 0, 1823, 1822, 1,
		0, 0, 0, 1823, 1824, 1, 0, 0, 0, 1824, 1825, 1, 0, 0, 0, 1825, 1826, 5,
		15, 0, 0, 1826, 321, 1, 0, 0, 0, 1827, 1828, 3, 238, 119, 0, 1828, 1829,
		5, 52, 0, 0, 1829, 1830, 3, 244, 122, 0, 1830, 323, 1, 0, 0, 0, 1831, 1835,
		3, 326, 163, 0, 1832, 1835, 3, 328, 164, 0, 1833, 1835, 3, 330, 165, 0,
		1834, 1831, 1, 0, 0, 0, 1834, 1832, 1, 0, 0, 0, 1834, 1833, 1, 0, 0, 0,
		1835, 325, 1, 0, 0, 0, 1836, 1837, 5, 43, 0, 0, 1837, 1838, 3, 264, 132,
		0, 1838, 1839, 5, 12, 0, 0, 1839, 1840, 3, 244, 122, 0, 1840, 327, 1, 0,
		0, 0, 1841, 1842, 5, 36, 0, 0, 1842, 1843, 3, 314, 157, 0, 1843, 1844,
		5, 41, 0, 0, 1844, 1845, 3, 264, 132, 0, 1845, 329, 1, 0, 0, 0, 1846, 1848,
		5, 17, 0, 0, 1847, 1849, 5, 42, 0, 0, 1848, 1847, 1, 0, 0, 0, 1848, 1849,
		1, 0, 0, 0, 1849, 1850, 1, 0, 0, 0, 1850, 1851, 3, 14, 7, 0, 1851, 1852,
		5, 49, 0, 0, 1852, 1853, 3, 332, 166, 0, 1853, 1854, 5, 12, 0, 0, 1854,
		1855, 3, 244, 122, 0, 1855, 1867, 1, 0, 0, 0, 1856, 1858, 5, 17, 0, 0,
		1857, 1859, 5, 42, 0, 0, 1858, 1857, 1, 0, 0, 0, 1858, 1859, 1, 0, 0, 0,
		1859, 1860, 1, 0, 0, 0, 1860, 1861, 3, 14, 7, 0, 1861, 1862, 5, 22, 0,
		0, 1862, 1863, 3, 264, 132, 0, 1863, 1864, 5, 12, 0, 0, 1864, 1865, 3,
		244, 122, 0, 1865, 1867, 1, 0, 0, 0, 1866, 1846, 1, 0, 0, 0, 1866, 1856,
		1, 0, 0, 0, 1867, 331, 1, 0, 0, 0, 1868, 1869, 3, 334, 167, 0, 1869, 1870,
		7, 15, 0, 0, 1870, 1871, 3, 336, 168, 0, 1871, 333, 1, 0, 0, 0, 1872, 1873,
		3, 264, 132, 0, 1873, 335, 1, 0, 0, 0, 1874, 1875, 3, 264, 132, 0, 1875,
		337, 1, 0, 0, 0, 1876, 1877, 5, 44, 0, 0, 1877, 1878, 3, 348, 174, 0, 1878,
		1879, 5, 12, 0, 0, 1879, 1880, 3, 244, 122, 0, 1880, 1887, 1, 0, 0, 0,
		1881, 1882, 5, 44, 0, 0, 1882, 1883, 3, 264, 132, 0, 1883, 1884, 5, 12,
		0, 0, 1884, 1885, 3, 244, 122, 0, 1885, 1887, 1, 0, 0, 0, 1886, 1876, 1,
		0, 0, 0, 1886, 1881, 1, 0, 0, 0, 1887, 339, 1, 0, 0, 0, 1888, 1889, 5,
		91, 0, 0, 1889, 1890, 3, 314, 157, 0, 1890, 1891, 5, 93, 0, 0, 1891, 1892,
		3, 314, 157, 0, 1892, 1893, 5, 15, 0, 0, 1893, 1910, 1, 0, 0, 0, 1894,
		1895, 5, 91, 0, 0, 1895, 1896, 3, 314, 157, 0, 1896, 1900, 5, 93, 0, 0,
		1897, 1898, 3, 342, 171, 0, 1898, 1899, 5, 51, 0, 0, 1899, 1901, 1, 0,
		0, 0, 1900, 1897, 1, 0, 0, 0, 1901, 1902, 1, 0, 0, 0, 1902, 1900, 1, 0,
		0, 0, 1902, 1903, 1, 0, 0, 0, 1903, 1905, 1, 0, 0, 0, 1904, 1906, 3, 344,
		172, 0, 1905, 1904, 1, 0, 0, 0, 1905, 1906, 1, 0, 0, 0, 1906, 1907, 1,
		0, 0, 0, 1907, 1908, 5, 15, 0, 0, 1908, 1910, 1, 0, 0, 0, 1909, 1888, 1,
		0, 0, 0, 1909, 1894, 1, 0, 0, 0, 1910, 341, 1, 0, 0, 0, 1911, 1912, 5,
		121, 0, 0, 1912, 1913, 3, 14, 7, 0, 1913, 1914, 5, 52, 0, 0, 1914, 1915,
		3, 148, 74, 0, 1915, 1916, 5, 12, 0, 0, 1916, 1917, 3, 314, 157, 0, 1917,
		343, 1, 0, 0, 0, 1918, 1919, 5, 14, 0, 0, 1919, 1920, 3, 314, 157, 0, 1920,
		345, 1, 0, 0, 0, 1921, 1922, 5, 91, 0, 0, 1922, 1923, 3, 314, 157, 0, 1923,
		1924, 5, 92, 0, 0, 1924, 1925, 3, 314, 157, 0, 1925, 1926, 5, 15, 0, 0,
		1926, 347, 1, 0, 0, 0, 1927, 1932, 3, 258, 129, 0, 1928, 1929, 5, 50, 0,
		0, 1929, 1931, 3, 258, 129, 0, 1930, 1928, 1, 0, 0, 0, 1931, 1934, 1, 0,
		0, 0, 1932, 1930, 1, 0, 0, 0, 1932, 1933, 1, 0, 0, 0, 1933, 349, 1, 0,
		0, 0, 1934, 1932, 1, 0, 0, 0, 1935, 1936, 5, 61, 0, 0, 1936, 1937, 3, 352,
		176, 0, 1937, 1938, 5, 63, 0, 0, 1938, 351, 1, 0, 0, 0, 1939, 1944, 3,
		354, 177, 0, 1940, 1941, 5, 50, 0, 0, 1941, 1943, 3, 354, 177, 0, 1942,
		1940, 1, 0, 0, 0, 1943, 1946, 1, 0, 0, 0, 1944, 1942, 1, 0, 0, 0, 1944,
		1945, 1, 0, 0, 0, 1945, 353, 1, 0, 0, 0, 1946, 1944, 1, 0, 0, 0, 1947,
		1952, 3, 14, 7, 0, 1948, 1949, 5, 59, 0, 0, 1949, 1950, 3, 286, 143, 0,
		1950, 1951, 5, 60, 0, 0, 1951, 1953, 1, 0, 0, 0, 1952, 1948, 1, 0, 0, 0,
		1952, 1953, 1, 0, 0, 0, 1953, 355, 1, 0, 0, 0, 224, 358, 366, 370, 384,
		387, 390, 398, 404, 419, 424, 433, 435, 442, 455, 457, 465, 467, 480, 493,
		498, 503, 511, 519, 521, 537, 541, 546, 554, 565, 570, 578, 597, 601, 614,
		620, 624, 631, 647, 651, 654, 666, 674, 677, 683, 688, 695, 698, 703, 713,
		716, 722, 732, 735, 742, 748, 756, 762, 766, 770, 777, 780, 795, 799, 803,
		808, 814, 820, 824, 837, 842, 849, 860, 865, 870, 875, 880, 883, 886, 889,
		893, 898, 900, 920, 935, 947, 953, 960, 970, 975, 982, 993, 999, 1008,
		1016, 1020, 1025, 1031, 1039, 1051, 1061, 1069, 1076, 1086, 1093, 1096,
		1102, 1108, 1112, 1126, 1131, 1136, 1141, 1144, 1151, 1155, 1165, 1173,
		1189, 1198, 1204, 1215, 1220, 1225, 1235, 1246, 1252, 1257, 1260, 1263,
		1268, 1272, 1279, 1282, 1285, 1290, 1296, 1303, 1307, 1313, 1318, 1330,
		1336, 1351, 1368, 1374, 1378, 1383, 1388, 1393, 1398, 1402, 1407, 1410,
		1417, 1425, 1441, 1446, 1450, 1461, 1471, 1475, 1481, 1485, 1491, 1499,
		1510, 1520, 1522, 1524, 1538, 1545, 1556, 1561, 1567, 1575, 1583, 1588,
		1594, 1601, 1613, 1620, 1625, 1631, 1640, 1650, 1652, 1654, 1658, 1665,
		1670, 1673, 1680, 1687, 1698, 1705, 1709, 1714, 1719, 1722, 1729, 1738,
		1744, 1749, 1763, 1765, 1777, 1788, 1793, 1801, 1804, 1814, 1820, 1823,
		1834, 1848, 1858, 1866, 1886, 1902, 1905, 1909, 1932, 1944, 1952,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// pascalParserInit initializes any static state used to implement pascalParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewpascalParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func PascalParserInit() {
	staticData := &PascalParserStaticData
	staticData.once.Do(pascalParserInit)
}

// NewpascalParser produces a new parser instance for the optional input antlr.TokenStream.
func NewpascalParser(input antlr.TokenStream) *pascalParser {
	PascalParserInit()
	this := new(pascalParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &PascalParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "pascal.g4"

	return this
}

// pascalParser tokens.
const (
	pascalParserEOF                       = antlr.TokenEOF
	pascalParserGUID_LITERAL              = 1
	pascalParserAND                       = 2
	pascalParserARRAY                     = 3
	pascalParserBEGIN                     = 4
	pascalParserBOOLEAN                   = 5
	pascalParserCASE                      = 6
	pascalParserCHAR                      = 7
	pascalParserCHR                       = 8
	pascalParserCONST                     = 9
	pascalParserDEPRECATED                = 10
	pascalParserDIV                       = 11
	pascalParserDO                        = 12
	pascalParserDOWNTO                    = 13
	pascalParserELSE                      = 14
	pascalParserEND                       = 15
	pascalParserFILE                      = 16
	pascalParserFOR                       = 17
	pascalParserFUNCTION                  = 18
	pascalParserGOTO                      = 19
	pascalParserHELPER                    = 20
	pascalParserIF                        = 21
	pascalParserIN                        = 22
	pascalParserINTEGER                   = 23
	pascalParserLABEL                     = 24
	pascalParserMOD                       = 25
	pascalParserNIL                       = 26
	pascalParserNOT                       = 27
	pascalParserOF                        = 28
	pascalParserOR                        = 29
	pascalParserPACKED                    = 30
	pascalParserPROCEDURE                 = 31
	pascalParserPROGRAM                   = 32
	pascalParserREAL                      = 33
	pascalParserRECORD                    = 34
	pascalParserREFERENCE                 = 35
	pascalParserREPEAT                    = 36
	pascalParserSET                       = 37
	pascalParserTHEN                      = 38
	pascalParserTO                        = 39
	pascalParserTYPE                      = 40
	pascalParserUNTIL                     = 41
	pascalParserVAR                       = 42
	pascalParserWHILE                     = 43
	pascalParserWITH                      = 44
	pascalParserPLUS                      = 45
	pascalParserMINUS                     = 46
	pascalParserSTAR                      = 47
	pascalParserSLASH                     = 48
	pascalParserASSIGN                    = 49
	pascalParserCOMMA                     = 50
	pascalParserSEMI                      = 51
	pascalParserCOLON                     = 52
	pascalParserEQUAL                     = 53
	pascalParserNOT_EQUAL                 = 54
	pascalParserLT                        = 55
	pascalParserLE                        = 56
	pascalParserGE                        = 57
	pascalParserGT                        = 58
	pascalParserLPAREN                    = 59
	pascalParserRPAREN                    = 60
	pascalParserLBRACK                    = 61
	pascalParserLBRACK2                   = 62
	pascalParserRBRACK                    = 63
	pascalParserRBRACK2                   = 64
	pascalParserDEREFERENCE               = 65
	pascalParserAT                        = 66
	pascalParserDOT                       = 67
	pascalParserDOTDOT                    = 68
	pascalParserLCURLY                    = 69
	pascalParserRCURLY                    = 70
	pascalParserUNIT                      = 71
	pascalParserINTERFACE                 = 72
	pascalParserUSES                      = 73
	pascalParserSTRING                    = 74
	pascalParserIMPLEMENTATION            = 75
	pascalParserTRUE                      = 76
	pascalParserFALSE                     = 77
	pascalParserCLASS                     = 78
	pascalParserPRIVATE                   = 79
	pascalParserPROTECTED                 = 80
	pascalParserPUBLIC                    = 81
	pascalParserPUBLISHED                 = 82
	pascalParserSTRICT                    = 83
	pascalParserOUT                       = 84
	pascalParserPROPERTY                  = 85
	pascalParserREAD                      = 86
	pascalParserWRITE                     = 87
	pascalParserDEFAULT                   = 88
	pascalParserINDEX                     = 89
	pascalParserAS                        = 90
	pascalParserTRY                       = 91
	pascalParserFINALLY                   = 92
	pascalParserEXCEPT                    = 93
	pascalParserINITIALIZATION            = 94
	pascalParserFINALIZATION              = 95
	pascalParserOBJECT                    = 96
	pascalParserINHERITED                 = 97
	pascalParserABSTRACT                  = 98
	pascalParserREINTRODUCE               = 99
	pascalParserVIRTUAL                   = 100
	pascalParserOVERRIDE                  = 101
	pascalParserOVERLOAD                  = 102
	pascalParserINLINE                    = 103
	pascalParserCDECL                     = 104
	pascalParserSTDCALL                   = 105
	pascalParserSTATIC                    = 106
	pascalParserCONSTRUCTOR               = 107
	pascalParserDESTRUCTOR                = 108
	pascalParserRESOURCESTRING            = 109
	pascalParserFORWARD                   = 110
	pascalParserRAISE                     = 111
	pascalParserSHR                       = 112
	pascalParserSHL                       = 113
	pascalParserXOR                       = 114
	pascalParserCARDINAL                  = 115
	pascalParserLONGBOOL                  = 116
	pascalParserLONGINT                   = 117
	pascalParserLONGWORD                  = 118
	pascalParserWORD                      = 119
	pascalParserOPERATOR                  = 120
	pascalParserON                        = 121
	pascalParserWS                        = 122
	pascalParserCOMMENT_1                 = 123
	pascalParserCOMMENT_2                 = 124
	pascalParserCOMMENT_3                 = 125
	pascalParserIDENT                     = 126
	pascalParserHEX_LITERAL               = 127
	pascalParserSTRING_LITERAL            = 128
	pascalParserSTRING_CROSSHATCH_LITERAL = 129
	pascalParserNUM_INT                   = 130
	pascalParserNUM_REAL                  = 131
	pascalParserUTF8BOM                   = 132
	pascalParserBYTE                      = 133
	pascalParserSHORTINT                  = 134
	pascalParserSMALLINT                  = 135
	pascalParserINT64                     = 136
	pascalParserUINT64                    = 137
	pascalParserSINGLE                    = 138
	pascalParserDOUBLE                    = 139
	pascalParserEXTENDED                  = 140
	pascalParserCOMP                      = 141
	pascalParserCURRENCY                  = 142
	pascalParserANSICHAR                  = 143
	pascalParserWIDECHAR                  = 144
	pascalParserANSISTRING                = 145
	pascalParserWIDESTRING                = 146
	pascalParserUNICODESTRING             = 147
	pascalParserRAWBYTESTRING             = 148
	pascalParserUTF8STRING                = 149
	pascalParserVARIANT                   = 150
	pascalParserOLEVARIANT                = 151
	pascalParserPOINTER                   = 152
	pascalParserPCHAR                     = 153
	pascalParserPANSICHAR                 = 154
	pascalParserPWIDECHAR                 = 155
	pascalParserPUNICODECHAR              = 156
	pascalParserTHANDLE                   = 157
	pascalParserHWND                      = 158
	pascalParserHDC                       = 159
	pascalParserHICON                     = 160
	pascalParserHBITMAP                   = 161
	pascalParserHMENU                     = 162
	pascalParserHINSTANCE                 = 163
	pascalParserHMODULE                   = 164
	pascalParserHKEY                      = 165
	pascalParserDWORD                     = 166
	pascalParserQWORD                     = 167
	pascalParserNATIVEINT                 = 168
	pascalParserNATIVEUINT                = 169
	pascalParserCODEPAGE                  = 170
	pascalParserTGUID                     = 171
	pascalParserPGUID                     = 172
	pascalParserTEXTFILE                  = 173
	pascalParserTEXT                      = 174
	pascalParserSHORTSTRING               = 175
	pascalParserOPENSTRING                = 176
)

// pascalParser rules.
const (
	pascalParserRULE_source                             = 0
	pascalParserRULE_program                            = 1
	pascalParserRULE_unit                               = 2
	pascalParserRULE_interfaceSection                   = 3
	pascalParserRULE_implementationSection              = 4
	pascalParserRULE_initializationSection              = 5
	pascalParserRULE_finalizationSection                = 6
	pascalParserRULE_identifier                         = 7
	pascalParserRULE_identifierPart                     = 8
	pascalParserRULE_interfaceBlock                     = 9
	pascalParserRULE_errorInterfaceBlockPart            = 10
	pascalParserRULE_implementationBlock                = 11
	pascalParserRULE_block                              = 12
	pascalParserRULE_usesUnits                          = 13
	pascalParserRULE_labelDeclarationPart               = 14
	pascalParserRULE_label                              = 15
	pascalParserRULE_constantDefinitionPart             = 16
	pascalParserRULE_constantDefinition                 = 17
	pascalParserRULE_constantChr                        = 18
	pascalParserRULE_hexConstant                        = 19
	pascalParserRULE_constant                           = 20
	pascalParserRULE_arrayConstant                      = 21
	pascalParserRULE_recordConstant                     = 22
	pascalParserRULE_recordField                        = 23
	pascalParserRULE_unsignedNumber                     = 24
	pascalParserRULE_unsignedInteger                    = 25
	pascalParserRULE_unsignedReal                       = 26
	pascalParserRULE_sign                               = 27
	pascalParserRULE_bool_                              = 28
	pascalParserRULE_string                             = 29
	pascalParserRULE_stringExpression                   = 30
	pascalParserRULE_resourceDefinitionPart             = 31
	pascalParserRULE_resourceDefinition                 = 32
	pascalParserRULE_deprecatedHint                     = 33
	pascalParserRULE_typeDefinitionPart                 = 34
	pascalParserRULE_typeDefinition                     = 35
	pascalParserRULE_classTypeOrForward                 = 36
	pascalParserRULE_interfaceTypeOrForward             = 37
	pascalParserRULE_forwardDeclaration                 = 38
	pascalParserRULE_classType                          = 39
	pascalParserRULE_interfaceType                      = 40
	pascalParserRULE_functionType                       = 41
	pascalParserRULE_procedureType                      = 42
	pascalParserRULE_metaClassType                      = 43
	pascalParserRULE_aliasDistinctType                  = 44
	pascalParserRULE_aliasType                          = 45
	pascalParserRULE_classImplementsInterfaces          = 46
	pascalParserRULE_accessSpecifier                    = 47
	pascalParserRULE_classDeclaration                   = 48
	pascalParserRULE_classImplicitPublishedDeclaration  = 49
	pascalParserRULE_classDeclarationPart               = 50
	pascalParserRULE_interfaceGuidConst                 = 51
	pascalParserRULE_interfaceDeclaration               = 52
	pascalParserRULE_interfaceDeclarationPart           = 53
	pascalParserRULE_errorInterfaceDeclarationPart      = 54
	pascalParserRULE_errorClassDeclarationPart          = 55
	pascalParserRULE_propertyDeclaration                = 56
	pascalParserRULE_propertyReadDeclaration            = 57
	pascalParserRULE_propertyWriteDeclaration           = 58
	pascalParserRULE_propertyDefaultValueDeclaration    = 59
	pascalParserRULE_propertyIndexDeclaration           = 60
	pascalParserRULE_propertyIndexParameters            = 61
	pascalParserRULE_propertyIndexParametersList        = 62
	pascalParserRULE_genericTemplate                    = 63
	pascalParserRULE_genericTemplateList                = 64
	pascalParserRULE_genericTypeParameter               = 65
	pascalParserRULE_genericConstraints                 = 66
	pascalParserRULE_genericConstraint                  = 67
	pascalParserRULE_type_                              = 68
	pascalParserRULE_simpleType                         = 69
	pascalParserRULE_scalarType                         = 70
	pascalParserRULE_scalerList                         = 71
	pascalParserRULE_scalerMember                       = 72
	pascalParserRULE_subrangeType                       = 73
	pascalParserRULE_typeIdentifier                     = 74
	pascalParserRULE_structuredType                     = 75
	pascalParserRULE_unpackedStructuredType             = 76
	pascalParserRULE_stringtype                         = 77
	pascalParserRULE_ansistringtype                     = 78
	pascalParserRULE_arrayType                          = 79
	pascalParserRULE_typeList                           = 80
	pascalParserRULE_indexType                          = 81
	pascalParserRULE_recordType                         = 82
	pascalParserRULE_recordDeclaration                  = 83
	pascalParserRULE_recordImplicitPublishedDeclaration = 84
	pascalParserRULE_recordDeclarationPart              = 85
	pascalParserRULE_errorRecordDeclarationPart         = 86
	pascalParserRULE_recordParts                        = 87
	pascalParserRULE_recordFixedPart                    = 88
	pascalParserRULE_recordVariantPart                  = 89
	pascalParserRULE_tag                                = 90
	pascalParserRULE_recordVariant                      = 91
	pascalParserRULE_helperType                         = 92
	pascalParserRULE_helperDeclaration                  = 93
	pascalParserRULE_helperImplicitPublishedDeclaration = 94
	pascalParserRULE_helperDeclarationPart              = 95
	pascalParserRULE_errorHelperDeclarationPart         = 96
	pascalParserRULE_setType                            = 97
	pascalParserRULE_fileType                           = 98
	pascalParserRULE_pointerType                        = 99
	pascalParserRULE_variableDeclarationPart            = 100
	pascalParserRULE_variableDeclaration                = 101
	pascalParserRULE_procedureHeader                    = 102
	pascalParserRULE_functionHeader                     = 103
	pascalParserRULE_procedureOrFunctionHeader          = 104
	pascalParserRULE_procedureOrFunctionHeaderModifiers = 105
	pascalParserRULE_procedureOrFunctionDeclaration     = 106
	pascalParserRULE_procedureDeclaration               = 107
	pascalParserRULE_functionDeclaration                = 108
	pascalParserRULE_procedureLambdaDeclaration         = 109
	pascalParserRULE_functionLambdaDeclaration          = 110
	pascalParserRULE_resultType                         = 111
	pascalParserRULE_procedureOrFunctionBody            = 112
	pascalParserRULE_classOperatorHeader                = 113
	pascalParserRULE_classOperatorDeclaration           = 114
	pascalParserRULE_formalParameterList                = 115
	pascalParserRULE_formalParameterSection             = 116
	pascalParserRULE_parameterGroup                     = 117
	pascalParserRULE_identifierList                     = 118
	pascalParserRULE_constList                          = 119
	pascalParserRULE_defaultValue                       = 120
	pascalParserRULE_typedIdentifierList                = 121
	pascalParserRULE_statement                          = 122
	pascalParserRULE_errorStatement                     = 123
	pascalParserRULE_unlabelledStatement                = 124
	pascalParserRULE_simpleStatement                    = 125
	pascalParserRULE_assignmentStatement                = 126
	pascalParserRULE_raiseExceptionStatement            = 127
	pascalParserRULE_variableDeclarationStatement       = 128
	pascalParserRULE_variableDesignator                 = 129
	pascalParserRULE_typeCast                           = 130
	pascalParserRULE_propertyDesignator                 = 131
	pascalParserRULE_expression                         = 132
	pascalParserRULE_relationaloperator                 = 133
	pascalParserRULE_simpleExpression                   = 134
	pascalParserRULE_additiveoperator                   = 135
	pascalParserRULE_term                               = 136
	pascalParserRULE_multiplicativeoperator             = 137
	pascalParserRULE_signedFactor                       = 138
	pascalParserRULE_factor                             = 139
	pascalParserRULE_unsignedConstant                   = 140
	pascalParserRULE_functionDesignator                 = 141
	pascalParserRULE_defaultDesignator                  = 142
	pascalParserRULE_parameterList                      = 143
	pascalParserRULE_set_                               = 144
	pascalParserRULE_elementList                        = 145
	pascalParserRULE_element                            = 146
	pascalParserRULE_procedureStatement                 = 147
	pascalParserRULE_methodCallStatement                = 148
	pascalParserRULE_actualParameter                    = 149
	pascalParserRULE_parameterwidth                     = 150
	pascalParserRULE_gotoStatement                      = 151
	pascalParserRULE_inheritedStatement                 = 152
	pascalParserRULE_emptyStatement_                    = 153
	pascalParserRULE_empty_                             = 154
	pascalParserRULE_structuredStatement                = 155
	pascalParserRULE_compoundStatement                  = 156
	pascalParserRULE_statements                         = 157
	pascalParserRULE_conditionalStatement               = 158
	pascalParserRULE_ifStatement                        = 159
	pascalParserRULE_caseStatement                      = 160
	pascalParserRULE_caseListElement                    = 161
	pascalParserRULE_repetetiveStatement                = 162
	pascalParserRULE_whileStatement                     = 163
	pascalParserRULE_repeatStatement                    = 164
	pascalParserRULE_forStatement                       = 165
	pascalParserRULE_forList                            = 166
	pascalParserRULE_initialValue                       = 167
	pascalParserRULE_finalValue                         = 168
	pascalParserRULE_withStatement                      = 169
	pascalParserRULE_tryExceptStatement                 = 170
	pascalParserRULE_exceptionCase                      = 171
	pascalParserRULE_exceptionElse                      = 172
	pascalParserRULE_tryFinallyStatement                = 173
	pascalParserRULE_withStatementVariableList          = 174
	pascalParserRULE_attributeSection                   = 175
	pascalParserRULE_attributeList                      = 176
	pascalParserRULE_attributeItem                      = 177
)

// ISourceContext is an interface to support dynamic dispatch.
type ISourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Program() IProgramContext
	Unit() IUnitContext

	// IsSourceContext differentiates from other interfaces.
	IsSourceContext()
}

type SourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceContext() *SourceContext {
	var p = new(SourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_source
	return p
}

func InitEmptySourceContext(p *SourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_source
}

func (*SourceContext) IsSourceContext() {}

func NewSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceContext {
	var p = new(SourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_source

	return p
}

func (s *SourceContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceContext) Program() IProgramContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProgramContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProgramContext)
}

func (s *SourceContext) Unit() IUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitContext)
}

func (s *SourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSource(s)
	}
}

func (s *SourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSource(s)
	}
}

func (s *SourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSource(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Source() (localctx ISourceContext) {
	localctx = NewSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, pascalParserRULE_source)
	p.SetState(358)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserPROGRAM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(356)
			p.Program()
		}

	case pascalParserUNIT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(357)
			p.Unit()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROGRAM() antlr.TerminalNode
	Identifier() IIdentifierContext
	SEMI() antlr.TerminalNode
	ImplementationBlock() IImplementationBlockContext
	BEGIN() antlr.TerminalNode
	Statements() IStatementsContext
	END() antlr.TerminalNode
	DOT() antlr.TerminalNode
	EOF() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	RPAREN() antlr.TerminalNode
	UsesUnits() IUsesUnitsContext

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) PROGRAM() antlr.TerminalNode {
	return s.GetToken(pascalParserPROGRAM, 0)
}

func (s *ProgramContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ProgramContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ProgramContext) ImplementationBlock() IImplementationBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplementationBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplementationBlockContext)
}

func (s *ProgramContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(pascalParserBEGIN, 0)
}

func (s *ProgramContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *ProgramContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *ProgramContext) DOT() antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, 0)
}

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(pascalParserEOF, 0)
}

func (s *ProgramContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ProgramContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ProgramContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ProgramContext) UsesUnits() IUsesUnitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsesUnitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsesUnitsContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProgram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, pascalParserRULE_program)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(360)
		p.Match(pascalParserPROGRAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(361)
		p.Identifier()
	}
	p.SetState(366)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(362)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(363)
			p.IdentifierList()
		}
		{
			p.SetState(364)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(368)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(370)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserUSES {
		{
			p.SetState(369)
			p.UsesUnits()
		}

	}
	{
		p.SetState(372)
		p.ImplementationBlock()
	}
	{
		p.SetState(373)
		p.Match(pascalParserBEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(374)
		p.Statements()
	}
	{
		p.SetState(375)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(376)
		p.Match(pascalParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(377)
		p.Match(pascalParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitContext is an interface to support dynamic dispatch.
type IUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNIT() antlr.TerminalNode
	Identifier() IIdentifierContext
	SEMI() antlr.TerminalNode
	InterfaceSection() IInterfaceSectionContext
	END() antlr.TerminalNode
	DOT() antlr.TerminalNode
	EOF() antlr.TerminalNode
	ImplementationSection() IImplementationSectionContext
	InitializationSection() IInitializationSectionContext
	FinalizationSection() IFinalizationSectionContext

	// IsUnitContext differentiates from other interfaces.
	IsUnitContext()
}

type UnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitContext() *UnitContext {
	var p = new(UnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unit
	return p
}

func InitEmptyUnitContext(p *UnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unit
}

func (*UnitContext) IsUnitContext() {}

func NewUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitContext {
	var p = new(UnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unit

	return p
}

func (s *UnitContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitContext) UNIT() antlr.TerminalNode {
	return s.GetToken(pascalParserUNIT, 0)
}

func (s *UnitContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnitContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *UnitContext) InterfaceSection() IInterfaceSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceSectionContext)
}

func (s *UnitContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *UnitContext) DOT() antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, 0)
}

func (s *UnitContext) EOF() antlr.TerminalNode {
	return s.GetToken(pascalParserEOF, 0)
}

func (s *UnitContext) ImplementationSection() IImplementationSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplementationSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplementationSectionContext)
}

func (s *UnitContext) InitializationSection() IInitializationSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializationSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializationSectionContext)
}

func (s *UnitContext) FinalizationSection() IFinalizationSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinalizationSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinalizationSectionContext)
}

func (s *UnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnit(s)
	}
}

func (s *UnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnit(s)
	}
}

func (s *UnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Unit() (localctx IUnitContext) {
	localctx = NewUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, pascalParserRULE_unit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(379)
		p.Match(pascalParserUNIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(380)
		p.Identifier()
	}
	{
		p.SetState(381)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(382)
		p.InterfaceSection()
	}
	p.SetState(384)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserIMPLEMENTATION {
		{
			p.SetState(383)
			p.ImplementationSection()
		}

	}
	p.SetState(387)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserINITIALIZATION {
		{
			p.SetState(386)
			p.InitializationSection()
		}

	}
	p.SetState(390)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserFINALIZATION {
		{
			p.SetState(389)
			p.FinalizationSection()
		}

	}
	{
		p.SetState(392)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(393)
		p.Match(pascalParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(394)
		p.Match(pascalParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceSectionContext is an interface to support dynamic dispatch.
type IInterfaceSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	InterfaceBlock() IInterfaceBlockContext
	UsesUnits() IUsesUnitsContext

	// IsInterfaceSectionContext differentiates from other interfaces.
	IsInterfaceSectionContext()
}

type InterfaceSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceSectionContext() *InterfaceSectionContext {
	var p = new(InterfaceSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceSection
	return p
}

func InitEmptyInterfaceSectionContext(p *InterfaceSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceSection
}

func (*InterfaceSectionContext) IsInterfaceSectionContext() {}

func NewInterfaceSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceSectionContext {
	var p = new(InterfaceSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceSection

	return p
}

func (s *InterfaceSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceSectionContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(pascalParserINTERFACE, 0)
}

func (s *InterfaceSectionContext) InterfaceBlock() IInterfaceBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceBlockContext)
}

func (s *InterfaceSectionContext) UsesUnits() IUsesUnitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsesUnitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsesUnitsContext)
}

func (s *InterfaceSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceSection(s)
	}
}

func (s *InterfaceSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceSection(s)
	}
}

func (s *InterfaceSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceSection() (localctx IInterfaceSectionContext) {
	localctx = NewInterfaceSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, pascalParserRULE_interfaceSection)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(396)
		p.Match(pascalParserINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(398)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserUSES {
		{
			p.SetState(397)
			p.UsesUnits()
		}

	}
	{
		p.SetState(400)
		p.InterfaceBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImplementationSectionContext is an interface to support dynamic dispatch.
type IImplementationSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPLEMENTATION() antlr.TerminalNode
	ImplementationBlock() IImplementationBlockContext
	UsesUnits() IUsesUnitsContext

	// IsImplementationSectionContext differentiates from other interfaces.
	IsImplementationSectionContext()
}

type ImplementationSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplementationSectionContext() *ImplementationSectionContext {
	var p = new(ImplementationSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_implementationSection
	return p
}

func InitEmptyImplementationSectionContext(p *ImplementationSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_implementationSection
}

func (*ImplementationSectionContext) IsImplementationSectionContext() {}

func NewImplementationSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplementationSectionContext {
	var p = new(ImplementationSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_implementationSection

	return p
}

func (s *ImplementationSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplementationSectionContext) IMPLEMENTATION() antlr.TerminalNode {
	return s.GetToken(pascalParserIMPLEMENTATION, 0)
}

func (s *ImplementationSectionContext) ImplementationBlock() IImplementationBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplementationBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplementationBlockContext)
}

func (s *ImplementationSectionContext) UsesUnits() IUsesUnitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsesUnitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsesUnitsContext)
}

func (s *ImplementationSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplementationSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplementationSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterImplementationSection(s)
	}
}

func (s *ImplementationSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitImplementationSection(s)
	}
}

func (s *ImplementationSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitImplementationSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ImplementationSection() (localctx IImplementationSectionContext) {
	localctx = NewImplementationSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, pascalParserRULE_implementationSection)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(402)
		p.Match(pascalParserIMPLEMENTATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(404)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserUSES {
		{
			p.SetState(403)
			p.UsesUnits()
		}

	}
	{
		p.SetState(406)
		p.ImplementationBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitializationSectionContext is an interface to support dynamic dispatch.
type IInitializationSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INITIALIZATION() antlr.TerminalNode
	Statements() IStatementsContext

	// IsInitializationSectionContext differentiates from other interfaces.
	IsInitializationSectionContext()
}

type InitializationSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializationSectionContext() *InitializationSectionContext {
	var p = new(InitializationSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_initializationSection
	return p
}

func InitEmptyInitializationSectionContext(p *InitializationSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_initializationSection
}

func (*InitializationSectionContext) IsInitializationSectionContext() {}

func NewInitializationSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializationSectionContext {
	var p = new(InitializationSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_initializationSection

	return p
}

func (s *InitializationSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializationSectionContext) INITIALIZATION() antlr.TerminalNode {
	return s.GetToken(pascalParserINITIALIZATION, 0)
}

func (s *InitializationSectionContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *InitializationSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializationSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializationSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInitializationSection(s)
	}
}

func (s *InitializationSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInitializationSection(s)
	}
}

func (s *InitializationSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInitializationSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InitializationSection() (localctx IInitializationSectionContext) {
	localctx = NewInitializationSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, pascalParserRULE_initializationSection)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(408)
		p.Match(pascalParserINITIALIZATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(409)
		p.Statements()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFinalizationSectionContext is an interface to support dynamic dispatch.
type IFinalizationSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FINALIZATION() antlr.TerminalNode
	Statements() IStatementsContext

	// IsFinalizationSectionContext differentiates from other interfaces.
	IsFinalizationSectionContext()
}

type FinalizationSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinalizationSectionContext() *FinalizationSectionContext {
	var p = new(FinalizationSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_finalizationSection
	return p
}

func InitEmptyFinalizationSectionContext(p *FinalizationSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_finalizationSection
}

func (*FinalizationSectionContext) IsFinalizationSectionContext() {}

func NewFinalizationSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinalizationSectionContext {
	var p = new(FinalizationSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_finalizationSection

	return p
}

func (s *FinalizationSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *FinalizationSectionContext) FINALIZATION() antlr.TerminalNode {
	return s.GetToken(pascalParserFINALIZATION, 0)
}

func (s *FinalizationSectionContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *FinalizationSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinalizationSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinalizationSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFinalizationSection(s)
	}
}

func (s *FinalizationSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFinalizationSection(s)
	}
}

func (s *FinalizationSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFinalizationSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FinalizationSection() (localctx IFinalizationSectionContext) {
	localctx = NewFinalizationSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, pascalParserRULE_finalizationSection)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(411)
		p.Match(pascalParserFINALIZATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(412)
		p.Statements()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierPart() []IIdentifierPartContext
	IdentifierPart(i int) IIdentifierPartContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) AllIdentifierPart() []IIdentifierPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierPartContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierPartContext); ok {
			tst[i] = t.(IIdentifierPartContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierContext) IdentifierPart(i int) IIdentifierPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierPartContext)
}

func (s *IdentifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDOT)
}

func (s *IdentifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, i)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, pascalParserRULE_identifier)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(414)
		p.IdentifierPart()
	}
	p.SetState(419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(415)
				p.Match(pascalParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(416)
				p.IdentifierPart()
			}

		}
		p.SetState(421)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierPartContext is an interface to support dynamic dispatch.
type IIdentifierPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENT() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	READ() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	GenericTemplate() IGenericTemplateContext

	// IsIdentifierPartContext differentiates from other interfaces.
	IsIdentifierPartContext()
}

type IdentifierPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierPartContext() *IdentifierPartContext {
	var p = new(IdentifierPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifierPart
	return p
}

func InitEmptyIdentifierPartContext(p *IdentifierPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifierPart
}

func (*IdentifierPartContext) IsIdentifierPartContext() {}

func NewIdentifierPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierPartContext {
	var p = new(IdentifierPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_identifierPart

	return p
}

func (s *IdentifierPartContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierPartContext) IDENT() antlr.TerminalNode {
	return s.GetToken(pascalParserIDENT, 0)
}

func (s *IdentifierPartContext) INDEX() antlr.TerminalNode {
	return s.GetToken(pascalParserINDEX, 0)
}

func (s *IdentifierPartContext) READ() antlr.TerminalNode {
	return s.GetToken(pascalParserREAD, 0)
}

func (s *IdentifierPartContext) WRITE() antlr.TerminalNode {
	return s.GetToken(pascalParserWRITE, 0)
}

func (s *IdentifierPartContext) GenericTemplate() IGenericTemplateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericTemplateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericTemplateContext)
}

func (s *IdentifierPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterIdentifierPart(s)
	}
}

func (s *IdentifierPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitIdentifierPart(s)
	}
}

func (s *IdentifierPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitIdentifierPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) IdentifierPart() (localctx IIdentifierPartContext) {
	localctx = NewIdentifierPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, pascalParserRULE_identifierPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(422)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-86)) & ^0x3f) == 0 && ((int64(1)<<(_la-86))&1099511627787) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(424)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(423)
			p.GenericTemplate()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceBlockContext is an interface to support dynamic dispatch.
type IInterfaceBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLabelDeclarationPart() []ILabelDeclarationPartContext
	LabelDeclarationPart(i int) ILabelDeclarationPartContext
	AllConstantDefinitionPart() []IConstantDefinitionPartContext
	ConstantDefinitionPart(i int) IConstantDefinitionPartContext
	AllResourceDefinitionPart() []IResourceDefinitionPartContext
	ResourceDefinitionPart(i int) IResourceDefinitionPartContext
	AllTypeDefinitionPart() []ITypeDefinitionPartContext
	TypeDefinitionPart(i int) ITypeDefinitionPartContext
	AllVariableDeclarationPart() []IVariableDeclarationPartContext
	VariableDeclarationPart(i int) IVariableDeclarationPartContext
	AllProcedureOrFunctionHeader() []IProcedureOrFunctionHeaderContext
	ProcedureOrFunctionHeader(i int) IProcedureOrFunctionHeaderContext
	AllErrorInterfaceBlockPart() []IErrorInterfaceBlockPartContext
	ErrorInterfaceBlockPart(i int) IErrorInterfaceBlockPartContext

	// IsInterfaceBlockContext differentiates from other interfaces.
	IsInterfaceBlockContext()
}

type InterfaceBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceBlockContext() *InterfaceBlockContext {
	var p = new(InterfaceBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceBlock
	return p
}

func InitEmptyInterfaceBlockContext(p *InterfaceBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceBlock
}

func (*InterfaceBlockContext) IsInterfaceBlockContext() {}

func NewInterfaceBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceBlockContext {
	var p = new(InterfaceBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceBlock

	return p
}

func (s *InterfaceBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceBlockContext) AllLabelDeclarationPart() []ILabelDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]ILabelDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelDeclarationPartContext); ok {
			tst[i] = t.(ILabelDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) LabelDeclarationPart(i int) ILabelDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelDeclarationPartContext)
}

func (s *InterfaceBlockContext) AllConstantDefinitionPart() []IConstantDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IConstantDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantDefinitionPartContext); ok {
			tst[i] = t.(IConstantDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) ConstantDefinitionPart(i int) IConstantDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *InterfaceBlockContext) AllResourceDefinitionPart() []IResourceDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResourceDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IResourceDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResourceDefinitionPartContext); ok {
			tst[i] = t.(IResourceDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) ResourceDefinitionPart(i int) IResourceDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceDefinitionPartContext)
}

func (s *InterfaceBlockContext) AllTypeDefinitionPart() []ITypeDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]ITypeDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeDefinitionPartContext); ok {
			tst[i] = t.(ITypeDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) TypeDefinitionPart(i int) ITypeDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionPartContext)
}

func (s *InterfaceBlockContext) AllVariableDeclarationPart() []IVariableDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationPartContext); ok {
			tst[i] = t.(IVariableDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) VariableDeclarationPart(i int) IVariableDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationPartContext)
}

func (s *InterfaceBlockContext) AllProcedureOrFunctionHeader() []IProcedureOrFunctionHeaderContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			len++
		}
	}

	tst := make([]IProcedureOrFunctionHeaderContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			tst[i] = t.(IProcedureOrFunctionHeaderContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) ProcedureOrFunctionHeader(i int) IProcedureOrFunctionHeaderContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderContext)
}

func (s *InterfaceBlockContext) AllErrorInterfaceBlockPart() []IErrorInterfaceBlockPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IErrorInterfaceBlockPartContext); ok {
			len++
		}
	}

	tst := make([]IErrorInterfaceBlockPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IErrorInterfaceBlockPartContext); ok {
			tst[i] = t.(IErrorInterfaceBlockPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) ErrorInterfaceBlockPart(i int) IErrorInterfaceBlockPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorInterfaceBlockPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorInterfaceBlockPartContext)
}

func (s *InterfaceBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceBlock(s)
	}
}

func (s *InterfaceBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceBlock(s)
	}
}

func (s *InterfaceBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceBlock() (localctx IInterfaceBlockContext) {
	localctx = NewInterfaceBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, pascalParserRULE_interfaceBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2305848508936356352) != 0) || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&3758096385) != 0) {
		p.SetState(433)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(426)
				p.LabelDeclarationPart()
			}

		case 2:
			{
				p.SetState(427)
				p.ConstantDefinitionPart()
			}

		case 3:
			{
				p.SetState(428)
				p.ResourceDefinitionPart()
			}

		case 4:
			{
				p.SetState(429)
				p.TypeDefinitionPart()
			}

		case 5:
			{
				p.SetState(430)
				p.VariableDeclarationPart()
			}

		case 6:
			{
				p.SetState(431)
				p.ProcedureOrFunctionHeader()
			}

		case 7:
			{
				p.SetState(432)
				p.ErrorInterfaceBlockPart()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(437)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorInterfaceBlockPartContext is an interface to support dynamic dispatch.
type IErrorInterfaceBlockPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE() antlr.TerminalNode
	AllIMPLEMENTATION() []antlr.TerminalNode
	IMPLEMENTATION(i int) antlr.TerminalNode
	AllINITIALIZATION() []antlr.TerminalNode
	INITIALIZATION(i int) antlr.TerminalNode
	AllFINALIZATION() []antlr.TerminalNode
	FINALIZATION(i int) antlr.TerminalNode
	AllEND() []antlr.TerminalNode
	END(i int) antlr.TerminalNode

	// IsErrorInterfaceBlockPartContext differentiates from other interfaces.
	IsErrorInterfaceBlockPartContext()
}

type ErrorInterfaceBlockPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorInterfaceBlockPartContext() *ErrorInterfaceBlockPartContext {
	var p = new(ErrorInterfaceBlockPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorInterfaceBlockPart
	return p
}

func InitEmptyErrorInterfaceBlockPartContext(p *ErrorInterfaceBlockPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorInterfaceBlockPart
}

func (*ErrorInterfaceBlockPartContext) IsErrorInterfaceBlockPartContext() {}

func NewErrorInterfaceBlockPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorInterfaceBlockPartContext {
	var p = new(ErrorInterfaceBlockPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_errorInterfaceBlockPart

	return p
}

func (s *ErrorInterfaceBlockPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorInterfaceBlockPartContext) TYPE() antlr.TerminalNode {
	return s.GetToken(pascalParserTYPE, 0)
}

func (s *ErrorInterfaceBlockPartContext) AllIMPLEMENTATION() []antlr.TerminalNode {
	return s.GetTokens(pascalParserIMPLEMENTATION)
}

func (s *ErrorInterfaceBlockPartContext) IMPLEMENTATION(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserIMPLEMENTATION, i)
}

func (s *ErrorInterfaceBlockPartContext) AllINITIALIZATION() []antlr.TerminalNode {
	return s.GetTokens(pascalParserINITIALIZATION)
}

func (s *ErrorInterfaceBlockPartContext) INITIALIZATION(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserINITIALIZATION, i)
}

func (s *ErrorInterfaceBlockPartContext) AllFINALIZATION() []antlr.TerminalNode {
	return s.GetTokens(pascalParserFINALIZATION)
}

func (s *ErrorInterfaceBlockPartContext) FINALIZATION(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserFINALIZATION, i)
}

func (s *ErrorInterfaceBlockPartContext) AllEND() []antlr.TerminalNode {
	return s.GetTokens(pascalParserEND)
}

func (s *ErrorInterfaceBlockPartContext) END(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserEND, i)
}

func (s *ErrorInterfaceBlockPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorInterfaceBlockPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorInterfaceBlockPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterErrorInterfaceBlockPart(s)
	}
}

func (s *ErrorInterfaceBlockPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitErrorInterfaceBlockPart(s)
	}
}

func (s *ErrorInterfaceBlockPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitErrorInterfaceBlockPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ErrorInterfaceBlockPart() (localctx IErrorInterfaceBlockPartContext) {
	localctx = NewErrorInterfaceBlockPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, pascalParserRULE_errorInterfaceBlockPart)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(438)
		p.Match(pascalParserTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(440)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(439)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || _la == pascalParserEND || ((int64((_la-75)) & ^0x3f) == 0 && ((int64(1)<<(_la-75))&1572865) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(442)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImplementationBlockContext is an interface to support dynamic dispatch.
type IImplementationBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLabelDeclarationPart() []ILabelDeclarationPartContext
	LabelDeclarationPart(i int) ILabelDeclarationPartContext
	AllConstantDefinitionPart() []IConstantDefinitionPartContext
	ConstantDefinitionPart(i int) IConstantDefinitionPartContext
	AllResourceDefinitionPart() []IResourceDefinitionPartContext
	ResourceDefinitionPart(i int) IResourceDefinitionPartContext
	AllTypeDefinitionPart() []ITypeDefinitionPartContext
	TypeDefinitionPart(i int) ITypeDefinitionPartContext
	AllVariableDeclarationPart() []IVariableDeclarationPartContext
	VariableDeclarationPart(i int) IVariableDeclarationPartContext
	AllProcedureOrFunctionDeclaration() []IProcedureOrFunctionDeclarationContext
	ProcedureOrFunctionDeclaration(i int) IProcedureOrFunctionDeclarationContext
	AllProcedureOrFunctionHeader() []IProcedureOrFunctionHeaderContext
	ProcedureOrFunctionHeader(i int) IProcedureOrFunctionHeaderContext
	AllFORWARD() []antlr.TerminalNode
	FORWARD(i int) antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AllClassOperatorDeclaration() []IClassOperatorDeclarationContext
	ClassOperatorDeclaration(i int) IClassOperatorDeclarationContext

	// IsImplementationBlockContext differentiates from other interfaces.
	IsImplementationBlockContext()
}

type ImplementationBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplementationBlockContext() *ImplementationBlockContext {
	var p = new(ImplementationBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_implementationBlock
	return p
}

func InitEmptyImplementationBlockContext(p *ImplementationBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_implementationBlock
}

func (*ImplementationBlockContext) IsImplementationBlockContext() {}

func NewImplementationBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplementationBlockContext {
	var p = new(ImplementationBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_implementationBlock

	return p
}

func (s *ImplementationBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplementationBlockContext) AllLabelDeclarationPart() []ILabelDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]ILabelDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelDeclarationPartContext); ok {
			tst[i] = t.(ILabelDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) LabelDeclarationPart(i int) ILabelDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelDeclarationPartContext)
}

func (s *ImplementationBlockContext) AllConstantDefinitionPart() []IConstantDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IConstantDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantDefinitionPartContext); ok {
			tst[i] = t.(IConstantDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) ConstantDefinitionPart(i int) IConstantDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *ImplementationBlockContext) AllResourceDefinitionPart() []IResourceDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResourceDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IResourceDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResourceDefinitionPartContext); ok {
			tst[i] = t.(IResourceDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) ResourceDefinitionPart(i int) IResourceDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceDefinitionPartContext)
}

func (s *ImplementationBlockContext) AllTypeDefinitionPart() []ITypeDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]ITypeDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeDefinitionPartContext); ok {
			tst[i] = t.(ITypeDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) TypeDefinitionPart(i int) ITypeDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionPartContext)
}

func (s *ImplementationBlockContext) AllVariableDeclarationPart() []IVariableDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationPartContext); ok {
			tst[i] = t.(IVariableDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) VariableDeclarationPart(i int) IVariableDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationPartContext)
}

func (s *ImplementationBlockContext) AllProcedureOrFunctionDeclaration() []IProcedureOrFunctionDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IProcedureOrFunctionDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			tst[i] = t.(IProcedureOrFunctionDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) ProcedureOrFunctionDeclaration(i int) IProcedureOrFunctionDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionDeclarationContext)
}

func (s *ImplementationBlockContext) AllProcedureOrFunctionHeader() []IProcedureOrFunctionHeaderContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			len++
		}
	}

	tst := make([]IProcedureOrFunctionHeaderContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			tst[i] = t.(IProcedureOrFunctionHeaderContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) ProcedureOrFunctionHeader(i int) IProcedureOrFunctionHeaderContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderContext)
}

func (s *ImplementationBlockContext) AllFORWARD() []antlr.TerminalNode {
	return s.GetTokens(pascalParserFORWARD)
}

func (s *ImplementationBlockContext) FORWARD(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserFORWARD, i)
}

func (s *ImplementationBlockContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ImplementationBlockContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ImplementationBlockContext) AllClassOperatorDeclaration() []IClassOperatorDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassOperatorDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassOperatorDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassOperatorDeclarationContext); ok {
			tst[i] = t.(IClassOperatorDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) ClassOperatorDeclaration(i int) IClassOperatorDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOperatorDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOperatorDeclarationContext)
}

func (s *ImplementationBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplementationBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplementationBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterImplementationBlock(s)
	}
}

func (s *ImplementationBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitImplementationBlock(s)
	}
}

func (s *ImplementationBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitImplementationBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ImplementationBlock() (localctx IImplementationBlockContext) {
	localctx = NewImplementationBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, pascalParserRULE_implementationBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(457)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2305848508936356352) != 0) || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&3758096385) != 0) {
		p.SetState(455)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(444)
				p.LabelDeclarationPart()
			}

		case 2:
			{
				p.SetState(445)
				p.ConstantDefinitionPart()
			}

		case 3:
			{
				p.SetState(446)
				p.ResourceDefinitionPart()
			}

		case 4:
			{
				p.SetState(447)
				p.TypeDefinitionPart()
			}

		case 5:
			{
				p.SetState(448)
				p.VariableDeclarationPart()
			}

		case 6:
			{
				p.SetState(449)
				p.ProcedureOrFunctionDeclaration()
			}

		case 7:
			{
				p.SetState(450)
				p.ProcedureOrFunctionHeader()
			}
			{
				p.SetState(451)
				p.Match(pascalParserFORWARD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(452)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 8:
			{
				p.SetState(454)
				p.ClassOperatorDeclaration()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(459)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLabelDeclarationPart() []ILabelDeclarationPartContext
	LabelDeclarationPart(i int) ILabelDeclarationPartContext
	AllConstantDefinitionPart() []IConstantDefinitionPartContext
	ConstantDefinitionPart(i int) IConstantDefinitionPartContext
	AllVariableDeclarationPart() []IVariableDeclarationPartContext
	VariableDeclarationPart(i int) IVariableDeclarationPartContext
	AllProcedureOrFunctionDeclaration() []IProcedureOrFunctionDeclarationContext
	ProcedureOrFunctionDeclaration(i int) IProcedureOrFunctionDeclarationContext
	AllClassOperatorDeclaration() []IClassOperatorDeclarationContext
	ClassOperatorDeclaration(i int) IClassOperatorDeclarationContext

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) AllLabelDeclarationPart() []ILabelDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]ILabelDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelDeclarationPartContext); ok {
			tst[i] = t.(ILabelDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) LabelDeclarationPart(i int) ILabelDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelDeclarationPartContext)
}

func (s *BlockContext) AllConstantDefinitionPart() []IConstantDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IConstantDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantDefinitionPartContext); ok {
			tst[i] = t.(IConstantDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) ConstantDefinitionPart(i int) IConstantDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *BlockContext) AllVariableDeclarationPart() []IVariableDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationPartContext); ok {
			tst[i] = t.(IVariableDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) VariableDeclarationPart(i int) IVariableDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationPartContext)
}

func (s *BlockContext) AllProcedureOrFunctionDeclaration() []IProcedureOrFunctionDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IProcedureOrFunctionDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			tst[i] = t.(IProcedureOrFunctionDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) ProcedureOrFunctionDeclaration(i int) IProcedureOrFunctionDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionDeclarationContext)
}

func (s *BlockContext) AllClassOperatorDeclaration() []IClassOperatorDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassOperatorDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassOperatorDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassOperatorDeclarationContext); ok {
			tst[i] = t.(IClassOperatorDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) ClassOperatorDeclaration(i int) IClassOperatorDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOperatorDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOperatorDeclarationContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (s *BlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, pascalParserRULE_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(467)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2305847409424728576) != 0) || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&1610612737) != 0) {
		p.SetState(465)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(460)
				p.LabelDeclarationPart()
			}

		case 2:
			{
				p.SetState(461)
				p.ConstantDefinitionPart()
			}

		case 3:
			{
				p.SetState(462)
				p.VariableDeclarationPart()
			}

		case 4:
			{
				p.SetState(463)
				p.ProcedureOrFunctionDeclaration()
			}

		case 5:
			{
				p.SetState(464)
				p.ClassOperatorDeclaration()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(469)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsesUnitsContext is an interface to support dynamic dispatch.
type IUsesUnitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USES() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	SEMI() antlr.TerminalNode

	// IsUsesUnitsContext differentiates from other interfaces.
	IsUsesUnitsContext()
}

type UsesUnitsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsesUnitsContext() *UsesUnitsContext {
	var p = new(UsesUnitsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_usesUnits
	return p
}

func InitEmptyUsesUnitsContext(p *UsesUnitsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_usesUnits
}

func (*UsesUnitsContext) IsUsesUnitsContext() {}

func NewUsesUnitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsesUnitsContext {
	var p = new(UsesUnitsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_usesUnits

	return p
}

func (s *UsesUnitsContext) GetParser() antlr.Parser { return s.parser }

func (s *UsesUnitsContext) USES() antlr.TerminalNode {
	return s.GetToken(pascalParserUSES, 0)
}

func (s *UsesUnitsContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *UsesUnitsContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *UsesUnitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsesUnitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsesUnitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUsesUnits(s)
	}
}

func (s *UsesUnitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUsesUnits(s)
	}
}

func (s *UsesUnitsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUsesUnits(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UsesUnits() (localctx IUsesUnitsContext) {
	localctx = NewUsesUnitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, pascalParserRULE_usesUnits)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(470)
		p.Match(pascalParserUSES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(471)
		p.IdentifierList()
	}
	{
		p.SetState(472)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelDeclarationPartContext is an interface to support dynamic dispatch.
type ILabelDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LABEL() antlr.TerminalNode
	AllLabel() []ILabelContext
	Label(i int) ILabelContext
	SEMI() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLabelDeclarationPartContext differentiates from other interfaces.
	IsLabelDeclarationPartContext()
}

type LabelDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelDeclarationPartContext() *LabelDeclarationPartContext {
	var p = new(LabelDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_labelDeclarationPart
	return p
}

func InitEmptyLabelDeclarationPartContext(p *LabelDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_labelDeclarationPart
}

func (*LabelDeclarationPartContext) IsLabelDeclarationPartContext() {}

func NewLabelDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelDeclarationPartContext {
	var p = new(LabelDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_labelDeclarationPart

	return p
}

func (s *LabelDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelDeclarationPartContext) LABEL() antlr.TerminalNode {
	return s.GetToken(pascalParserLABEL, 0)
}

func (s *LabelDeclarationPartContext) AllLabel() []ILabelContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelContext); ok {
			len++
		}
	}

	tst := make([]ILabelContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelContext); ok {
			tst[i] = t.(ILabelContext)
			i++
		}
	}

	return tst
}

func (s *LabelDeclarationPartContext) Label(i int) ILabelContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *LabelDeclarationPartContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *LabelDeclarationPartContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *LabelDeclarationPartContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *LabelDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterLabelDeclarationPart(s)
	}
}

func (s *LabelDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitLabelDeclarationPart(s)
	}
}

func (s *LabelDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitLabelDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) LabelDeclarationPart() (localctx ILabelDeclarationPartContext) {
	localctx = NewLabelDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, pascalParserRULE_labelDeclarationPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(474)
		p.Match(pascalParserLABEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(475)
		p.Label()
	}
	p.SetState(480)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(476)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(477)
			p.Label()
		}

		p.SetState(482)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(483)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelContext is an interface to support dynamic dispatch.
type ILabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedInteger() IUnsignedIntegerContext

	// IsLabelContext differentiates from other interfaces.
	IsLabelContext()
}

type LabelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelContext() *LabelContext {
	var p = new(LabelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_label
	return p
}

func InitEmptyLabelContext(p *LabelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_label
}

func (*LabelContext) IsLabelContext() {}

func NewLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelContext {
	var p = new(LabelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_label

	return p
}

func (s *LabelContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelContext) UnsignedInteger() IUnsignedIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerContext)
}

func (s *LabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterLabel(s)
	}
}

func (s *LabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitLabel(s)
	}
}

func (s *LabelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitLabel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Label() (localctx ILabelContext) {
	localctx = NewLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, pascalParserRULE_label)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(485)
		p.UnsignedInteger()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantDefinitionPartContext is an interface to support dynamic dispatch.
type IConstantDefinitionPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONST() antlr.TerminalNode
	AllConstantDefinition() []IConstantDefinitionContext
	ConstantDefinition(i int) IConstantDefinitionContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsConstantDefinitionPartContext differentiates from other interfaces.
	IsConstantDefinitionPartContext()
}

type ConstantDefinitionPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantDefinitionPartContext() *ConstantDefinitionPartContext {
	var p = new(ConstantDefinitionPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantDefinitionPart
	return p
}

func InitEmptyConstantDefinitionPartContext(p *ConstantDefinitionPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantDefinitionPart
}

func (*ConstantDefinitionPartContext) IsConstantDefinitionPartContext() {}

func NewConstantDefinitionPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantDefinitionPartContext {
	var p = new(ConstantDefinitionPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constantDefinitionPart

	return p
}

func (s *ConstantDefinitionPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantDefinitionPartContext) CONST() antlr.TerminalNode {
	return s.GetToken(pascalParserCONST, 0)
}

func (s *ConstantDefinitionPartContext) AllConstantDefinition() []IConstantDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IConstantDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantDefinitionContext); ok {
			tst[i] = t.(IConstantDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *ConstantDefinitionPartContext) ConstantDefinition(i int) IConstantDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionContext)
}

func (s *ConstantDefinitionPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ConstantDefinitionPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ConstantDefinitionPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantDefinitionPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantDefinitionPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstantDefinitionPart(s)
	}
}

func (s *ConstantDefinitionPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstantDefinitionPart(s)
	}
}

func (s *ConstantDefinitionPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstantDefinitionPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConstantDefinitionPart() (localctx IConstantDefinitionPartContext) {
	localctx = NewConstantDefinitionPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, pascalParserRULE_constantDefinitionPart)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(487)
		p.Match(pascalParserCONST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(491)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(488)
				p.ConstantDefinition()
			}
			{
				p.SetState(489)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(493)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantDefinitionContext is an interface to support dynamic dispatch.
type IConstantDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQUAL() antlr.TerminalNode
	Constant() IConstantContext
	COLON() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	DeprecatedHint() IDeprecatedHintContext
	ArrayType() IArrayTypeContext
	SetType() ISetTypeContext

	// IsConstantDefinitionContext differentiates from other interfaces.
	IsConstantDefinitionContext()
}

type ConstantDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantDefinitionContext() *ConstantDefinitionContext {
	var p = new(ConstantDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantDefinition
	return p
}

func InitEmptyConstantDefinitionContext(p *ConstantDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantDefinition
}

func (*ConstantDefinitionContext) IsConstantDefinitionContext() {}

func NewConstantDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantDefinitionContext {
	var p = new(ConstantDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constantDefinition

	return p
}

func (s *ConstantDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConstantDefinitionContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *ConstantDefinitionContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantDefinitionContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *ConstantDefinitionContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ConstantDefinitionContext) DeprecatedHint() IDeprecatedHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeprecatedHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeprecatedHintContext)
}

func (s *ConstantDefinitionContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *ConstantDefinitionContext) SetType() ISetTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetTypeContext)
}

func (s *ConstantDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstantDefinition(s)
	}
}

func (s *ConstantDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstantDefinition(s)
	}
}

func (s *ConstantDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstantDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConstantDefinition() (localctx IConstantDefinitionContext) {
	localctx = NewConstantDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, pascalParserRULE_constantDefinition)
	var _la int

	p.SetState(521)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(495)
			p.Identifier()
		}
		p.SetState(498)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserCOLON {
			{
				p.SetState(496)
				p.Match(pascalParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(497)
				p.TypeIdentifier()
			}

		}
		{
			p.SetState(500)
			p.Match(pascalParserEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(501)
			p.Constant()
		}
		p.SetState(503)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserDEPRECATED {
			{
				p.SetState(502)
				p.DeprecatedHint()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(505)
			p.Identifier()
		}
		{
			p.SetState(506)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(507)
			p.ArrayType()
		}
		{
			p.SetState(508)
			p.Match(pascalParserEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(509)
			p.Constant()
		}
		p.SetState(511)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserDEPRECATED {
			{
				p.SetState(510)
				p.DeprecatedHint()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(513)
			p.Identifier()
		}
		{
			p.SetState(514)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(515)
			p.SetType()
		}
		{
			p.SetState(516)
			p.Match(pascalParserEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(517)
			p.Constant()
		}
		p.SetState(519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserDEPRECATED {
			{
				p.SetState(518)
				p.DeprecatedHint()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantChrContext is an interface to support dynamic dispatch.
type IConstantChrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHR() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	UnsignedInteger() IUnsignedIntegerContext
	RPAREN() antlr.TerminalNode

	// IsConstantChrContext differentiates from other interfaces.
	IsConstantChrContext()
}

type ConstantChrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantChrContext() *ConstantChrContext {
	var p = new(ConstantChrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantChr
	return p
}

func InitEmptyConstantChrContext(p *ConstantChrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantChr
}

func (*ConstantChrContext) IsConstantChrContext() {}

func NewConstantChrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantChrContext {
	var p = new(ConstantChrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constantChr

	return p
}

func (s *ConstantChrContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantChrContext) CHR() antlr.TerminalNode {
	return s.GetToken(pascalParserCHR, 0)
}

func (s *ConstantChrContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ConstantChrContext) UnsignedInteger() IUnsignedIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerContext)
}

func (s *ConstantChrContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ConstantChrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantChrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantChrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstantChr(s)
	}
}

func (s *ConstantChrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstantChr(s)
	}
}

func (s *ConstantChrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstantChr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConstantChr() (localctx IConstantChrContext) {
	localctx = NewConstantChrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, pascalParserRULE_constantChr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(523)
		p.Match(pascalParserCHR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(524)
		p.Match(pascalParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(525)
		p.UnsignedInteger()
	}
	{
		p.SetState(526)
		p.Match(pascalParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHexConstantContext is an interface to support dynamic dispatch.
type IHexConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HEX_LITERAL() antlr.TerminalNode

	// IsHexConstantContext differentiates from other interfaces.
	IsHexConstantContext()
}

type HexConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexConstantContext() *HexConstantContext {
	var p = new(HexConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_hexConstant
	return p
}

func InitEmptyHexConstantContext(p *HexConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_hexConstant
}

func (*HexConstantContext) IsHexConstantContext() {}

func NewHexConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexConstantContext {
	var p = new(HexConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_hexConstant

	return p
}

func (s *HexConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *HexConstantContext) HEX_LITERAL() antlr.TerminalNode {
	return s.GetToken(pascalParserHEX_LITERAL, 0)
}

func (s *HexConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterHexConstant(s)
	}
}

func (s *HexConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitHexConstant(s)
	}
}

func (s *HexConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitHexConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) HexConstant() (localctx IHexConstantContext) {
	localctx = NewHexConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, pascalParserRULE_hexConstant)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(528)
		p.Match(pascalParserHEX_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedConstant() IUnsignedConstantContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	ScalarType() IScalarTypeContext
	AllArrayConstant() []IArrayConstantContext
	ArrayConstant(i int) IArrayConstantContext
	AllPLUS() []antlr.TerminalNode
	PLUS(i int) antlr.TerminalNode
	RecordConstant() IRecordConstantContext
	SimpleExpression() ISimpleExpressionContext

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constant
	return p
}

func InitEmptyConstantContext(p *ConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constant
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) UnsignedConstant() IUnsignedConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedConstantContext)
}

func (s *ConstantContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ConstantContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConstantContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ConstantContext) AllArrayConstant() []IArrayConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayConstantContext); ok {
			len++
		}
	}

	tst := make([]IArrayConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayConstantContext); ok {
			tst[i] = t.(IArrayConstantContext)
			i++
		}
	}

	return tst
}

func (s *ConstantContext) ArrayConstant(i int) IArrayConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayConstantContext)
}

func (s *ConstantContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPLUS)
}

func (s *ConstantContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPLUS, i)
}

func (s *ConstantContext) RecordConstant() IRecordConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordConstantContext)
}

func (s *ConstantContext) SimpleExpression() ISimpleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExpressionContext)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstant(s)
	}
}

func (s *ConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, pascalParserRULE_constant)
	var _la int

	p.SetState(546)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(530)
			p.UnsignedConstant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(531)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(532)
			p.ScalarType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(533)
			p.ArrayConstant()
		}
		p.SetState(541)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == pascalParserPLUS {
			{
				p.SetState(534)
				p.Match(pascalParserPLUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(537)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case pascalParserLPAREN, pascalParserLBRACK:
				{
					p.SetState(535)
					p.ArrayConstant()
				}

			case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
				{
					p.SetState(536)
					p.Identifier()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(543)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(544)
			p.RecordConstant()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(545)
			p.SimpleExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayConstantContext is an interface to support dynamic dispatch.
type IArrayConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	RBRACK() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsArrayConstantContext differentiates from other interfaces.
	IsArrayConstantContext()
}

type ArrayConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayConstantContext() *ArrayConstantContext {
	var p = new(ArrayConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_arrayConstant
	return p
}

func InitEmptyArrayConstantContext(p *ArrayConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_arrayConstant
}

func (*ArrayConstantContext) IsArrayConstantContext() {}

func NewArrayConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayConstantContext {
	var p = new(ArrayConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_arrayConstant

	return p
}

func (s *ArrayConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayConstantContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *ArrayConstantContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *ArrayConstantContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ArrayConstantContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *ArrayConstantContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ArrayConstantContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ArrayConstantContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ArrayConstantContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ArrayConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterArrayConstant(s)
	}
}

func (s *ArrayConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitArrayConstant(s)
	}
}

func (s *ArrayConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitArrayConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ArrayConstant() (localctx IArrayConstantContext) {
	localctx = NewArrayConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, pascalParserRULE_arrayConstant)
	var _la int

	p.SetState(570)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserLBRACK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(548)
			p.Match(pascalParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(549)
			p.Constant()
		}
		p.SetState(554)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == pascalParserCOMMA {
			{
				p.SetState(550)
				p.Match(pascalParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(551)
				p.Constant()
			}

			p.SetState(556)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(557)
			p.Match(pascalParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case pascalParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(559)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(560)
			p.Constant()
		}
		p.SetState(565)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == pascalParserCOMMA {
			{
				p.SetState(561)
				p.Match(pascalParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(562)
				p.Constant()
			}

			p.SetState(567)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(568)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordConstantContext is an interface to support dynamic dispatch.
type IRecordConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllRecordField() []IRecordFieldContext
	RecordField(i int) IRecordFieldContext
	RPAREN() antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsRecordConstantContext differentiates from other interfaces.
	IsRecordConstantContext()
}

type RecordConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordConstantContext() *RecordConstantContext {
	var p = new(RecordConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordConstant
	return p
}

func InitEmptyRecordConstantContext(p *RecordConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordConstant
}

func (*RecordConstantContext) IsRecordConstantContext() {}

func NewRecordConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordConstantContext {
	var p = new(RecordConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordConstant

	return p
}

func (s *RecordConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordConstantContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *RecordConstantContext) AllRecordField() []IRecordFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordFieldContext); ok {
			len++
		}
	}

	tst := make([]IRecordFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordFieldContext); ok {
			tst[i] = t.(IRecordFieldContext)
			i++
		}
	}

	return tst
}

func (s *RecordConstantContext) RecordField(i int) IRecordFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordFieldContext)
}

func (s *RecordConstantContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *RecordConstantContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *RecordConstantContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *RecordConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordConstant(s)
	}
}

func (s *RecordConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordConstant(s)
	}
}

func (s *RecordConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordConstant() (localctx IRecordConstantContext) {
	localctx = NewRecordConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, pascalParserRULE_recordConstant)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(572)
		p.Match(pascalParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(573)
		p.RecordField()
	}
	p.SetState(578)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserSEMI {
		{
			p.SetState(574)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(575)
			p.RecordField()
		}

		p.SetState(580)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(581)
		p.Match(pascalParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordFieldContext is an interface to support dynamic dispatch.
type IRecordFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	DOTDOT() antlr.TerminalNode
	ArrayConstant() IArrayConstantContext

	// IsRecordFieldContext differentiates from other interfaces.
	IsRecordFieldContext()
}

type RecordFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordFieldContext() *RecordFieldContext {
	var p = new(RecordFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordField
	return p
}

func InitEmptyRecordFieldContext(p *RecordFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordField
}

func (*RecordFieldContext) IsRecordFieldContext() {}

func NewRecordFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordFieldContext {
	var p = new(RecordFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordField

	return p
}

func (s *RecordFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordFieldContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RecordFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *RecordFieldContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *RecordFieldContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *RecordFieldContext) DOTDOT() antlr.TerminalNode {
	return s.GetToken(pascalParserDOTDOT, 0)
}

func (s *RecordFieldContext) ArrayConstant() IArrayConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayConstantContext)
}

func (s *RecordFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordField(s)
	}
}

func (s *RecordFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordField(s)
	}
}

func (s *RecordFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordField() (localctx IRecordFieldContext) {
	localctx = NewRecordFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, pascalParserRULE_recordField)
	p.SetState(597)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(583)
			p.Identifier()
		}
		{
			p.SetState(584)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(585)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(587)
			p.Identifier()
		}
		{
			p.SetState(588)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(589)
			p.Constant()
		}
		{
			p.SetState(590)
			p.Match(pascalParserDOTDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(591)
			p.Constant()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(593)
			p.Identifier()
		}
		{
			p.SetState(594)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(595)
			p.ArrayConstant()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedNumberContext is an interface to support dynamic dispatch.
type IUnsignedNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedInteger() IUnsignedIntegerContext
	UnsignedReal() IUnsignedRealContext

	// IsUnsignedNumberContext differentiates from other interfaces.
	IsUnsignedNumberContext()
}

type UnsignedNumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedNumberContext() *UnsignedNumberContext {
	var p = new(UnsignedNumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedNumber
	return p
}

func InitEmptyUnsignedNumberContext(p *UnsignedNumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedNumber
}

func (*UnsignedNumberContext) IsUnsignedNumberContext() {}

func NewUnsignedNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedNumberContext {
	var p = new(UnsignedNumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unsignedNumber

	return p
}

func (s *UnsignedNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedNumberContext) UnsignedInteger() IUnsignedIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerContext)
}

func (s *UnsignedNumberContext) UnsignedReal() IUnsignedRealContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedRealContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedRealContext)
}

func (s *UnsignedNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnsignedNumber(s)
	}
}

func (s *UnsignedNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnsignedNumber(s)
	}
}

func (s *UnsignedNumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnsignedNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnsignedNumber() (localctx IUnsignedNumberContext) {
	localctx = NewUnsignedNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, pascalParserRULE_unsignedNumber)
	p.SetState(601)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserNUM_INT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(599)
			p.UnsignedInteger()
		}

	case pascalParserNUM_REAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(600)
			p.UnsignedReal()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedIntegerContext is an interface to support dynamic dispatch.
type IUnsignedIntegerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUM_INT() antlr.TerminalNode

	// IsUnsignedIntegerContext differentiates from other interfaces.
	IsUnsignedIntegerContext()
}

type UnsignedIntegerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedIntegerContext() *UnsignedIntegerContext {
	var p = new(UnsignedIntegerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedInteger
	return p
}

func InitEmptyUnsignedIntegerContext(p *UnsignedIntegerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedInteger
}

func (*UnsignedIntegerContext) IsUnsignedIntegerContext() {}

func NewUnsignedIntegerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedIntegerContext {
	var p = new(UnsignedIntegerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unsignedInteger

	return p
}

func (s *UnsignedIntegerContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedIntegerContext) NUM_INT() antlr.TerminalNode {
	return s.GetToken(pascalParserNUM_INT, 0)
}

func (s *UnsignedIntegerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedIntegerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedIntegerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnsignedInteger(s)
	}
}

func (s *UnsignedIntegerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnsignedInteger(s)
	}
}

func (s *UnsignedIntegerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnsignedInteger(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnsignedInteger() (localctx IUnsignedIntegerContext) {
	localctx = NewUnsignedIntegerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, pascalParserRULE_unsignedInteger)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(603)
		p.Match(pascalParserNUM_INT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedRealContext is an interface to support dynamic dispatch.
type IUnsignedRealContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUM_REAL() antlr.TerminalNode

	// IsUnsignedRealContext differentiates from other interfaces.
	IsUnsignedRealContext()
}

type UnsignedRealContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedRealContext() *UnsignedRealContext {
	var p = new(UnsignedRealContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedReal
	return p
}

func InitEmptyUnsignedRealContext(p *UnsignedRealContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedReal
}

func (*UnsignedRealContext) IsUnsignedRealContext() {}

func NewUnsignedRealContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedRealContext {
	var p = new(UnsignedRealContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unsignedReal

	return p
}

func (s *UnsignedRealContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedRealContext) NUM_REAL() antlr.TerminalNode {
	return s.GetToken(pascalParserNUM_REAL, 0)
}

func (s *UnsignedRealContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedRealContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedRealContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnsignedReal(s)
	}
}

func (s *UnsignedRealContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnsignedReal(s)
	}
}

func (s *UnsignedRealContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnsignedReal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnsignedReal() (localctx IUnsignedRealContext) {
	localctx = NewUnsignedRealContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, pascalParserRULE_unsignedReal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(605)
		p.Match(pascalParserNUM_REAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignContext is an interface to support dynamic dispatch.
type ISignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsSignContext differentiates from other interfaces.
	IsSignContext()
}

type SignContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignContext() *SignContext {
	var p = new(SignContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_sign
	return p
}

func InitEmptySignContext(p *SignContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_sign
}

func (*SignContext) IsSignContext() {}

func NewSignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignContext {
	var p = new(SignContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_sign

	return p
}

func (s *SignContext) GetParser() antlr.Parser { return s.parser }

func (s *SignContext) PLUS() antlr.TerminalNode {
	return s.GetToken(pascalParserPLUS, 0)
}

func (s *SignContext) MINUS() antlr.TerminalNode {
	return s.GetToken(pascalParserMINUS, 0)
}

func (s *SignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSign(s)
	}
}

func (s *SignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSign(s)
	}
}

func (s *SignContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSign(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Sign() (localctx ISignContext) {
	localctx = NewSignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, pascalParserRULE_sign)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(607)
		_la = p.GetTokenStream().LA(1)

		if !(_la == pascalParserPLUS || _la == pascalParserMINUS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_Context is an interface to support dynamic dispatch.
type IBool_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBool_Context differentiates from other interfaces.
	IsBool_Context()
}

type Bool_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_Context() *Bool_Context {
	var p = new(Bool_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_bool_
	return p
}

func InitEmptyBool_Context(p *Bool_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_bool_
}

func (*Bool_Context) IsBool_Context() {}

func NewBool_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_Context {
	var p = new(Bool_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_bool_

	return p
}

func (s *Bool_Context) GetParser() antlr.Parser { return s.parser }

func (s *Bool_Context) TRUE() antlr.TerminalNode {
	return s.GetToken(pascalParserTRUE, 0)
}

func (s *Bool_Context) FALSE() antlr.TerminalNode {
	return s.GetToken(pascalParserFALSE, 0)
}

func (s *Bool_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterBool_(s)
	}
}

func (s *Bool_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitBool_(s)
	}
}

func (s *Bool_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitBool_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Bool_() (localctx IBool_Context) {
	localctx = NewBool_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, pascalParserRULE_bool_)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(609)
		_la = p.GetTokenStream().LA(1)

		if !(_la == pascalParserTRUE || _la == pascalParserFALSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringContext is an interface to support dynamic dispatch.
type IStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	AllSTRING_CROSSHATCH_LITERAL() []antlr.TerminalNode
	STRING_CROSSHATCH_LITERAL(i int) antlr.TerminalNode

	// IsStringContext differentiates from other interfaces.
	IsStringContext()
}

type StringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringContext() *StringContext {
	var p = new(StringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_string
	return p
}

func InitEmptyStringContext(p *StringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_string
}

func (*StringContext) IsStringContext() {}

func NewStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringContext {
	var p = new(StringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_string

	return p
}

func (s *StringContext) GetParser() antlr.Parser { return s.parser }

func (s *StringContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTRING_LITERAL)
}

func (s *StringContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTRING_LITERAL, i)
}

func (s *StringContext) AllSTRING_CROSSHATCH_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTRING_CROSSHATCH_LITERAL)
}

func (s *StringContext) STRING_CROSSHATCH_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTRING_CROSSHATCH_LITERAL, i)
}

func (s *StringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterString(s)
	}
}

func (s *StringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitString(s)
	}
}

func (s *StringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) String_() (localctx IStringContext) {
	localctx = NewStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, pascalParserRULE_string)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(612)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(611)
				_la = p.GetTokenStream().LA(1)

				if !(_la == pascalParserSTRING_LITERAL || _la == pascalParserSTRING_CROSSHATCH_LITERAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(614)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringExpressionContext is an interface to support dynamic dispatch.
type IStringExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllString_() []IStringContext
	String_(i int) IStringContext
	AllPLUS() []antlr.TerminalNode
	PLUS(i int) antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsStringExpressionContext differentiates from other interfaces.
	IsStringExpressionContext()
}

type StringExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringExpressionContext() *StringExpressionContext {
	var p = new(StringExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_stringExpression
	return p
}

func InitEmptyStringExpressionContext(p *StringExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_stringExpression
}

func (*StringExpressionContext) IsStringExpressionContext() {}

func NewStringExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringExpressionContext {
	var p = new(StringExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_stringExpression

	return p
}

func (s *StringExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *StringExpressionContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *StringExpressionContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *StringExpressionContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPLUS)
}

func (s *StringExpressionContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPLUS, i)
}

func (s *StringExpressionContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *StringExpressionContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStringExpression(s)
	}
}

func (s *StringExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStringExpression(s)
	}
}

func (s *StringExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStringExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) StringExpression() (localctx IStringExpressionContext) {
	localctx = NewStringExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, pascalParserRULE_stringExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(616)
		p.String_()
	}
	p.SetState(624)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserPLUS {
		{
			p.SetState(617)
			p.Match(pascalParserPLUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(620)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case pascalParserSTRING_LITERAL, pascalParserSTRING_CROSSHATCH_LITERAL:
			{
				p.SetState(618)
				p.String_()
			}

		case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
			{
				p.SetState(619)
				p.Identifier()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(626)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceDefinitionPartContext is an interface to support dynamic dispatch.
type IResourceDefinitionPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESOURCESTRING() antlr.TerminalNode
	AllResourceDefinition() []IResourceDefinitionContext
	ResourceDefinition(i int) IResourceDefinitionContext

	// IsResourceDefinitionPartContext differentiates from other interfaces.
	IsResourceDefinitionPartContext()
}

type ResourceDefinitionPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceDefinitionPartContext() *ResourceDefinitionPartContext {
	var p = new(ResourceDefinitionPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resourceDefinitionPart
	return p
}

func InitEmptyResourceDefinitionPartContext(p *ResourceDefinitionPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resourceDefinitionPart
}

func (*ResourceDefinitionPartContext) IsResourceDefinitionPartContext() {}

func NewResourceDefinitionPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceDefinitionPartContext {
	var p = new(ResourceDefinitionPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_resourceDefinitionPart

	return p
}

func (s *ResourceDefinitionPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceDefinitionPartContext) RESOURCESTRING() antlr.TerminalNode {
	return s.GetToken(pascalParserRESOURCESTRING, 0)
}

func (s *ResourceDefinitionPartContext) AllResourceDefinition() []IResourceDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResourceDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IResourceDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResourceDefinitionContext); ok {
			tst[i] = t.(IResourceDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *ResourceDefinitionPartContext) ResourceDefinition(i int) IResourceDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceDefinitionContext)
}

func (s *ResourceDefinitionPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceDefinitionPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceDefinitionPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterResourceDefinitionPart(s)
	}
}

func (s *ResourceDefinitionPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitResourceDefinitionPart(s)
	}
}

func (s *ResourceDefinitionPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitResourceDefinitionPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ResourceDefinitionPart() (localctx IResourceDefinitionPartContext) {
	localctx = NewResourceDefinitionPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, pascalParserRULE_resourceDefinitionPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(627)
		p.Match(pascalParserRESOURCESTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(629)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64((_la-86)) & ^0x3f) == 0 && ((int64(1)<<(_la-86))&1099511627787) != 0) {
		{
			p.SetState(628)
			p.ResourceDefinition()
		}

		p.SetState(631)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceDefinitionContext is an interface to support dynamic dispatch.
type IResourceDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQUAL() antlr.TerminalNode
	StringExpression() IStringExpressionContext
	SEMI() antlr.TerminalNode

	// IsResourceDefinitionContext differentiates from other interfaces.
	IsResourceDefinitionContext()
}

type ResourceDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceDefinitionContext() *ResourceDefinitionContext {
	var p = new(ResourceDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resourceDefinition
	return p
}

func InitEmptyResourceDefinitionContext(p *ResourceDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resourceDefinition
}

func (*ResourceDefinitionContext) IsResourceDefinitionContext() {}

func NewResourceDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceDefinitionContext {
	var p = new(ResourceDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_resourceDefinition

	return p
}

func (s *ResourceDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ResourceDefinitionContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *ResourceDefinitionContext) StringExpression() IStringExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringExpressionContext)
}

func (s *ResourceDefinitionContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ResourceDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterResourceDefinition(s)
	}
}

func (s *ResourceDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitResourceDefinition(s)
	}
}

func (s *ResourceDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitResourceDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ResourceDefinition() (localctx IResourceDefinitionContext) {
	localctx = NewResourceDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, pascalParserRULE_resourceDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(633)
		p.Identifier()
	}
	{
		p.SetState(634)
		p.Match(pascalParserEQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(635)
		p.StringExpression()
	}
	{
		p.SetState(636)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeprecatedHintContext is an interface to support dynamic dispatch.
type IDeprecatedHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEPRECATED() antlr.TerminalNode
	StringExpression() IStringExpressionContext

	// IsDeprecatedHintContext differentiates from other interfaces.
	IsDeprecatedHintContext()
}

type DeprecatedHintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeprecatedHintContext() *DeprecatedHintContext {
	var p = new(DeprecatedHintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_deprecatedHint
	return p
}

func InitEmptyDeprecatedHintContext(p *DeprecatedHintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_deprecatedHint
}

func (*DeprecatedHintContext) IsDeprecatedHintContext() {}

func NewDeprecatedHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeprecatedHintContext {
	var p = new(DeprecatedHintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_deprecatedHint

	return p
}

func (s *DeprecatedHintContext) GetParser() antlr.Parser { return s.parser }

func (s *DeprecatedHintContext) DEPRECATED() antlr.TerminalNode {
	return s.GetToken(pascalParserDEPRECATED, 0)
}

func (s *DeprecatedHintContext) StringExpression() IStringExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringExpressionContext)
}

func (s *DeprecatedHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeprecatedHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeprecatedHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterDeprecatedHint(s)
	}
}

func (s *DeprecatedHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitDeprecatedHint(s)
	}
}

func (s *DeprecatedHintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitDeprecatedHint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) DeprecatedHint() (localctx IDeprecatedHintContext) {
	localctx = NewDeprecatedHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, pascalParserRULE_deprecatedHint)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(638)
		p.Match(pascalParserDEPRECATED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(639)
		p.StringExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDefinitionPartContext is an interface to support dynamic dispatch.
type ITypeDefinitionPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE() antlr.TerminalNode
	AllTypeDefinition() []ITypeDefinitionContext
	TypeDefinition(i int) ITypeDefinitionContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsTypeDefinitionPartContext differentiates from other interfaces.
	IsTypeDefinitionPartContext()
}

type TypeDefinitionPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDefinitionPartContext() *TypeDefinitionPartContext {
	var p = new(TypeDefinitionPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeDefinitionPart
	return p
}

func InitEmptyTypeDefinitionPartContext(p *TypeDefinitionPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeDefinitionPart
}

func (*TypeDefinitionPartContext) IsTypeDefinitionPartContext() {}

func NewTypeDefinitionPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDefinitionPartContext {
	var p = new(TypeDefinitionPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typeDefinitionPart

	return p
}

func (s *TypeDefinitionPartContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDefinitionPartContext) TYPE() antlr.TerminalNode {
	return s.GetToken(pascalParserTYPE, 0)
}

func (s *TypeDefinitionPartContext) AllTypeDefinition() []ITypeDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ITypeDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeDefinitionContext); ok {
			tst[i] = t.(ITypeDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *TypeDefinitionPartContext) TypeDefinition(i int) ITypeDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionContext)
}

func (s *TypeDefinitionPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *TypeDefinitionPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *TypeDefinitionPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDefinitionPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDefinitionPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypeDefinitionPart(s)
	}
}

func (s *TypeDefinitionPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypeDefinitionPart(s)
	}
}

func (s *TypeDefinitionPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypeDefinitionPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypeDefinitionPart() (localctx ITypeDefinitionPartContext) {
	localctx = NewTypeDefinitionPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, pascalParserRULE_typeDefinitionPart)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(641)
		p.Match(pascalParserTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(642)
		p.TypeDefinition()
	}
	p.SetState(647)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(643)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(644)
				p.TypeDefinition()
			}

		}
		p.SetState(649)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(651)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(650)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDefinitionContext is an interface to support dynamic dispatch.
type ITypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQUAL() antlr.TerminalNode
	ClassTypeOrForward() IClassTypeOrForwardContext
	InterfaceTypeOrForward() IInterfaceTypeOrForwardContext
	FunctionType() IFunctionTypeContext
	ProcedureType() IProcedureTypeContext
	MetaClassType() IMetaClassTypeContext
	AliasDistinctType() IAliasDistinctTypeContext
	AliasType() IAliasTypeContext
	Type_() IType_Context
	AttributeSection() IAttributeSectionContext

	// IsTypeDefinitionContext differentiates from other interfaces.
	IsTypeDefinitionContext()
}

type TypeDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDefinitionContext() *TypeDefinitionContext {
	var p = new(TypeDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeDefinition
	return p
}

func InitEmptyTypeDefinitionContext(p *TypeDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeDefinition
}

func (*TypeDefinitionContext) IsTypeDefinitionContext() {}

func NewTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDefinitionContext {
	var p = new(TypeDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typeDefinition

	return p
}

func (s *TypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeDefinitionContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *TypeDefinitionContext) ClassTypeOrForward() IClassTypeOrForwardContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTypeOrForwardContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTypeOrForwardContext)
}

func (s *TypeDefinitionContext) InterfaceTypeOrForward() IInterfaceTypeOrForwardContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceTypeOrForwardContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceTypeOrForwardContext)
}

func (s *TypeDefinitionContext) FunctionType() IFunctionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *TypeDefinitionContext) ProcedureType() IProcedureTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureTypeContext)
}

func (s *TypeDefinitionContext) MetaClassType() IMetaClassTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMetaClassTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMetaClassTypeContext)
}

func (s *TypeDefinitionContext) AliasDistinctType() IAliasDistinctTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasDistinctTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasDistinctTypeContext)
}

func (s *TypeDefinitionContext) AliasType() IAliasTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasTypeContext)
}

func (s *TypeDefinitionContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeDefinitionContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *TypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypeDefinition(s)
	}
}

func (s *TypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypeDefinition(s)
	}
}

func (s *TypeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypeDefinition() (localctx ITypeDefinitionContext) {
	localctx = NewTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, pascalParserRULE_typeDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(654)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLBRACK {
		{
			p.SetState(653)
			p.AttributeSection()
		}

	}
	{
		p.SetState(656)
		p.Identifier()
	}
	{
		p.SetState(657)
		p.Match(pascalParserEQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(666)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(658)
			p.ClassTypeOrForward()
		}

	case 2:
		{
			p.SetState(659)
			p.InterfaceTypeOrForward()
		}

	case 3:
		{
			p.SetState(660)
			p.FunctionType()
		}

	case 4:
		{
			p.SetState(661)
			p.ProcedureType()
		}

	case 5:
		{
			p.SetState(662)
			p.MetaClassType()
		}

	case 6:
		{
			p.SetState(663)
			p.AliasDistinctType()
		}

	case 7:
		{
			p.SetState(664)
			p.AliasType()
		}

	case 8:
		{
			p.SetState(665)
			p.Type_()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassTypeOrForwardContext is an interface to support dynamic dispatch.
type IClassTypeOrForwardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	ClassImplementsInterfaces() IClassImplementsInterfacesContext
	RPAREN() antlr.TerminalNode
	ABSTRACT() antlr.TerminalNode
	ClassImplicitPublishedDeclaration() IClassImplicitPublishedDeclarationContext
	END() antlr.TerminalNode
	AllClassDeclaration() []IClassDeclarationContext
	ClassDeclaration(i int) IClassDeclarationContext

	// IsClassTypeOrForwardContext differentiates from other interfaces.
	IsClassTypeOrForwardContext()
}

type ClassTypeOrForwardContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassTypeOrForwardContext() *ClassTypeOrForwardContext {
	var p = new(ClassTypeOrForwardContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classTypeOrForward
	return p
}

func InitEmptyClassTypeOrForwardContext(p *ClassTypeOrForwardContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classTypeOrForward
}

func (*ClassTypeOrForwardContext) IsClassTypeOrForwardContext() {}

func NewClassTypeOrForwardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassTypeOrForwardContext {
	var p = new(ClassTypeOrForwardContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classTypeOrForward

	return p
}

func (s *ClassTypeOrForwardContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassTypeOrForwardContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *ClassTypeOrForwardContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ClassTypeOrForwardContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassTypeOrForwardContext) ClassImplementsInterfaces() IClassImplementsInterfacesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassImplementsInterfacesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassImplementsInterfacesContext)
}

func (s *ClassTypeOrForwardContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ClassTypeOrForwardContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(pascalParserABSTRACT, 0)
}

func (s *ClassTypeOrForwardContext) ClassImplicitPublishedDeclaration() IClassImplicitPublishedDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassImplicitPublishedDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassImplicitPublishedDeclarationContext)
}

func (s *ClassTypeOrForwardContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *ClassTypeOrForwardContext) AllClassDeclaration() []IClassDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassDeclarationContext); ok {
			tst[i] = t.(IClassDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ClassTypeOrForwardContext) ClassDeclaration(i int) IClassDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *ClassTypeOrForwardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassTypeOrForwardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassTypeOrForwardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassTypeOrForward(s)
	}
}

func (s *ClassTypeOrForwardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassTypeOrForward(s)
	}
}

func (s *ClassTypeOrForwardContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassTypeOrForward(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassTypeOrForward() (localctx IClassTypeOrForwardContext) {
	localctx = NewClassTypeOrForwardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, pascalParserRULE_classTypeOrForward)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(668)
		p.Match(pascalParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(674)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(669)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(670)
			p.Identifier()
		}
		{
			p.SetState(671)
			p.ClassImplementsInterfaces()
		}
		{
			p.SetState(672)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(677)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(676)
			p.Match(pascalParserABSTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(688)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(679)
			p.ClassImplicitPublishedDeclaration()
		}
		p.SetState(683)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-79)) & ^0x3f) == 0 && ((int64(1)<<(_la-79))&31) != 0 {
			{
				p.SetState(680)
				p.ClassDeclaration()
			}

			p.SetState(685)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(686)
			p.Match(pascalParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceTypeOrForwardContext is an interface to support dynamic dispatch.
type IInterfaceTypeOrForwardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	RPAREN() antlr.TerminalNode
	GUID_LITERAL() antlr.TerminalNode
	InterfaceDeclaration() IInterfaceDeclarationContext
	END() antlr.TerminalNode

	// IsInterfaceTypeOrForwardContext differentiates from other interfaces.
	IsInterfaceTypeOrForwardContext()
}

type InterfaceTypeOrForwardContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceTypeOrForwardContext() *InterfaceTypeOrForwardContext {
	var p = new(InterfaceTypeOrForwardContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceTypeOrForward
	return p
}

func InitEmptyInterfaceTypeOrForwardContext(p *InterfaceTypeOrForwardContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceTypeOrForward
}

func (*InterfaceTypeOrForwardContext) IsInterfaceTypeOrForwardContext() {}

func NewInterfaceTypeOrForwardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceTypeOrForwardContext {
	var p = new(InterfaceTypeOrForwardContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceTypeOrForward

	return p
}

func (s *InterfaceTypeOrForwardContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceTypeOrForwardContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(pascalParserINTERFACE, 0)
}

func (s *InterfaceTypeOrForwardContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *InterfaceTypeOrForwardContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InterfaceTypeOrForwardContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *InterfaceTypeOrForwardContext) GUID_LITERAL() antlr.TerminalNode {
	return s.GetToken(pascalParserGUID_LITERAL, 0)
}

func (s *InterfaceTypeOrForwardContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *InterfaceTypeOrForwardContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *InterfaceTypeOrForwardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceTypeOrForwardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceTypeOrForwardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceTypeOrForward(s)
	}
}

func (s *InterfaceTypeOrForwardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceTypeOrForward(s)
	}
}

func (s *InterfaceTypeOrForwardContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceTypeOrForward(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceTypeOrForward() (localctx IInterfaceTypeOrForwardContext) {
	localctx = NewInterfaceTypeOrForwardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, pascalParserRULE_interfaceTypeOrForward)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(690)
		p.Match(pascalParserINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(695)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(691)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(692)
			p.Identifier()
		}
		{
			p.SetState(693)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(698)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(697)
			p.Match(pascalParserGUID_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(703)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(700)
			p.InterfaceDeclaration()
		}
		{
			p.SetState(701)
			p.Match(pascalParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForwardDeclarationContext is an interface to support dynamic dispatch.
type IForwardDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	INTERFACE() antlr.TerminalNode

	// IsForwardDeclarationContext differentiates from other interfaces.
	IsForwardDeclarationContext()
}

type ForwardDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForwardDeclarationContext() *ForwardDeclarationContext {
	var p = new(ForwardDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forwardDeclaration
	return p
}

func InitEmptyForwardDeclarationContext(p *ForwardDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forwardDeclaration
}

func (*ForwardDeclarationContext) IsForwardDeclarationContext() {}

func NewForwardDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForwardDeclarationContext {
	var p = new(ForwardDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_forwardDeclaration

	return p
}

func (s *ForwardDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ForwardDeclarationContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *ForwardDeclarationContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(pascalParserINTERFACE, 0)
}

func (s *ForwardDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForwardDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForwardDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterForwardDeclaration(s)
	}
}

func (s *ForwardDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitForwardDeclaration(s)
	}
}

func (s *ForwardDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitForwardDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ForwardDeclaration() (localctx IForwardDeclarationContext) {
	localctx = NewForwardDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, pascalParserRULE_forwardDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(705)
		_la = p.GetTokenStream().LA(1)

		if !(_la == pascalParserINTERFACE || _la == pascalParserCLASS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassTypeContext is an interface to support dynamic dispatch.
type IClassTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	ClassImplicitPublishedDeclaration() IClassImplicitPublishedDeclarationContext
	END() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	ClassImplementsInterfaces() IClassImplementsInterfacesContext
	RPAREN() antlr.TerminalNode
	ABSTRACT() antlr.TerminalNode
	AllClassDeclaration() []IClassDeclarationContext
	ClassDeclaration(i int) IClassDeclarationContext

	// IsClassTypeContext differentiates from other interfaces.
	IsClassTypeContext()
}

type ClassTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassTypeContext() *ClassTypeContext {
	var p = new(ClassTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classType
	return p
}

func InitEmptyClassTypeContext(p *ClassTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classType
}

func (*ClassTypeContext) IsClassTypeContext() {}

func NewClassTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassTypeContext {
	var p = new(ClassTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classType

	return p
}

func (s *ClassTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassTypeContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *ClassTypeContext) ClassImplicitPublishedDeclaration() IClassImplicitPublishedDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassImplicitPublishedDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassImplicitPublishedDeclarationContext)
}

func (s *ClassTypeContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *ClassTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ClassTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassTypeContext) ClassImplementsInterfaces() IClassImplementsInterfacesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassImplementsInterfacesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassImplementsInterfacesContext)
}

func (s *ClassTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ClassTypeContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(pascalParserABSTRACT, 0)
}

func (s *ClassTypeContext) AllClassDeclaration() []IClassDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassDeclarationContext); ok {
			tst[i] = t.(IClassDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ClassTypeContext) ClassDeclaration(i int) IClassDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *ClassTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassType(s)
	}
}

func (s *ClassTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassType(s)
	}
}

func (s *ClassTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassType() (localctx IClassTypeContext) {
	localctx = NewClassTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, pascalParserRULE_classType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(707)
		p.Match(pascalParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(713)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(708)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(709)
			p.Identifier()
		}
		{
			p.SetState(710)
			p.ClassImplementsInterfaces()
		}
		{
			p.SetState(711)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(716)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(715)
			p.Match(pascalParserABSTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(718)
		p.ClassImplicitPublishedDeclaration()
	}
	p.SetState(722)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-79)) & ^0x3f) == 0 && ((int64(1)<<(_la-79))&31) != 0 {
		{
			p.SetState(719)
			p.ClassDeclaration()
		}

		p.SetState(724)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(725)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceTypeContext is an interface to support dynamic dispatch.
type IInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	InterfaceDeclaration() IInterfaceDeclarationContext
	END() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	RPAREN() antlr.TerminalNode
	GUID_LITERAL() antlr.TerminalNode

	// IsInterfaceTypeContext differentiates from other interfaces.
	IsInterfaceTypeContext()
}

type InterfaceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceTypeContext() *InterfaceTypeContext {
	var p = new(InterfaceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceType
	return p
}

func InitEmptyInterfaceTypeContext(p *InterfaceTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceType
}

func (*InterfaceTypeContext) IsInterfaceTypeContext() {}

func NewInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceTypeContext {
	var p = new(InterfaceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceType

	return p
}

func (s *InterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceTypeContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(pascalParserINTERFACE, 0)
}

func (s *InterfaceTypeContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *InterfaceTypeContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *InterfaceTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *InterfaceTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InterfaceTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *InterfaceTypeContext) GUID_LITERAL() antlr.TerminalNode {
	return s.GetToken(pascalParserGUID_LITERAL, 0)
}

func (s *InterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceType(s)
	}
}

func (s *InterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceType(s)
	}
}

func (s *InterfaceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceType() (localctx IInterfaceTypeContext) {
	localctx = NewInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, pascalParserRULE_interfaceType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(727)
		p.Match(pascalParserINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(732)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(728)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(729)
			p.Identifier()
		}
		{
			p.SetState(730)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(735)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(734)
			p.Match(pascalParserGUID_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(737)
		p.InterfaceDeclaration()
	}
	{
		p.SetState(738)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTypeContext is an interface to support dynamic dispatch.
type IFunctionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNCTION() antlr.TerminalNode
	COLON() antlr.TerminalNode
	ResultType() IResultTypeContext
	ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext
	FormalParameterList() IFormalParameterListContext
	OF() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	REFERENCE() antlr.TerminalNode
	TO() antlr.TerminalNode

	// IsFunctionTypeContext differentiates from other interfaces.
	IsFunctionTypeContext()
}

type FunctionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeContext() *FunctionTypeContext {
	var p = new(FunctionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionType
	return p
}

func InitEmptyFunctionTypeContext(p *FunctionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionType
}

func (*FunctionTypeContext) IsFunctionTypeContext() {}

func NewFunctionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeContext {
	var p = new(FunctionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_functionType

	return p
}

func (s *FunctionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(pascalParserFUNCTION, 0)
}

func (s *FunctionTypeContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *FunctionTypeContext) ResultType() IResultTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultTypeContext)
}

func (s *FunctionTypeContext) ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderModifiersContext)
}

func (s *FunctionTypeContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *FunctionTypeContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(pascalParserOBJECT, 0)
}

func (s *FunctionTypeContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(pascalParserREFERENCE, 0)
}

func (s *FunctionTypeContext) TO() antlr.TerminalNode {
	return s.GetToken(pascalParserTO, 0)
}

func (s *FunctionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFunctionType(s)
	}
}

func (s *FunctionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFunctionType(s)
	}
}

func (s *FunctionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFunctionType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FunctionType() (localctx IFunctionTypeContext) {
	localctx = NewFunctionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, pascalParserRULE_functionType)
	var _la int

	p.SetState(762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserFUNCTION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(740)
			p.Match(pascalParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(742)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLPAREN {
			{
				p.SetState(741)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(744)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(745)
			p.ResultType()
		}
		p.SetState(748)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(746)
				p.Match(pascalParserOF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(747)
				p.Match(pascalParserOBJECT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(750)
			p.ProcedureOrFunctionHeaderModifiers()
		}

	case pascalParserREFERENCE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(752)
			p.Match(pascalParserREFERENCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(753)
			p.Match(pascalParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(754)
			p.Match(pascalParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(756)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLPAREN {
			{
				p.SetState(755)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(758)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(759)
			p.ResultType()
		}
		{
			p.SetState(760)
			p.ProcedureOrFunctionHeaderModifiers()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureTypeContext is an interface to support dynamic dispatch.
type IProcedureTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROCEDURE() antlr.TerminalNode
	ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext
	FormalParameterList() IFormalParameterListContext
	OF() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	REFERENCE() antlr.TerminalNode
	TO() antlr.TerminalNode

	// IsProcedureTypeContext differentiates from other interfaces.
	IsProcedureTypeContext()
}

type ProcedureTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureTypeContext() *ProcedureTypeContext {
	var p = new(ProcedureTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureType
	return p
}

func InitEmptyProcedureTypeContext(p *ProcedureTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureType
}

func (*ProcedureTypeContext) IsProcedureTypeContext() {}

func NewProcedureTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureTypeContext {
	var p = new(ProcedureTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureType

	return p
}

func (s *ProcedureTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureTypeContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(pascalParserPROCEDURE, 0)
}

func (s *ProcedureTypeContext) ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderModifiersContext)
}

func (s *ProcedureTypeContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ProcedureTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *ProcedureTypeContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(pascalParserOBJECT, 0)
}

func (s *ProcedureTypeContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(pascalParserREFERENCE, 0)
}

func (s *ProcedureTypeContext) TO() antlr.TerminalNode {
	return s.GetToken(pascalParserTO, 0)
}

func (s *ProcedureTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureType(s)
	}
}

func (s *ProcedureTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureType(s)
	}
}

func (s *ProcedureTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureType() (localctx IProcedureTypeContext) {
	localctx = NewProcedureTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, pascalParserRULE_procedureType)
	p.SetState(780)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserPROCEDURE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(764)
			p.Match(pascalParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(766)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(765)
				p.FormalParameterList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(770)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(768)
				p.Match(pascalParserOF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(769)
				p.Match(pascalParserOBJECT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(772)
			p.ProcedureOrFunctionHeaderModifiers()
		}

	case pascalParserREFERENCE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(773)
			p.Match(pascalParserREFERENCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(774)
			p.Match(pascalParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(775)
			p.Match(pascalParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(777)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(776)
				p.FormalParameterList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(779)
			p.ProcedureOrFunctionHeaderModifiers()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMetaClassTypeContext is an interface to support dynamic dispatch.
type IMetaClassTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	OF() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext

	// IsMetaClassTypeContext differentiates from other interfaces.
	IsMetaClassTypeContext()
}

type MetaClassTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMetaClassTypeContext() *MetaClassTypeContext {
	var p = new(MetaClassTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_metaClassType
	return p
}

func InitEmptyMetaClassTypeContext(p *MetaClassTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_metaClassType
}

func (*MetaClassTypeContext) IsMetaClassTypeContext() {}

func NewMetaClassTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MetaClassTypeContext {
	var p = new(MetaClassTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_metaClassType

	return p
}

func (s *MetaClassTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *MetaClassTypeContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *MetaClassTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *MetaClassTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *MetaClassTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MetaClassTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MetaClassTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterMetaClassType(s)
	}
}

func (s *MetaClassTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitMetaClassType(s)
	}
}

func (s *MetaClassTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitMetaClassType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) MetaClassType() (localctx IMetaClassTypeContext) {
	localctx = NewMetaClassTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, pascalParserRULE_metaClassType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(782)
		p.Match(pascalParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(783)
		p.Match(pascalParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(784)
		p.TypeIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAliasDistinctTypeContext is an interface to support dynamic dispatch.
type IAliasDistinctTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext

	// IsAliasDistinctTypeContext differentiates from other interfaces.
	IsAliasDistinctTypeContext()
}

type AliasDistinctTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasDistinctTypeContext() *AliasDistinctTypeContext {
	var p = new(AliasDistinctTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_aliasDistinctType
	return p
}

func InitEmptyAliasDistinctTypeContext(p *AliasDistinctTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_aliasDistinctType
}

func (*AliasDistinctTypeContext) IsAliasDistinctTypeContext() {}

func NewAliasDistinctTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasDistinctTypeContext {
	var p = new(AliasDistinctTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_aliasDistinctType

	return p
}

func (s *AliasDistinctTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasDistinctTypeContext) TYPE() antlr.TerminalNode {
	return s.GetToken(pascalParserTYPE, 0)
}

func (s *AliasDistinctTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *AliasDistinctTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasDistinctTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasDistinctTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAliasDistinctType(s)
	}
}

func (s *AliasDistinctTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAliasDistinctType(s)
	}
}

func (s *AliasDistinctTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAliasDistinctType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) AliasDistinctType() (localctx IAliasDistinctTypeContext) {
	localctx = NewAliasDistinctTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, pascalParserRULE_aliasDistinctType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(786)
		p.Match(pascalParserTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(787)
		p.TypeIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAliasTypeContext is an interface to support dynamic dispatch.
type IAliasTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIdentifier() ITypeIdentifierContext

	// IsAliasTypeContext differentiates from other interfaces.
	IsAliasTypeContext()
}

type AliasTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasTypeContext() *AliasTypeContext {
	var p = new(AliasTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_aliasType
	return p
}

func InitEmptyAliasTypeContext(p *AliasTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_aliasType
}

func (*AliasTypeContext) IsAliasTypeContext() {}

func NewAliasTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasTypeContext {
	var p = new(AliasTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_aliasType

	return p
}

func (s *AliasTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *AliasTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAliasType(s)
	}
}

func (s *AliasTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAliasType(s)
	}
}

func (s *AliasTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAliasType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) AliasType() (localctx IAliasTypeContext) {
	localctx = NewAliasTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, pascalParserRULE_aliasType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(789)
		p.TypeIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassImplementsInterfacesContext is an interface to support dynamic dispatch.
type IClassImplementsInterfacesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllTypeIdentifier() []ITypeIdentifierContext
	TypeIdentifier(i int) ITypeIdentifierContext

	// IsClassImplementsInterfacesContext differentiates from other interfaces.
	IsClassImplementsInterfacesContext()
}

type ClassImplementsInterfacesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassImplementsInterfacesContext() *ClassImplementsInterfacesContext {
	var p = new(ClassImplementsInterfacesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classImplementsInterfaces
	return p
}

func InitEmptyClassImplementsInterfacesContext(p *ClassImplementsInterfacesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classImplementsInterfaces
}

func (*ClassImplementsInterfacesContext) IsClassImplementsInterfacesContext() {}

func NewClassImplementsInterfacesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassImplementsInterfacesContext {
	var p = new(ClassImplementsInterfacesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classImplementsInterfaces

	return p
}

func (s *ClassImplementsInterfacesContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassImplementsInterfacesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ClassImplementsInterfacesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ClassImplementsInterfacesContext) AllTypeIdentifier() []ITypeIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			len++
		}
	}

	tst := make([]ITypeIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeIdentifierContext); ok {
			tst[i] = t.(ITypeIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ClassImplementsInterfacesContext) TypeIdentifier(i int) ITypeIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ClassImplementsInterfacesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassImplementsInterfacesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassImplementsInterfacesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassImplementsInterfaces(s)
	}
}

func (s *ClassImplementsInterfacesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassImplementsInterfaces(s)
	}
}

func (s *ClassImplementsInterfacesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassImplementsInterfaces(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassImplementsInterfaces() (localctx IClassImplementsInterfacesContext) {
	localctx = NewClassImplementsInterfacesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, pascalParserRULE_classImplementsInterfaces)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(795)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(791)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(792)
			p.TypeIdentifier()
		}

		p.SetState(797)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAccessSpecifierContext is an interface to support dynamic dispatch.
type IAccessSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRIVATE() antlr.TerminalNode
	STRICT() antlr.TerminalNode
	PROTECTED() antlr.TerminalNode
	PUBLIC() antlr.TerminalNode
	PUBLISHED() antlr.TerminalNode

	// IsAccessSpecifierContext differentiates from other interfaces.
	IsAccessSpecifierContext()
}

type AccessSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccessSpecifierContext() *AccessSpecifierContext {
	var p = new(AccessSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_accessSpecifier
	return p
}

func InitEmptyAccessSpecifierContext(p *AccessSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_accessSpecifier
}

func (*AccessSpecifierContext) IsAccessSpecifierContext() {}

func NewAccessSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccessSpecifierContext {
	var p = new(AccessSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_accessSpecifier

	return p
}

func (s *AccessSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AccessSpecifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(pascalParserPRIVATE, 0)
}

func (s *AccessSpecifierContext) STRICT() antlr.TerminalNode {
	return s.GetToken(pascalParserSTRICT, 0)
}

func (s *AccessSpecifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(pascalParserPROTECTED, 0)
}

func (s *AccessSpecifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLIC, 0)
}

func (s *AccessSpecifierContext) PUBLISHED() antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLISHED, 0)
}

func (s *AccessSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccessSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AccessSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAccessSpecifier(s)
	}
}

func (s *AccessSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAccessSpecifier(s)
	}
}

func (s *AccessSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAccessSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) AccessSpecifier() (localctx IAccessSpecifierContext) {
	localctx = NewAccessSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, pascalParserRULE_accessSpecifier)
	var _la int

	p.SetState(808)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(799)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserSTRICT {
			{
				p.SetState(798)
				p.Match(pascalParserSTRICT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(801)
			p.Match(pascalParserPRIVATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(803)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserSTRICT {
			{
				p.SetState(802)
				p.Match(pascalParserSTRICT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(805)
			p.Match(pascalParserPROTECTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(806)
			p.Match(pascalParserPUBLIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(807)
			p.Match(pascalParserPUBLISHED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AccessSpecifier() IAccessSpecifierContext
	AllClassDeclarationPart() []IClassDeclarationPartContext
	ClassDeclarationPart(i int) IClassDeclarationPartContext

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classDeclaration
	return p
}

func InitEmptyClassDeclarationContext(p *ClassDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classDeclaration
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) AccessSpecifier() IAccessSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessSpecifierContext)
}

func (s *ClassDeclarationContext) AllClassDeclarationPart() []IClassDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IClassDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassDeclarationPartContext); ok {
			tst[i] = t.(IClassDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ClassDeclarationContext) ClassDeclarationPart(i int) IClassDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationPartContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, pascalParserRULE_classDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(810)
		p.AccessSpecifier()
	}
	p.SetState(814)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-32770) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1015809) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&562949953421311) != 0) {
		{
			p.SetState(811)
			p.ClassDeclarationPart()
		}

		p.SetState(816)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassImplicitPublishedDeclarationContext is an interface to support dynamic dispatch.
type IClassImplicitPublishedDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllClassDeclarationPart() []IClassDeclarationPartContext
	ClassDeclarationPart(i int) IClassDeclarationPartContext

	// IsClassImplicitPublishedDeclarationContext differentiates from other interfaces.
	IsClassImplicitPublishedDeclarationContext()
}

type ClassImplicitPublishedDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassImplicitPublishedDeclarationContext() *ClassImplicitPublishedDeclarationContext {
	var p = new(ClassImplicitPublishedDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classImplicitPublishedDeclaration
	return p
}

func InitEmptyClassImplicitPublishedDeclarationContext(p *ClassImplicitPublishedDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classImplicitPublishedDeclaration
}

func (*ClassImplicitPublishedDeclarationContext) IsClassImplicitPublishedDeclarationContext() {}

func NewClassImplicitPublishedDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassImplicitPublishedDeclarationContext {
	var p = new(ClassImplicitPublishedDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classImplicitPublishedDeclaration

	return p
}

func (s *ClassImplicitPublishedDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassImplicitPublishedDeclarationContext) AllClassDeclarationPart() []IClassDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IClassDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassDeclarationPartContext); ok {
			tst[i] = t.(IClassDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ClassImplicitPublishedDeclarationContext) ClassDeclarationPart(i int) IClassDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationPartContext)
}

func (s *ClassImplicitPublishedDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassImplicitPublishedDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassImplicitPublishedDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassImplicitPublishedDeclaration(s)
	}
}

func (s *ClassImplicitPublishedDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassImplicitPublishedDeclaration(s)
	}
}

func (s *ClassImplicitPublishedDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassImplicitPublishedDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassImplicitPublishedDeclaration() (localctx IClassImplicitPublishedDeclarationContext) {
	localctx = NewClassImplicitPublishedDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, pascalParserRULE_classImplicitPublishedDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(820)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-32770) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1015809) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&562949953421311) != 0) {
		{
			p.SetState(817)
			p.ClassDeclarationPart()
		}

		p.SetState(822)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassDeclarationPartContext is an interface to support dynamic dispatch.
type IClassDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypedIdentifierList() ITypedIdentifierListContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AttributeSection() IAttributeSectionContext
	TypeDefinitionPart() ITypeDefinitionPartContext
	ConstantDefinitionPart() IConstantDefinitionPartContext
	FunctionHeader() IFunctionHeaderContext
	ProcedureHeader() IProcedureHeaderContext
	PropertyDeclaration() IPropertyDeclarationContext
	DEFAULT() antlr.TerminalNode
	ErrorClassDeclarationPart() IErrorClassDeclarationPartContext

	// IsClassDeclarationPartContext differentiates from other interfaces.
	IsClassDeclarationPartContext()
}

type ClassDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationPartContext() *ClassDeclarationPartContext {
	var p = new(ClassDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classDeclarationPart
	return p
}

func InitEmptyClassDeclarationPartContext(p *ClassDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classDeclarationPart
}

func (*ClassDeclarationPartContext) IsClassDeclarationPartContext() {}

func NewClassDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationPartContext {
	var p = new(ClassDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classDeclarationPart

	return p
}

func (s *ClassDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationPartContext) TypedIdentifierList() ITypedIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIdentifierListContext)
}

func (s *ClassDeclarationPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ClassDeclarationPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ClassDeclarationPartContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *ClassDeclarationPartContext) TypeDefinitionPart() ITypeDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionPartContext)
}

func (s *ClassDeclarationPartContext) ConstantDefinitionPart() IConstantDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *ClassDeclarationPartContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *ClassDeclarationPartContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *ClassDeclarationPartContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *ClassDeclarationPartContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *ClassDeclarationPartContext) ErrorClassDeclarationPart() IErrorClassDeclarationPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorClassDeclarationPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorClassDeclarationPartContext)
}

func (s *ClassDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassDeclarationPart(s)
	}
}

func (s *ClassDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassDeclarationPart(s)
	}
}

func (s *ClassDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassDeclarationPart() (localctx IClassDeclarationPartContext) {
	localctx = NewClassDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, pascalParserRULE_classDeclarationPart)
	var _la int

	p.SetState(842)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(824)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(823)
				p.AttributeSection()
			}

		}
		{
			p.SetState(826)
			p.TypedIdentifierList()
		}
		{
			p.SetState(827)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(829)
			p.TypeDefinitionPart()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(830)
			p.ConstantDefinitionPart()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(831)
			p.FunctionHeader()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(832)
			p.ProcedureHeader()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(833)
			p.PropertyDeclaration()
		}
		{
			p.SetState(834)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(837)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(835)
				p.Match(pascalParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(836)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(839)
			p.ErrorClassDeclarationPart()
		}
		{
			p.SetState(840)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceGuidConstContext is an interface to support dynamic dispatch.
type IInterfaceGuidConstContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GUID_LITERAL() antlr.TerminalNode

	// IsInterfaceGuidConstContext differentiates from other interfaces.
	IsInterfaceGuidConstContext()
}

type InterfaceGuidConstContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceGuidConstContext() *InterfaceGuidConstContext {
	var p = new(InterfaceGuidConstContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceGuidConst
	return p
}

func InitEmptyInterfaceGuidConstContext(p *InterfaceGuidConstContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceGuidConst
}

func (*InterfaceGuidConstContext) IsInterfaceGuidConstContext() {}

func NewInterfaceGuidConstContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceGuidConstContext {
	var p = new(InterfaceGuidConstContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceGuidConst

	return p
}

func (s *InterfaceGuidConstContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceGuidConstContext) GUID_LITERAL() antlr.TerminalNode {
	return s.GetToken(pascalParserGUID_LITERAL, 0)
}

func (s *InterfaceGuidConstContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceGuidConstContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceGuidConstContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceGuidConst(s)
	}
}

func (s *InterfaceGuidConstContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceGuidConst(s)
	}
}

func (s *InterfaceGuidConstContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceGuidConst(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceGuidConst() (localctx IInterfaceGuidConstContext) {
	localctx = NewInterfaceGuidConstContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, pascalParserRULE_interfaceGuidConst)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(844)
		p.Match(pascalParserGUID_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInterfaceDeclarationPart() []IInterfaceDeclarationPartContext
	InterfaceDeclarationPart(i int) IInterfaceDeclarationPartContext

	// IsInterfaceDeclarationContext differentiates from other interfaces.
	IsInterfaceDeclarationContext()
}

type InterfaceDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclarationContext() *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceDeclaration
	return p
}

func InitEmptyInterfaceDeclarationContext(p *InterfaceDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceDeclaration
}

func (*InterfaceDeclarationContext) IsInterfaceDeclarationContext() {}

func NewInterfaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceDeclaration

	return p
}

func (s *InterfaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclarationContext) AllInterfaceDeclarationPart() []IInterfaceDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceDeclarationPartContext); ok {
			tst[i] = t.(IInterfaceDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceDeclarationContext) InterfaceDeclarationPart(i int) IInterfaceDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationPartContext)
}

func (s *InterfaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceDeclaration(s)
	}
}

func (s *InterfaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceDeclaration(s)
	}
}

func (s *InterfaceDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceDeclaration() (localctx IInterfaceDeclarationContext) {
	localctx = NewInterfaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, pascalParserRULE_interfaceDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(849)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-32770) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&562949953421311) != 0) {
		{
			p.SetState(846)
			p.InterfaceDeclarationPart()
		}

		p.SetState(851)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceDeclarationPartContext is an interface to support dynamic dispatch.
type IInterfaceDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionHeader() IFunctionHeaderContext
	ProcedureHeader() IProcedureHeaderContext
	PropertyDeclaration() IPropertyDeclarationContext
	SEMI() antlr.TerminalNode
	ErrorInterfaceDeclarationPart() IErrorInterfaceDeclarationPartContext

	// IsInterfaceDeclarationPartContext differentiates from other interfaces.
	IsInterfaceDeclarationPartContext()
}

type InterfaceDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclarationPartContext() *InterfaceDeclarationPartContext {
	var p = new(InterfaceDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceDeclarationPart
	return p
}

func InitEmptyInterfaceDeclarationPartContext(p *InterfaceDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceDeclarationPart
}

func (*InterfaceDeclarationPartContext) IsInterfaceDeclarationPartContext() {}

func NewInterfaceDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclarationPartContext {
	var p = new(InterfaceDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceDeclarationPart

	return p
}

func (s *InterfaceDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclarationPartContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *InterfaceDeclarationPartContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *InterfaceDeclarationPartContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *InterfaceDeclarationPartContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *InterfaceDeclarationPartContext) ErrorInterfaceDeclarationPart() IErrorInterfaceDeclarationPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorInterfaceDeclarationPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorInterfaceDeclarationPartContext)
}

func (s *InterfaceDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceDeclarationPart(s)
	}
}

func (s *InterfaceDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceDeclarationPart(s)
	}
}

func (s *InterfaceDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceDeclarationPart() (localctx IInterfaceDeclarationPartContext) {
	localctx = NewInterfaceDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, pascalParserRULE_interfaceDeclarationPart)
	p.SetState(860)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(852)
			p.FunctionHeader()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(853)
			p.ProcedureHeader()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(854)
			p.PropertyDeclaration()
		}
		{
			p.SetState(855)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(857)
			p.ErrorInterfaceDeclarationPart()
		}
		{
			p.SetState(858)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorInterfaceDeclarationPartContext is an interface to support dynamic dispatch.
type IErrorInterfaceDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEND() []antlr.TerminalNode
	END(i int) antlr.TerminalNode

	// IsErrorInterfaceDeclarationPartContext differentiates from other interfaces.
	IsErrorInterfaceDeclarationPartContext()
}

type ErrorInterfaceDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorInterfaceDeclarationPartContext() *ErrorInterfaceDeclarationPartContext {
	var p = new(ErrorInterfaceDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorInterfaceDeclarationPart
	return p
}

func InitEmptyErrorInterfaceDeclarationPartContext(p *ErrorInterfaceDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorInterfaceDeclarationPart
}

func (*ErrorInterfaceDeclarationPartContext) IsErrorInterfaceDeclarationPartContext() {}

func NewErrorInterfaceDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorInterfaceDeclarationPartContext {
	var p = new(ErrorInterfaceDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_errorInterfaceDeclarationPart

	return p
}

func (s *ErrorInterfaceDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorInterfaceDeclarationPartContext) AllEND() []antlr.TerminalNode {
	return s.GetTokens(pascalParserEND)
}

func (s *ErrorInterfaceDeclarationPartContext) END(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserEND, i)
}

func (s *ErrorInterfaceDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorInterfaceDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorInterfaceDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterErrorInterfaceDeclarationPart(s)
	}
}

func (s *ErrorInterfaceDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitErrorInterfaceDeclarationPart(s)
	}
}

func (s *ErrorInterfaceDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitErrorInterfaceDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ErrorInterfaceDeclarationPart() (localctx IErrorInterfaceDeclarationPartContext) {
	localctx = NewErrorInterfaceDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, pascalParserRULE_errorInterfaceDeclarationPart)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(863)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(862)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || _la == pascalParserEND {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(865)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorClassDeclarationPartContext is an interface to support dynamic dispatch.
type IErrorClassDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRICT() []antlr.TerminalNode
	STRICT(i int) antlr.TerminalNode
	AllPRIVATE() []antlr.TerminalNode
	PRIVATE(i int) antlr.TerminalNode
	AllPROTECTED() []antlr.TerminalNode
	PROTECTED(i int) antlr.TerminalNode
	AllPUBLIC() []antlr.TerminalNode
	PUBLIC(i int) antlr.TerminalNode
	AllPUBLISHED() []antlr.TerminalNode
	PUBLISHED(i int) antlr.TerminalNode
	AllEND() []antlr.TerminalNode
	END(i int) antlr.TerminalNode

	// IsErrorClassDeclarationPartContext differentiates from other interfaces.
	IsErrorClassDeclarationPartContext()
}

type ErrorClassDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorClassDeclarationPartContext() *ErrorClassDeclarationPartContext {
	var p = new(ErrorClassDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorClassDeclarationPart
	return p
}

func InitEmptyErrorClassDeclarationPartContext(p *ErrorClassDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorClassDeclarationPart
}

func (*ErrorClassDeclarationPartContext) IsErrorClassDeclarationPartContext() {}

func NewErrorClassDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorClassDeclarationPartContext {
	var p = new(ErrorClassDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_errorClassDeclarationPart

	return p
}

func (s *ErrorClassDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorClassDeclarationPartContext) AllSTRICT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTRICT)
}

func (s *ErrorClassDeclarationPartContext) STRICT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTRICT, i)
}

func (s *ErrorClassDeclarationPartContext) AllPRIVATE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPRIVATE)
}

func (s *ErrorClassDeclarationPartContext) PRIVATE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPRIVATE, i)
}

func (s *ErrorClassDeclarationPartContext) AllPROTECTED() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPROTECTED)
}

func (s *ErrorClassDeclarationPartContext) PROTECTED(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPROTECTED, i)
}

func (s *ErrorClassDeclarationPartContext) AllPUBLIC() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPUBLIC)
}

func (s *ErrorClassDeclarationPartContext) PUBLIC(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLIC, i)
}

func (s *ErrorClassDeclarationPartContext) AllPUBLISHED() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPUBLISHED)
}

func (s *ErrorClassDeclarationPartContext) PUBLISHED(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLISHED, i)
}

func (s *ErrorClassDeclarationPartContext) AllEND() []antlr.TerminalNode {
	return s.GetTokens(pascalParserEND)
}

func (s *ErrorClassDeclarationPartContext) END(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserEND, i)
}

func (s *ErrorClassDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorClassDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorClassDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterErrorClassDeclarationPart(s)
	}
}

func (s *ErrorClassDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitErrorClassDeclarationPart(s)
	}
}

func (s *ErrorClassDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitErrorClassDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ErrorClassDeclarationPart() (localctx IErrorClassDeclarationPartContext) {
	localctx = NewErrorClassDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, pascalParserRULE_errorClassDeclarationPart)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(868)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(867)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || _la == pascalParserEND || ((int64((_la-79)) & ^0x3f) == 0 && ((int64(1)<<(_la-79))&31) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(870)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyDeclarationContext is an interface to support dynamic dispatch.
type IPropertyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROPERTY() antlr.TerminalNode
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	PropertyIndexParameters() IPropertyIndexParametersContext
	PropertyReadDeclaration() IPropertyReadDeclarationContext
	PropertyWriteDeclaration() IPropertyWriteDeclarationContext
	PropertyDefaultValueDeclaration() IPropertyDefaultValueDeclarationContext
	PropertyIndexDeclaration() IPropertyIndexDeclarationContext
	SEMI() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode

	// IsPropertyDeclarationContext differentiates from other interfaces.
	IsPropertyDeclarationContext()
}

type PropertyDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDeclarationContext() *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDeclaration
	return p
}

func InitEmptyPropertyDeclarationContext(p *PropertyDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDeclaration
}

func (*PropertyDeclarationContext) IsPropertyDeclarationContext() {}

func NewPropertyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyDeclaration

	return p
}

func (s *PropertyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDeclarationContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(pascalParserPROPERTY, 0)
}

func (s *PropertyDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *PropertyDeclarationContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *PropertyDeclarationContext) PropertyIndexParameters() IPropertyIndexParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyIndexParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyIndexParametersContext)
}

func (s *PropertyDeclarationContext) PropertyReadDeclaration() IPropertyReadDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyReadDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyReadDeclarationContext)
}

func (s *PropertyDeclarationContext) PropertyWriteDeclaration() IPropertyWriteDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyWriteDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyWriteDeclarationContext)
}

func (s *PropertyDeclarationContext) PropertyDefaultValueDeclaration() IPropertyDefaultValueDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDefaultValueDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDefaultValueDeclarationContext)
}

func (s *PropertyDeclarationContext) PropertyIndexDeclaration() IPropertyIndexDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyIndexDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyIndexDeclarationContext)
}

func (s *PropertyDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *PropertyDeclarationContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *PropertyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyDeclaration(s)
	}
}

func (s *PropertyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyDeclaration(s)
	}
}

func (s *PropertyDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyDeclaration() (localctx IPropertyDeclarationContext) {
	localctx = NewPropertyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, pascalParserRULE_propertyDeclaration)
	var _la int

	p.SetState(900)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(872)
			p.Match(pascalParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(873)
			p.Identifier()
		}
		p.SetState(875)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(874)
				p.PropertyIndexParameters()
			}

		}
		{
			p.SetState(877)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(878)
			p.TypeIdentifier()
		}
		p.SetState(880)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserREAD {
			{
				p.SetState(879)
				p.PropertyReadDeclaration()
			}

		}
		p.SetState(883)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserWRITE {
			{
				p.SetState(882)
				p.PropertyWriteDeclaration()
			}

		}
		p.SetState(886)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserDEFAULT {
			{
				p.SetState(885)
				p.PropertyDefaultValueDeclaration()
			}

		}
		p.SetState(889)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserINDEX {
			{
				p.SetState(888)
				p.PropertyIndexDeclaration()
			}

		}
		p.SetState(893)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(891)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(892)
				p.Match(pascalParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(895)
			p.Match(pascalParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(896)
			p.Identifier()
		}
		p.SetState(898)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserDEFAULT {
			{
				p.SetState(897)
				p.PropertyDefaultValueDeclaration()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyReadDeclarationContext is an interface to support dynamic dispatch.
type IPropertyReadDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsPropertyReadDeclarationContext differentiates from other interfaces.
	IsPropertyReadDeclarationContext()
}

type PropertyReadDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyReadDeclarationContext() *PropertyReadDeclarationContext {
	var p = new(PropertyReadDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyReadDeclaration
	return p
}

func InitEmptyPropertyReadDeclarationContext(p *PropertyReadDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyReadDeclaration
}

func (*PropertyReadDeclarationContext) IsPropertyReadDeclarationContext() {}

func NewPropertyReadDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyReadDeclarationContext {
	var p = new(PropertyReadDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyReadDeclaration

	return p
}

func (s *PropertyReadDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyReadDeclarationContext) READ() antlr.TerminalNode {
	return s.GetToken(pascalParserREAD, 0)
}

func (s *PropertyReadDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyReadDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyReadDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyReadDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyReadDeclaration(s)
	}
}

func (s *PropertyReadDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyReadDeclaration(s)
	}
}

func (s *PropertyReadDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyReadDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyReadDeclaration() (localctx IPropertyReadDeclarationContext) {
	localctx = NewPropertyReadDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, pascalParserRULE_propertyReadDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(902)
		p.Match(pascalParserREAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(903)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyWriteDeclarationContext is an interface to support dynamic dispatch.
type IPropertyWriteDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WRITE() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsPropertyWriteDeclarationContext differentiates from other interfaces.
	IsPropertyWriteDeclarationContext()
}

type PropertyWriteDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyWriteDeclarationContext() *PropertyWriteDeclarationContext {
	var p = new(PropertyWriteDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyWriteDeclaration
	return p
}

func InitEmptyPropertyWriteDeclarationContext(p *PropertyWriteDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyWriteDeclaration
}

func (*PropertyWriteDeclarationContext) IsPropertyWriteDeclarationContext() {}

func NewPropertyWriteDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyWriteDeclarationContext {
	var p = new(PropertyWriteDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyWriteDeclaration

	return p
}

func (s *PropertyWriteDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyWriteDeclarationContext) WRITE() antlr.TerminalNode {
	return s.GetToken(pascalParserWRITE, 0)
}

func (s *PropertyWriteDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyWriteDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyWriteDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyWriteDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyWriteDeclaration(s)
	}
}

func (s *PropertyWriteDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyWriteDeclaration(s)
	}
}

func (s *PropertyWriteDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyWriteDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyWriteDeclaration() (localctx IPropertyWriteDeclarationContext) {
	localctx = NewPropertyWriteDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, pascalParserRULE_propertyWriteDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(905)
		p.Match(pascalParserWRITE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(906)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyDefaultValueDeclarationContext is an interface to support dynamic dispatch.
type IPropertyDefaultValueDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	Expression() IExpressionContext

	// IsPropertyDefaultValueDeclarationContext differentiates from other interfaces.
	IsPropertyDefaultValueDeclarationContext()
}

type PropertyDefaultValueDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDefaultValueDeclarationContext() *PropertyDefaultValueDeclarationContext {
	var p = new(PropertyDefaultValueDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDefaultValueDeclaration
	return p
}

func InitEmptyPropertyDefaultValueDeclarationContext(p *PropertyDefaultValueDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDefaultValueDeclaration
}

func (*PropertyDefaultValueDeclarationContext) IsPropertyDefaultValueDeclarationContext() {}

func NewPropertyDefaultValueDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDefaultValueDeclarationContext {
	var p = new(PropertyDefaultValueDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyDefaultValueDeclaration

	return p
}

func (s *PropertyDefaultValueDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDefaultValueDeclarationContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *PropertyDefaultValueDeclarationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PropertyDefaultValueDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDefaultValueDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyDefaultValueDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyDefaultValueDeclaration(s)
	}
}

func (s *PropertyDefaultValueDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyDefaultValueDeclaration(s)
	}
}

func (s *PropertyDefaultValueDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyDefaultValueDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyDefaultValueDeclaration() (localctx IPropertyDefaultValueDeclarationContext) {
	localctx = NewPropertyDefaultValueDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, pascalParserRULE_propertyDefaultValueDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(908)
		p.Match(pascalParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(909)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyIndexDeclarationContext is an interface to support dynamic dispatch.
type IPropertyIndexDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INDEX() antlr.TerminalNode
	UnsignedNumber() IUnsignedNumberContext

	// IsPropertyIndexDeclarationContext differentiates from other interfaces.
	IsPropertyIndexDeclarationContext()
}

type PropertyIndexDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyIndexDeclarationContext() *PropertyIndexDeclarationContext {
	var p = new(PropertyIndexDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexDeclaration
	return p
}

func InitEmptyPropertyIndexDeclarationContext(p *PropertyIndexDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexDeclaration
}

func (*PropertyIndexDeclarationContext) IsPropertyIndexDeclarationContext() {}

func NewPropertyIndexDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyIndexDeclarationContext {
	var p = new(PropertyIndexDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyIndexDeclaration

	return p
}

func (s *PropertyIndexDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyIndexDeclarationContext) INDEX() antlr.TerminalNode {
	return s.GetToken(pascalParserINDEX, 0)
}

func (s *PropertyIndexDeclarationContext) UnsignedNumber() IUnsignedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedNumberContext)
}

func (s *PropertyIndexDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyIndexDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyIndexDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyIndexDeclaration(s)
	}
}

func (s *PropertyIndexDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyIndexDeclaration(s)
	}
}

func (s *PropertyIndexDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyIndexDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyIndexDeclaration() (localctx IPropertyIndexDeclarationContext) {
	localctx = NewPropertyIndexDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, pascalParserRULE_propertyIndexDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(911)
		p.Match(pascalParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(912)
		p.UnsignedNumber()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyIndexParametersContext is an interface to support dynamic dispatch.
type IPropertyIndexParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	AllFormalParameterSection() []IFormalParameterSectionContext
	FormalParameterSection(i int) IFormalParameterSectionContext
	RBRACK() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPropertyIndexParametersContext differentiates from other interfaces.
	IsPropertyIndexParametersContext()
}

type PropertyIndexParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyIndexParametersContext() *PropertyIndexParametersContext {
	var p = new(PropertyIndexParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexParameters
	return p
}

func InitEmptyPropertyIndexParametersContext(p *PropertyIndexParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexParameters
}

func (*PropertyIndexParametersContext) IsPropertyIndexParametersContext() {}

func NewPropertyIndexParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyIndexParametersContext {
	var p = new(PropertyIndexParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyIndexParameters

	return p
}

func (s *PropertyIndexParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyIndexParametersContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *PropertyIndexParametersContext) AllFormalParameterSection() []IFormalParameterSectionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormalParameterSectionContext); ok {
			len++
		}
	}

	tst := make([]IFormalParameterSectionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormalParameterSectionContext); ok {
			tst[i] = t.(IFormalParameterSectionContext)
			i++
		}
	}

	return tst
}

func (s *PropertyIndexParametersContext) FormalParameterSection(i int) IFormalParameterSectionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterSectionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterSectionContext)
}

func (s *PropertyIndexParametersContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *PropertyIndexParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *PropertyIndexParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *PropertyIndexParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyIndexParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyIndexParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyIndexParameters(s)
	}
}

func (s *PropertyIndexParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyIndexParameters(s)
	}
}

func (s *PropertyIndexParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyIndexParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyIndexParameters() (localctx IPropertyIndexParametersContext) {
	localctx = NewPropertyIndexParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, pascalParserRULE_propertyIndexParameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(914)
		p.Match(pascalParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(915)
		p.FormalParameterSection()
	}
	p.SetState(920)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(916)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(917)
			p.FormalParameterSection()
		}

		p.SetState(922)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(923)
		p.Match(pascalParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyIndexParametersListContext is an interface to support dynamic dispatch.
type IPropertyIndexParametersListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierList() []IIdentifierListContext
	IdentifierList(i int) IIdentifierListContext
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllIndexType() []IIndexTypeContext
	IndexType(i int) IIndexTypeContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsPropertyIndexParametersListContext differentiates from other interfaces.
	IsPropertyIndexParametersListContext()
}

type PropertyIndexParametersListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyIndexParametersListContext() *PropertyIndexParametersListContext {
	var p = new(PropertyIndexParametersListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexParametersList
	return p
}

func InitEmptyPropertyIndexParametersListContext(p *PropertyIndexParametersListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexParametersList
}

func (*PropertyIndexParametersListContext) IsPropertyIndexParametersListContext() {}

func NewPropertyIndexParametersListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyIndexParametersListContext {
	var p = new(PropertyIndexParametersListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyIndexParametersList

	return p
}

func (s *PropertyIndexParametersListContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyIndexParametersListContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *PropertyIndexParametersListContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PropertyIndexParametersListContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOLON)
}

func (s *PropertyIndexParametersListContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, i)
}

func (s *PropertyIndexParametersListContext) AllIndexType() []IIndexTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexTypeContext); ok {
			len++
		}
	}

	tst := make([]IIndexTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexTypeContext); ok {
			tst[i] = t.(IIndexTypeContext)
			i++
		}
	}

	return tst
}

func (s *PropertyIndexParametersListContext) IndexType(i int) IIndexTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *PropertyIndexParametersListContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *PropertyIndexParametersListContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *PropertyIndexParametersListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyIndexParametersListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyIndexParametersListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyIndexParametersList(s)
	}
}

func (s *PropertyIndexParametersListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyIndexParametersList(s)
	}
}

func (s *PropertyIndexParametersListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyIndexParametersList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyIndexParametersList() (localctx IPropertyIndexParametersListContext) {
	localctx = NewPropertyIndexParametersListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, pascalParserRULE_propertyIndexParametersList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(925)
		p.IdentifierList()
	}
	{
		p.SetState(926)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(927)
		p.IndexType()
	}
	p.SetState(935)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserSEMI {
		{
			p.SetState(928)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(929)
			p.IdentifierList()
		}
		{
			p.SetState(930)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(931)
			p.IndexType()
		}

		p.SetState(937)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericTemplateContext is an interface to support dynamic dispatch.
type IGenericTemplateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	GenericTemplateList() IGenericTemplateListContext
	GT() antlr.TerminalNode

	// IsGenericTemplateContext differentiates from other interfaces.
	IsGenericTemplateContext()
}

type GenericTemplateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericTemplateContext() *GenericTemplateContext {
	var p = new(GenericTemplateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericTemplate
	return p
}

func InitEmptyGenericTemplateContext(p *GenericTemplateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericTemplate
}

func (*GenericTemplateContext) IsGenericTemplateContext() {}

func NewGenericTemplateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericTemplateContext {
	var p = new(GenericTemplateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_genericTemplate

	return p
}

func (s *GenericTemplateContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericTemplateContext) LT() antlr.TerminalNode {
	return s.GetToken(pascalParserLT, 0)
}

func (s *GenericTemplateContext) GenericTemplateList() IGenericTemplateListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericTemplateListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericTemplateListContext)
}

func (s *GenericTemplateContext) GT() antlr.TerminalNode {
	return s.GetToken(pascalParserGT, 0)
}

func (s *GenericTemplateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericTemplateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericTemplateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterGenericTemplate(s)
	}
}

func (s *GenericTemplateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitGenericTemplate(s)
	}
}

func (s *GenericTemplateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitGenericTemplate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) GenericTemplate() (localctx IGenericTemplateContext) {
	localctx = NewGenericTemplateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, pascalParserRULE_genericTemplate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(938)
		p.Match(pascalParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(939)
		p.GenericTemplateList()
	}
	{
		p.SetState(940)
		p.Match(pascalParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericTemplateListContext is an interface to support dynamic dispatch.
type IGenericTemplateListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGenericTypeParameter() []IGenericTypeParameterContext
	GenericTypeParameter(i int) IGenericTypeParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGenericTemplateListContext differentiates from other interfaces.
	IsGenericTemplateListContext()
}

type GenericTemplateListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericTemplateListContext() *GenericTemplateListContext {
	var p = new(GenericTemplateListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericTemplateList
	return p
}

func InitEmptyGenericTemplateListContext(p *GenericTemplateListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericTemplateList
}

func (*GenericTemplateListContext) IsGenericTemplateListContext() {}

func NewGenericTemplateListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericTemplateListContext {
	var p = new(GenericTemplateListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_genericTemplateList

	return p
}

func (s *GenericTemplateListContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericTemplateListContext) AllGenericTypeParameter() []IGenericTypeParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGenericTypeParameterContext); ok {
			len++
		}
	}

	tst := make([]IGenericTypeParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGenericTypeParameterContext); ok {
			tst[i] = t.(IGenericTypeParameterContext)
			i++
		}
	}

	return tst
}

func (s *GenericTemplateListContext) GenericTypeParameter(i int) IGenericTypeParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericTypeParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericTypeParameterContext)
}

func (s *GenericTemplateListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *GenericTemplateListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *GenericTemplateListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericTemplateListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericTemplateListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterGenericTemplateList(s)
	}
}

func (s *GenericTemplateListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitGenericTemplateList(s)
	}
}

func (s *GenericTemplateListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitGenericTemplateList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) GenericTemplateList() (localctx IGenericTemplateListContext) {
	localctx = NewGenericTemplateListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, pascalParserRULE_genericTemplateList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(942)
		p.GenericTypeParameter()
	}
	p.SetState(947)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(943)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(944)
			p.GenericTypeParameter()
		}

		p.SetState(949)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericTypeParameterContext is an interface to support dynamic dispatch.
type IGenericTypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIdentifier() ITypeIdentifierContext
	COLON() antlr.TerminalNode
	GenericConstraints() IGenericConstraintsContext

	// IsGenericTypeParameterContext differentiates from other interfaces.
	IsGenericTypeParameterContext()
}

type GenericTypeParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericTypeParameterContext() *GenericTypeParameterContext {
	var p = new(GenericTypeParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericTypeParameter
	return p
}

func InitEmptyGenericTypeParameterContext(p *GenericTypeParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericTypeParameter
}

func (*GenericTypeParameterContext) IsGenericTypeParameterContext() {}

func NewGenericTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericTypeParameterContext {
	var p = new(GenericTypeParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_genericTypeParameter

	return p
}

func (s *GenericTypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericTypeParameterContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *GenericTypeParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *GenericTypeParameterContext) GenericConstraints() IGenericConstraintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericConstraintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericConstraintsContext)
}

func (s *GenericTypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericTypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericTypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterGenericTypeParameter(s)
	}
}

func (s *GenericTypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitGenericTypeParameter(s)
	}
}

func (s *GenericTypeParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitGenericTypeParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) GenericTypeParameter() (localctx IGenericTypeParameterContext) {
	localctx = NewGenericTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, pascalParserRULE_genericTypeParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(950)
		p.TypeIdentifier()
	}
	p.SetState(953)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserCOLON {
		{
			p.SetState(951)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(952)
			p.GenericConstraints()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericConstraintsContext is an interface to support dynamic dispatch.
type IGenericConstraintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGenericConstraint() []IGenericConstraintContext
	GenericConstraint(i int) IGenericConstraintContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGenericConstraintsContext differentiates from other interfaces.
	IsGenericConstraintsContext()
}

type GenericConstraintsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericConstraintsContext() *GenericConstraintsContext {
	var p = new(GenericConstraintsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericConstraints
	return p
}

func InitEmptyGenericConstraintsContext(p *GenericConstraintsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericConstraints
}

func (*GenericConstraintsContext) IsGenericConstraintsContext() {}

func NewGenericConstraintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericConstraintsContext {
	var p = new(GenericConstraintsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_genericConstraints

	return p
}

func (s *GenericConstraintsContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericConstraintsContext) AllGenericConstraint() []IGenericConstraintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGenericConstraintContext); ok {
			len++
		}
	}

	tst := make([]IGenericConstraintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGenericConstraintContext); ok {
			tst[i] = t.(IGenericConstraintContext)
			i++
		}
	}

	return tst
}

func (s *GenericConstraintsContext) GenericConstraint(i int) IGenericConstraintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericConstraintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericConstraintContext)
}

func (s *GenericConstraintsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *GenericConstraintsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *GenericConstraintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericConstraintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericConstraintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterGenericConstraints(s)
	}
}

func (s *GenericConstraintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitGenericConstraints(s)
	}
}

func (s *GenericConstraintsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitGenericConstraints(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) GenericConstraints() (localctx IGenericConstraintsContext) {
	localctx = NewGenericConstraintsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, pascalParserRULE_genericConstraints)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(955)
		p.GenericConstraint()
	}
	p.SetState(960)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(956)
				p.Match(pascalParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(957)
				p.GenericConstraint()
			}

		}
		p.SetState(962)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericConstraintContext is an interface to support dynamic dispatch.
type IGenericConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONSTRUCTOR() antlr.TerminalNode
	CLASS() antlr.TerminalNode
	RECORD() antlr.TerminalNode
	OF() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext

	// IsGenericConstraintContext differentiates from other interfaces.
	IsGenericConstraintContext()
}

type GenericConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericConstraintContext() *GenericConstraintContext {
	var p = new(GenericConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericConstraint
	return p
}

func InitEmptyGenericConstraintContext(p *GenericConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericConstraint
}

func (*GenericConstraintContext) IsGenericConstraintContext() {}

func NewGenericConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericConstraintContext {
	var p = new(GenericConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_genericConstraint

	return p
}

func (s *GenericConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericConstraintContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(pascalParserCONSTRUCTOR, 0)
}

func (s *GenericConstraintContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *GenericConstraintContext) RECORD() antlr.TerminalNode {
	return s.GetToken(pascalParserRECORD, 0)
}

func (s *GenericConstraintContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *GenericConstraintContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *GenericConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterGenericConstraint(s)
	}
}

func (s *GenericConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitGenericConstraint(s)
	}
}

func (s *GenericConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitGenericConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) GenericConstraint() (localctx IGenericConstraintContext) {
	localctx = NewGenericConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, pascalParserRULE_genericConstraint)
	p.SetState(970)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(963)
			p.Match(pascalParserCONSTRUCTOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(964)
			p.Match(pascalParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(965)
			p.Match(pascalParserRECORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(966)
			p.Match(pascalParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(967)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(968)
			p.TypeIdentifier()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(969)
			p.TypeIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_Context is an interface to support dynamic dispatch.
type IType_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleType() ISimpleTypeContext
	StructuredType() IStructuredTypeContext
	PointerType() IPointerTypeContext

	// IsType_Context differentiates from other interfaces.
	IsType_Context()
}

type Type_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_Context() *Type_Context {
	var p = new(Type_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_type_
	return p
}

func InitEmptyType_Context(p *Type_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_type_
}

func (*Type_Context) IsType_Context() {}

func NewType_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_Context {
	var p = new(Type_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_type_

	return p
}

func (s *Type_Context) GetParser() antlr.Parser { return s.parser }

func (s *Type_Context) SimpleType() ISimpleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeContext)
}

func (s *Type_Context) StructuredType() IStructuredTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructuredTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructuredTypeContext)
}

func (s *Type_Context) PointerType() IPointerTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerTypeContext)
}

func (s *Type_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterType_(s)
	}
}

func (s *Type_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitType_(s)
	}
}

func (s *Type_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitType_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Type_() (localctx IType_Context) {
	localctx = NewType_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, pascalParserRULE_type_)
	p.SetState(975)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(972)
			p.SimpleType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(973)
			p.StructuredType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(974)
			p.PointerType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleTypeContext is an interface to support dynamic dispatch.
type ISimpleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ScalarType() IScalarTypeContext
	SubrangeType() ISubrangeTypeContext
	TypeIdentifier() ITypeIdentifierContext
	Stringtype() IStringtypeContext
	Ansistringtype() IAnsistringtypeContext

	// IsSimpleTypeContext differentiates from other interfaces.
	IsSimpleTypeContext()
}

type SimpleTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleTypeContext() *SimpleTypeContext {
	var p = new(SimpleTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleType
	return p
}

func InitEmptySimpleTypeContext(p *SimpleTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleType
}

func (*SimpleTypeContext) IsSimpleTypeContext() {}

func NewSimpleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleTypeContext {
	var p = new(SimpleTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_simpleType

	return p
}

func (s *SimpleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleTypeContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *SimpleTypeContext) SubrangeType() ISubrangeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubrangeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubrangeTypeContext)
}

func (s *SimpleTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *SimpleTypeContext) Stringtype() IStringtypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringtypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringtypeContext)
}

func (s *SimpleTypeContext) Ansistringtype() IAnsistringtypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnsistringtypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnsistringtypeContext)
}

func (s *SimpleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSimpleType(s)
	}
}

func (s *SimpleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSimpleType(s)
	}
}

func (s *SimpleTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSimpleType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SimpleType() (localctx ISimpleTypeContext) {
	localctx = NewSimpleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, pascalParserRULE_simpleType)
	p.SetState(982)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(977)
			p.ScalarType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(978)
			p.SubrangeType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(979)
			p.TypeIdentifier()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(980)
			p.Stringtype()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(981)
			p.Ansistringtype()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScalarTypeContext is an interface to support dynamic dispatch.
type IScalarTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	ScalerList() IScalerListContext
	RPAREN() antlr.TerminalNode

	// IsScalarTypeContext differentiates from other interfaces.
	IsScalarTypeContext()
}

type ScalarTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalarTypeContext() *ScalarTypeContext {
	var p = new(ScalarTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalarType
	return p
}

func InitEmptyScalarTypeContext(p *ScalarTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalarType
}

func (*ScalarTypeContext) IsScalarTypeContext() {}

func NewScalarTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalarTypeContext {
	var p = new(ScalarTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_scalarType

	return p
}

func (s *ScalarTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalarTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ScalarTypeContext) ScalerList() IScalerListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalerListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalerListContext)
}

func (s *ScalarTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ScalarTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalarTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterScalarType(s)
	}
}

func (s *ScalarTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitScalarType(s)
	}
}

func (s *ScalarTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitScalarType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ScalarType() (localctx IScalarTypeContext) {
	localctx = NewScalarTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, pascalParserRULE_scalarType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(984)
		p.Match(pascalParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(985)
		p.ScalerList()
	}
	{
		p.SetState(986)
		p.Match(pascalParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScalerListContext is an interface to support dynamic dispatch.
type IScalerListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllScalerMember() []IScalerMemberContext
	ScalerMember(i int) IScalerMemberContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsScalerListContext differentiates from other interfaces.
	IsScalerListContext()
}

type ScalerListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalerListContext() *ScalerListContext {
	var p = new(ScalerListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalerList
	return p
}

func InitEmptyScalerListContext(p *ScalerListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalerList
}

func (*ScalerListContext) IsScalerListContext() {}

func NewScalerListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalerListContext {
	var p = new(ScalerListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_scalerList

	return p
}

func (s *ScalerListContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalerListContext) AllScalerMember() []IScalerMemberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScalerMemberContext); ok {
			len++
		}
	}

	tst := make([]IScalerMemberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScalerMemberContext); ok {
			tst[i] = t.(IScalerMemberContext)
			i++
		}
	}

	return tst
}

func (s *ScalerListContext) ScalerMember(i int) IScalerMemberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalerMemberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalerMemberContext)
}

func (s *ScalerListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ScalerListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ScalerListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalerListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalerListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterScalerList(s)
	}
}

func (s *ScalerListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitScalerList(s)
	}
}

func (s *ScalerListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitScalerList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ScalerList() (localctx IScalerListContext) {
	localctx = NewScalerListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, pascalParserRULE_scalerList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(988)
		p.ScalerMember()
	}
	p.SetState(993)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(989)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(990)
			p.ScalerMember()
		}

		p.SetState(995)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScalerMemberContext is an interface to support dynamic dispatch.
type IScalerMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQUAL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsScalerMemberContext differentiates from other interfaces.
	IsScalerMemberContext()
}

type ScalerMemberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalerMemberContext() *ScalerMemberContext {
	var p = new(ScalerMemberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalerMember
	return p
}

func InitEmptyScalerMemberContext(p *ScalerMemberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalerMember
}

func (*ScalerMemberContext) IsScalerMemberContext() {}

func NewScalerMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalerMemberContext {
	var p = new(ScalerMemberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_scalerMember

	return p
}

func (s *ScalerMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalerMemberContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScalerMemberContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *ScalerMemberContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ScalerMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalerMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalerMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterScalerMember(s)
	}
}

func (s *ScalerMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitScalerMember(s)
	}
}

func (s *ScalerMemberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitScalerMember(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ScalerMember() (localctx IScalerMemberContext) {
	localctx = NewScalerMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, pascalParserRULE_scalerMember)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(996)
		p.Identifier()
	}
	p.SetState(999)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserEQUAL {
		{
			p.SetState(997)
			p.Match(pascalParserEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(998)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubrangeTypeContext is an interface to support dynamic dispatch.
type ISubrangeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSimpleExpression() []ISimpleExpressionContext
	SimpleExpression(i int) ISimpleExpressionContext
	DOTDOT() antlr.TerminalNode

	// IsSubrangeTypeContext differentiates from other interfaces.
	IsSubrangeTypeContext()
}

type SubrangeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubrangeTypeContext() *SubrangeTypeContext {
	var p = new(SubrangeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_subrangeType
	return p
}

func InitEmptySubrangeTypeContext(p *SubrangeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_subrangeType
}

func (*SubrangeTypeContext) IsSubrangeTypeContext() {}

func NewSubrangeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubrangeTypeContext {
	var p = new(SubrangeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_subrangeType

	return p
}

func (s *SubrangeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SubrangeTypeContext) AllSimpleExpression() []ISimpleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISimpleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleExpressionContext); ok {
			tst[i] = t.(ISimpleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SubrangeTypeContext) SimpleExpression(i int) ISimpleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExpressionContext)
}

func (s *SubrangeTypeContext) DOTDOT() antlr.TerminalNode {
	return s.GetToken(pascalParserDOTDOT, 0)
}

func (s *SubrangeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubrangeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubrangeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSubrangeType(s)
	}
}

func (s *SubrangeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSubrangeType(s)
	}
}

func (s *SubrangeTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSubrangeType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SubrangeType() (localctx ISubrangeTypeContext) {
	localctx = NewSubrangeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, pascalParserRULE_subrangeType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1001)
		p.SimpleExpression()
	}
	{
		p.SetState(1002)
		p.Match(pascalParserDOTDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1003)
		p.SimpleExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeIdentifierContext is an interface to support dynamic dispatch.
type ITypeIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	CHAR() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	REAL() antlr.TerminalNode
	STRING() antlr.TerminalNode
	CARDINAL() antlr.TerminalNode
	LONGBOOL() antlr.TerminalNode
	LONGINT() antlr.TerminalNode
	LONGWORD() antlr.TerminalNode
	WORD() antlr.TerminalNode
	BYTE() antlr.TerminalNode
	SHORTINT() antlr.TerminalNode
	SMALLINT() antlr.TerminalNode
	INT64() antlr.TerminalNode
	UINT64() antlr.TerminalNode
	SINGLE() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode
	COMP() antlr.TerminalNode
	CURRENCY() antlr.TerminalNode
	ANSICHAR() antlr.TerminalNode
	WIDECHAR() antlr.TerminalNode
	ANSISTRING() antlr.TerminalNode
	WIDESTRING() antlr.TerminalNode
	UNICODESTRING() antlr.TerminalNode
	RAWBYTESTRING() antlr.TerminalNode
	UTF8STRING() antlr.TerminalNode
	VARIANT() antlr.TerminalNode
	OLEVARIANT() antlr.TerminalNode
	POINTER() antlr.TerminalNode
	PCHAR() antlr.TerminalNode
	PANSICHAR() antlr.TerminalNode
	PWIDECHAR() antlr.TerminalNode
	PUNICODECHAR() antlr.TerminalNode
	THANDLE() antlr.TerminalNode
	HWND() antlr.TerminalNode
	HDC() antlr.TerminalNode
	HICON() antlr.TerminalNode
	HBITMAP() antlr.TerminalNode
	HMENU() antlr.TerminalNode
	HINSTANCE() antlr.TerminalNode
	HMODULE() antlr.TerminalNode
	HKEY() antlr.TerminalNode
	DWORD() antlr.TerminalNode
	QWORD() antlr.TerminalNode
	NATIVEINT() antlr.TerminalNode
	NATIVEUINT() antlr.TerminalNode
	CODEPAGE() antlr.TerminalNode
	TGUID() antlr.TerminalNode
	PGUID() antlr.TerminalNode
	TEXTFILE() antlr.TerminalNode
	TEXT() antlr.TerminalNode
	SHORTSTRING() antlr.TerminalNode
	OPENSTRING() antlr.TerminalNode
	ArrayType() IArrayTypeContext

	// IsTypeIdentifierContext differentiates from other interfaces.
	IsTypeIdentifierContext()
}

type TypeIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeIdentifierContext() *TypeIdentifierContext {
	var p = new(TypeIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeIdentifier
	return p
}

func InitEmptyTypeIdentifierContext(p *TypeIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeIdentifier
}

func (*TypeIdentifierContext) IsTypeIdentifierContext() {}

func NewTypeIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeIdentifierContext {
	var p = new(TypeIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typeIdentifier

	return p
}

func (s *TypeIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeIdentifierContext) CHAR() antlr.TerminalNode {
	return s.GetToken(pascalParserCHAR, 0)
}

func (s *TypeIdentifierContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(pascalParserBOOLEAN, 0)
}

func (s *TypeIdentifierContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(pascalParserINTEGER, 0)
}

func (s *TypeIdentifierContext) REAL() antlr.TerminalNode {
	return s.GetToken(pascalParserREAL, 0)
}

func (s *TypeIdentifierContext) STRING() antlr.TerminalNode {
	return s.GetToken(pascalParserSTRING, 0)
}

func (s *TypeIdentifierContext) CARDINAL() antlr.TerminalNode {
	return s.GetToken(pascalParserCARDINAL, 0)
}

func (s *TypeIdentifierContext) LONGBOOL() antlr.TerminalNode {
	return s.GetToken(pascalParserLONGBOOL, 0)
}

func (s *TypeIdentifierContext) LONGINT() antlr.TerminalNode {
	return s.GetToken(pascalParserLONGINT, 0)
}

func (s *TypeIdentifierContext) LONGWORD() antlr.TerminalNode {
	return s.GetToken(pascalParserLONGWORD, 0)
}

func (s *TypeIdentifierContext) WORD() antlr.TerminalNode {
	return s.GetToken(pascalParserWORD, 0)
}

func (s *TypeIdentifierContext) BYTE() antlr.TerminalNode {
	return s.GetToken(pascalParserBYTE, 0)
}

func (s *TypeIdentifierContext) SHORTINT() antlr.TerminalNode {
	return s.GetToken(pascalParserSHORTINT, 0)
}

func (s *TypeIdentifierContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(pascalParserSMALLINT, 0)
}

func (s *TypeIdentifierContext) INT64() antlr.TerminalNode {
	return s.GetToken(pascalParserINT64, 0)
}

func (s *TypeIdentifierContext) UINT64() antlr.TerminalNode {
	return s.GetToken(pascalParserUINT64, 0)
}

func (s *TypeIdentifierContext) SINGLE() antlr.TerminalNode {
	return s.GetToken(pascalParserSINGLE, 0)
}

func (s *TypeIdentifierContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(pascalParserDOUBLE, 0)
}

func (s *TypeIdentifierContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(pascalParserEXTENDED, 0)
}

func (s *TypeIdentifierContext) COMP() antlr.TerminalNode {
	return s.GetToken(pascalParserCOMP, 0)
}

func (s *TypeIdentifierContext) CURRENCY() antlr.TerminalNode {
	return s.GetToken(pascalParserCURRENCY, 0)
}

func (s *TypeIdentifierContext) ANSICHAR() antlr.TerminalNode {
	return s.GetToken(pascalParserANSICHAR, 0)
}

func (s *TypeIdentifierContext) WIDECHAR() antlr.TerminalNode {
	return s.GetToken(pascalParserWIDECHAR, 0)
}

func (s *TypeIdentifierContext) ANSISTRING() antlr.TerminalNode {
	return s.GetToken(pascalParserANSISTRING, 0)
}

func (s *TypeIdentifierContext) WIDESTRING() antlr.TerminalNode {
	return s.GetToken(pascalParserWIDESTRING, 0)
}

func (s *TypeIdentifierContext) UNICODESTRING() antlr.TerminalNode {
	return s.GetToken(pascalParserUNICODESTRING, 0)
}

func (s *TypeIdentifierContext) RAWBYTESTRING() antlr.TerminalNode {
	return s.GetToken(pascalParserRAWBYTESTRING, 0)
}

func (s *TypeIdentifierContext) UTF8STRING() antlr.TerminalNode {
	return s.GetToken(pascalParserUTF8STRING, 0)
}

func (s *TypeIdentifierContext) VARIANT() antlr.TerminalNode {
	return s.GetToken(pascalParserVARIANT, 0)
}

func (s *TypeIdentifierContext) OLEVARIANT() antlr.TerminalNode {
	return s.GetToken(pascalParserOLEVARIANT, 0)
}

func (s *TypeIdentifierContext) POINTER() antlr.TerminalNode {
	return s.GetToken(pascalParserPOINTER, 0)
}

func (s *TypeIdentifierContext) PCHAR() antlr.TerminalNode {
	return s.GetToken(pascalParserPCHAR, 0)
}

func (s *TypeIdentifierContext) PANSICHAR() antlr.TerminalNode {
	return s.GetToken(pascalParserPANSICHAR, 0)
}

func (s *TypeIdentifierContext) PWIDECHAR() antlr.TerminalNode {
	return s.GetToken(pascalParserPWIDECHAR, 0)
}

func (s *TypeIdentifierContext) PUNICODECHAR() antlr.TerminalNode {
	return s.GetToken(pascalParserPUNICODECHAR, 0)
}

func (s *TypeIdentifierContext) THANDLE() antlr.TerminalNode {
	return s.GetToken(pascalParserTHANDLE, 0)
}

func (s *TypeIdentifierContext) HWND() antlr.TerminalNode {
	return s.GetToken(pascalParserHWND, 0)
}

func (s *TypeIdentifierContext) HDC() antlr.TerminalNode {
	return s.GetToken(pascalParserHDC, 0)
}

func (s *TypeIdentifierContext) HICON() antlr.TerminalNode {
	return s.GetToken(pascalParserHICON, 0)
}

func (s *TypeIdentifierContext) HBITMAP() antlr.TerminalNode {
	return s.GetToken(pascalParserHBITMAP, 0)
}

func (s *TypeIdentifierContext) HMENU() antlr.TerminalNode {
	return s.GetToken(pascalParserHMENU, 0)
}

func (s *TypeIdentifierContext) HINSTANCE() antlr.TerminalNode {
	return s.GetToken(pascalParserHINSTANCE, 0)
}

func (s *TypeIdentifierContext) HMODULE() antlr.TerminalNode {
	return s.GetToken(pascalParserHMODULE, 0)
}

func (s *TypeIdentifierContext) HKEY() antlr.TerminalNode {
	return s.GetToken(pascalParserHKEY, 0)
}

func (s *TypeIdentifierContext) DWORD() antlr.TerminalNode {
	return s.GetToken(pascalParserDWORD, 0)
}

func (s *TypeIdentifierContext) QWORD() antlr.TerminalNode {
	return s.GetToken(pascalParserQWORD, 0)
}

func (s *TypeIdentifierContext) NATIVEINT() antlr.TerminalNode {
	return s.GetToken(pascalParserNATIVEINT, 0)
}

func (s *TypeIdentifierContext) NATIVEUINT() antlr.TerminalNode {
	return s.GetToken(pascalParserNATIVEUINT, 0)
}

func (s *TypeIdentifierContext) CODEPAGE() antlr.TerminalNode {
	return s.GetToken(pascalParserCODEPAGE, 0)
}

func (s *TypeIdentifierContext) TGUID() antlr.TerminalNode {
	return s.GetToken(pascalParserTGUID, 0)
}

func (s *TypeIdentifierContext) PGUID() antlr.TerminalNode {
	return s.GetToken(pascalParserPGUID, 0)
}

func (s *TypeIdentifierContext) TEXTFILE() antlr.TerminalNode {
	return s.GetToken(pascalParserTEXTFILE, 0)
}

func (s *TypeIdentifierContext) TEXT() antlr.TerminalNode {
	return s.GetToken(pascalParserTEXT, 0)
}

func (s *TypeIdentifierContext) SHORTSTRING() antlr.TerminalNode {
	return s.GetToken(pascalParserSHORTSTRING, 0)
}

func (s *TypeIdentifierContext) OPENSTRING() antlr.TerminalNode {
	return s.GetToken(pascalParserOPENSTRING, 0)
}

func (s *TypeIdentifierContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *TypeIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypeIdentifier(s)
	}
}

func (s *TypeIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypeIdentifier(s)
	}
}

func (s *TypeIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypeIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypeIdentifier() (localctx ITypeIdentifierContext) {
	localctx = NewTypeIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, pascalParserRULE_typeIdentifier)
	var _la int

	p.SetState(1008)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1005)
			p.Identifier()
		}

	case pascalParserBOOLEAN, pascalParserCHAR, pascalParserINTEGER, pascalParserREAL, pascalParserSTRING, pascalParserCARDINAL, pascalParserLONGBOOL, pascalParserLONGINT, pascalParserLONGWORD, pascalParserWORD, pascalParserBYTE, pascalParserSHORTINT, pascalParserSMALLINT, pascalParserINT64, pascalParserUINT64, pascalParserSINGLE, pascalParserDOUBLE, pascalParserEXTENDED, pascalParserCOMP, pascalParserCURRENCY, pascalParserANSICHAR, pascalParserWIDECHAR, pascalParserANSISTRING, pascalParserWIDESTRING, pascalParserUNICODESTRING, pascalParserRAWBYTESTRING, pascalParserUTF8STRING, pascalParserVARIANT, pascalParserOLEVARIANT, pascalParserPOINTER, pascalParserPCHAR, pascalParserPANSICHAR, pascalParserPWIDECHAR, pascalParserPUNICODECHAR, pascalParserTHANDLE, pascalParserHWND, pascalParserHDC, pascalParserHICON, pascalParserHBITMAP, pascalParserHMENU, pascalParserHINSTANCE, pascalParserHMODULE, pascalParserHKEY, pascalParserDWORD, pascalParserQWORD, pascalParserNATIVEINT, pascalParserNATIVEUINT, pascalParserCODEPAGE, pascalParserTGUID, pascalParserPGUID, pascalParserTEXTFILE, pascalParserTEXT, pascalParserSHORTSTRING, pascalParserOPENSTRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1006)
			_la = p.GetTokenStream().LA(1)

			if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8598323360) != 0) || ((int64((_la-74)) & ^0x3f) == 0 && ((int64(1)<<(_la-74))&-576392582582501375) != 0) || ((int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&549755813887) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case pascalParserARRAY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1007)
			p.ArrayType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructuredTypeContext is an interface to support dynamic dispatch.
type IStructuredTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PACKED() antlr.TerminalNode
	UnpackedStructuredType() IUnpackedStructuredTypeContext
	HelperType() IHelperTypeContext
	ClassType() IClassTypeContext
	RecordType() IRecordTypeContext
	InterfaceType() IInterfaceTypeContext

	// IsStructuredTypeContext differentiates from other interfaces.
	IsStructuredTypeContext()
}

type StructuredTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructuredTypeContext() *StructuredTypeContext {
	var p = new(StructuredTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_structuredType
	return p
}

func InitEmptyStructuredTypeContext(p *StructuredTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_structuredType
}

func (*StructuredTypeContext) IsStructuredTypeContext() {}

func NewStructuredTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructuredTypeContext {
	var p = new(StructuredTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_structuredType

	return p
}

func (s *StructuredTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StructuredTypeContext) PACKED() antlr.TerminalNode {
	return s.GetToken(pascalParserPACKED, 0)
}

func (s *StructuredTypeContext) UnpackedStructuredType() IUnpackedStructuredTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpackedStructuredTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpackedStructuredTypeContext)
}

func (s *StructuredTypeContext) HelperType() IHelperTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelperTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelperTypeContext)
}

func (s *StructuredTypeContext) ClassType() IClassTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTypeContext)
}

func (s *StructuredTypeContext) RecordType() IRecordTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordTypeContext)
}

func (s *StructuredTypeContext) InterfaceType() IInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceTypeContext)
}

func (s *StructuredTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructuredTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructuredTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStructuredType(s)
	}
}

func (s *StructuredTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStructuredType(s)
	}
}

func (s *StructuredTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStructuredType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) StructuredType() (localctx IStructuredTypeContext) {
	localctx = NewStructuredTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, pascalParserRULE_structuredType)
	var _la int

	p.SetState(1020)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1010)
			p.Match(pascalParserPACKED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1011)
			p.UnpackedStructuredType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1012)
			p.UnpackedStructuredType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1013)
			p.HelperType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1014)
			p.ClassType()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1016)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserPACKED {
			{
				p.SetState(1015)
				p.Match(pascalParserPACKED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1018)
			p.RecordType()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1019)
			p.InterfaceType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpackedStructuredTypeContext is an interface to support dynamic dispatch.
type IUnpackedStructuredTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ArrayType() IArrayTypeContext
	SetType() ISetTypeContext
	FileType() IFileTypeContext

	// IsUnpackedStructuredTypeContext differentiates from other interfaces.
	IsUnpackedStructuredTypeContext()
}

type UnpackedStructuredTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpackedStructuredTypeContext() *UnpackedStructuredTypeContext {
	var p = new(UnpackedStructuredTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unpackedStructuredType
	return p
}

func InitEmptyUnpackedStructuredTypeContext(p *UnpackedStructuredTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unpackedStructuredType
}

func (*UnpackedStructuredTypeContext) IsUnpackedStructuredTypeContext() {}

func NewUnpackedStructuredTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpackedStructuredTypeContext {
	var p = new(UnpackedStructuredTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unpackedStructuredType

	return p
}

func (s *UnpackedStructuredTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpackedStructuredTypeContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *UnpackedStructuredTypeContext) SetType() ISetTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetTypeContext)
}

func (s *UnpackedStructuredTypeContext) FileType() IFileTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileTypeContext)
}

func (s *UnpackedStructuredTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpackedStructuredTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpackedStructuredTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnpackedStructuredType(s)
	}
}

func (s *UnpackedStructuredTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnpackedStructuredType(s)
	}
}

func (s *UnpackedStructuredTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnpackedStructuredType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnpackedStructuredType() (localctx IUnpackedStructuredTypeContext) {
	localctx = NewUnpackedStructuredTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, pascalParserRULE_unpackedStructuredType)
	p.SetState(1025)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserARRAY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1022)
			p.ArrayType()
		}

	case pascalParserSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1023)
			p.SetType()
		}

	case pascalParserFILE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1024)
			p.FileType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringtypeContext is an interface to support dynamic dispatch.
type IStringtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	Identifier() IIdentifierContext
	UnsignedNumber() IUnsignedNumberContext

	// IsStringtypeContext differentiates from other interfaces.
	IsStringtypeContext()
}

type StringtypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringtypeContext() *StringtypeContext {
	var p = new(StringtypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_stringtype
	return p
}

func InitEmptyStringtypeContext(p *StringtypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_stringtype
}

func (*StringtypeContext) IsStringtypeContext() {}

func NewStringtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringtypeContext {
	var p = new(StringtypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_stringtype

	return p
}

func (s *StringtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StringtypeContext) STRING() antlr.TerminalNode {
	return s.GetToken(pascalParserSTRING, 0)
}

func (s *StringtypeContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *StringtypeContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *StringtypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StringtypeContext) UnsignedNumber() IUnsignedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedNumberContext)
}

func (s *StringtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStringtype(s)
	}
}

func (s *StringtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStringtype(s)
	}
}

func (s *StringtypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStringtype(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Stringtype() (localctx IStringtypeContext) {
	localctx = NewStringtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, pascalParserRULE_stringtype)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1027)
		p.Match(pascalParserSTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1028)
		p.Match(pascalParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1031)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
		{
			p.SetState(1029)
			p.Identifier()
		}

	case pascalParserNUM_INT, pascalParserNUM_REAL:
		{
			p.SetState(1030)
			p.UnsignedNumber()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1033)
		p.Match(pascalParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnsistringtypeContext is an interface to support dynamic dispatch.
type IAnsistringtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANSISTRING() antlr.TerminalNode
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	Identifier() IIdentifierContext
	UnsignedNumber() IUnsignedNumberContext

	// IsAnsistringtypeContext differentiates from other interfaces.
	IsAnsistringtypeContext()
}

type AnsistringtypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnsistringtypeContext() *AnsistringtypeContext {
	var p = new(AnsistringtypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_ansistringtype
	return p
}

func InitEmptyAnsistringtypeContext(p *AnsistringtypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_ansistringtype
}

func (*AnsistringtypeContext) IsAnsistringtypeContext() {}

func NewAnsistringtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnsistringtypeContext {
	var p = new(AnsistringtypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_ansistringtype

	return p
}

func (s *AnsistringtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *AnsistringtypeContext) ANSISTRING() antlr.TerminalNode {
	return s.GetToken(pascalParserANSISTRING, 0)
}

func (s *AnsistringtypeContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *AnsistringtypeContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *AnsistringtypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AnsistringtypeContext) UnsignedNumber() IUnsignedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedNumberContext)
}

func (s *AnsistringtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnsistringtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnsistringtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAnsistringtype(s)
	}
}

func (s *AnsistringtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAnsistringtype(s)
	}
}

func (s *AnsistringtypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAnsistringtype(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Ansistringtype() (localctx IAnsistringtypeContext) {
	localctx = NewAnsistringtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, pascalParserRULE_ansistringtype)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1035)
		p.Match(pascalParserANSISTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1036)
		p.Match(pascalParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1039)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
		{
			p.SetState(1037)
			p.Identifier()
		}

	case pascalParserNUM_INT, pascalParserNUM_REAL:
		{
			p.SetState(1038)
			p.UnsignedNumber()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1041)
		p.Match(pascalParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY() antlr.TerminalNode
	LBRACK() antlr.TerminalNode
	TypeList() ITypeListContext
	RBRACK() antlr.TerminalNode
	OF() antlr.TerminalNode
	Type_() IType_Context
	EQUAL() antlr.TerminalNode
	ScalarType() IScalarTypeContext
	LBRACK2() antlr.TerminalNode
	RBRACK2() antlr.TerminalNode
	CONST() antlr.TerminalNode

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_arrayType
	return p
}

func InitEmptyArrayTypeContext(p *ArrayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_arrayType
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(pascalParserARRAY, 0)
}

func (s *ArrayTypeContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *ArrayTypeContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *ArrayTypeContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *ArrayTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *ArrayTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ArrayTypeContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *ArrayTypeContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ArrayTypeContext) LBRACK2() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK2, 0)
}

func (s *ArrayTypeContext) RBRACK2() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK2, 0)
}

func (s *ArrayTypeContext) CONST() antlr.TerminalNode {
	return s.GetToken(pascalParserCONST, 0)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (s *ArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, pascalParserRULE_arrayType)
	p.SetState(1069)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1043)
			p.Match(pascalParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1044)
			p.Match(pascalParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1045)
			p.TypeList()
		}
		{
			p.SetState(1046)
			p.Match(pascalParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1047)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1048)
			p.Type_()
		}
		p.SetState(1051)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1049)
				p.Match(pascalParserEQUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1050)
				p.ScalarType()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1053)
			p.Match(pascalParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1054)
			p.Match(pascalParserLBRACK2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1055)
			p.TypeList()
		}
		{
			p.SetState(1056)
			p.Match(pascalParserRBRACK2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1057)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1058)
			p.Type_()
		}
		p.SetState(1061)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1059)
				p.Match(pascalParserEQUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1060)
				p.ScalarType()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1063)
			p.Match(pascalParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1064)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1065)
			p.Match(pascalParserCONST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1066)
			p.Match(pascalParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1067)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1068)
			p.Type_()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIndexType() []IIndexTypeContext
	IndexType(i int) IIndexTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeList
	return p
}

func InitEmptyTypeListContext(p *TypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeList
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllIndexType() []IIndexTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexTypeContext); ok {
			len++
		}
	}

	tst := make([]IIndexTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexTypeContext); ok {
			tst[i] = t.(IIndexTypeContext)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) IndexType(i int) IIndexTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *TypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *TypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypeList(s)
	}
}

func (s *TypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypeList(s)
	}
}

func (s *TypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, pascalParserRULE_typeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1071)
		p.IndexType()
	}
	p.SetState(1076)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(1072)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1073)
			p.IndexType()
		}

		p.SetState(1078)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexTypeContext is an interface to support dynamic dispatch.
type IIndexTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleType() ISimpleTypeContext

	// IsIndexTypeContext differentiates from other interfaces.
	IsIndexTypeContext()
}

type IndexTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexTypeContext() *IndexTypeContext {
	var p = new(IndexTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_indexType
	return p
}

func InitEmptyIndexTypeContext(p *IndexTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_indexType
}

func (*IndexTypeContext) IsIndexTypeContext() {}

func NewIndexTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexTypeContext {
	var p = new(IndexTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_indexType

	return p
}

func (s *IndexTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexTypeContext) SimpleType() ISimpleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeContext)
}

func (s *IndexTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterIndexType(s)
	}
}

func (s *IndexTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitIndexType(s)
	}
}

func (s *IndexTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitIndexType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) IndexType() (localctx IIndexTypeContext) {
	localctx = NewIndexTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, pascalParserRULE_indexType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1079)
		p.SimpleType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordTypeContext is an interface to support dynamic dispatch.
type IRecordTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RECORD() antlr.TerminalNode
	RecordImplicitPublishedDeclaration() IRecordImplicitPublishedDeclarationContext
	END() antlr.TerminalNode
	AllRecordDeclaration() []IRecordDeclarationContext
	RecordDeclaration(i int) IRecordDeclarationContext
	RecordParts() IRecordPartsContext

	// IsRecordTypeContext differentiates from other interfaces.
	IsRecordTypeContext()
}

type RecordTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordTypeContext() *RecordTypeContext {
	var p = new(RecordTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordType
	return p
}

func InitEmptyRecordTypeContext(p *RecordTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordType
}

func (*RecordTypeContext) IsRecordTypeContext() {}

func NewRecordTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordTypeContext {
	var p = new(RecordTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordType

	return p
}

func (s *RecordTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordTypeContext) RECORD() antlr.TerminalNode {
	return s.GetToken(pascalParserRECORD, 0)
}

func (s *RecordTypeContext) RecordImplicitPublishedDeclaration() IRecordImplicitPublishedDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordImplicitPublishedDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordImplicitPublishedDeclarationContext)
}

func (s *RecordTypeContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *RecordTypeContext) AllRecordDeclaration() []IRecordDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IRecordDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordDeclarationContext); ok {
			tst[i] = t.(IRecordDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *RecordTypeContext) RecordDeclaration(i int) IRecordDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDeclarationContext)
}

func (s *RecordTypeContext) RecordParts() IRecordPartsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordPartsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordPartsContext)
}

func (s *RecordTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordType(s)
	}
}

func (s *RecordTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordType(s)
	}
}

func (s *RecordTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordType() (localctx IRecordTypeContext) {
	localctx = NewRecordTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, pascalParserRULE_recordType)
	var _la int

	p.SetState(1096)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1081)
			p.Match(pascalParserRECORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1082)
			p.RecordImplicitPublishedDeclaration()
		}
		p.SetState(1086)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-79)) & ^0x3f) == 0 && ((int64(1)<<(_la-79))&31) != 0 {
			{
				p.SetState(1083)
				p.RecordDeclaration()
			}

			p.SetState(1088)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1089)
			p.Match(pascalParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1091)
			p.Match(pascalParserRECORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1093)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserCASE || ((int64((_la-86)) & ^0x3f) == 0 && ((int64(1)<<(_la-86))&1099511627787) != 0) {
			{
				p.SetState(1092)
				p.RecordParts()
			}

		}
		{
			p.SetState(1095)
			p.Match(pascalParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordDeclarationContext is an interface to support dynamic dispatch.
type IRecordDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AccessSpecifier() IAccessSpecifierContext
	AllRecordDeclarationPart() []IRecordDeclarationPartContext
	RecordDeclarationPart(i int) IRecordDeclarationPartContext

	// IsRecordDeclarationContext differentiates from other interfaces.
	IsRecordDeclarationContext()
}

type RecordDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordDeclarationContext() *RecordDeclarationContext {
	var p = new(RecordDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordDeclaration
	return p
}

func InitEmptyRecordDeclarationContext(p *RecordDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordDeclaration
}

func (*RecordDeclarationContext) IsRecordDeclarationContext() {}

func NewRecordDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordDeclarationContext {
	var p = new(RecordDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordDeclaration

	return p
}

func (s *RecordDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordDeclarationContext) AccessSpecifier() IAccessSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessSpecifierContext)
}

func (s *RecordDeclarationContext) AllRecordDeclarationPart() []IRecordDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IRecordDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordDeclarationPartContext); ok {
			tst[i] = t.(IRecordDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *RecordDeclarationContext) RecordDeclarationPart(i int) IRecordDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDeclarationPartContext)
}

func (s *RecordDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordDeclaration(s)
	}
}

func (s *RecordDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordDeclaration(s)
	}
}

func (s *RecordDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordDeclaration() (localctx IRecordDeclarationContext) {
	localctx = NewRecordDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, pascalParserRULE_recordDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1098)
		p.AccessSpecifier()
	}
	p.SetState(1102)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-32770) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1015809) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&562949953421311) != 0) {
		{
			p.SetState(1099)
			p.RecordDeclarationPart()
		}

		p.SetState(1104)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordImplicitPublishedDeclarationContext is an interface to support dynamic dispatch.
type IRecordImplicitPublishedDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRecordDeclarationPart() []IRecordDeclarationPartContext
	RecordDeclarationPart(i int) IRecordDeclarationPartContext

	// IsRecordImplicitPublishedDeclarationContext differentiates from other interfaces.
	IsRecordImplicitPublishedDeclarationContext()
}

type RecordImplicitPublishedDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordImplicitPublishedDeclarationContext() *RecordImplicitPublishedDeclarationContext {
	var p = new(RecordImplicitPublishedDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordImplicitPublishedDeclaration
	return p
}

func InitEmptyRecordImplicitPublishedDeclarationContext(p *RecordImplicitPublishedDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordImplicitPublishedDeclaration
}

func (*RecordImplicitPublishedDeclarationContext) IsRecordImplicitPublishedDeclarationContext() {}

func NewRecordImplicitPublishedDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordImplicitPublishedDeclarationContext {
	var p = new(RecordImplicitPublishedDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordImplicitPublishedDeclaration

	return p
}

func (s *RecordImplicitPublishedDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordImplicitPublishedDeclarationContext) AllRecordDeclarationPart() []IRecordDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IRecordDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordDeclarationPartContext); ok {
			tst[i] = t.(IRecordDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *RecordImplicitPublishedDeclarationContext) RecordDeclarationPart(i int) IRecordDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDeclarationPartContext)
}

func (s *RecordImplicitPublishedDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordImplicitPublishedDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordImplicitPublishedDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordImplicitPublishedDeclaration(s)
	}
}

func (s *RecordImplicitPublishedDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordImplicitPublishedDeclaration(s)
	}
}

func (s *RecordImplicitPublishedDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordImplicitPublishedDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordImplicitPublishedDeclaration() (localctx IRecordImplicitPublishedDeclarationContext) {
	localctx = NewRecordImplicitPublishedDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, pascalParserRULE_recordImplicitPublishedDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1108)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-32770) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1015809) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&562949953421311) != 0) {
		{
			p.SetState(1105)
			p.RecordDeclarationPart()
		}

		p.SetState(1110)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordDeclarationPartContext is an interface to support dynamic dispatch.
type IRecordDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypedIdentifierList() ITypedIdentifierListContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AttributeSection() IAttributeSectionContext
	TypeDefinitionPart() ITypeDefinitionPartContext
	ConstantDefinitionPart() IConstantDefinitionPartContext
	FunctionHeader() IFunctionHeaderContext
	ProcedureHeader() IProcedureHeaderContext
	ClassOperatorHeader() IClassOperatorHeaderContext
	PropertyDeclaration() IPropertyDeclarationContext
	DEFAULT() antlr.TerminalNode
	ErrorRecordDeclarationPart() IErrorRecordDeclarationPartContext

	// IsRecordDeclarationPartContext differentiates from other interfaces.
	IsRecordDeclarationPartContext()
}

type RecordDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordDeclarationPartContext() *RecordDeclarationPartContext {
	var p = new(RecordDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordDeclarationPart
	return p
}

func InitEmptyRecordDeclarationPartContext(p *RecordDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordDeclarationPart
}

func (*RecordDeclarationPartContext) IsRecordDeclarationPartContext() {}

func NewRecordDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordDeclarationPartContext {
	var p = new(RecordDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordDeclarationPart

	return p
}

func (s *RecordDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordDeclarationPartContext) TypedIdentifierList() ITypedIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIdentifierListContext)
}

func (s *RecordDeclarationPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *RecordDeclarationPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *RecordDeclarationPartContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *RecordDeclarationPartContext) TypeDefinitionPart() ITypeDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionPartContext)
}

func (s *RecordDeclarationPartContext) ConstantDefinitionPart() IConstantDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *RecordDeclarationPartContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *RecordDeclarationPartContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *RecordDeclarationPartContext) ClassOperatorHeader() IClassOperatorHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOperatorHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOperatorHeaderContext)
}

func (s *RecordDeclarationPartContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *RecordDeclarationPartContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *RecordDeclarationPartContext) ErrorRecordDeclarationPart() IErrorRecordDeclarationPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorRecordDeclarationPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorRecordDeclarationPartContext)
}

func (s *RecordDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordDeclarationPart(s)
	}
}

func (s *RecordDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordDeclarationPart(s)
	}
}

func (s *RecordDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordDeclarationPart() (localctx IRecordDeclarationPartContext) {
	localctx = NewRecordDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, pascalParserRULE_recordDeclarationPart)
	var _la int

	p.SetState(1131)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 109, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1112)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1111)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1114)
			p.TypedIdentifierList()
		}
		{
			p.SetState(1115)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1117)
			p.TypeDefinitionPart()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1118)
			p.ConstantDefinitionPart()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1119)
			p.FunctionHeader()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1120)
			p.ProcedureHeader()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1121)
			p.ClassOperatorHeader()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1122)
			p.PropertyDeclaration()
		}
		{
			p.SetState(1123)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1126)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 108, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1124)
				p.Match(pascalParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1125)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1128)
			p.ErrorRecordDeclarationPart()
		}
		{
			p.SetState(1129)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorRecordDeclarationPartContext is an interface to support dynamic dispatch.
type IErrorRecordDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRICT() []antlr.TerminalNode
	STRICT(i int) antlr.TerminalNode
	AllPRIVATE() []antlr.TerminalNode
	PRIVATE(i int) antlr.TerminalNode
	AllPROTECTED() []antlr.TerminalNode
	PROTECTED(i int) antlr.TerminalNode
	AllPUBLIC() []antlr.TerminalNode
	PUBLIC(i int) antlr.TerminalNode
	AllPUBLISHED() []antlr.TerminalNode
	PUBLISHED(i int) antlr.TerminalNode
	AllEND() []antlr.TerminalNode
	END(i int) antlr.TerminalNode

	// IsErrorRecordDeclarationPartContext differentiates from other interfaces.
	IsErrorRecordDeclarationPartContext()
}

type ErrorRecordDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorRecordDeclarationPartContext() *ErrorRecordDeclarationPartContext {
	var p = new(ErrorRecordDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorRecordDeclarationPart
	return p
}

func InitEmptyErrorRecordDeclarationPartContext(p *ErrorRecordDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorRecordDeclarationPart
}

func (*ErrorRecordDeclarationPartContext) IsErrorRecordDeclarationPartContext() {}

func NewErrorRecordDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorRecordDeclarationPartContext {
	var p = new(ErrorRecordDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_errorRecordDeclarationPart

	return p
}

func (s *ErrorRecordDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorRecordDeclarationPartContext) AllSTRICT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTRICT)
}

func (s *ErrorRecordDeclarationPartContext) STRICT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTRICT, i)
}

func (s *ErrorRecordDeclarationPartContext) AllPRIVATE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPRIVATE)
}

func (s *ErrorRecordDeclarationPartContext) PRIVATE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPRIVATE, i)
}

func (s *ErrorRecordDeclarationPartContext) AllPROTECTED() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPROTECTED)
}

func (s *ErrorRecordDeclarationPartContext) PROTECTED(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPROTECTED, i)
}

func (s *ErrorRecordDeclarationPartContext) AllPUBLIC() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPUBLIC)
}

func (s *ErrorRecordDeclarationPartContext) PUBLIC(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLIC, i)
}

func (s *ErrorRecordDeclarationPartContext) AllPUBLISHED() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPUBLISHED)
}

func (s *ErrorRecordDeclarationPartContext) PUBLISHED(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLISHED, i)
}

func (s *ErrorRecordDeclarationPartContext) AllEND() []antlr.TerminalNode {
	return s.GetTokens(pascalParserEND)
}

func (s *ErrorRecordDeclarationPartContext) END(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserEND, i)
}

func (s *ErrorRecordDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorRecordDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorRecordDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterErrorRecordDeclarationPart(s)
	}
}

func (s *ErrorRecordDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitErrorRecordDeclarationPart(s)
	}
}

func (s *ErrorRecordDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitErrorRecordDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ErrorRecordDeclarationPart() (localctx IErrorRecordDeclarationPartContext) {
	localctx = NewErrorRecordDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, pascalParserRULE_errorRecordDeclarationPart)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1134)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1133)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || _la == pascalParserEND || ((int64((_la-79)) & ^0x3f) == 0 && ((int64(1)<<(_la-79))&31) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1136)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordPartsContext is an interface to support dynamic dispatch.
type IRecordPartsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RecordFixedPart() IRecordFixedPartContext
	SEMI() antlr.TerminalNode
	RecordVariantPart() IRecordVariantPartContext

	// IsRecordPartsContext differentiates from other interfaces.
	IsRecordPartsContext()
}

type RecordPartsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordPartsContext() *RecordPartsContext {
	var p = new(RecordPartsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordParts
	return p
}

func InitEmptyRecordPartsContext(p *RecordPartsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordParts
}

func (*RecordPartsContext) IsRecordPartsContext() {}

func NewRecordPartsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordPartsContext {
	var p = new(RecordPartsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordParts

	return p
}

func (s *RecordPartsContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordPartsContext) RecordFixedPart() IRecordFixedPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordFixedPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordFixedPartContext)
}

func (s *RecordPartsContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *RecordPartsContext) RecordVariantPart() IRecordVariantPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordVariantPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordVariantPartContext)
}

func (s *RecordPartsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordPartsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordPartsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordParts(s)
	}
}

func (s *RecordPartsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordParts(s)
	}
}

func (s *RecordPartsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordParts(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordParts() (localctx IRecordPartsContext) {
	localctx = NewRecordPartsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, pascalParserRULE_recordParts)
	var _la int

	p.SetState(1144)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1138)
			p.RecordFixedPart()
		}
		p.SetState(1141)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserSEMI {
			{
				p.SetState(1139)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1140)
				p.RecordVariantPart()
			}

		}

	case pascalParserCASE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1143)
			p.RecordVariantPart()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordFixedPartContext is an interface to support dynamic dispatch.
type IRecordFixedPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypedIdentifierList() []ITypedIdentifierListContext
	TypedIdentifierList(i int) ITypedIdentifierListContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsRecordFixedPartContext differentiates from other interfaces.
	IsRecordFixedPartContext()
}

type RecordFixedPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordFixedPartContext() *RecordFixedPartContext {
	var p = new(RecordFixedPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordFixedPart
	return p
}

func InitEmptyRecordFixedPartContext(p *RecordFixedPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordFixedPart
}

func (*RecordFixedPartContext) IsRecordFixedPartContext() {}

func NewRecordFixedPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordFixedPartContext {
	var p = new(RecordFixedPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordFixedPart

	return p
}

func (s *RecordFixedPartContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordFixedPartContext) AllTypedIdentifierList() []ITypedIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypedIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]ITypedIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypedIdentifierListContext); ok {
			tst[i] = t.(ITypedIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *RecordFixedPartContext) TypedIdentifierList(i int) ITypedIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIdentifierListContext)
}

func (s *RecordFixedPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *RecordFixedPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *RecordFixedPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordFixedPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordFixedPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordFixedPart(s)
	}
}

func (s *RecordFixedPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordFixedPart(s)
	}
}

func (s *RecordFixedPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordFixedPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordFixedPart() (localctx IRecordFixedPartContext) {
	localctx = NewRecordFixedPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, pascalParserRULE_recordFixedPart)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1146)
		p.TypedIdentifierList()
	}
	p.SetState(1151)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1147)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1148)
				p.TypedIdentifierList()
			}

		}
		p.SetState(1153)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1155)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1154)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordVariantPartContext is an interface to support dynamic dispatch.
type IRecordVariantPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	Tag() ITagContext
	OF() antlr.TerminalNode
	AllRecordVariant() []IRecordVariantContext
	RecordVariant(i int) IRecordVariantContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsRecordVariantPartContext differentiates from other interfaces.
	IsRecordVariantPartContext()
}

type RecordVariantPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordVariantPartContext() *RecordVariantPartContext {
	var p = new(RecordVariantPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordVariantPart
	return p
}

func InitEmptyRecordVariantPartContext(p *RecordVariantPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordVariantPart
}

func (*RecordVariantPartContext) IsRecordVariantPartContext() {}

func NewRecordVariantPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordVariantPartContext {
	var p = new(RecordVariantPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordVariantPart

	return p
}

func (s *RecordVariantPartContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordVariantPartContext) CASE() antlr.TerminalNode {
	return s.GetToken(pascalParserCASE, 0)
}

func (s *RecordVariantPartContext) Tag() ITagContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITagContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITagContext)
}

func (s *RecordVariantPartContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *RecordVariantPartContext) AllRecordVariant() []IRecordVariantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordVariantContext); ok {
			len++
		}
	}

	tst := make([]IRecordVariantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordVariantContext); ok {
			tst[i] = t.(IRecordVariantContext)
			i++
		}
	}

	return tst
}

func (s *RecordVariantPartContext) RecordVariant(i int) IRecordVariantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordVariantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordVariantContext)
}

func (s *RecordVariantPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *RecordVariantPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *RecordVariantPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordVariantPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordVariantPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordVariantPart(s)
	}
}

func (s *RecordVariantPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordVariantPart(s)
	}
}

func (s *RecordVariantPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordVariantPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordVariantPart() (localctx IRecordVariantPartContext) {
	localctx = NewRecordVariantPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, pascalParserRULE_recordVariantPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1157)
		p.Match(pascalParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1158)
		p.Tag()
	}
	{
		p.SetState(1159)
		p.Match(pascalParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1160)
		p.RecordVariant()
	}
	p.SetState(1165)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserSEMI {
		{
			p.SetState(1161)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1162)
			p.RecordVariant()
		}

		p.SetState(1167)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITagContext is an interface to support dynamic dispatch.
type ITagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext

	// IsTagContext differentiates from other interfaces.
	IsTagContext()
}

type TagContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTagContext() *TagContext {
	var p = new(TagContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tag
	return p
}

func InitEmptyTagContext(p *TagContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tag
}

func (*TagContext) IsTagContext() {}

func NewTagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TagContext {
	var p = new(TagContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_tag

	return p
}

func (s *TagContext) GetParser() antlr.Parser { return s.parser }

func (s *TagContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TagContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *TagContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *TagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTag(s)
	}
}

func (s *TagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTag(s)
	}
}

func (s *TagContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTag(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Tag() (localctx ITagContext) {
	localctx = NewTagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, pascalParserRULE_tag)
	p.SetState(1173)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 116, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1168)
			p.Identifier()
		}
		{
			p.SetState(1169)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1170)
			p.TypeIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1172)
			p.TypeIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordVariantContext is an interface to support dynamic dispatch.
type IRecordVariantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConstList() IConstListContext
	COLON() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RecordParts() IRecordPartsContext
	RPAREN() antlr.TerminalNode

	// IsRecordVariantContext differentiates from other interfaces.
	IsRecordVariantContext()
}

type RecordVariantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordVariantContext() *RecordVariantContext {
	var p = new(RecordVariantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordVariant
	return p
}

func InitEmptyRecordVariantContext(p *RecordVariantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordVariant
}

func (*RecordVariantContext) IsRecordVariantContext() {}

func NewRecordVariantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordVariantContext {
	var p = new(RecordVariantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordVariant

	return p
}

func (s *RecordVariantContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordVariantContext) ConstList() IConstListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstListContext)
}

func (s *RecordVariantContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *RecordVariantContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *RecordVariantContext) RecordParts() IRecordPartsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordPartsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordPartsContext)
}

func (s *RecordVariantContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *RecordVariantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordVariantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordVariantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordVariant(s)
	}
}

func (s *RecordVariantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordVariant(s)
	}
}

func (s *RecordVariantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordVariant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordVariant() (localctx IRecordVariantContext) {
	localctx = NewRecordVariantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, pascalParserRULE_recordVariant)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1175)
		p.ConstList()
	}
	{
		p.SetState(1176)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1177)
		p.Match(pascalParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1178)
		p.RecordParts()
	}
	{
		p.SetState(1179)
		p.Match(pascalParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHelperTypeContext is an interface to support dynamic dispatch.
type IHelperTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	HELPER() antlr.TerminalNode
	FOR() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	HelperImplicitPublishedDeclaration() IHelperImplicitPublishedDeclarationContext
	END() antlr.TerminalNode
	AllHelperDeclaration() []IHelperDeclarationContext
	HelperDeclaration(i int) IHelperDeclarationContext

	// IsHelperTypeContext differentiates from other interfaces.
	IsHelperTypeContext()
}

type HelperTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelperTypeContext() *HelperTypeContext {
	var p = new(HelperTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperType
	return p
}

func InitEmptyHelperTypeContext(p *HelperTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperType
}

func (*HelperTypeContext) IsHelperTypeContext() {}

func NewHelperTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelperTypeContext {
	var p = new(HelperTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_helperType

	return p
}

func (s *HelperTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *HelperTypeContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *HelperTypeContext) HELPER() antlr.TerminalNode {
	return s.GetToken(pascalParserHELPER, 0)
}

func (s *HelperTypeContext) FOR() antlr.TerminalNode {
	return s.GetToken(pascalParserFOR, 0)
}

func (s *HelperTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *HelperTypeContext) HelperImplicitPublishedDeclaration() IHelperImplicitPublishedDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelperImplicitPublishedDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelperImplicitPublishedDeclarationContext)
}

func (s *HelperTypeContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *HelperTypeContext) AllHelperDeclaration() []IHelperDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHelperDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IHelperDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHelperDeclarationContext); ok {
			tst[i] = t.(IHelperDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *HelperTypeContext) HelperDeclaration(i int) IHelperDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelperDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelperDeclarationContext)
}

func (s *HelperTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelperTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelperTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterHelperType(s)
	}
}

func (s *HelperTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitHelperType(s)
	}
}

func (s *HelperTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitHelperType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) HelperType() (localctx IHelperTypeContext) {
	localctx = NewHelperTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, pascalParserRULE_helperType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1181)
		p.Match(pascalParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1182)
		p.Match(pascalParserHELPER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1183)
		p.Match(pascalParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1184)
		p.TypeIdentifier()
	}
	{
		p.SetState(1185)
		p.HelperImplicitPublishedDeclaration()
	}
	p.SetState(1189)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-79)) & ^0x3f) == 0 && ((int64(1)<<(_la-79))&31) != 0 {
		{
			p.SetState(1186)
			p.HelperDeclaration()
		}

		p.SetState(1191)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1192)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHelperDeclarationContext is an interface to support dynamic dispatch.
type IHelperDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AccessSpecifier() IAccessSpecifierContext
	AllHelperDeclarationPart() []IHelperDeclarationPartContext
	HelperDeclarationPart(i int) IHelperDeclarationPartContext

	// IsHelperDeclarationContext differentiates from other interfaces.
	IsHelperDeclarationContext()
}

type HelperDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelperDeclarationContext() *HelperDeclarationContext {
	var p = new(HelperDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperDeclaration
	return p
}

func InitEmptyHelperDeclarationContext(p *HelperDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperDeclaration
}

func (*HelperDeclarationContext) IsHelperDeclarationContext() {}

func NewHelperDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelperDeclarationContext {
	var p = new(HelperDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_helperDeclaration

	return p
}

func (s *HelperDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *HelperDeclarationContext) AccessSpecifier() IAccessSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessSpecifierContext)
}

func (s *HelperDeclarationContext) AllHelperDeclarationPart() []IHelperDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHelperDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IHelperDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHelperDeclarationPartContext); ok {
			tst[i] = t.(IHelperDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *HelperDeclarationContext) HelperDeclarationPart(i int) IHelperDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelperDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelperDeclarationPartContext)
}

func (s *HelperDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelperDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelperDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterHelperDeclaration(s)
	}
}

func (s *HelperDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitHelperDeclaration(s)
	}
}

func (s *HelperDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitHelperDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) HelperDeclaration() (localctx IHelperDeclarationContext) {
	localctx = NewHelperDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, pascalParserRULE_helperDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1194)
		p.AccessSpecifier()
	}
	p.SetState(1198)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-32770) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1015809) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&562949953421311) != 0) {
		{
			p.SetState(1195)
			p.HelperDeclarationPart()
		}

		p.SetState(1200)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHelperImplicitPublishedDeclarationContext is an interface to support dynamic dispatch.
type IHelperImplicitPublishedDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllHelperDeclarationPart() []IHelperDeclarationPartContext
	HelperDeclarationPart(i int) IHelperDeclarationPartContext

	// IsHelperImplicitPublishedDeclarationContext differentiates from other interfaces.
	IsHelperImplicitPublishedDeclarationContext()
}

type HelperImplicitPublishedDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelperImplicitPublishedDeclarationContext() *HelperImplicitPublishedDeclarationContext {
	var p = new(HelperImplicitPublishedDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperImplicitPublishedDeclaration
	return p
}

func InitEmptyHelperImplicitPublishedDeclarationContext(p *HelperImplicitPublishedDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperImplicitPublishedDeclaration
}

func (*HelperImplicitPublishedDeclarationContext) IsHelperImplicitPublishedDeclarationContext() {}

func NewHelperImplicitPublishedDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelperImplicitPublishedDeclarationContext {
	var p = new(HelperImplicitPublishedDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_helperImplicitPublishedDeclaration

	return p
}

func (s *HelperImplicitPublishedDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *HelperImplicitPublishedDeclarationContext) AllHelperDeclarationPart() []IHelperDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHelperDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IHelperDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHelperDeclarationPartContext); ok {
			tst[i] = t.(IHelperDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *HelperImplicitPublishedDeclarationContext) HelperDeclarationPart(i int) IHelperDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelperDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelperDeclarationPartContext)
}

func (s *HelperImplicitPublishedDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelperImplicitPublishedDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelperImplicitPublishedDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterHelperImplicitPublishedDeclaration(s)
	}
}

func (s *HelperImplicitPublishedDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitHelperImplicitPublishedDeclaration(s)
	}
}

func (s *HelperImplicitPublishedDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitHelperImplicitPublishedDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) HelperImplicitPublishedDeclaration() (localctx IHelperImplicitPublishedDeclarationContext) {
	localctx = NewHelperImplicitPublishedDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, pascalParserRULE_helperImplicitPublishedDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1204)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-32770) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1015809) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&562949953421311) != 0) {
		{
			p.SetState(1201)
			p.HelperDeclarationPart()
		}

		p.SetState(1206)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHelperDeclarationPartContext is an interface to support dynamic dispatch.
type IHelperDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeDefinitionPart() ITypeDefinitionPartContext
	ConstantDefinitionPart() IConstantDefinitionPartContext
	FunctionHeader() IFunctionHeaderContext
	ProcedureHeader() IProcedureHeaderContext
	PropertyDeclaration() IPropertyDeclarationContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	ErrorHelperDeclarationPart() IErrorHelperDeclarationPartContext

	// IsHelperDeclarationPartContext differentiates from other interfaces.
	IsHelperDeclarationPartContext()
}

type HelperDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelperDeclarationPartContext() *HelperDeclarationPartContext {
	var p = new(HelperDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperDeclarationPart
	return p
}

func InitEmptyHelperDeclarationPartContext(p *HelperDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperDeclarationPart
}

func (*HelperDeclarationPartContext) IsHelperDeclarationPartContext() {}

func NewHelperDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelperDeclarationPartContext {
	var p = new(HelperDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_helperDeclarationPart

	return p
}

func (s *HelperDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *HelperDeclarationPartContext) TypeDefinitionPart() ITypeDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionPartContext)
}

func (s *HelperDeclarationPartContext) ConstantDefinitionPart() IConstantDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *HelperDeclarationPartContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *HelperDeclarationPartContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *HelperDeclarationPartContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *HelperDeclarationPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *HelperDeclarationPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *HelperDeclarationPartContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *HelperDeclarationPartContext) ErrorHelperDeclarationPart() IErrorHelperDeclarationPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorHelperDeclarationPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorHelperDeclarationPartContext)
}

func (s *HelperDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelperDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelperDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterHelperDeclarationPart(s)
	}
}

func (s *HelperDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitHelperDeclarationPart(s)
	}
}

func (s *HelperDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitHelperDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) HelperDeclarationPart() (localctx IHelperDeclarationPartContext) {
	localctx = NewHelperDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, pascalParserRULE_helperDeclarationPart)
	p.SetState(1220)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1207)
			p.TypeDefinitionPart()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1208)
			p.ConstantDefinitionPart()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1209)
			p.FunctionHeader()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1210)
			p.ProcedureHeader()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1211)
			p.PropertyDeclaration()
		}
		{
			p.SetState(1212)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1215)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1213)
				p.Match(pascalParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1214)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1217)
			p.ErrorHelperDeclarationPart()
		}
		{
			p.SetState(1218)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorHelperDeclarationPartContext is an interface to support dynamic dispatch.
type IErrorHelperDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRICT() []antlr.TerminalNode
	STRICT(i int) antlr.TerminalNode
	AllPRIVATE() []antlr.TerminalNode
	PRIVATE(i int) antlr.TerminalNode
	AllPROTECTED() []antlr.TerminalNode
	PROTECTED(i int) antlr.TerminalNode
	AllPUBLIC() []antlr.TerminalNode
	PUBLIC(i int) antlr.TerminalNode
	AllPUBLISHED() []antlr.TerminalNode
	PUBLISHED(i int) antlr.TerminalNode
	AllEND() []antlr.TerminalNode
	END(i int) antlr.TerminalNode

	// IsErrorHelperDeclarationPartContext differentiates from other interfaces.
	IsErrorHelperDeclarationPartContext()
}

type ErrorHelperDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorHelperDeclarationPartContext() *ErrorHelperDeclarationPartContext {
	var p = new(ErrorHelperDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorHelperDeclarationPart
	return p
}

func InitEmptyErrorHelperDeclarationPartContext(p *ErrorHelperDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorHelperDeclarationPart
}

func (*ErrorHelperDeclarationPartContext) IsErrorHelperDeclarationPartContext() {}

func NewErrorHelperDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorHelperDeclarationPartContext {
	var p = new(ErrorHelperDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_errorHelperDeclarationPart

	return p
}

func (s *ErrorHelperDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorHelperDeclarationPartContext) AllSTRICT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTRICT)
}

func (s *ErrorHelperDeclarationPartContext) STRICT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTRICT, i)
}

func (s *ErrorHelperDeclarationPartContext) AllPRIVATE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPRIVATE)
}

func (s *ErrorHelperDeclarationPartContext) PRIVATE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPRIVATE, i)
}

func (s *ErrorHelperDeclarationPartContext) AllPROTECTED() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPROTECTED)
}

func (s *ErrorHelperDeclarationPartContext) PROTECTED(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPROTECTED, i)
}

func (s *ErrorHelperDeclarationPartContext) AllPUBLIC() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPUBLIC)
}

func (s *ErrorHelperDeclarationPartContext) PUBLIC(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLIC, i)
}

func (s *ErrorHelperDeclarationPartContext) AllPUBLISHED() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPUBLISHED)
}

func (s *ErrorHelperDeclarationPartContext) PUBLISHED(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLISHED, i)
}

func (s *ErrorHelperDeclarationPartContext) AllEND() []antlr.TerminalNode {
	return s.GetTokens(pascalParserEND)
}

func (s *ErrorHelperDeclarationPartContext) END(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserEND, i)
}

func (s *ErrorHelperDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorHelperDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorHelperDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterErrorHelperDeclarationPart(s)
	}
}

func (s *ErrorHelperDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitErrorHelperDeclarationPart(s)
	}
}

func (s *ErrorHelperDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitErrorHelperDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ErrorHelperDeclarationPart() (localctx IErrorHelperDeclarationPartContext) {
	localctx = NewErrorHelperDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, pascalParserRULE_errorHelperDeclarationPart)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1223)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1222)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || _la == pascalParserEND || ((int64((_la-79)) & ^0x3f) == 0 && ((int64(1)<<(_la-79))&31) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1225)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetTypeContext is an interface to support dynamic dispatch.
type ISetTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	OF() antlr.TerminalNode
	SimpleType() ISimpleTypeContext

	// IsSetTypeContext differentiates from other interfaces.
	IsSetTypeContext()
}

type SetTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetTypeContext() *SetTypeContext {
	var p = new(SetTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_setType
	return p
}

func InitEmptySetTypeContext(p *SetTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_setType
}

func (*SetTypeContext) IsSetTypeContext() {}

func NewSetTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetTypeContext {
	var p = new(SetTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_setType

	return p
}

func (s *SetTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SetTypeContext) SET() antlr.TerminalNode {
	return s.GetToken(pascalParserSET, 0)
}

func (s *SetTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *SetTypeContext) SimpleType() ISimpleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeContext)
}

func (s *SetTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSetType(s)
	}
}

func (s *SetTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSetType(s)
	}
}

func (s *SetTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSetType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SetType() (localctx ISetTypeContext) {
	localctx = NewSetTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, pascalParserRULE_setType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1227)
		p.Match(pascalParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1228)
		p.Match(pascalParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1229)
		p.SimpleType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFileTypeContext is an interface to support dynamic dispatch.
type IFileTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FILE() antlr.TerminalNode
	OF() antlr.TerminalNode
	Type_() IType_Context

	// IsFileTypeContext differentiates from other interfaces.
	IsFileTypeContext()
}

type FileTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileTypeContext() *FileTypeContext {
	var p = new(FileTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_fileType
	return p
}

func InitEmptyFileTypeContext(p *FileTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_fileType
}

func (*FileTypeContext) IsFileTypeContext() {}

func NewFileTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileTypeContext {
	var p = new(FileTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_fileType

	return p
}

func (s *FileTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FileTypeContext) FILE() antlr.TerminalNode {
	return s.GetToken(pascalParserFILE, 0)
}

func (s *FileTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *FileTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *FileTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFileType(s)
	}
}

func (s *FileTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFileType(s)
	}
}

func (s *FileTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFileType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FileType() (localctx IFileTypeContext) {
	localctx = NewFileTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, pascalParserRULE_fileType)
	p.SetState(1235)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1231)
			p.Match(pascalParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1232)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1233)
			p.Type_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1234)
			p.Match(pascalParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPointerTypeContext is an interface to support dynamic dispatch.
type IPointerTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEREFERENCE() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext

	// IsPointerTypeContext differentiates from other interfaces.
	IsPointerTypeContext()
}

type PointerTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPointerTypeContext() *PointerTypeContext {
	var p = new(PointerTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_pointerType
	return p
}

func InitEmptyPointerTypeContext(p *PointerTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_pointerType
}

func (*PointerTypeContext) IsPointerTypeContext() {}

func NewPointerTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PointerTypeContext {
	var p = new(PointerTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_pointerType

	return p
}

func (s *PointerTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PointerTypeContext) DEREFERENCE() antlr.TerminalNode {
	return s.GetToken(pascalParserDEREFERENCE, 0)
}

func (s *PointerTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *PointerTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PointerTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PointerTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPointerType(s)
	}
}

func (s *PointerTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPointerType(s)
	}
}

func (s *PointerTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPointerType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PointerType() (localctx IPointerTypeContext) {
	localctx = NewPointerTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, pascalParserRULE_pointerType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1237)
		p.Match(pascalParserDEREFERENCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1238)
		p.TypeIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationPartContext is an interface to support dynamic dispatch.
type IVariableDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VAR() antlr.TerminalNode
	AllVariableDeclaration() []IVariableDeclarationContext
	VariableDeclaration(i int) IVariableDeclarationContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsVariableDeclarationPartContext differentiates from other interfaces.
	IsVariableDeclarationPartContext()
}

type VariableDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationPartContext() *VariableDeclarationPartContext {
	var p = new(VariableDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclarationPart
	return p
}

func InitEmptyVariableDeclarationPartContext(p *VariableDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclarationPart
}

func (*VariableDeclarationPartContext) IsVariableDeclarationPartContext() {}

func NewVariableDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationPartContext {
	var p = new(VariableDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_variableDeclarationPart

	return p
}

func (s *VariableDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationPartContext) VAR() antlr.TerminalNode {
	return s.GetToken(pascalParserVAR, 0)
}

func (s *VariableDeclarationPartContext) AllVariableDeclaration() []IVariableDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationContext); ok {
			tst[i] = t.(IVariableDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclarationPartContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *VariableDeclarationPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *VariableDeclarationPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *VariableDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterVariableDeclarationPart(s)
	}
}

func (s *VariableDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitVariableDeclarationPart(s)
	}
}

func (s *VariableDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitVariableDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) VariableDeclarationPart() (localctx IVariableDeclarationPartContext) {
	localctx = NewVariableDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, pascalParserRULE_variableDeclarationPart)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1240)
		p.Match(pascalParserVAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1241)
		p.VariableDeclaration()
	}
	p.SetState(1246)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1242)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1243)
				p.VariableDeclaration()
			}

		}
		p.SetState(1248)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1249)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypedIdentifierList() ITypedIdentifierListContext
	AttributeSection() IAttributeSectionContext
	EQUAL() antlr.TerminalNode
	SimpleExpression() ISimpleExpressionContext

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclaration
	return p
}

func InitEmptyVariableDeclarationContext(p *VariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclaration
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) TypedIdentifierList() ITypedIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIdentifierListContext)
}

func (s *VariableDeclarationContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *VariableDeclarationContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *VariableDeclarationContext) SimpleExpression() ISimpleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExpressionContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitVariableDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, pascalParserRULE_variableDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1252)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLBRACK {
		{
			p.SetState(1251)
			p.AttributeSection()
		}

	}
	{
		p.SetState(1254)
		p.TypedIdentifierList()
	}
	p.SetState(1257)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserEQUAL {
		{
			p.SetState(1255)
			p.Match(pascalParserEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1256)
			p.SimpleExpression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureHeaderContext is an interface to support dynamic dispatch.
type IProcedureHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	CONSTRUCTOR() antlr.TerminalNode
	DESTRUCTOR() antlr.TerminalNode
	AttributeSection() IAttributeSectionContext
	CLASS() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext
	AllDeprecatedHint() []IDeprecatedHintContext
	DeprecatedHint(i int) IDeprecatedHintContext

	// IsProcedureHeaderContext differentiates from other interfaces.
	IsProcedureHeaderContext()
}

type ProcedureHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureHeaderContext() *ProcedureHeaderContext {
	var p = new(ProcedureHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureHeader
	return p
}

func InitEmptyProcedureHeaderContext(p *ProcedureHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureHeader
}

func (*ProcedureHeaderContext) IsProcedureHeaderContext() {}

func NewProcedureHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureHeaderContext {
	var p = new(ProcedureHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureHeader

	return p
}

func (s *ProcedureHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureHeaderContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ProcedureHeaderContext) ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderModifiersContext)
}

func (s *ProcedureHeaderContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ProcedureHeaderContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ProcedureHeaderContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(pascalParserPROCEDURE, 0)
}

func (s *ProcedureHeaderContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(pascalParserCONSTRUCTOR, 0)
}

func (s *ProcedureHeaderContext) DESTRUCTOR() antlr.TerminalNode {
	return s.GetToken(pascalParserDESTRUCTOR, 0)
}

func (s *ProcedureHeaderContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *ProcedureHeaderContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *ProcedureHeaderContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ProcedureHeaderContext) AllDeprecatedHint() []IDeprecatedHintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeprecatedHintContext); ok {
			len++
		}
	}

	tst := make([]IDeprecatedHintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeprecatedHintContext); ok {
			tst[i] = t.(IDeprecatedHintContext)
			i++
		}
	}

	return tst
}

func (s *ProcedureHeaderContext) DeprecatedHint(i int) IDeprecatedHintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeprecatedHintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeprecatedHintContext)
}

func (s *ProcedureHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureHeader(s)
	}
}

func (s *ProcedureHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureHeader(s)
	}
}

func (s *ProcedureHeaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureHeader(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureHeader() (localctx IProcedureHeaderContext) {
	localctx = NewProcedureHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, pascalParserRULE_procedureHeader)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1260)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLBRACK {
		{
			p.SetState(1259)
			p.AttributeSection()
		}

	}
	p.SetState(1263)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserCLASS {
		{
			p.SetState(1262)
			p.Match(pascalParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1265)
		_la = p.GetTokenStream().LA(1)

		if !(_la == pascalParserPROCEDURE || _la == pascalParserCONSTRUCTOR || _la == pascalParserDESTRUCTOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1266)
		p.Identifier()
	}
	p.SetState(1268)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1267)
			p.FormalParameterList()
		}

	}
	p.SetState(1272)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 130, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1270)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1271)
			p.DeprecatedHint()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1274)
		p.ProcedureOrFunctionHeaderModifiers()
	}
	{
		p.SetState(1275)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1279)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 131, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1276)
			p.DeprecatedHint()
		}
		{
			p.SetState(1277)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionHeaderContext is an interface to support dynamic dispatch.
type IFunctionHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNCTION() antlr.TerminalNode
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	ResultType() IResultTypeContext
	ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AttributeSection() IAttributeSectionContext
	CLASS() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext
	AllDeprecatedHint() []IDeprecatedHintContext
	DeprecatedHint(i int) IDeprecatedHintContext

	// IsFunctionHeaderContext differentiates from other interfaces.
	IsFunctionHeaderContext()
}

type FunctionHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionHeaderContext() *FunctionHeaderContext {
	var p = new(FunctionHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionHeader
	return p
}

func InitEmptyFunctionHeaderContext(p *FunctionHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionHeader
}

func (*FunctionHeaderContext) IsFunctionHeaderContext() {}

func NewFunctionHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionHeaderContext {
	var p = new(FunctionHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_functionHeader

	return p
}

func (s *FunctionHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionHeaderContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(pascalParserFUNCTION, 0)
}

func (s *FunctionHeaderContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionHeaderContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *FunctionHeaderContext) ResultType() IResultTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultTypeContext)
}

func (s *FunctionHeaderContext) ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderModifiersContext)
}

func (s *FunctionHeaderContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *FunctionHeaderContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *FunctionHeaderContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *FunctionHeaderContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *FunctionHeaderContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionHeaderContext) AllDeprecatedHint() []IDeprecatedHintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeprecatedHintContext); ok {
			len++
		}
	}

	tst := make([]IDeprecatedHintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeprecatedHintContext); ok {
			tst[i] = t.(IDeprecatedHintContext)
			i++
		}
	}

	return tst
}

func (s *FunctionHeaderContext) DeprecatedHint(i int) IDeprecatedHintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeprecatedHintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeprecatedHintContext)
}

func (s *FunctionHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFunctionHeader(s)
	}
}

func (s *FunctionHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFunctionHeader(s)
	}
}

func (s *FunctionHeaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFunctionHeader(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FunctionHeader() (localctx IFunctionHeaderContext) {
	localctx = NewFunctionHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, pascalParserRULE_functionHeader)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1282)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLBRACK {
		{
			p.SetState(1281)
			p.AttributeSection()
		}

	}
	p.SetState(1285)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserCLASS {
		{
			p.SetState(1284)
			p.Match(pascalParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1287)
		p.Match(pascalParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1288)
		p.Identifier()
	}
	p.SetState(1290)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1289)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1292)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1293)
		p.ResultType()
	}
	p.SetState(1296)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1294)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1295)
			p.DeprecatedHint()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1298)
		p.ProcedureOrFunctionHeaderModifiers()
	}
	{
		p.SetState(1299)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1303)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1300)
			p.DeprecatedHint()
		}
		{
			p.SetState(1301)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureOrFunctionHeaderContext is an interface to support dynamic dispatch.
type IProcedureOrFunctionHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ProcedureHeader() IProcedureHeaderContext
	FunctionHeader() IFunctionHeaderContext

	// IsProcedureOrFunctionHeaderContext differentiates from other interfaces.
	IsProcedureOrFunctionHeaderContext()
}

type ProcedureOrFunctionHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureOrFunctionHeaderContext() *ProcedureOrFunctionHeaderContext {
	var p = new(ProcedureOrFunctionHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeader
	return p
}

func InitEmptyProcedureOrFunctionHeaderContext(p *ProcedureOrFunctionHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeader
}

func (*ProcedureOrFunctionHeaderContext) IsProcedureOrFunctionHeaderContext() {}

func NewProcedureOrFunctionHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureOrFunctionHeaderContext {
	var p = new(ProcedureOrFunctionHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeader

	return p
}

func (s *ProcedureOrFunctionHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureOrFunctionHeaderContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *ProcedureOrFunctionHeaderContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *ProcedureOrFunctionHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureOrFunctionHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureOrFunctionHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureOrFunctionHeader(s)
	}
}

func (s *ProcedureOrFunctionHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureOrFunctionHeader(s)
	}
}

func (s *ProcedureOrFunctionHeaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureOrFunctionHeader(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureOrFunctionHeader() (localctx IProcedureOrFunctionHeaderContext) {
	localctx = NewProcedureOrFunctionHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, pascalParserRULE_procedureOrFunctionHeader)
	p.SetState(1307)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 137, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1305)
			p.ProcedureHeader()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1306)
			p.FunctionHeader()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureOrFunctionHeaderModifiersContext is an interface to support dynamic dispatch.
type IProcedureOrFunctionHeaderModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AllABSTRACT() []antlr.TerminalNode
	ABSTRACT(i int) antlr.TerminalNode
	AllVIRTUAL() []antlr.TerminalNode
	VIRTUAL(i int) antlr.TerminalNode
	AllOVERRIDE() []antlr.TerminalNode
	OVERRIDE(i int) antlr.TerminalNode
	AllREINTRODUCE() []antlr.TerminalNode
	REINTRODUCE(i int) antlr.TerminalNode
	AllOVERLOAD() []antlr.TerminalNode
	OVERLOAD(i int) antlr.TerminalNode
	AllINLINE() []antlr.TerminalNode
	INLINE(i int) antlr.TerminalNode
	AllSTDCALL() []antlr.TerminalNode
	STDCALL(i int) antlr.TerminalNode
	AllCDECL() []antlr.TerminalNode
	CDECL(i int) antlr.TerminalNode
	AllSTATIC() []antlr.TerminalNode
	STATIC(i int) antlr.TerminalNode

	// IsProcedureOrFunctionHeaderModifiersContext differentiates from other interfaces.
	IsProcedureOrFunctionHeaderModifiersContext()
}

type ProcedureOrFunctionHeaderModifiersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureOrFunctionHeaderModifiersContext() *ProcedureOrFunctionHeaderModifiersContext {
	var p = new(ProcedureOrFunctionHeaderModifiersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeaderModifiers
	return p
}

func InitEmptyProcedureOrFunctionHeaderModifiersContext(p *ProcedureOrFunctionHeaderModifiersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeaderModifiers
}

func (*ProcedureOrFunctionHeaderModifiersContext) IsProcedureOrFunctionHeaderModifiersContext() {}

func NewProcedureOrFunctionHeaderModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureOrFunctionHeaderModifiersContext {
	var p = new(ProcedureOrFunctionHeaderModifiersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeaderModifiers

	return p
}

func (s *ProcedureOrFunctionHeaderModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureOrFunctionHeaderModifiersContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllABSTRACT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserABSTRACT)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) ABSTRACT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserABSTRACT, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllVIRTUAL() []antlr.TerminalNode {
	return s.GetTokens(pascalParserVIRTUAL)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) VIRTUAL(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserVIRTUAL, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllOVERRIDE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserOVERRIDE)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) OVERRIDE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserOVERRIDE, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllREINTRODUCE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserREINTRODUCE)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) REINTRODUCE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserREINTRODUCE, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllOVERLOAD() []antlr.TerminalNode {
	return s.GetTokens(pascalParserOVERLOAD)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) OVERLOAD(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserOVERLOAD, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllINLINE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserINLINE)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) INLINE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserINLINE, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllSTDCALL() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTDCALL)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) STDCALL(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTDCALL, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllCDECL() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCDECL)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) CDECL(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCDECL, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllSTATIC() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTATIC)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) STATIC(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTATIC, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureOrFunctionHeaderModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureOrFunctionHeaderModifiers(s)
	}
}

func (s *ProcedureOrFunctionHeaderModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureOrFunctionHeaderModifiers(s)
	}
}

func (s *ProcedureOrFunctionHeaderModifiersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureOrFunctionHeaderModifiers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureOrFunctionHeaderModifiers() (localctx IProcedureOrFunctionHeaderModifiersContext) {
	localctx = NewProcedureOrFunctionHeaderModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, pascalParserRULE_procedureOrFunctionHeaderModifiers)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1313)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 138, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1309)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1310)
				_la = p.GetTokenStream().LA(1)

				if !((int64((_la-98)) & ^0x3f) == 0 && ((int64(1)<<(_la-98))&511) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1315)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 138, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureOrFunctionDeclarationContext is an interface to support dynamic dispatch.
type IProcedureOrFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ProcedureDeclaration() IProcedureDeclarationContext
	FunctionDeclaration() IFunctionDeclarationContext

	// IsProcedureOrFunctionDeclarationContext differentiates from other interfaces.
	IsProcedureOrFunctionDeclarationContext()
}

type ProcedureOrFunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureOrFunctionDeclarationContext() *ProcedureOrFunctionDeclarationContext {
	var p = new(ProcedureOrFunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionDeclaration
	return p
}

func InitEmptyProcedureOrFunctionDeclarationContext(p *ProcedureOrFunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionDeclaration
}

func (*ProcedureOrFunctionDeclarationContext) IsProcedureOrFunctionDeclarationContext() {}

func NewProcedureOrFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureOrFunctionDeclarationContext {
	var p = new(ProcedureOrFunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureOrFunctionDeclaration

	return p
}

func (s *ProcedureOrFunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureOrFunctionDeclarationContext) ProcedureDeclaration() IProcedureDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureDeclarationContext)
}

func (s *ProcedureOrFunctionDeclarationContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *ProcedureOrFunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureOrFunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureOrFunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureOrFunctionDeclaration(s)
	}
}

func (s *ProcedureOrFunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureOrFunctionDeclaration(s)
	}
}

func (s *ProcedureOrFunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureOrFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureOrFunctionDeclaration() (localctx IProcedureOrFunctionDeclarationContext) {
	localctx = NewProcedureOrFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, pascalParserRULE_procedureOrFunctionDeclaration)
	p.SetState(1318)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 139, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1316)
			p.ProcedureDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1317)
			p.FunctionDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureDeclarationContext is an interface to support dynamic dispatch.
type IProcedureDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ProcedureHeader() IProcedureHeaderContext
	ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext
	SEMI() antlr.TerminalNode

	// IsProcedureDeclarationContext differentiates from other interfaces.
	IsProcedureDeclarationContext()
}

type ProcedureDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDeclarationContext() *ProcedureDeclarationContext {
	var p = new(ProcedureDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureDeclaration
	return p
}

func InitEmptyProcedureDeclarationContext(p *ProcedureDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureDeclaration
}

func (*ProcedureDeclarationContext) IsProcedureDeclarationContext() {}

func NewProcedureDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDeclarationContext {
	var p = new(ProcedureDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureDeclaration

	return p
}

func (s *ProcedureDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDeclarationContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *ProcedureDeclarationContext) ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionBodyContext)
}

func (s *ProcedureDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ProcedureDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureDeclaration(s)
	}
}

func (s *ProcedureDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureDeclaration(s)
	}
}

func (s *ProcedureDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureDeclaration() (localctx IProcedureDeclarationContext) {
	localctx = NewProcedureDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, pascalParserRULE_procedureDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1320)
		p.ProcedureHeader()
	}
	{
		p.SetState(1321)
		p.ProcedureOrFunctionBody()
	}
	{
		p.SetState(1322)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionHeader() IFunctionHeaderContext
	ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext
	SEMI() antlr.TerminalNode

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionDeclaration
	return p
}

func InitEmptyFunctionDeclarationContext(p *FunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionDeclaration
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *FunctionDeclarationContext) ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionBodyContext)
}

func (s *FunctionDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, pascalParserRULE_functionDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1324)
		p.FunctionHeader()
	}
	{
		p.SetState(1325)
		p.ProcedureOrFunctionBody()
	}
	{
		p.SetState(1326)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureLambdaDeclarationContext is an interface to support dynamic dispatch.
type IProcedureLambdaDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROCEDURE() antlr.TerminalNode
	ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext
	FormalParameterList() IFormalParameterListContext

	// IsProcedureLambdaDeclarationContext differentiates from other interfaces.
	IsProcedureLambdaDeclarationContext()
}

type ProcedureLambdaDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureLambdaDeclarationContext() *ProcedureLambdaDeclarationContext {
	var p = new(ProcedureLambdaDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureLambdaDeclaration
	return p
}

func InitEmptyProcedureLambdaDeclarationContext(p *ProcedureLambdaDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureLambdaDeclaration
}

func (*ProcedureLambdaDeclarationContext) IsProcedureLambdaDeclarationContext() {}

func NewProcedureLambdaDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureLambdaDeclarationContext {
	var p = new(ProcedureLambdaDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureLambdaDeclaration

	return p
}

func (s *ProcedureLambdaDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureLambdaDeclarationContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(pascalParserPROCEDURE, 0)
}

func (s *ProcedureLambdaDeclarationContext) ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionBodyContext)
}

func (s *ProcedureLambdaDeclarationContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ProcedureLambdaDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureLambdaDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureLambdaDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureLambdaDeclaration(s)
	}
}

func (s *ProcedureLambdaDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureLambdaDeclaration(s)
	}
}

func (s *ProcedureLambdaDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureLambdaDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureLambdaDeclaration() (localctx IProcedureLambdaDeclarationContext) {
	localctx = NewProcedureLambdaDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, pascalParserRULE_procedureLambdaDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1328)
		p.Match(pascalParserPROCEDURE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1330)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1329)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1332)
		p.ProcedureOrFunctionBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionLambdaDeclarationContext is an interface to support dynamic dispatch.
type IFunctionLambdaDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNCTION() antlr.TerminalNode
	COLON() antlr.TerminalNode
	ResultType() IResultTypeContext
	ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext
	FormalParameterList() IFormalParameterListContext

	// IsFunctionLambdaDeclarationContext differentiates from other interfaces.
	IsFunctionLambdaDeclarationContext()
}

type FunctionLambdaDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionLambdaDeclarationContext() *FunctionLambdaDeclarationContext {
	var p = new(FunctionLambdaDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionLambdaDeclaration
	return p
}

func InitEmptyFunctionLambdaDeclarationContext(p *FunctionLambdaDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionLambdaDeclaration
}

func (*FunctionLambdaDeclarationContext) IsFunctionLambdaDeclarationContext() {}

func NewFunctionLambdaDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionLambdaDeclarationContext {
	var p = new(FunctionLambdaDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_functionLambdaDeclaration

	return p
}

func (s *FunctionLambdaDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionLambdaDeclarationContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(pascalParserFUNCTION, 0)
}

func (s *FunctionLambdaDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *FunctionLambdaDeclarationContext) ResultType() IResultTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultTypeContext)
}

func (s *FunctionLambdaDeclarationContext) ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionBodyContext)
}

func (s *FunctionLambdaDeclarationContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionLambdaDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionLambdaDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionLambdaDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFunctionLambdaDeclaration(s)
	}
}

func (s *FunctionLambdaDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFunctionLambdaDeclaration(s)
	}
}

func (s *FunctionLambdaDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFunctionLambdaDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FunctionLambdaDeclaration() (localctx IFunctionLambdaDeclarationContext) {
	localctx = NewFunctionLambdaDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, pascalParserRULE_functionLambdaDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1334)
		p.Match(pascalParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1336)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1335)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1338)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1339)
		p.ResultType()
	}
	{
		p.SetState(1340)
		p.ProcedureOrFunctionBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResultTypeContext is an interface to support dynamic dispatch.
type IResultTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIdentifier() ITypeIdentifierContext

	// IsResultTypeContext differentiates from other interfaces.
	IsResultTypeContext()
}

type ResultTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResultTypeContext() *ResultTypeContext {
	var p = new(ResultTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resultType
	return p
}

func InitEmptyResultTypeContext(p *ResultTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resultType
}

func (*ResultTypeContext) IsResultTypeContext() {}

func NewResultTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResultTypeContext {
	var p = new(ResultTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_resultType

	return p
}

func (s *ResultTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ResultTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ResultTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResultTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResultTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterResultType(s)
	}
}

func (s *ResultTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitResultType(s)
	}
}

func (s *ResultTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitResultType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ResultType() (localctx IResultTypeContext) {
	localctx = NewResultTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, pascalParserRULE_resultType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1342)
		p.TypeIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureOrFunctionBodyContext is an interface to support dynamic dispatch.
type IProcedureOrFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	CompoundStatement() ICompoundStatementContext

	// IsProcedureOrFunctionBodyContext differentiates from other interfaces.
	IsProcedureOrFunctionBodyContext()
}

type ProcedureOrFunctionBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureOrFunctionBodyContext() *ProcedureOrFunctionBodyContext {
	var p = new(ProcedureOrFunctionBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionBody
	return p
}

func InitEmptyProcedureOrFunctionBodyContext(p *ProcedureOrFunctionBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionBody
}

func (*ProcedureOrFunctionBodyContext) IsProcedureOrFunctionBodyContext() {}

func NewProcedureOrFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureOrFunctionBodyContext {
	var p = new(ProcedureOrFunctionBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureOrFunctionBody

	return p
}

func (s *ProcedureOrFunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureOrFunctionBodyContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ProcedureOrFunctionBodyContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *ProcedureOrFunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureOrFunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureOrFunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureOrFunctionBody(s)
	}
}

func (s *ProcedureOrFunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureOrFunctionBody(s)
	}
}

func (s *ProcedureOrFunctionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureOrFunctionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureOrFunctionBody() (localctx IProcedureOrFunctionBodyContext) {
	localctx = NewProcedureOrFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, pascalParserRULE_procedureOrFunctionBody)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1344)
		p.Block()
	}
	{
		p.SetState(1345)
		p.CompoundStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassOperatorHeaderContext is an interface to support dynamic dispatch.
type IClassOperatorHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	OPERATOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	ResultType() IResultTypeContext
	ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext
	SEMI() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext

	// IsClassOperatorHeaderContext differentiates from other interfaces.
	IsClassOperatorHeaderContext()
}

type ClassOperatorHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOperatorHeaderContext() *ClassOperatorHeaderContext {
	var p = new(ClassOperatorHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classOperatorHeader
	return p
}

func InitEmptyClassOperatorHeaderContext(p *ClassOperatorHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classOperatorHeader
}

func (*ClassOperatorHeaderContext) IsClassOperatorHeaderContext() {}

func NewClassOperatorHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOperatorHeaderContext {
	var p = new(ClassOperatorHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classOperatorHeader

	return p
}

func (s *ClassOperatorHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOperatorHeaderContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *ClassOperatorHeaderContext) OPERATOR() antlr.TerminalNode {
	return s.GetToken(pascalParserOPERATOR, 0)
}

func (s *ClassOperatorHeaderContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassOperatorHeaderContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *ClassOperatorHeaderContext) ResultType() IResultTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultTypeContext)
}

func (s *ClassOperatorHeaderContext) ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderModifiersContext)
}

func (s *ClassOperatorHeaderContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ClassOperatorHeaderContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ClassOperatorHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOperatorHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOperatorHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassOperatorHeader(s)
	}
}

func (s *ClassOperatorHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassOperatorHeader(s)
	}
}

func (s *ClassOperatorHeaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassOperatorHeader(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassOperatorHeader() (localctx IClassOperatorHeaderContext) {
	localctx = NewClassOperatorHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, pascalParserRULE_classOperatorHeader)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1347)
		p.Match(pascalParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1348)
		p.Match(pascalParserOPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1349)
		p.Identifier()
	}
	p.SetState(1351)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1350)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1353)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1354)
		p.ResultType()
	}
	{
		p.SetState(1355)
		p.ProcedureOrFunctionHeaderModifiers()
	}
	{
		p.SetState(1356)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassOperatorDeclarationContext is an interface to support dynamic dispatch.
type IClassOperatorDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassOperatorHeader() IClassOperatorHeaderContext
	ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext
	SEMI() antlr.TerminalNode

	// IsClassOperatorDeclarationContext differentiates from other interfaces.
	IsClassOperatorDeclarationContext()
}

type ClassOperatorDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOperatorDeclarationContext() *ClassOperatorDeclarationContext {
	var p = new(ClassOperatorDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classOperatorDeclaration
	return p
}

func InitEmptyClassOperatorDeclarationContext(p *ClassOperatorDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classOperatorDeclaration
}

func (*ClassOperatorDeclarationContext) IsClassOperatorDeclarationContext() {}

func NewClassOperatorDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOperatorDeclarationContext {
	var p = new(ClassOperatorDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classOperatorDeclaration

	return p
}

func (s *ClassOperatorDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOperatorDeclarationContext) ClassOperatorHeader() IClassOperatorHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOperatorHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOperatorHeaderContext)
}

func (s *ClassOperatorDeclarationContext) ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionBodyContext)
}

func (s *ClassOperatorDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ClassOperatorDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOperatorDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOperatorDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassOperatorDeclaration(s)
	}
}

func (s *ClassOperatorDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassOperatorDeclaration(s)
	}
}

func (s *ClassOperatorDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassOperatorDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassOperatorDeclaration() (localctx IClassOperatorDeclarationContext) {
	localctx = NewClassOperatorDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, pascalParserRULE_classOperatorDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1358)
		p.ClassOperatorHeader()
	}
	{
		p.SetState(1359)
		p.ProcedureOrFunctionBody()
	}
	{
		p.SetState(1360)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllFormalParameterSection() []IFormalParameterSectionContext
	FormalParameterSection(i int) IFormalParameterSectionContext
	RPAREN() antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_formalParameterList
	return p
}

func InitEmptyFormalParameterListContext(p *FormalParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_formalParameterList
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *FormalParameterListContext) AllFormalParameterSection() []IFormalParameterSectionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormalParameterSectionContext); ok {
			len++
		}
	}

	tst := make([]IFormalParameterSectionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormalParameterSectionContext); ok {
			tst[i] = t.(IFormalParameterSectionContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameterSection(i int) IFormalParameterSectionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterSectionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterSectionContext)
}

func (s *FormalParameterListContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *FormalParameterListContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *FormalParameterListContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFormalParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FormalParameterList() (localctx IFormalParameterListContext) {
	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, pascalParserRULE_formalParameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1362)
		p.Match(pascalParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1363)
		p.FormalParameterSection()
	}
	p.SetState(1368)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserSEMI {
		{
			p.SetState(1364)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1365)
			p.FormalParameterSection()
		}

		p.SetState(1370)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1371)
		p.Match(pascalParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterSectionContext is an interface to support dynamic dispatch.
type IFormalParameterSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParameterGroup() IParameterGroupContext
	AttributeSection() IAttributeSectionContext
	VAR() antlr.TerminalNode
	CONST() antlr.TerminalNode
	OUT() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode

	// IsFormalParameterSectionContext differentiates from other interfaces.
	IsFormalParameterSectionContext()
}

type FormalParameterSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterSectionContext() *FormalParameterSectionContext {
	var p = new(FormalParameterSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_formalParameterSection
	return p
}

func InitEmptyFormalParameterSectionContext(p *FormalParameterSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_formalParameterSection
}

func (*FormalParameterSectionContext) IsFormalParameterSectionContext() {}

func NewFormalParameterSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterSectionContext {
	var p = new(FormalParameterSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_formalParameterSection

	return p
}

func (s *FormalParameterSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterSectionContext) ParameterGroup() IParameterGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterGroupContext)
}

func (s *FormalParameterSectionContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *FormalParameterSectionContext) VAR() antlr.TerminalNode {
	return s.GetToken(pascalParserVAR, 0)
}

func (s *FormalParameterSectionContext) CONST() antlr.TerminalNode {
	return s.GetToken(pascalParserCONST, 0)
}

func (s *FormalParameterSectionContext) OUT() antlr.TerminalNode {
	return s.GetToken(pascalParserOUT, 0)
}

func (s *FormalParameterSectionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(pascalParserFUNCTION, 0)
}

func (s *FormalParameterSectionContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(pascalParserPROCEDURE, 0)
}

func (s *FormalParameterSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFormalParameterSection(s)
	}
}

func (s *FormalParameterSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFormalParameterSection(s)
	}
}

func (s *FormalParameterSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFormalParameterSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FormalParameterSection() (localctx IFormalParameterSectionContext) {
	localctx = NewFormalParameterSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, pascalParserRULE_formalParameterSection)
	var _la int

	p.SetState(1402)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 150, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1374)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1373)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1376)
			p.ParameterGroup()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1378)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1377)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1380)
			p.Match(pascalParserVAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1381)
			p.ParameterGroup()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1383)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1382)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1385)
			p.Match(pascalParserCONST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1386)
			p.ParameterGroup()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1388)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1387)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1390)
			p.Match(pascalParserOUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1391)
			p.ParameterGroup()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1393)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1392)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1395)
			p.Match(pascalParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1396)
			p.ParameterGroup()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1398)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1397)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1400)
			p.Match(pascalParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1401)
			p.ParameterGroup()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterGroupContext is an interface to support dynamic dispatch.
type IParameterGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierList() IIdentifierListContext
	COLON() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	DefaultValue() IDefaultValueContext

	// IsParameterGroupContext differentiates from other interfaces.
	IsParameterGroupContext()
}

type ParameterGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterGroupContext() *ParameterGroupContext {
	var p = new(ParameterGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterGroup
	return p
}

func InitEmptyParameterGroupContext(p *ParameterGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterGroup
}

func (*ParameterGroupContext) IsParameterGroupContext() {}

func NewParameterGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterGroupContext {
	var p = new(ParameterGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_parameterGroup

	return p
}

func (s *ParameterGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterGroupContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ParameterGroupContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *ParameterGroupContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ParameterGroupContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *ParameterGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterParameterGroup(s)
	}
}

func (s *ParameterGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitParameterGroup(s)
	}
}

func (s *ParameterGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitParameterGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ParameterGroup() (localctx IParameterGroupContext) {
	localctx = NewParameterGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, pascalParserRULE_parameterGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1404)
		p.IdentifierList()
	}
	p.SetState(1407)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserCOLON {
		{
			p.SetState(1405)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1406)
			p.TypeIdentifier()
		}

	}
	p.SetState(1410)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserEQUAL {
		{
			p.SetState(1409)
			p.DefaultValue()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifierList
	return p
}

func InitEmptyIdentifierListContext(p *IdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifierList
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierListContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *IdentifierListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (s *IdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, pascalParserRULE_identifierList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1412)
		p.Identifier()
	}
	p.SetState(1417)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 153, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1413)
				p.Match(pascalParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1414)
				p.Identifier()
			}

		}
		p.SetState(1419)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 153, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstListContext is an interface to support dynamic dispatch.
type IConstListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsConstListContext differentiates from other interfaces.
	IsConstListContext()
}

type ConstListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstListContext() *ConstListContext {
	var p = new(ConstListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constList
	return p
}

func InitEmptyConstListContext(p *ConstListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constList
}

func (*ConstListContext) IsConstListContext() {}

func NewConstListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstListContext {
	var p = new(ConstListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constList

	return p
}

func (s *ConstListContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstListContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *ConstListContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ConstListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ConstListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstList(s)
	}
}

func (s *ConstListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstList(s)
	}
}

func (s *ConstListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConstList() (localctx IConstListContext) {
	localctx = NewConstListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, pascalParserRULE_constList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1420)
		p.Constant()
	}
	p.SetState(1425)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(1421)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1422)
			p.Constant()
		}

		p.SetState(1427)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultValueContext is an interface to support dynamic dispatch.
type IDefaultValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsDefaultValueContext differentiates from other interfaces.
	IsDefaultValueContext()
}

type DefaultValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultValueContext() *DefaultValueContext {
	var p = new(DefaultValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_defaultValue
	return p
}

func InitEmptyDefaultValueContext(p *DefaultValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_defaultValue
}

func (*DefaultValueContext) IsDefaultValueContext() {}

func NewDefaultValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultValueContext {
	var p = new(DefaultValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_defaultValue

	return p
}

func (s *DefaultValueContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultValueContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *DefaultValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DefaultValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterDefaultValue(s)
	}
}

func (s *DefaultValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitDefaultValue(s)
	}
}

func (s *DefaultValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitDefaultValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) DefaultValue() (localctx IDefaultValueContext) {
	localctx = NewDefaultValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, pascalParserRULE_defaultValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1428)
		p.Match(pascalParserEQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1429)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypedIdentifierListContext is an interface to support dynamic dispatch.
type ITypedIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierList() IIdentifierListContext
	COLON() antlr.TerminalNode
	Type_() IType_Context

	// IsTypedIdentifierListContext differentiates from other interfaces.
	IsTypedIdentifierListContext()
}

type TypedIdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedIdentifierListContext() *TypedIdentifierListContext {
	var p = new(TypedIdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typedIdentifierList
	return p
}

func InitEmptyTypedIdentifierListContext(p *TypedIdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typedIdentifierList
}

func (*TypedIdentifierListContext) IsTypedIdentifierListContext() {}

func NewTypedIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedIdentifierListContext {
	var p = new(TypedIdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typedIdentifierList

	return p
}

func (s *TypedIdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedIdentifierListContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *TypedIdentifierListContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *TypedIdentifierListContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypedIdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedIdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedIdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypedIdentifierList(s)
	}
}

func (s *TypedIdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypedIdentifierList(s)
	}
}

func (s *TypedIdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypedIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypedIdentifierList() (localctx ITypedIdentifierListContext) {
	localctx = NewTypedIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, pascalParserRULE_typedIdentifierList)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1431)
		p.IdentifierList()
	}
	{
		p.SetState(1432)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1433)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Label() ILabelContext
	COLON() antlr.TerminalNode
	UnlabelledStatement() IUnlabelledStatementContext
	ErrorStatement() IErrorStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Label() ILabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *StatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *StatementContext) UnlabelledStatement() IUnlabelledStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnlabelledStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnlabelledStatementContext)
}

func (s *StatementContext) ErrorStatement() IErrorStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, pascalParserRULE_statement)
	p.SetState(1441)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 155, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1435)
			p.Label()
		}
		{
			p.SetState(1436)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1437)
			p.UnlabelledStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1439)
			p.UnlabelledStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1440)
			p.ErrorStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorStatementContext is an interface to support dynamic dispatch.
type IErrorStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEND() []antlr.TerminalNode
	END(i int) antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsErrorStatementContext differentiates from other interfaces.
	IsErrorStatementContext()
}

type ErrorStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorStatementContext() *ErrorStatementContext {
	var p = new(ErrorStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorStatement
	return p
}

func InitEmptyErrorStatementContext(p *ErrorStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorStatement
}

func (*ErrorStatementContext) IsErrorStatementContext() {}

func NewErrorStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorStatementContext {
	var p = new(ErrorStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_errorStatement

	return p
}

func (s *ErrorStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorStatementContext) AllEND() []antlr.TerminalNode {
	return s.GetTokens(pascalParserEND)
}

func (s *ErrorStatementContext) END(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserEND, i)
}

func (s *ErrorStatementContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ErrorStatementContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ErrorStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterErrorStatement(s)
	}
}

func (s *ErrorStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitErrorStatement(s)
	}
}

func (s *ErrorStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitErrorStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ErrorStatement() (localctx IErrorStatementContext) {
	localctx = NewErrorStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, pascalParserRULE_errorStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1444)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1443)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || _la == pascalParserEND || _la == pascalParserSEMI {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1446)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 156, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnlabelledStatementContext is an interface to support dynamic dispatch.
type IUnlabelledStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleStatement() ISimpleStatementContext
	StructuredStatement() IStructuredStatementContext

	// IsUnlabelledStatementContext differentiates from other interfaces.
	IsUnlabelledStatementContext()
}

type UnlabelledStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnlabelledStatementContext() *UnlabelledStatementContext {
	var p = new(UnlabelledStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unlabelledStatement
	return p
}

func InitEmptyUnlabelledStatementContext(p *UnlabelledStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unlabelledStatement
}

func (*UnlabelledStatementContext) IsUnlabelledStatementContext() {}

func NewUnlabelledStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnlabelledStatementContext {
	var p = new(UnlabelledStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unlabelledStatement

	return p
}

func (s *UnlabelledStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnlabelledStatementContext) SimpleStatement() ISimpleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStatementContext)
}

func (s *UnlabelledStatementContext) StructuredStatement() IStructuredStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructuredStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructuredStatementContext)
}

func (s *UnlabelledStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnlabelledStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnlabelledStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnlabelledStatement(s)
	}
}

func (s *UnlabelledStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnlabelledStatement(s)
	}
}

func (s *UnlabelledStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnlabelledStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnlabelledStatement() (localctx IUnlabelledStatementContext) {
	localctx = NewUnlabelledStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, pascalParserRULE_unlabelledStatement)
	p.SetState(1450)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserARRAY, pascalParserBOOLEAN, pascalParserCHAR, pascalParserELSE, pascalParserEND, pascalParserGOTO, pascalParserINTEGER, pascalParserREAL, pascalParserUNTIL, pascalParserVAR, pascalParserSEMI, pascalParserLPAREN, pascalParserAT, pascalParserSTRING, pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserFINALLY, pascalParserEXCEPT, pascalParserFINALIZATION, pascalParserINHERITED, pascalParserRAISE, pascalParserCARDINAL, pascalParserLONGBOOL, pascalParserLONGINT, pascalParserLONGWORD, pascalParserWORD, pascalParserIDENT, pascalParserBYTE, pascalParserSHORTINT, pascalParserSMALLINT, pascalParserINT64, pascalParserUINT64, pascalParserSINGLE, pascalParserDOUBLE, pascalParserEXTENDED, pascalParserCOMP, pascalParserCURRENCY, pascalParserANSICHAR, pascalParserWIDECHAR, pascalParserANSISTRING, pascalParserWIDESTRING, pascalParserUNICODESTRING, pascalParserRAWBYTESTRING, pascalParserUTF8STRING, pascalParserVARIANT, pascalParserOLEVARIANT, pascalParserPOINTER, pascalParserPCHAR, pascalParserPANSICHAR, pascalParserPWIDECHAR, pascalParserPUNICODECHAR, pascalParserTHANDLE, pascalParserHWND, pascalParserHDC, pascalParserHICON, pascalParserHBITMAP, pascalParserHMENU, pascalParserHINSTANCE, pascalParserHMODULE, pascalParserHKEY, pascalParserDWORD, pascalParserQWORD, pascalParserNATIVEINT, pascalParserNATIVEUINT, pascalParserCODEPAGE, pascalParserTGUID, pascalParserPGUID, pascalParserTEXTFILE, pascalParserTEXT, pascalParserSHORTSTRING, pascalParserOPENSTRING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1448)
			p.SimpleStatement()
		}

	case pascalParserBEGIN, pascalParserCASE, pascalParserFOR, pascalParserIF, pascalParserREPEAT, pascalParserWHILE, pascalParserWITH, pascalParserTRY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1449)
			p.StructuredStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleStatementContext is an interface to support dynamic dispatch.
type ISimpleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssignmentStatement() IAssignmentStatementContext
	MethodCallStatement() IMethodCallStatementContext
	ProcedureStatement() IProcedureStatementContext
	GotoStatement() IGotoStatementContext
	InheritedStatement() IInheritedStatementContext
	TypeCast() ITypeCastContext
	EmptyStatement_() IEmptyStatement_Context
	RaiseExceptionStatement() IRaiseExceptionStatementContext
	VariableDeclarationStatement() IVariableDeclarationStatementContext

	// IsSimpleStatementContext differentiates from other interfaces.
	IsSimpleStatementContext()
}

type SimpleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleStatementContext() *SimpleStatementContext {
	var p = new(SimpleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleStatement
	return p
}

func InitEmptySimpleStatementContext(p *SimpleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleStatement
}

func (*SimpleStatementContext) IsSimpleStatementContext() {}

func NewSimpleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleStatementContext {
	var p = new(SimpleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_simpleStatement

	return p
}

func (s *SimpleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleStatementContext) AssignmentStatement() IAssignmentStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentStatementContext)
}

func (s *SimpleStatementContext) MethodCallStatement() IMethodCallStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodCallStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodCallStatementContext)
}

func (s *SimpleStatementContext) ProcedureStatement() IProcedureStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureStatementContext)
}

func (s *SimpleStatementContext) GotoStatement() IGotoStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGotoStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGotoStatementContext)
}

func (s *SimpleStatementContext) InheritedStatement() IInheritedStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInheritedStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInheritedStatementContext)
}

func (s *SimpleStatementContext) TypeCast() ITypeCastContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeCastContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeCastContext)
}

func (s *SimpleStatementContext) EmptyStatement_() IEmptyStatement_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatement_Context)
}

func (s *SimpleStatementContext) RaiseExceptionStatement() IRaiseExceptionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRaiseExceptionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRaiseExceptionStatementContext)
}

func (s *SimpleStatementContext) VariableDeclarationStatement() IVariableDeclarationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationStatementContext)
}

func (s *SimpleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSimpleStatement(s)
	}
}

func (s *SimpleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSimpleStatement(s)
	}
}

func (s *SimpleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSimpleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SimpleStatement() (localctx ISimpleStatementContext) {
	localctx = NewSimpleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, pascalParserRULE_simpleStatement)
	p.SetState(1461)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 158, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1452)
			p.AssignmentStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1453)
			p.MethodCallStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1454)
			p.ProcedureStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1455)
			p.GotoStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1456)
			p.InheritedStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1457)
			p.TypeCast()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1458)
			p.EmptyStatement_()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1459)
			p.RaiseExceptionStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1460)
			p.VariableDeclarationStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentStatementContext is an interface to support dynamic dispatch.
type IAssignmentStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableDesignator() IVariableDesignatorContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext
	PropertyDesignator() IPropertyDesignatorContext

	// IsAssignmentStatementContext differentiates from other interfaces.
	IsAssignmentStatementContext()
}

type AssignmentStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentStatementContext() *AssignmentStatementContext {
	var p = new(AssignmentStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_assignmentStatement
	return p
}

func InitEmptyAssignmentStatementContext(p *AssignmentStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_assignmentStatement
}

func (*AssignmentStatementContext) IsAssignmentStatementContext() {}

func NewAssignmentStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentStatementContext {
	var p = new(AssignmentStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_assignmentStatement

	return p
}

func (s *AssignmentStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentStatementContext) VariableDesignator() IVariableDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDesignatorContext)
}

func (s *AssignmentStatementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(pascalParserASSIGN, 0)
}

func (s *AssignmentStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentStatementContext) PropertyDesignator() IPropertyDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDesignatorContext)
}

func (s *AssignmentStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAssignmentStatement(s)
	}
}

func (s *AssignmentStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAssignmentStatement(s)
	}
}

func (s *AssignmentStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAssignmentStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) AssignmentStatement() (localctx IAssignmentStatementContext) {
	localctx = NewAssignmentStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, pascalParserRULE_assignmentStatement)
	p.SetState(1471)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1463)
			p.VariableDesignator()
		}
		{
			p.SetState(1464)
			p.Match(pascalParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1465)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1467)
			p.PropertyDesignator()
		}
		{
			p.SetState(1468)
			p.Match(pascalParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1469)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRaiseExceptionStatementContext is an interface to support dynamic dispatch.
type IRaiseExceptionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RAISE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsRaiseExceptionStatementContext differentiates from other interfaces.
	IsRaiseExceptionStatementContext()
}

type RaiseExceptionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaiseExceptionStatementContext() *RaiseExceptionStatementContext {
	var p = new(RaiseExceptionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_raiseExceptionStatement
	return p
}

func InitEmptyRaiseExceptionStatementContext(p *RaiseExceptionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_raiseExceptionStatement
}

func (*RaiseExceptionStatementContext) IsRaiseExceptionStatementContext() {}

func NewRaiseExceptionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RaiseExceptionStatementContext {
	var p = new(RaiseExceptionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_raiseExceptionStatement

	return p
}

func (s *RaiseExceptionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RaiseExceptionStatementContext) RAISE() antlr.TerminalNode {
	return s.GetToken(pascalParserRAISE, 0)
}

func (s *RaiseExceptionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RaiseExceptionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RaiseExceptionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RaiseExceptionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRaiseExceptionStatement(s)
	}
}

func (s *RaiseExceptionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRaiseExceptionStatement(s)
	}
}

func (s *RaiseExceptionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRaiseExceptionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RaiseExceptionStatement() (localctx IRaiseExceptionStatementContext) {
	localctx = NewRaiseExceptionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, pascalParserRULE_raiseExceptionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1473)
		p.Match(pascalParserRAISE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1475)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&7494095344008167848) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-1135470053887570687) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&140737488355323) != 0) {
		{
			p.SetState(1474)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationStatementContext is an interface to support dynamic dispatch.
type IVariableDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VAR() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	COLON() antlr.TerminalNode
	Type_() IType_Context
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsVariableDeclarationStatementContext differentiates from other interfaces.
	IsVariableDeclarationStatementContext()
}

type VariableDeclarationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationStatementContext() *VariableDeclarationStatementContext {
	var p = new(VariableDeclarationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclarationStatement
	return p
}

func InitEmptyVariableDeclarationStatementContext(p *VariableDeclarationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclarationStatement
}

func (*VariableDeclarationStatementContext) IsVariableDeclarationStatementContext() {}

func NewVariableDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationStatementContext {
	var p = new(VariableDeclarationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_variableDeclarationStatement

	return p
}

func (s *VariableDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationStatementContext) VAR() antlr.TerminalNode {
	return s.GetToken(pascalParserVAR, 0)
}

func (s *VariableDeclarationStatementContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *VariableDeclarationStatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *VariableDeclarationStatementContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *VariableDeclarationStatementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(pascalParserASSIGN, 0)
}

func (s *VariableDeclarationStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterVariableDeclarationStatement(s)
	}
}

func (s *VariableDeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitVariableDeclarationStatement(s)
	}
}

func (s *VariableDeclarationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitVariableDeclarationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) VariableDeclarationStatement() (localctx IVariableDeclarationStatementContext) {
	localctx = NewVariableDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, pascalParserRULE_variableDeclarationStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1477)
		p.Match(pascalParserVAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1478)
		p.IdentifierList()
	}
	p.SetState(1481)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserCOLON {
		{
			p.SetState(1479)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1480)
			p.Type_()
		}

	}
	p.SetState(1485)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserASSIGN {
		{
			p.SetState(1483)
			p.Match(pascalParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1484)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDesignatorContext is an interface to support dynamic dispatch.
type IVariableDesignatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeCast() ITypeCastContext
	AT() antlr.TerminalNode
	Identifier() IIdentifierContext
	AllFunctionDesignator() []IFunctionDesignatorContext
	FunctionDesignator(i int) IFunctionDesignatorContext
	AllLBRACK() []antlr.TerminalNode
	LBRACK(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllRBRACK() []antlr.TerminalNode
	RBRACK(i int) antlr.TerminalNode
	AllLBRACK2() []antlr.TerminalNode
	LBRACK2(i int) antlr.TerminalNode
	AllRBRACK2() []antlr.TerminalNode
	RBRACK2(i int) antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllDEREFERENCE() []antlr.TerminalNode
	DEREFERENCE(i int) antlr.TerminalNode

	// IsVariableDesignatorContext differentiates from other interfaces.
	IsVariableDesignatorContext()
}

type VariableDesignatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDesignatorContext() *VariableDesignatorContext {
	var p = new(VariableDesignatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDesignator
	return p
}

func InitEmptyVariableDesignatorContext(p *VariableDesignatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDesignator
}

func (*VariableDesignatorContext) IsVariableDesignatorContext() {}

func NewVariableDesignatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDesignatorContext {
	var p = new(VariableDesignatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_variableDesignator

	return p
}

func (s *VariableDesignatorContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDesignatorContext) TypeCast() ITypeCastContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeCastContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeCastContext)
}

func (s *VariableDesignatorContext) AT() antlr.TerminalNode {
	return s.GetToken(pascalParserAT, 0)
}

func (s *VariableDesignatorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableDesignatorContext) AllFunctionDesignator() []IFunctionDesignatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionDesignatorContext); ok {
			len++
		}
	}

	tst := make([]IFunctionDesignatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionDesignatorContext); ok {
			tst[i] = t.(IFunctionDesignatorContext)
			i++
		}
	}

	return tst
}

func (s *VariableDesignatorContext) FunctionDesignator(i int) IFunctionDesignatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDesignatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDesignatorContext)
}

func (s *VariableDesignatorContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(pascalParserLBRACK)
}

func (s *VariableDesignatorContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, i)
}

func (s *VariableDesignatorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *VariableDesignatorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableDesignatorContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(pascalParserRBRACK)
}

func (s *VariableDesignatorContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, i)
}

func (s *VariableDesignatorContext) AllLBRACK2() []antlr.TerminalNode {
	return s.GetTokens(pascalParserLBRACK2)
}

func (s *VariableDesignatorContext) LBRACK2(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK2, i)
}

func (s *VariableDesignatorContext) AllRBRACK2() []antlr.TerminalNode {
	return s.GetTokens(pascalParserRBRACK2)
}

func (s *VariableDesignatorContext) RBRACK2(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK2, i)
}

func (s *VariableDesignatorContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDOT)
}

func (s *VariableDesignatorContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, i)
}

func (s *VariableDesignatorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *VariableDesignatorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *VariableDesignatorContext) AllDEREFERENCE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDEREFERENCE)
}

func (s *VariableDesignatorContext) DEREFERENCE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDEREFERENCE, i)
}

func (s *VariableDesignatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDesignatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDesignatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterVariableDesignator(s)
	}
}

func (s *VariableDesignatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitVariableDesignator(s)
	}
}

func (s *VariableDesignatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitVariableDesignator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) VariableDesignator() (localctx IVariableDesignatorContext) {
	localctx = NewVariableDesignatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, pascalParserRULE_variableDesignator)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1491)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 163, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1487)
			p.TypeCast()
		}

	case 2:
		{
			p.SetState(1488)
			p.Match(pascalParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1489)
			p.Identifier()
		}

	case 3:
		{
			p.SetState(1490)
			p.FunctionDesignator()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(1524)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1522)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case pascalParserLBRACK:
				{
					p.SetState(1493)
					p.Match(pascalParserLBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1494)
					p.Expression()
				}
				p.SetState(1499)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == pascalParserCOMMA {
					{
						p.SetState(1495)
						p.Match(pascalParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1496)
						p.Expression()
					}

					p.SetState(1501)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1502)
					p.Match(pascalParserRBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case pascalParserLBRACK2:
				{
					p.SetState(1504)
					p.Match(pascalParserLBRACK2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1505)
					p.Expression()
				}
				p.SetState(1510)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == pascalParserCOMMA {
					{
						p.SetState(1506)
						p.Match(pascalParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1507)
						p.Expression()
					}

					p.SetState(1512)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1513)
					p.Match(pascalParserRBRACK2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case pascalParserDOT:
				{
					p.SetState(1515)
					p.Match(pascalParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1516)
					p.FunctionDesignator()
				}

			case pascalParserDEREFERENCE:
				p.SetState(1518)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = 1
				for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					switch _alt {
					case 1:
						{
							p.SetState(1517)
							p.Match(pascalParserDEREFERENCE)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					default:
						p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
						goto errorExit
					}

					p.SetState(1520)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 166, p.GetParserRuleContext())
					if p.HasError() {
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(1526)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeCastContext is an interface to support dynamic dispatch.
type ITypeCastContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIdentifier() ITypeIdentifierContext
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsTypeCastContext differentiates from other interfaces.
	IsTypeCastContext()
}

type TypeCastContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeCastContext() *TypeCastContext {
	var p = new(TypeCastContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeCast
	return p
}

func InitEmptyTypeCastContext(p *TypeCastContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeCast
}

func (*TypeCastContext) IsTypeCastContext() {}

func NewTypeCastContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeCastContext {
	var p = new(TypeCastContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typeCast

	return p
}

func (s *TypeCastContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeCastContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *TypeCastContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *TypeCastContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TypeCastContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *TypeCastContext) AS() antlr.TerminalNode {
	return s.GetToken(pascalParserAS, 0)
}

func (s *TypeCastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeCastContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeCastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypeCast(s)
	}
}

func (s *TypeCastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypeCast(s)
	}
}

func (s *TypeCastContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypeCast(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypeCast() (localctx ITypeCastContext) {
	localctx = NewTypeCastContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, pascalParserRULE_typeCast)
	p.SetState(1538)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserARRAY, pascalParserBOOLEAN, pascalParserCHAR, pascalParserINTEGER, pascalParserREAL, pascalParserSTRING, pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserCARDINAL, pascalParserLONGBOOL, pascalParserLONGINT, pascalParserLONGWORD, pascalParserWORD, pascalParserIDENT, pascalParserBYTE, pascalParserSHORTINT, pascalParserSMALLINT, pascalParserINT64, pascalParserUINT64, pascalParserSINGLE, pascalParserDOUBLE, pascalParserEXTENDED, pascalParserCOMP, pascalParserCURRENCY, pascalParserANSICHAR, pascalParserWIDECHAR, pascalParserANSISTRING, pascalParserWIDESTRING, pascalParserUNICODESTRING, pascalParserRAWBYTESTRING, pascalParserUTF8STRING, pascalParserVARIANT, pascalParserOLEVARIANT, pascalParserPOINTER, pascalParserPCHAR, pascalParserPANSICHAR, pascalParserPWIDECHAR, pascalParserPUNICODECHAR, pascalParserTHANDLE, pascalParserHWND, pascalParserHDC, pascalParserHICON, pascalParserHBITMAP, pascalParserHMENU, pascalParserHINSTANCE, pascalParserHMODULE, pascalParserHKEY, pascalParserDWORD, pascalParserQWORD, pascalParserNATIVEINT, pascalParserNATIVEUINT, pascalParserCODEPAGE, pascalParserTGUID, pascalParserPGUID, pascalParserTEXTFILE, pascalParserTEXT, pascalParserSHORTSTRING, pascalParserOPENSTRING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1527)
			p.TypeIdentifier()
		}
		{
			p.SetState(1528)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1529)
			p.Expression()
		}
		{
			p.SetState(1530)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case pascalParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1532)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1533)
			p.Expression()
		}
		{
			p.SetState(1534)
			p.Match(pascalParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1535)
			p.TypeIdentifier()
		}
		{
			p.SetState(1536)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyDesignatorContext is an interface to support dynamic dispatch.
type IPropertyDesignatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFunctionDesignator() []IFunctionDesignatorContext
	FunctionDesignator(i int) IFunctionDesignatorContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	Identifier() IIdentifierContext
	LBRACK() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	RBRACK() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPropertyDesignatorContext differentiates from other interfaces.
	IsPropertyDesignatorContext()
}

type PropertyDesignatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDesignatorContext() *PropertyDesignatorContext {
	var p = new(PropertyDesignatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDesignator
	return p
}

func InitEmptyPropertyDesignatorContext(p *PropertyDesignatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDesignator
}

func (*PropertyDesignatorContext) IsPropertyDesignatorContext() {}

func NewPropertyDesignatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDesignatorContext {
	var p = new(PropertyDesignatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyDesignator

	return p
}

func (s *PropertyDesignatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDesignatorContext) AllFunctionDesignator() []IFunctionDesignatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionDesignatorContext); ok {
			len++
		}
	}

	tst := make([]IFunctionDesignatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionDesignatorContext); ok {
			tst[i] = t.(IFunctionDesignatorContext)
			i++
		}
	}

	return tst
}

func (s *PropertyDesignatorContext) FunctionDesignator(i int) IFunctionDesignatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDesignatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDesignatorContext)
}

func (s *PropertyDesignatorContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDOT)
}

func (s *PropertyDesignatorContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, i)
}

func (s *PropertyDesignatorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyDesignatorContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *PropertyDesignatorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PropertyDesignatorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PropertyDesignatorContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *PropertyDesignatorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *PropertyDesignatorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *PropertyDesignatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDesignatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyDesignatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyDesignator(s)
	}
}

func (s *PropertyDesignatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyDesignator(s)
	}
}

func (s *PropertyDesignatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyDesignator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyDesignator() (localctx IPropertyDesignatorContext) {
	localctx = NewPropertyDesignatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, pascalParserRULE_propertyDesignator)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1540)
		p.FunctionDesignator()
	}
	p.SetState(1545)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1541)
				p.Match(pascalParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1542)
				p.FunctionDesignator()
			}

		}
		p.SetState(1547)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1548)
		p.Match(pascalParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1549)
		p.Identifier()
	}
	p.SetState(1561)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLBRACK {
		{
			p.SetState(1550)
			p.Match(pascalParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1551)
			p.Expression()
		}
		p.SetState(1556)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == pascalParserCOMMA {
			{
				p.SetState(1552)
				p.Match(pascalParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1553)
				p.Expression()
			}

			p.SetState(1558)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1559)
			p.Match(pascalParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleExpression() ISimpleExpressionContext
	Relationaloperator() IRelationaloperatorContext
	Expression() IExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) SimpleExpression() ISimpleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExpressionContext)
}

func (s *ExpressionContext) Relationaloperator() IRelationaloperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationaloperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationaloperatorContext)
}

func (s *ExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, pascalParserRULE_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1563)
		p.SimpleExpression()
	}
	p.SetState(1567)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 173, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1564)
			p.Relationaloperator()
		}
		{
			p.SetState(1565)
			p.Expression()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationaloperatorContext is an interface to support dynamic dispatch.
type IRelationaloperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL() antlr.TerminalNode
	NOT_EQUAL() antlr.TerminalNode
	LT() antlr.TerminalNode
	LE() antlr.TerminalNode
	GE() antlr.TerminalNode
	GT() antlr.TerminalNode
	IN() antlr.TerminalNode

	// IsRelationaloperatorContext differentiates from other interfaces.
	IsRelationaloperatorContext()
}

type RelationaloperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationaloperatorContext() *RelationaloperatorContext {
	var p = new(RelationaloperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_relationaloperator
	return p
}

func InitEmptyRelationaloperatorContext(p *RelationaloperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_relationaloperator
}

func (*RelationaloperatorContext) IsRelationaloperatorContext() {}

func NewRelationaloperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationaloperatorContext {
	var p = new(RelationaloperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_relationaloperator

	return p
}

func (s *RelationaloperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationaloperatorContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *RelationaloperatorContext) NOT_EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserNOT_EQUAL, 0)
}

func (s *RelationaloperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(pascalParserLT, 0)
}

func (s *RelationaloperatorContext) LE() antlr.TerminalNode {
	return s.GetToken(pascalParserLE, 0)
}

func (s *RelationaloperatorContext) GE() antlr.TerminalNode {
	return s.GetToken(pascalParserGE, 0)
}

func (s *RelationaloperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(pascalParserGT, 0)
}

func (s *RelationaloperatorContext) IN() antlr.TerminalNode {
	return s.GetToken(pascalParserIN, 0)
}

func (s *RelationaloperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationaloperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationaloperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRelationaloperator(s)
	}
}

func (s *RelationaloperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRelationaloperator(s)
	}
}

func (s *RelationaloperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRelationaloperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Relationaloperator() (localctx IRelationaloperatorContext) {
	localctx = NewRelationaloperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, pascalParserRULE_relationaloperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1569)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&567453553052876800) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleExpressionContext is an interface to support dynamic dispatch.
type ISimpleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Term() ITermContext
	Additiveoperator() IAdditiveoperatorContext
	SimpleExpression() ISimpleExpressionContext

	// IsSimpleExpressionContext differentiates from other interfaces.
	IsSimpleExpressionContext()
}

type SimpleExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleExpressionContext() *SimpleExpressionContext {
	var p = new(SimpleExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleExpression
	return p
}

func InitEmptySimpleExpressionContext(p *SimpleExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleExpression
}

func (*SimpleExpressionContext) IsSimpleExpressionContext() {}

func NewSimpleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleExpressionContext {
	var p = new(SimpleExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_simpleExpression

	return p
}

func (s *SimpleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleExpressionContext) Term() ITermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *SimpleExpressionContext) Additiveoperator() IAdditiveoperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveoperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveoperatorContext)
}

func (s *SimpleExpressionContext) SimpleExpression() ISimpleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExpressionContext)
}

func (s *SimpleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSimpleExpression(s)
	}
}

func (s *SimpleExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSimpleExpression(s)
	}
}

func (s *SimpleExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSimpleExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SimpleExpression() (localctx ISimpleExpressionContext) {
	localctx = NewSimpleExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, pascalParserRULE_simpleExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1571)
		p.Term()
	}
	p.SetState(1575)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 174, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1572)
			p.Additiveoperator()
		}
		{
			p.SetState(1573)
			p.SimpleExpression()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdditiveoperatorContext is an interface to support dynamic dispatch.
type IAdditiveoperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	OR() antlr.TerminalNode

	// IsAdditiveoperatorContext differentiates from other interfaces.
	IsAdditiveoperatorContext()
}

type AdditiveoperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveoperatorContext() *AdditiveoperatorContext {
	var p = new(AdditiveoperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_additiveoperator
	return p
}

func InitEmptyAdditiveoperatorContext(p *AdditiveoperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_additiveoperator
}

func (*AdditiveoperatorContext) IsAdditiveoperatorContext() {}

func NewAdditiveoperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveoperatorContext {
	var p = new(AdditiveoperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_additiveoperator

	return p
}

func (s *AdditiveoperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveoperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(pascalParserPLUS, 0)
}

func (s *AdditiveoperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(pascalParserMINUS, 0)
}

func (s *AdditiveoperatorContext) OR() antlr.TerminalNode {
	return s.GetToken(pascalParserOR, 0)
}

func (s *AdditiveoperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveoperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveoperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAdditiveoperator(s)
	}
}

func (s *AdditiveoperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAdditiveoperator(s)
	}
}

func (s *AdditiveoperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAdditiveoperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Additiveoperator() (localctx IAdditiveoperatorContext) {
	localctx = NewAdditiveoperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, pascalParserRULE_additiveoperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1577)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&105553653137408) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SignedFactor() ISignedFactorContext
	Multiplicativeoperator() IMultiplicativeoperatorContext
	Term() ITermContext

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_term
	return p
}

func InitEmptyTermContext(p *TermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_term
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) SignedFactor() ISignedFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignedFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignedFactorContext)
}

func (s *TermContext) Multiplicativeoperator() IMultiplicativeoperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeoperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeoperatorContext)
}

func (s *TermContext) Term() ITermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTerm(s)
	}
}

func (s *TermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTerm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, pascalParserRULE_term)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1579)
		p.SignedFactor()
	}
	p.SetState(1583)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 175, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1580)
			p.Multiplicativeoperator()
		}
		{
			p.SetState(1581)
			p.Term()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplicativeoperatorContext is an interface to support dynamic dispatch.
type IMultiplicativeoperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	SLASH() antlr.TerminalNode
	DIV() antlr.TerminalNode
	MOD() antlr.TerminalNode
	AND() antlr.TerminalNode
	SHR() antlr.TerminalNode
	SHL() antlr.TerminalNode
	XOR() antlr.TerminalNode

	// IsMultiplicativeoperatorContext differentiates from other interfaces.
	IsMultiplicativeoperatorContext()
}

type MultiplicativeoperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeoperatorContext() *MultiplicativeoperatorContext {
	var p = new(MultiplicativeoperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_multiplicativeoperator
	return p
}

func InitEmptyMultiplicativeoperatorContext(p *MultiplicativeoperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_multiplicativeoperator
}

func (*MultiplicativeoperatorContext) IsMultiplicativeoperatorContext() {}

func NewMultiplicativeoperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeoperatorContext {
	var p = new(MultiplicativeoperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_multiplicativeoperator

	return p
}

func (s *MultiplicativeoperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeoperatorContext) STAR() antlr.TerminalNode {
	return s.GetToken(pascalParserSTAR, 0)
}

func (s *MultiplicativeoperatorContext) SLASH() antlr.TerminalNode {
	return s.GetToken(pascalParserSLASH, 0)
}

func (s *MultiplicativeoperatorContext) DIV() antlr.TerminalNode {
	return s.GetToken(pascalParserDIV, 0)
}

func (s *MultiplicativeoperatorContext) MOD() antlr.TerminalNode {
	return s.GetToken(pascalParserMOD, 0)
}

func (s *MultiplicativeoperatorContext) AND() antlr.TerminalNode {
	return s.GetToken(pascalParserAND, 0)
}

func (s *MultiplicativeoperatorContext) SHR() antlr.TerminalNode {
	return s.GetToken(pascalParserSHR, 0)
}

func (s *MultiplicativeoperatorContext) SHL() antlr.TerminalNode {
	return s.GetToken(pascalParserSHL, 0)
}

func (s *MultiplicativeoperatorContext) XOR() antlr.TerminalNode {
	return s.GetToken(pascalParserXOR, 0)
}

func (s *MultiplicativeoperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeoperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeoperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterMultiplicativeoperator(s)
	}
}

func (s *MultiplicativeoperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitMultiplicativeoperator(s)
	}
}

func (s *MultiplicativeoperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitMultiplicativeoperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Multiplicativeoperator() (localctx IMultiplicativeoperatorContext) {
	localctx = NewMultiplicativeoperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, pascalParserRULE_multiplicativeoperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1585)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&422212498622468) != 0) || ((int64((_la-112)) & ^0x3f) == 0 && ((int64(1)<<(_la-112))&7) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignedFactorContext is an interface to support dynamic dispatch.
type ISignedFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Factor() IFactorContext
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsSignedFactorContext differentiates from other interfaces.
	IsSignedFactorContext()
}

type SignedFactorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignedFactorContext() *SignedFactorContext {
	var p = new(SignedFactorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_signedFactor
	return p
}

func InitEmptySignedFactorContext(p *SignedFactorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_signedFactor
}

func (*SignedFactorContext) IsSignedFactorContext() {}

func NewSignedFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignedFactorContext {
	var p = new(SignedFactorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_signedFactor

	return p
}

func (s *SignedFactorContext) GetParser() antlr.Parser { return s.parser }

func (s *SignedFactorContext) Factor() IFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *SignedFactorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(pascalParserPLUS, 0)
}

func (s *SignedFactorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(pascalParserMINUS, 0)
}

func (s *SignedFactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignedFactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignedFactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSignedFactor(s)
	}
}

func (s *SignedFactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSignedFactor(s)
	}
}

func (s *SignedFactorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSignedFactor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SignedFactor() (localctx ISignedFactorContext) {
	localctx = NewSignedFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, pascalParserRULE_signedFactor)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1588)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 176, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1587)
			_la = p.GetTokenStream().LA(1)

			if !(_la == pascalParserPLUS || _la == pascalParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1590)
		p.factor(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFactorContext is an interface to support dynamic dispatch.
type IFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionDesignator() IFunctionDesignatorContext
	INHERITED() antlr.TerminalNode
	DefaultDesignator() IDefaultDesignatorContext
	VariableDesignator() IVariableDesignatorContext
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	RPAREN() antlr.TerminalNode
	UnsignedConstant() IUnsignedConstantContext
	Set_() ISet_Context
	NOT() antlr.TerminalNode
	Factor() IFactorContext
	Bool_() IBool_Context
	TypeIdentifier() ITypeIdentifierContext
	AT() antlr.TerminalNode
	AllDEREFERENCE() []antlr.TerminalNode
	DEREFERENCE(i int) antlr.TerminalNode
	FunctionLambdaDeclaration() IFunctionLambdaDeclarationContext
	ProcedureLambdaDeclaration() IProcedureLambdaDeclarationContext
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsFactorContext differentiates from other interfaces.
	IsFactorContext()
}

type FactorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFactorContext() *FactorContext {
	var p = new(FactorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_factor
	return p
}

func InitEmptyFactorContext(p *FactorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_factor
}

func (*FactorContext) IsFactorContext() {}

func NewFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FactorContext {
	var p = new(FactorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_factor

	return p
}

func (s *FactorContext) GetParser() antlr.Parser { return s.parser }

func (s *FactorContext) FunctionDesignator() IFunctionDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDesignatorContext)
}

func (s *FactorContext) INHERITED() antlr.TerminalNode {
	return s.GetToken(pascalParserINHERITED, 0)
}

func (s *FactorContext) DefaultDesignator() IDefaultDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultDesignatorContext)
}

func (s *FactorContext) VariableDesignator() IVariableDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDesignatorContext)
}

func (s *FactorContext) AS() antlr.TerminalNode {
	return s.GetToken(pascalParserAS, 0)
}

func (s *FactorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FactorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *FactorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *FactorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FactorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *FactorContext) UnsignedConstant() IUnsignedConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedConstantContext)
}

func (s *FactorContext) Set_() ISet_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_Context)
}

func (s *FactorContext) NOT() antlr.TerminalNode {
	return s.GetToken(pascalParserNOT, 0)
}

func (s *FactorContext) Factor() IFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *FactorContext) Bool_() IBool_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_Context)
}

func (s *FactorContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *FactorContext) AT() antlr.TerminalNode {
	return s.GetToken(pascalParserAT, 0)
}

func (s *FactorContext) AllDEREFERENCE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDEREFERENCE)
}

func (s *FactorContext) DEREFERENCE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDEREFERENCE, i)
}

func (s *FactorContext) FunctionLambdaDeclaration() IFunctionLambdaDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionLambdaDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionLambdaDeclarationContext)
}

func (s *FactorContext) ProcedureLambdaDeclaration() IProcedureLambdaDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureLambdaDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureLambdaDeclarationContext)
}

func (s *FactorContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *FactorContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *FactorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *FactorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *FactorContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDOT)
}

func (s *FactorContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, i)
}

func (s *FactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFactor(s)
	}
}

func (s *FactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFactor(s)
	}
}

func (s *FactorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFactor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Factor() (localctx IFactorContext) {
	return p.factor(0)
}

func (p *pascalParser) factor(_p int) (localctx IFactorContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewFactorContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IFactorContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 278
	p.EnterRecursionRule(localctx, 278, pascalParserRULE_factor, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1631)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 182, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1594)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserINHERITED {
			{
				p.SetState(1593)
				p.Match(pascalParserINHERITED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1596)
			p.FunctionDesignator()
		}

	case 2:
		{
			p.SetState(1597)
			p.DefaultDesignator()
		}

	case 3:
		{
			p.SetState(1598)
			p.VariableDesignator()
		}
		p.SetState(1601)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 178, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1599)
				p.Match(pascalParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1600)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		{
			p.SetState(1603)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1604)
			p.Expression()
		}
		{
			p.SetState(1605)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		{
			p.SetState(1607)
			p.UnsignedConstant()
		}

	case 6:
		{
			p.SetState(1608)
			p.Set_()
		}

	case 7:
		{
			p.SetState(1609)
			p.Match(pascalParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1610)
			p.factor(8)
		}

	case 8:
		{
			p.SetState(1611)
			p.Bool_()
		}

	case 9:
		p.SetState(1613)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserAT {
			{
				p.SetState(1612)
				p.Match(pascalParserAT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1615)
			p.TypeIdentifier()
		}
		p.SetState(1620)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 180, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1616)
				p.Match(pascalParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1617)
				p.Expression()
			}
			{
				p.SetState(1618)
				p.Match(pascalParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1625)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 181, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1622)
					p.Match(pascalParserDEREFERENCE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1627)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 181, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 10:
		{
			p.SetState(1628)
			p.Identifier()
		}

	case 11:
		{
			p.SetState(1629)
			p.FunctionLambdaDeclaration()
		}

	case 12:
		{
			p.SetState(1630)
			p.ProcedureLambdaDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1654)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1652)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 185, p.GetParserRuleContext()) {
			case 1:
				localctx = NewFactorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, pascalParserRULE_factor)
				p.SetState(1633)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(1634)
					p.Match(pascalParserLBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1635)
					p.Expression()
				}
				p.SetState(1640)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == pascalParserCOMMA {
					{
						p.SetState(1636)
						p.Match(pascalParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1637)
						p.Expression()
					}

					p.SetState(1642)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1643)
					p.Match(pascalParserRBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				localctx = NewFactorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, pascalParserRULE_factor)
				p.SetState(1645)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				p.SetState(1648)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = 1
				for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					switch _alt {
					case 1:
						{
							p.SetState(1646)
							p.Match(pascalParserDOT)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(1647)
							p.Expression()
						}

					default:
						p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
						goto errorExit
					}

					p.SetState(1650)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 184, p.GetParserRuleContext())
					if p.HasError() {
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1656)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedConstantContext is an interface to support dynamic dispatch.
type IUnsignedConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedNumber() IUnsignedNumberContext
	Sign() ISignContext
	ConstantChr() IConstantChrContext
	HexConstant() IHexConstantContext
	String_() IStringContext
	NIL() antlr.TerminalNode

	// IsUnsignedConstantContext differentiates from other interfaces.
	IsUnsignedConstantContext()
}

type UnsignedConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedConstantContext() *UnsignedConstantContext {
	var p = new(UnsignedConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedConstant
	return p
}

func InitEmptyUnsignedConstantContext(p *UnsignedConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedConstant
}

func (*UnsignedConstantContext) IsUnsignedConstantContext() {}

func NewUnsignedConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedConstantContext {
	var p = new(UnsignedConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unsignedConstant

	return p
}

func (s *UnsignedConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedConstantContext) UnsignedNumber() IUnsignedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedNumberContext)
}

func (s *UnsignedConstantContext) Sign() ISignContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignContext)
}

func (s *UnsignedConstantContext) ConstantChr() IConstantChrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantChrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantChrContext)
}

func (s *UnsignedConstantContext) HexConstant() IHexConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexConstantContext)
}

func (s *UnsignedConstantContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *UnsignedConstantContext) NIL() antlr.TerminalNode {
	return s.GetToken(pascalParserNIL, 0)
}

func (s *UnsignedConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnsignedConstant(s)
	}
}

func (s *UnsignedConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnsignedConstant(s)
	}
}

func (s *UnsignedConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnsignedConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnsignedConstant() (localctx IUnsignedConstantContext) {
	localctx = NewUnsignedConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, pascalParserRULE_unsignedConstant)
	var _la int

	p.SetState(1665)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserPLUS, pascalParserMINUS, pascalParserNUM_INT, pascalParserNUM_REAL:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1658)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserPLUS || _la == pascalParserMINUS {
			{
				p.SetState(1657)
				p.Sign()
			}

		}
		{
			p.SetState(1660)
			p.UnsignedNumber()
		}

	case pascalParserCHR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1661)
			p.ConstantChr()
		}

	case pascalParserHEX_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1662)
			p.HexConstant()
		}

	case pascalParserSTRING_LITERAL, pascalParserSTRING_CROSSHATCH_LITERAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1663)
			p.String_()
		}

	case pascalParserNIL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1664)
			p.Match(pascalParserNIL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDesignatorContext is an interface to support dynamic dispatch.
type IFunctionDesignatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext

	// IsFunctionDesignatorContext differentiates from other interfaces.
	IsFunctionDesignatorContext()
}

type FunctionDesignatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDesignatorContext() *FunctionDesignatorContext {
	var p = new(FunctionDesignatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionDesignator
	return p
}

func InitEmptyFunctionDesignatorContext(p *FunctionDesignatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionDesignator
}

func (*FunctionDesignatorContext) IsFunctionDesignatorContext() {}

func NewFunctionDesignatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDesignatorContext {
	var p = new(FunctionDesignatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_functionDesignator

	return p
}

func (s *FunctionDesignatorContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDesignatorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionDesignatorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *FunctionDesignatorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *FunctionDesignatorContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *FunctionDesignatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDesignatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDesignatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFunctionDesignator(s)
	}
}

func (s *FunctionDesignatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFunctionDesignator(s)
	}
}

func (s *FunctionDesignatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFunctionDesignator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FunctionDesignator() (localctx IFunctionDesignatorContext) {
	localctx = NewFunctionDesignatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, pascalParserRULE_functionDesignator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1667)
		p.Identifier()
	}

	p.SetState(1673)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 190, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1668)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1670)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&7494095344008167848) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-1135470053887570687) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&140737488355323) != 0) {
			{
				p.SetState(1669)
				p.ParameterList()
			}

		}
		{
			p.SetState(1672)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultDesignatorContext is an interface to support dynamic dispatch.
type IDefaultDesignatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext
	RPAREN() antlr.TerminalNode

	// IsDefaultDesignatorContext differentiates from other interfaces.
	IsDefaultDesignatorContext()
}

type DefaultDesignatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultDesignatorContext() *DefaultDesignatorContext {
	var p = new(DefaultDesignatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_defaultDesignator
	return p
}

func InitEmptyDefaultDesignatorContext(p *DefaultDesignatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_defaultDesignator
}

func (*DefaultDesignatorContext) IsDefaultDesignatorContext() {}

func NewDefaultDesignatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultDesignatorContext {
	var p = new(DefaultDesignatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_defaultDesignator

	return p
}

func (s *DefaultDesignatorContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultDesignatorContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *DefaultDesignatorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *DefaultDesignatorContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *DefaultDesignatorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *DefaultDesignatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultDesignatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultDesignatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterDefaultDesignator(s)
	}
}

func (s *DefaultDesignatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitDefaultDesignator(s)
	}
}

func (s *DefaultDesignatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitDefaultDesignator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) DefaultDesignator() (localctx IDefaultDesignatorContext) {
	localctx = NewDefaultDesignatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, pascalParserRULE_defaultDesignator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1675)
		p.Match(pascalParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1680)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 191, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1676)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1677)
			p.ParameterList()
		}
		{
			p.SetState(1678)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterListContext is an interface to support dynamic dispatch.
type IParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllActualParameter() []IActualParameterContext
	ActualParameter(i int) IActualParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsParameterListContext differentiates from other interfaces.
	IsParameterListContext()
}

type ParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterListContext() *ParameterListContext {
	var p = new(ParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterList
	return p
}

func InitEmptyParameterListContext(p *ParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterList
}

func (*ParameterListContext) IsParameterListContext() {}

func NewParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterListContext {
	var p = new(ParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_parameterList

	return p
}

func (s *ParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterListContext) AllActualParameter() []IActualParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IActualParameterContext); ok {
			len++
		}
	}

	tst := make([]IActualParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IActualParameterContext); ok {
			tst[i] = t.(IActualParameterContext)
			i++
		}
	}

	return tst
}

func (s *ParameterListContext) ActualParameter(i int) IActualParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IActualParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IActualParameterContext)
}

func (s *ParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterParameterList(s)
	}
}

func (s *ParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitParameterList(s)
	}
}

func (s *ParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ParameterList() (localctx IParameterListContext) {
	localctx = NewParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, pascalParserRULE_parameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1682)
		p.ActualParameter()
	}
	p.SetState(1687)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(1683)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1684)
			p.ActualParameter()
		}

		p.SetState(1689)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_Context is an interface to support dynamic dispatch.
type ISet_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	ElementList() IElementListContext
	RBRACK() antlr.TerminalNode
	LBRACK2() antlr.TerminalNode
	RBRACK2() antlr.TerminalNode

	// IsSet_Context differentiates from other interfaces.
	IsSet_Context()
}

type Set_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_Context() *Set_Context {
	var p = new(Set_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_set_
	return p
}

func InitEmptySet_Context(p *Set_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_set_
}

func (*Set_Context) IsSet_Context() {}

func NewSet_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_Context {
	var p = new(Set_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_set_

	return p
}

func (s *Set_Context) GetParser() antlr.Parser { return s.parser }

func (s *Set_Context) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *Set_Context) ElementList() IElementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementListContext)
}

func (s *Set_Context) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *Set_Context) LBRACK2() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK2, 0)
}

func (s *Set_Context) RBRACK2() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK2, 0)
}

func (s *Set_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSet_(s)
	}
}

func (s *Set_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSet_(s)
	}
}

func (s *Set_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSet_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Set_() (localctx ISet_Context) {
	localctx = NewSet_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, pascalParserRULE_set_)
	p.SetState(1698)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserLBRACK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1690)
			p.Match(pascalParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1691)
			p.ElementList()
		}
		{
			p.SetState(1692)
			p.Match(pascalParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case pascalParserLBRACK2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1694)
			p.Match(pascalParserLBRACK2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1695)
			p.ElementList()
		}
		{
			p.SetState(1696)
			p.Match(pascalParserRBRACK2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementListContext is an interface to support dynamic dispatch.
type IElementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllElement() []IElementContext
	Element(i int) IElementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsElementListContext differentiates from other interfaces.
	IsElementListContext()
}

type ElementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementListContext() *ElementListContext {
	var p = new(ElementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_elementList
	return p
}

func InitEmptyElementListContext(p *ElementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_elementList
}

func (*ElementListContext) IsElementListContext() {}

func NewElementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementListContext {
	var p = new(ElementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_elementList

	return p
}

func (s *ElementListContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementListContext) AllElement() []IElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElementContext); ok {
			len++
		}
	}

	tst := make([]IElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElementContext); ok {
			tst[i] = t.(IElementContext)
			i++
		}
	}

	return tst
}

func (s *ElementListContext) Element(i int) IElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementContext)
}

func (s *ElementListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ElementListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ElementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterElementList(s)
	}
}

func (s *ElementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitElementList(s)
	}
}

func (s *ElementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitElementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ElementList() (localctx IElementListContext) {
	localctx = NewElementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, pascalParserRULE_elementList)
	var _la int

	p.SetState(1709)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserARRAY, pascalParserBOOLEAN, pascalParserCHAR, pascalParserCHR, pascalParserFUNCTION, pascalParserINTEGER, pascalParserNIL, pascalParserNOT, pascalParserPROCEDURE, pascalParserREAL, pascalParserPLUS, pascalParserMINUS, pascalParserLPAREN, pascalParserLBRACK, pascalParserLBRACK2, pascalParserAT, pascalParserSTRING, pascalParserTRUE, pascalParserFALSE, pascalParserREAD, pascalParserWRITE, pascalParserDEFAULT, pascalParserINDEX, pascalParserINHERITED, pascalParserCARDINAL, pascalParserLONGBOOL, pascalParserLONGINT, pascalParserLONGWORD, pascalParserWORD, pascalParserIDENT, pascalParserHEX_LITERAL, pascalParserSTRING_LITERAL, pascalParserSTRING_CROSSHATCH_LITERAL, pascalParserNUM_INT, pascalParserNUM_REAL, pascalParserBYTE, pascalParserSHORTINT, pascalParserSMALLINT, pascalParserINT64, pascalParserUINT64, pascalParserSINGLE, pascalParserDOUBLE, pascalParserEXTENDED, pascalParserCOMP, pascalParserCURRENCY, pascalParserANSICHAR, pascalParserWIDECHAR, pascalParserANSISTRING, pascalParserWIDESTRING, pascalParserUNICODESTRING, pascalParserRAWBYTESTRING, pascalParserUTF8STRING, pascalParserVARIANT, pascalParserOLEVARIANT, pascalParserPOINTER, pascalParserPCHAR, pascalParserPANSICHAR, pascalParserPWIDECHAR, pascalParserPUNICODECHAR, pascalParserTHANDLE, pascalParserHWND, pascalParserHDC, pascalParserHICON, pascalParserHBITMAP, pascalParserHMENU, pascalParserHINSTANCE, pascalParserHMODULE, pascalParserHKEY, pascalParserDWORD, pascalParserQWORD, pascalParserNATIVEINT, pascalParserNATIVEUINT, pascalParserCODEPAGE, pascalParserTGUID, pascalParserPGUID, pascalParserTEXTFILE, pascalParserTEXT, pascalParserSHORTSTRING, pascalParserOPENSTRING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1700)
			p.Element()
		}
		p.SetState(1705)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == pascalParserCOMMA {
			{
				p.SetState(1701)
				p.Match(pascalParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1702)
				p.Element()
			}

			p.SetState(1707)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case pascalParserRBRACK, pascalParserRBRACK2:
		p.EnterOuterAlt(localctx, 2)

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementContext is an interface to support dynamic dispatch.
type IElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	DOTDOT() antlr.TerminalNode

	// IsElementContext differentiates from other interfaces.
	IsElementContext()
}

type ElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementContext() *ElementContext {
	var p = new(ElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_element
	return p
}

func InitEmptyElementContext(p *ElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_element
}

func (*ElementContext) IsElementContext() {}

func NewElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementContext {
	var p = new(ElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_element

	return p
}

func (s *ElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ElementContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ElementContext) DOTDOT() antlr.TerminalNode {
	return s.GetToken(pascalParserDOTDOT, 0)
}

func (s *ElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterElement(s)
	}
}

func (s *ElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitElement(s)
	}
}

func (s *ElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Element() (localctx IElementContext) {
	localctx = NewElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, pascalParserRULE_element)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1711)
		p.Expression()
	}
	p.SetState(1714)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserDOTDOT {
		{
			p.SetState(1712)
			p.Match(pascalParserDOTDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1713)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureStatementContext is an interface to support dynamic dispatch.
type IProcedureStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext

	// IsProcedureStatementContext differentiates from other interfaces.
	IsProcedureStatementContext()
}

type ProcedureStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureStatementContext() *ProcedureStatementContext {
	var p = new(ProcedureStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureStatement
	return p
}

func InitEmptyProcedureStatementContext(p *ProcedureStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureStatement
}

func (*ProcedureStatementContext) IsProcedureStatementContext() {}

func NewProcedureStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureStatementContext {
	var p = new(ProcedureStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureStatement

	return p
}

func (s *ProcedureStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ProcedureStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ProcedureStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ProcedureStatementContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *ProcedureStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureStatement(s)
	}
}

func (s *ProcedureStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureStatement(s)
	}
}

func (s *ProcedureStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureStatement() (localctx IProcedureStatementContext) {
	localctx = NewProcedureStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, pascalParserRULE_procedureStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1716)
		p.Identifier()
	}
	p.SetState(1722)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1717)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1719)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&7494095344008167848) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-1135470053887570687) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&140737488355323) != 0) {
			{
				p.SetState(1718)
				p.ParameterList()
			}

		}
		{
			p.SetState(1721)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodCallStatementContext is an interface to support dynamic dispatch.
type IMethodCallStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariableDesignator() []IVariableDesignatorContext
	VariableDesignator(i int) IVariableDesignatorContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext
	RPAREN() antlr.TerminalNode

	// IsMethodCallStatementContext differentiates from other interfaces.
	IsMethodCallStatementContext()
}

type MethodCallStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodCallStatementContext() *MethodCallStatementContext {
	var p = new(MethodCallStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_methodCallStatement
	return p
}

func InitEmptyMethodCallStatementContext(p *MethodCallStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_methodCallStatement
}

func (*MethodCallStatementContext) IsMethodCallStatementContext() {}

func NewMethodCallStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodCallStatementContext {
	var p = new(MethodCallStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_methodCallStatement

	return p
}

func (s *MethodCallStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodCallStatementContext) AllVariableDesignator() []IVariableDesignatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDesignatorContext); ok {
			len++
		}
	}

	tst := make([]IVariableDesignatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDesignatorContext); ok {
			tst[i] = t.(IVariableDesignatorContext)
			i++
		}
	}

	return tst
}

func (s *MethodCallStatementContext) VariableDesignator(i int) IVariableDesignatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDesignatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDesignatorContext)
}

func (s *MethodCallStatementContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDOT)
}

func (s *MethodCallStatementContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, i)
}

func (s *MethodCallStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MethodCallStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *MethodCallStatementContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *MethodCallStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *MethodCallStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodCallStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodCallStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterMethodCallStatement(s)
	}
}

func (s *MethodCallStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitMethodCallStatement(s)
	}
}

func (s *MethodCallStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitMethodCallStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) MethodCallStatement() (localctx IMethodCallStatementContext) {
	localctx = NewMethodCallStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, pascalParserRULE_methodCallStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1724)
		p.VariableDesignator()
	}
	p.SetState(1729)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 199, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1725)
				p.Match(pascalParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1726)
				p.VariableDesignator()
			}

		}
		p.SetState(1731)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 199, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1732)
		p.Match(pascalParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1733)
		p.Identifier()
	}
	p.SetState(1738)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1734)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1735)
			p.ParameterList()
		}
		{
			p.SetState(1736)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IActualParameterContext is an interface to support dynamic dispatch.
type IActualParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	AllParameterwidth() []IParameterwidthContext
	Parameterwidth(i int) IParameterwidthContext
	ProcedureLambdaDeclaration() IProcedureLambdaDeclarationContext
	FunctionLambdaDeclaration() IFunctionLambdaDeclarationContext

	// IsActualParameterContext differentiates from other interfaces.
	IsActualParameterContext()
}

type ActualParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActualParameterContext() *ActualParameterContext {
	var p = new(ActualParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_actualParameter
	return p
}

func InitEmptyActualParameterContext(p *ActualParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_actualParameter
}

func (*ActualParameterContext) IsActualParameterContext() {}

func NewActualParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ActualParameterContext {
	var p = new(ActualParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_actualParameter

	return p
}

func (s *ActualParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ActualParameterContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ActualParameterContext) AllParameterwidth() []IParameterwidthContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterwidthContext); ok {
			len++
		}
	}

	tst := make([]IParameterwidthContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterwidthContext); ok {
			tst[i] = t.(IParameterwidthContext)
			i++
		}
	}

	return tst
}

func (s *ActualParameterContext) Parameterwidth(i int) IParameterwidthContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterwidthContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterwidthContext)
}

func (s *ActualParameterContext) ProcedureLambdaDeclaration() IProcedureLambdaDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureLambdaDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureLambdaDeclarationContext)
}

func (s *ActualParameterContext) FunctionLambdaDeclaration() IFunctionLambdaDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionLambdaDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionLambdaDeclarationContext)
}

func (s *ActualParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ActualParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ActualParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterActualParameter(s)
	}
}

func (s *ActualParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitActualParameter(s)
	}
}

func (s *ActualParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitActualParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ActualParameter() (localctx IActualParameterContext) {
	localctx = NewActualParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, pascalParserRULE_actualParameter)
	var _la int

	p.SetState(1749)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 202, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1740)
			p.Expression()
		}
		p.SetState(1744)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == pascalParserCOLON {
			{
				p.SetState(1741)
				p.Parameterwidth()
			}

			p.SetState(1746)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1747)
			p.ProcedureLambdaDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1748)
			p.FunctionLambdaDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterwidthContext is an interface to support dynamic dispatch.
type IParameterwidthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode
	Expression() IExpressionContext

	// IsParameterwidthContext differentiates from other interfaces.
	IsParameterwidthContext()
}

type ParameterwidthContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterwidthContext() *ParameterwidthContext {
	var p = new(ParameterwidthContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterwidth
	return p
}

func InitEmptyParameterwidthContext(p *ParameterwidthContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterwidth
}

func (*ParameterwidthContext) IsParameterwidthContext() {}

func NewParameterwidthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterwidthContext {
	var p = new(ParameterwidthContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_parameterwidth

	return p
}

func (s *ParameterwidthContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterwidthContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *ParameterwidthContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParameterwidthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterwidthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterwidthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterParameterwidth(s)
	}
}

func (s *ParameterwidthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitParameterwidth(s)
	}
}

func (s *ParameterwidthContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitParameterwidth(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Parameterwidth() (localctx IParameterwidthContext) {
	localctx = NewParameterwidthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, pascalParserRULE_parameterwidth)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1751)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1752)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGotoStatementContext is an interface to support dynamic dispatch.
type IGotoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GOTO() antlr.TerminalNode
	Label() ILabelContext

	// IsGotoStatementContext differentiates from other interfaces.
	IsGotoStatementContext()
}

type GotoStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGotoStatementContext() *GotoStatementContext {
	var p = new(GotoStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_gotoStatement
	return p
}

func InitEmptyGotoStatementContext(p *GotoStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_gotoStatement
}

func (*GotoStatementContext) IsGotoStatementContext() {}

func NewGotoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GotoStatementContext {
	var p = new(GotoStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_gotoStatement

	return p
}

func (s *GotoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GotoStatementContext) GOTO() antlr.TerminalNode {
	return s.GetToken(pascalParserGOTO, 0)
}

func (s *GotoStatementContext) Label() ILabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *GotoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GotoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GotoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterGotoStatement(s)
	}
}

func (s *GotoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitGotoStatement(s)
	}
}

func (s *GotoStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitGotoStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) GotoStatement() (localctx IGotoStatementContext) {
	localctx = NewGotoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, pascalParserRULE_gotoStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1754)
		p.Match(pascalParserGOTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1755)
		p.Label()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInheritedStatementContext is an interface to support dynamic dispatch.
type IInheritedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INHERITED() antlr.TerminalNode
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext
	RPAREN() antlr.TerminalNode

	// IsInheritedStatementContext differentiates from other interfaces.
	IsInheritedStatementContext()
}

type InheritedStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInheritedStatementContext() *InheritedStatementContext {
	var p = new(InheritedStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_inheritedStatement
	return p
}

func InitEmptyInheritedStatementContext(p *InheritedStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_inheritedStatement
}

func (*InheritedStatementContext) IsInheritedStatementContext() {}

func NewInheritedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InheritedStatementContext {
	var p = new(InheritedStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_inheritedStatement

	return p
}

func (s *InheritedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InheritedStatementContext) INHERITED() antlr.TerminalNode {
	return s.GetToken(pascalParserINHERITED, 0)
}

func (s *InheritedStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InheritedStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *InheritedStatementContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *InheritedStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *InheritedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InheritedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InheritedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInheritedStatement(s)
	}
}

func (s *InheritedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInheritedStatement(s)
	}
}

func (s *InheritedStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInheritedStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InheritedStatement() (localctx IInheritedStatementContext) {
	localctx = NewInheritedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, pascalParserRULE_inheritedStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1757)
		p.Match(pascalParserINHERITED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1765)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-86)) & ^0x3f) == 0 && ((int64(1)<<(_la-86))&1099511627787) != 0 {
		{
			p.SetState(1758)
			p.Identifier()
		}
		p.SetState(1763)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLPAREN {
			{
				p.SetState(1759)
				p.Match(pascalParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1760)
				p.ParameterList()
			}
			{
				p.SetState(1761)
				p.Match(pascalParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmptyStatement_Context is an interface to support dynamic dispatch.
type IEmptyStatement_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsEmptyStatement_Context differentiates from other interfaces.
	IsEmptyStatement_Context()
}

type EmptyStatement_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatement_Context() *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_emptyStatement_
	return p
}

func InitEmptyEmptyStatement_Context(p *EmptyStatement_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_emptyStatement_
}

func (*EmptyStatement_Context) IsEmptyStatement_Context() {}

func NewEmptyStatement_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_emptyStatement_

	return p
}

func (s *EmptyStatement_Context) GetParser() antlr.Parser { return s.parser }
func (s *EmptyStatement_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatement_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatement_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitEmptyStatement_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) EmptyStatement_() (localctx IEmptyStatement_Context) {
	localctx = NewEmptyStatement_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, pascalParserRULE_emptyStatement_)
	p.EnterOuterAlt(localctx, 1)

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmpty_Context is an interface to support dynamic dispatch.
type IEmpty_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsEmpty_Context differentiates from other interfaces.
	IsEmpty_Context()
}

type Empty_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmpty_Context() *Empty_Context {
	var p = new(Empty_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_empty_
	return p
}

func InitEmptyEmpty_Context(p *Empty_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_empty_
}

func (*Empty_Context) IsEmpty_Context() {}

func NewEmpty_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Empty_Context {
	var p = new(Empty_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_empty_

	return p
}

func (s *Empty_Context) GetParser() antlr.Parser { return s.parser }
func (s *Empty_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Empty_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Empty_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterEmpty_(s)
	}
}

func (s *Empty_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitEmpty_(s)
	}
}

func (s *Empty_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitEmpty_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Empty_() (localctx IEmpty_Context) {
	localctx = NewEmpty_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, pascalParserRULE_empty_)
	p.EnterOuterAlt(localctx, 1)

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructuredStatementContext is an interface to support dynamic dispatch.
type IStructuredStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CompoundStatement() ICompoundStatementContext
	ConditionalStatement() IConditionalStatementContext
	RepetetiveStatement() IRepetetiveStatementContext
	WithStatement() IWithStatementContext
	TryExceptStatement() ITryExceptStatementContext
	TryFinallyStatement() ITryFinallyStatementContext

	// IsStructuredStatementContext differentiates from other interfaces.
	IsStructuredStatementContext()
}

type StructuredStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructuredStatementContext() *StructuredStatementContext {
	var p = new(StructuredStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_structuredStatement
	return p
}

func InitEmptyStructuredStatementContext(p *StructuredStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_structuredStatement
}

func (*StructuredStatementContext) IsStructuredStatementContext() {}

func NewStructuredStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructuredStatementContext {
	var p = new(StructuredStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_structuredStatement

	return p
}

func (s *StructuredStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StructuredStatementContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *StructuredStatementContext) ConditionalStatement() IConditionalStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalStatementContext)
}

func (s *StructuredStatementContext) RepetetiveStatement() IRepetetiveStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepetetiveStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepetetiveStatementContext)
}

func (s *StructuredStatementContext) WithStatement() IWithStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithStatementContext)
}

func (s *StructuredStatementContext) TryExceptStatement() ITryExceptStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryExceptStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryExceptStatementContext)
}

func (s *StructuredStatementContext) TryFinallyStatement() ITryFinallyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryFinallyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryFinallyStatementContext)
}

func (s *StructuredStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructuredStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructuredStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStructuredStatement(s)
	}
}

func (s *StructuredStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStructuredStatement(s)
	}
}

func (s *StructuredStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStructuredStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) StructuredStatement() (localctx IStructuredStatementContext) {
	localctx = NewStructuredStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, pascalParserRULE_structuredStatement)
	p.SetState(1777)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 205, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1771)
			p.CompoundStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1772)
			p.ConditionalStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1773)
			p.RepetetiveStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1774)
			p.WithStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1775)
			p.TryExceptStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1776)
			p.TryFinallyStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompoundStatementContext is an interface to support dynamic dispatch.
type ICompoundStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEGIN() antlr.TerminalNode
	Statements() IStatementsContext
	END() antlr.TerminalNode

	// IsCompoundStatementContext differentiates from other interfaces.
	IsCompoundStatementContext()
}

type CompoundStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundStatementContext() *CompoundStatementContext {
	var p = new(CompoundStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_compoundStatement
	return p
}

func InitEmptyCompoundStatementContext(p *CompoundStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_compoundStatement
}

func (*CompoundStatementContext) IsCompoundStatementContext() {}

func NewCompoundStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundStatementContext {
	var p = new(CompoundStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_compoundStatement

	return p
}

func (s *CompoundStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundStatementContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(pascalParserBEGIN, 0)
}

func (s *CompoundStatementContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *CompoundStatementContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *CompoundStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitCompoundStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) CompoundStatement() (localctx ICompoundStatementContext) {
	localctx = NewCompoundStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, pascalParserRULE_compoundStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1779)
		p.Match(pascalParserBEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1780)
		p.Statements()
	}
	{
		p.SetState(1781)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementsContext is an interface to support dynamic dispatch.
type IStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsStatementsContext differentiates from other interfaces.
	IsStatementsContext()
}

type StatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsContext() *StatementsContext {
	var p = new(StatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_statements
	return p
}

func InitEmptyStatementsContext(p *StatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_statements
}

func (*StatementsContext) IsStatementsContext() {}

func NewStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsContext {
	var p = new(StatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_statements

	return p
}

func (s *StatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementsContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementsContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *StatementsContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *StatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStatements(s)
	}
}

func (s *StatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStatements(s)
	}
}

func (s *StatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Statements() (localctx IStatementsContext) {
	localctx = NewStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, pascalParserRULE_statements)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1783)
		p.Statement()
	}
	p.SetState(1788)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1784)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1785)
				p.Statement()
			}

		}
		p.SetState(1790)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionalStatementContext is an interface to support dynamic dispatch.
type IConditionalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IfStatement() IIfStatementContext
	CaseStatement() ICaseStatementContext

	// IsConditionalStatementContext differentiates from other interfaces.
	IsConditionalStatementContext()
}

type ConditionalStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalStatementContext() *ConditionalStatementContext {
	var p = new(ConditionalStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_conditionalStatement
	return p
}

func InitEmptyConditionalStatementContext(p *ConditionalStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_conditionalStatement
}

func (*ConditionalStatementContext) IsConditionalStatementContext() {}

func NewConditionalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalStatementContext {
	var p = new(ConditionalStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_conditionalStatement

	return p
}

func (s *ConditionalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalStatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *ConditionalStatementContext) CaseStatement() ICaseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseStatementContext)
}

func (s *ConditionalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConditionalStatement(s)
	}
}

func (s *ConditionalStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConditionalStatement(s)
	}
}

func (s *ConditionalStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConditionalStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConditionalStatement() (localctx IConditionalStatementContext) {
	localctx = NewConditionalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, pascalParserRULE_conditionalStatement)
	p.SetState(1793)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserIF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1791)
			p.IfStatement()
		}

	case pascalParserCASE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1792)
			p.CaseStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	Expression() IExpressionContext
	THEN() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	ELSE() antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_ifStatement
	return p
}

func InitEmptyIfStatementContext(p *IfStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_ifStatement
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(pascalParserIF, 0)
}

func (s *IfStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfStatementContext) THEN() antlr.TerminalNode {
	return s.GetToken(pascalParserTHEN, 0)
}

func (s *IfStatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(pascalParserELSE, 0)
}

func (s *IfStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, pascalParserRULE_ifStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1795)
		p.Match(pascalParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1796)
		p.Expression()
	}
	{
		p.SetState(1797)
		p.Match(pascalParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1798)
		p.Statement()
	}
	p.SetState(1801)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 208, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1799)
			p.Match(pascalParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1800)
			p.Statement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1804)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 209, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1803)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseStatementContext is an interface to support dynamic dispatch.
type ICaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	Expression() IExpressionContext
	OF() antlr.TerminalNode
	AllCaseListElement() []ICaseListElementContext
	CaseListElement(i int) ICaseListElementContext
	END() antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	ELSE() antlr.TerminalNode
	Statements() IStatementsContext

	// IsCaseStatementContext differentiates from other interfaces.
	IsCaseStatementContext()
}

type CaseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseStatementContext() *CaseStatementContext {
	var p = new(CaseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_caseStatement
	return p
}

func InitEmptyCaseStatementContext(p *CaseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_caseStatement
}

func (*CaseStatementContext) IsCaseStatementContext() {}

func NewCaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseStatementContext {
	var p = new(CaseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_caseStatement

	return p
}

func (s *CaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseStatementContext) CASE() antlr.TerminalNode {
	return s.GetToken(pascalParserCASE, 0)
}

func (s *CaseStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseStatementContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *CaseStatementContext) AllCaseListElement() []ICaseListElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseListElementContext); ok {
			len++
		}
	}

	tst := make([]ICaseListElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseListElementContext); ok {
			tst[i] = t.(ICaseListElementContext)
			i++
		}
	}

	return tst
}

func (s *CaseStatementContext) CaseListElement(i int) ICaseListElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseListElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseListElementContext)
}

func (s *CaseStatementContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *CaseStatementContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *CaseStatementContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *CaseStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(pascalParserELSE, 0)
}

func (s *CaseStatementContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *CaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterCaseStatement(s)
	}
}

func (s *CaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitCaseStatement(s)
	}
}

func (s *CaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitCaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) CaseStatement() (localctx ICaseStatementContext) {
	localctx = NewCaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, pascalParserRULE_caseStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1806)
		p.Match(pascalParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1807)
		p.Expression()
	}
	{
		p.SetState(1808)
		p.Match(pascalParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1809)
		p.CaseListElement()
	}
	p.SetState(1814)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 210, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1810)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1811)
				p.CaseListElement()
			}

		}
		p.SetState(1816)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 210, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1820)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 211, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1817)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1818)
			p.Match(pascalParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1819)
			p.Statements()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1823)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserSEMI {
		{
			p.SetState(1822)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1825)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseListElementContext is an interface to support dynamic dispatch.
type ICaseListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConstList() IConstListContext
	COLON() antlr.TerminalNode
	Statement() IStatementContext

	// IsCaseListElementContext differentiates from other interfaces.
	IsCaseListElementContext()
}

type CaseListElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseListElementContext() *CaseListElementContext {
	var p = new(CaseListElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_caseListElement
	return p
}

func InitEmptyCaseListElementContext(p *CaseListElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_caseListElement
}

func (*CaseListElementContext) IsCaseListElementContext() {}

func NewCaseListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseListElementContext {
	var p = new(CaseListElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_caseListElement

	return p
}

func (s *CaseListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseListElementContext) ConstList() IConstListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstListContext)
}

func (s *CaseListElementContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *CaseListElementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *CaseListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseListElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterCaseListElement(s)
	}
}

func (s *CaseListElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitCaseListElement(s)
	}
}

func (s *CaseListElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitCaseListElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) CaseListElement() (localctx ICaseListElementContext) {
	localctx = NewCaseListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, pascalParserRULE_caseListElement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1827)
		p.ConstList()
	}
	{
		p.SetState(1828)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1829)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRepetetiveStatementContext is an interface to support dynamic dispatch.
type IRepetetiveStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WhileStatement() IWhileStatementContext
	RepeatStatement() IRepeatStatementContext
	ForStatement() IForStatementContext

	// IsRepetetiveStatementContext differentiates from other interfaces.
	IsRepetetiveStatementContext()
}

type RepetetiveStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepetetiveStatementContext() *RepetetiveStatementContext {
	var p = new(RepetetiveStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_repetetiveStatement
	return p
}

func InitEmptyRepetetiveStatementContext(p *RepetetiveStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_repetetiveStatement
}

func (*RepetetiveStatementContext) IsRepetetiveStatementContext() {}

func NewRepetetiveStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RepetetiveStatementContext {
	var p = new(RepetetiveStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_repetetiveStatement

	return p
}

func (s *RepetetiveStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RepetetiveStatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *RepetetiveStatementContext) RepeatStatement() IRepeatStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepeatStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepeatStatementContext)
}

func (s *RepetetiveStatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *RepetetiveStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepetetiveStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RepetetiveStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRepetetiveStatement(s)
	}
}

func (s *RepetetiveStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRepetetiveStatement(s)
	}
}

func (s *RepetetiveStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRepetetiveStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RepetetiveStatement() (localctx IRepetetiveStatementContext) {
	localctx = NewRepetetiveStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, pascalParserRULE_repetetiveStatement)
	p.SetState(1834)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserWHILE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1831)
			p.WhileStatement()
		}

	case pascalParserREPEAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1832)
			p.RepeatStatement()
		}

	case pascalParserFOR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1833)
			p.ForStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHILE() antlr.TerminalNode
	Expression() IExpressionContext
	DO() antlr.TerminalNode
	Statement() IStatementContext

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_whileStatement
	return p
}

func InitEmptyWhileStatementContext(p *WhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_whileStatement
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(pascalParserWHILE, 0)
}

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(pascalParserDO, 0)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (s *WhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, pascalParserRULE_whileStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1836)
		p.Match(pascalParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1837)
		p.Expression()
	}
	{
		p.SetState(1838)
		p.Match(pascalParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1839)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRepeatStatementContext is an interface to support dynamic dispatch.
type IRepeatStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPEAT() antlr.TerminalNode
	Statements() IStatementsContext
	UNTIL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsRepeatStatementContext differentiates from other interfaces.
	IsRepeatStatementContext()
}

type RepeatStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepeatStatementContext() *RepeatStatementContext {
	var p = new(RepeatStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_repeatStatement
	return p
}

func InitEmptyRepeatStatementContext(p *RepeatStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_repeatStatement
}

func (*RepeatStatementContext) IsRepeatStatementContext() {}

func NewRepeatStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RepeatStatementContext {
	var p = new(RepeatStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_repeatStatement

	return p
}

func (s *RepeatStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RepeatStatementContext) REPEAT() antlr.TerminalNode {
	return s.GetToken(pascalParserREPEAT, 0)
}

func (s *RepeatStatementContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *RepeatStatementContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(pascalParserUNTIL, 0)
}

func (s *RepeatStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RepeatStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepeatStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RepeatStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRepeatStatement(s)
	}
}

func (s *RepeatStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRepeatStatement(s)
	}
}

func (s *RepeatStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRepeatStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RepeatStatement() (localctx IRepeatStatementContext) {
	localctx = NewRepeatStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, pascalParserRULE_repeatStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1841)
		p.Match(pascalParserREPEAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1842)
		p.Statements()
	}
	{
		p.SetState(1843)
		p.Match(pascalParserUNTIL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1844)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode
	ForList() IForListContext
	DO() antlr.TerminalNode
	Statement() IStatementContext
	VAR() antlr.TerminalNode
	IN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forStatement
	return p
}

func InitEmptyForStatementContext(p *ForStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forStatement
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(pascalParserFOR, 0)
}

func (s *ForStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ForStatementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(pascalParserASSIGN, 0)
}

func (s *ForStatementContext) ForList() IForListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForListContext)
}

func (s *ForStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(pascalParserDO, 0)
}

func (s *ForStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatementContext) VAR() antlr.TerminalNode {
	return s.GetToken(pascalParserVAR, 0)
}

func (s *ForStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(pascalParserIN, 0)
}

func (s *ForStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (s *ForStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitForStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ForStatement() (localctx IForStatementContext) {
	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, pascalParserRULE_forStatement)
	var _la int

	p.SetState(1866)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 216, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1846)
			p.Match(pascalParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1848)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserVAR {
			{
				p.SetState(1847)
				p.Match(pascalParserVAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1850)
			p.Identifier()
		}
		{
			p.SetState(1851)
			p.Match(pascalParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1852)
			p.ForList()
		}
		{
			p.SetState(1853)
			p.Match(pascalParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1854)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1856)
			p.Match(pascalParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1858)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserVAR {
			{
				p.SetState(1857)
				p.Match(pascalParserVAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1860)
			p.Identifier()
		}
		{
			p.SetState(1861)
			p.Match(pascalParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1862)
			p.Expression()
		}
		{
			p.SetState(1863)
			p.Match(pascalParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1864)
			p.Statement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForListContext is an interface to support dynamic dispatch.
type IForListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InitialValue() IInitialValueContext
	FinalValue() IFinalValueContext
	TO() antlr.TerminalNode
	DOWNTO() antlr.TerminalNode

	// IsForListContext differentiates from other interfaces.
	IsForListContext()
}

type ForListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForListContext() *ForListContext {
	var p = new(ForListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forList
	return p
}

func InitEmptyForListContext(p *ForListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forList
}

func (*ForListContext) IsForListContext() {}

func NewForListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForListContext {
	var p = new(ForListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_forList

	return p
}

func (s *ForListContext) GetParser() antlr.Parser { return s.parser }

func (s *ForListContext) InitialValue() IInitialValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitialValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitialValueContext)
}

func (s *ForListContext) FinalValue() IFinalValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinalValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinalValueContext)
}

func (s *ForListContext) TO() antlr.TerminalNode {
	return s.GetToken(pascalParserTO, 0)
}

func (s *ForListContext) DOWNTO() antlr.TerminalNode {
	return s.GetToken(pascalParserDOWNTO, 0)
}

func (s *ForListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterForList(s)
	}
}

func (s *ForListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitForList(s)
	}
}

func (s *ForListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitForList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ForList() (localctx IForListContext) {
	localctx = NewForListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, pascalParserRULE_forList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1868)
		p.InitialValue()
	}
	{
		p.SetState(1869)
		_la = p.GetTokenStream().LA(1)

		if !(_la == pascalParserDOWNTO || _la == pascalParserTO) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1870)
		p.FinalValue()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitialValueContext is an interface to support dynamic dispatch.
type IInitialValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsInitialValueContext differentiates from other interfaces.
	IsInitialValueContext()
}

type InitialValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitialValueContext() *InitialValueContext {
	var p = new(InitialValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_initialValue
	return p
}

func InitEmptyInitialValueContext(p *InitialValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_initialValue
}

func (*InitialValueContext) IsInitialValueContext() {}

func NewInitialValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitialValueContext {
	var p = new(InitialValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_initialValue

	return p
}

func (s *InitialValueContext) GetParser() antlr.Parser { return s.parser }

func (s *InitialValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InitialValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitialValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitialValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInitialValue(s)
	}
}

func (s *InitialValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInitialValue(s)
	}
}

func (s *InitialValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInitialValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InitialValue() (localctx IInitialValueContext) {
	localctx = NewInitialValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, pascalParserRULE_initialValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1872)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFinalValueContext is an interface to support dynamic dispatch.
type IFinalValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsFinalValueContext differentiates from other interfaces.
	IsFinalValueContext()
}

type FinalValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinalValueContext() *FinalValueContext {
	var p = new(FinalValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_finalValue
	return p
}

func InitEmptyFinalValueContext(p *FinalValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_finalValue
}

func (*FinalValueContext) IsFinalValueContext() {}

func NewFinalValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinalValueContext {
	var p = new(FinalValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_finalValue

	return p
}

func (s *FinalValueContext) GetParser() antlr.Parser { return s.parser }

func (s *FinalValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FinalValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinalValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinalValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFinalValue(s)
	}
}

func (s *FinalValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFinalValue(s)
	}
}

func (s *FinalValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFinalValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FinalValue() (localctx IFinalValueContext) {
	localctx = NewFinalValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, pascalParserRULE_finalValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1874)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithStatementContext is an interface to support dynamic dispatch.
type IWithStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	WithStatementVariableList() IWithStatementVariableListContext
	DO() antlr.TerminalNode
	Statement() IStatementContext
	Expression() IExpressionContext

	// IsWithStatementContext differentiates from other interfaces.
	IsWithStatementContext()
}

type WithStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithStatementContext() *WithStatementContext {
	var p = new(WithStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_withStatement
	return p
}

func InitEmptyWithStatementContext(p *WithStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_withStatement
}

func (*WithStatementContext) IsWithStatementContext() {}

func NewWithStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithStatementContext {
	var p = new(WithStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_withStatement

	return p
}

func (s *WithStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WithStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(pascalParserWITH, 0)
}

func (s *WithStatementContext) WithStatementVariableList() IWithStatementVariableListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithStatementVariableListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithStatementVariableListContext)
}

func (s *WithStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(pascalParserDO, 0)
}

func (s *WithStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WithStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WithStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterWithStatement(s)
	}
}

func (s *WithStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitWithStatement(s)
	}
}

func (s *WithStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitWithStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) WithStatement() (localctx IWithStatementContext) {
	localctx = NewWithStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, pascalParserRULE_withStatement)
	p.SetState(1886)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 217, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1876)
			p.Match(pascalParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1877)
			p.WithStatementVariableList()
		}
		{
			p.SetState(1878)
			p.Match(pascalParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1879)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1881)
			p.Match(pascalParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1882)
			p.Expression()
		}
		{
			p.SetState(1883)
			p.Match(pascalParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1884)
			p.Statement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryExceptStatementContext is an interface to support dynamic dispatch.
type ITryExceptStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRY() antlr.TerminalNode
	AllStatements() []IStatementsContext
	Statements(i int) IStatementsContext
	EXCEPT() antlr.TerminalNode
	END() antlr.TerminalNode
	AllExceptionCase() []IExceptionCaseContext
	ExceptionCase(i int) IExceptionCaseContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	ExceptionElse() IExceptionElseContext

	// IsTryExceptStatementContext differentiates from other interfaces.
	IsTryExceptStatementContext()
}

type TryExceptStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryExceptStatementContext() *TryExceptStatementContext {
	var p = new(TryExceptStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tryExceptStatement
	return p
}

func InitEmptyTryExceptStatementContext(p *TryExceptStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tryExceptStatement
}

func (*TryExceptStatementContext) IsTryExceptStatementContext() {}

func NewTryExceptStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryExceptStatementContext {
	var p = new(TryExceptStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_tryExceptStatement

	return p
}

func (s *TryExceptStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryExceptStatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(pascalParserTRY, 0)
}

func (s *TryExceptStatementContext) AllStatements() []IStatementsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementsContext); ok {
			len++
		}
	}

	tst := make([]IStatementsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementsContext); ok {
			tst[i] = t.(IStatementsContext)
			i++
		}
	}

	return tst
}

func (s *TryExceptStatementContext) Statements(i int) IStatementsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *TryExceptStatementContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(pascalParserEXCEPT, 0)
}

func (s *TryExceptStatementContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *TryExceptStatementContext) AllExceptionCase() []IExceptionCaseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExceptionCaseContext); ok {
			len++
		}
	}

	tst := make([]IExceptionCaseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExceptionCaseContext); ok {
			tst[i] = t.(IExceptionCaseContext)
			i++
		}
	}

	return tst
}

func (s *TryExceptStatementContext) ExceptionCase(i int) IExceptionCaseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExceptionCaseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExceptionCaseContext)
}

func (s *TryExceptStatementContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *TryExceptStatementContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *TryExceptStatementContext) ExceptionElse() IExceptionElseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExceptionElseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExceptionElseContext)
}

func (s *TryExceptStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryExceptStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryExceptStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTryExceptStatement(s)
	}
}

func (s *TryExceptStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTryExceptStatement(s)
	}
}

func (s *TryExceptStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTryExceptStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TryExceptStatement() (localctx ITryExceptStatementContext) {
	localctx = NewTryExceptStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, pascalParserRULE_tryExceptStatement)
	var _la int

	p.SetState(1909)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 220, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1888)
			p.Match(pascalParserTRY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1889)
			p.Statements()
		}
		{
			p.SetState(1890)
			p.Match(pascalParserEXCEPT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1891)
			p.Statements()
		}
		{
			p.SetState(1892)
			p.Match(pascalParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1894)
			p.Match(pascalParserTRY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1895)
			p.Statements()
		}
		{
			p.SetState(1896)
			p.Match(pascalParserEXCEPT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1900)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == pascalParserON {
			{
				p.SetState(1897)
				p.ExceptionCase()
			}
			{
				p.SetState(1898)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1902)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1905)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserELSE {
			{
				p.SetState(1904)
				p.ExceptionElse()
			}

		}
		{
			p.SetState(1907)
			p.Match(pascalParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExceptionCaseContext is an interface to support dynamic dispatch.
type IExceptionCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	DO() antlr.TerminalNode
	Statements() IStatementsContext

	// IsExceptionCaseContext differentiates from other interfaces.
	IsExceptionCaseContext()
}

type ExceptionCaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExceptionCaseContext() *ExceptionCaseContext {
	var p = new(ExceptionCaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_exceptionCase
	return p
}

func InitEmptyExceptionCaseContext(p *ExceptionCaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_exceptionCase
}

func (*ExceptionCaseContext) IsExceptionCaseContext() {}

func NewExceptionCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptionCaseContext {
	var p = new(ExceptionCaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_exceptionCase

	return p
}

func (s *ExceptionCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptionCaseContext) ON() antlr.TerminalNode {
	return s.GetToken(pascalParserON, 0)
}

func (s *ExceptionCaseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExceptionCaseContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *ExceptionCaseContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ExceptionCaseContext) DO() antlr.TerminalNode {
	return s.GetToken(pascalParserDO, 0)
}

func (s *ExceptionCaseContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *ExceptionCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptionCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExceptionCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterExceptionCase(s)
	}
}

func (s *ExceptionCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitExceptionCase(s)
	}
}

func (s *ExceptionCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitExceptionCase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ExceptionCase() (localctx IExceptionCaseContext) {
	localctx = NewExceptionCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, pascalParserRULE_exceptionCase)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1911)
		p.Match(pascalParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1912)
		p.Identifier()
	}
	{
		p.SetState(1913)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1914)
		p.TypeIdentifier()
	}
	{
		p.SetState(1915)
		p.Match(pascalParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1916)
		p.Statements()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExceptionElseContext is an interface to support dynamic dispatch.
type IExceptionElseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELSE() antlr.TerminalNode
	Statements() IStatementsContext

	// IsExceptionElseContext differentiates from other interfaces.
	IsExceptionElseContext()
}

type ExceptionElseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExceptionElseContext() *ExceptionElseContext {
	var p = new(ExceptionElseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_exceptionElse
	return p
}

func InitEmptyExceptionElseContext(p *ExceptionElseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_exceptionElse
}

func (*ExceptionElseContext) IsExceptionElseContext() {}

func NewExceptionElseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptionElseContext {
	var p = new(ExceptionElseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_exceptionElse

	return p
}

func (s *ExceptionElseContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptionElseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(pascalParserELSE, 0)
}

func (s *ExceptionElseContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *ExceptionElseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptionElseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExceptionElseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterExceptionElse(s)
	}
}

func (s *ExceptionElseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitExceptionElse(s)
	}
}

func (s *ExceptionElseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitExceptionElse(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ExceptionElse() (localctx IExceptionElseContext) {
	localctx = NewExceptionElseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, pascalParserRULE_exceptionElse)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1918)
		p.Match(pascalParserELSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1919)
		p.Statements()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryFinallyStatementContext is an interface to support dynamic dispatch.
type ITryFinallyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRY() antlr.TerminalNode
	AllStatements() []IStatementsContext
	Statements(i int) IStatementsContext
	FINALLY() antlr.TerminalNode
	END() antlr.TerminalNode

	// IsTryFinallyStatementContext differentiates from other interfaces.
	IsTryFinallyStatementContext()
}

type TryFinallyStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryFinallyStatementContext() *TryFinallyStatementContext {
	var p = new(TryFinallyStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tryFinallyStatement
	return p
}

func InitEmptyTryFinallyStatementContext(p *TryFinallyStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tryFinallyStatement
}

func (*TryFinallyStatementContext) IsTryFinallyStatementContext() {}

func NewTryFinallyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryFinallyStatementContext {
	var p = new(TryFinallyStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_tryFinallyStatement

	return p
}

func (s *TryFinallyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryFinallyStatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(pascalParserTRY, 0)
}

func (s *TryFinallyStatementContext) AllStatements() []IStatementsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementsContext); ok {
			len++
		}
	}

	tst := make([]IStatementsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementsContext); ok {
			tst[i] = t.(IStatementsContext)
			i++
		}
	}

	return tst
}

func (s *TryFinallyStatementContext) Statements(i int) IStatementsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *TryFinallyStatementContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(pascalParserFINALLY, 0)
}

func (s *TryFinallyStatementContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *TryFinallyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryFinallyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryFinallyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTryFinallyStatement(s)
	}
}

func (s *TryFinallyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTryFinallyStatement(s)
	}
}

func (s *TryFinallyStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTryFinallyStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TryFinallyStatement() (localctx ITryFinallyStatementContext) {
	localctx = NewTryFinallyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, pascalParserRULE_tryFinallyStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1921)
		p.Match(pascalParserTRY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1922)
		p.Statements()
	}
	{
		p.SetState(1923)
		p.Match(pascalParserFINALLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1924)
		p.Statements()
	}
	{
		p.SetState(1925)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithStatementVariableListContext is an interface to support dynamic dispatch.
type IWithStatementVariableListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariableDesignator() []IVariableDesignatorContext
	VariableDesignator(i int) IVariableDesignatorContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWithStatementVariableListContext differentiates from other interfaces.
	IsWithStatementVariableListContext()
}

type WithStatementVariableListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithStatementVariableListContext() *WithStatementVariableListContext {
	var p = new(WithStatementVariableListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_withStatementVariableList
	return p
}

func InitEmptyWithStatementVariableListContext(p *WithStatementVariableListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_withStatementVariableList
}

func (*WithStatementVariableListContext) IsWithStatementVariableListContext() {}

func NewWithStatementVariableListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithStatementVariableListContext {
	var p = new(WithStatementVariableListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_withStatementVariableList

	return p
}

func (s *WithStatementVariableListContext) GetParser() antlr.Parser { return s.parser }

func (s *WithStatementVariableListContext) AllVariableDesignator() []IVariableDesignatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDesignatorContext); ok {
			len++
		}
	}

	tst := make([]IVariableDesignatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDesignatorContext); ok {
			tst[i] = t.(IVariableDesignatorContext)
			i++
		}
	}

	return tst
}

func (s *WithStatementVariableListContext) VariableDesignator(i int) IVariableDesignatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDesignatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDesignatorContext)
}

func (s *WithStatementVariableListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *WithStatementVariableListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *WithStatementVariableListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithStatementVariableListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithStatementVariableListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterWithStatementVariableList(s)
	}
}

func (s *WithStatementVariableListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitWithStatementVariableList(s)
	}
}

func (s *WithStatementVariableListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitWithStatementVariableList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) WithStatementVariableList() (localctx IWithStatementVariableListContext) {
	localctx = NewWithStatementVariableListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, pascalParserRULE_withStatementVariableList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1927)
		p.VariableDesignator()
	}
	p.SetState(1932)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(1928)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1929)
			p.VariableDesignator()
		}

		p.SetState(1934)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeSectionContext is an interface to support dynamic dispatch.
type IAttributeSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	AttributeList() IAttributeListContext
	RBRACK() antlr.TerminalNode

	// IsAttributeSectionContext differentiates from other interfaces.
	IsAttributeSectionContext()
}

type AttributeSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeSectionContext() *AttributeSectionContext {
	var p = new(AttributeSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_attributeSection
	return p
}

func InitEmptyAttributeSectionContext(p *AttributeSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_attributeSection
}

func (*AttributeSectionContext) IsAttributeSectionContext() {}

func NewAttributeSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeSectionContext {
	var p = new(AttributeSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_attributeSection

	return p
}

func (s *AttributeSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeSectionContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *AttributeSectionContext) AttributeList() IAttributeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeListContext)
}

func (s *AttributeSectionContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *AttributeSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAttributeSection(s)
	}
}

func (s *AttributeSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAttributeSection(s)
	}
}

func (s *AttributeSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAttributeSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) AttributeSection() (localctx IAttributeSectionContext) {
	localctx = NewAttributeSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, pascalParserRULE_attributeSection)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1935)
		p.Match(pascalParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1936)
		p.AttributeList()
	}
	{
		p.SetState(1937)
		p.Match(pascalParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeListContext is an interface to support dynamic dispatch.
type IAttributeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAttributeItem() []IAttributeItemContext
	AttributeItem(i int) IAttributeItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAttributeListContext differentiates from other interfaces.
	IsAttributeListContext()
}

type AttributeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeListContext() *AttributeListContext {
	var p = new(AttributeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_attributeList
	return p
}

func InitEmptyAttributeListContext(p *AttributeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_attributeList
}

func (*AttributeListContext) IsAttributeListContext() {}

func NewAttributeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeListContext {
	var p = new(AttributeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_attributeList

	return p
}

func (s *AttributeListContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeListContext) AllAttributeItem() []IAttributeItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeItemContext); ok {
			len++
		}
	}

	tst := make([]IAttributeItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeItemContext); ok {
			tst[i] = t.(IAttributeItemContext)
			i++
		}
	}

	return tst
}

func (s *AttributeListContext) AttributeItem(i int) IAttributeItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeItemContext)
}

func (s *AttributeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *AttributeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *AttributeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAttributeList(s)
	}
}

func (s *AttributeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAttributeList(s)
	}
}

func (s *AttributeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAttributeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) AttributeList() (localctx IAttributeListContext) {
	localctx = NewAttributeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, pascalParserRULE_attributeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1939)
		p.AttributeItem()
	}
	p.SetState(1944)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(1940)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1941)
			p.AttributeItem()
		}

		p.SetState(1946)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeItemContext is an interface to support dynamic dispatch.
type IAttributeItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext
	RPAREN() antlr.TerminalNode

	// IsAttributeItemContext differentiates from other interfaces.
	IsAttributeItemContext()
}

type AttributeItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeItemContext() *AttributeItemContext {
	var p = new(AttributeItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_attributeItem
	return p
}

func InitEmptyAttributeItemContext(p *AttributeItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_attributeItem
}

func (*AttributeItemContext) IsAttributeItemContext() {}

func NewAttributeItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeItemContext {
	var p = new(AttributeItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_attributeItem

	return p
}

func (s *AttributeItemContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AttributeItemContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *AttributeItemContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *AttributeItemContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *AttributeItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAttributeItem(s)
	}
}

func (s *AttributeItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAttributeItem(s)
	}
}

func (s *AttributeItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAttributeItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) AttributeItem() (localctx IAttributeItemContext) {
	localctx = NewAttributeItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, pascalParserRULE_attributeItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1947)
		p.Identifier()
	}
	p.SetState(1952)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1948)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1949)
			p.ParameterList()
		}
		{
			p.SetState(1950)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *pascalParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 139:
		var t *FactorContext = nil
		if localctx != nil {
			t = localctx.(*FactorContext)
		}
		return p.Factor_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *pascalParser) Factor_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
