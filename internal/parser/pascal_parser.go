// Code generated from /home/tomas/development/tomas303/projects/pascallsp/palsp/internal/pascal.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // pascal

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type pascalParser struct {
	*antlr.BaseParser
}

var PascalParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func pascalParserInit() {
	staticData := &PascalParserStaticData
	staticData.LiteralNames = []string{
		"", "", "'AND'", "'ARRAY'", "'BEGIN'", "'BOOLEAN'", "'CASE'", "'CHAR'",
		"'CHR'", "'CONST'", "'DIV'", "'DO'", "'DOWNTO'", "'ELSE'", "'END'",
		"'FILE'", "'FOR'", "'FUNCTION'", "'GOTO'", "'HELPER'", "'IF'", "'IN'",
		"'INTEGER'", "'LABEL'", "'MOD'", "'NIL'", "'NOT'", "'OF'", "'OR'", "'PACKED'",
		"'PROCEDURE'", "'PROGRAM'", "'REAL'", "'RECORD'", "'REFERENCE'", "'REPEAT'",
		"'SET'", "'THEN'", "'TO'", "'TYPE'", "'UNTIL'", "'VAR'", "'WHILE'",
		"'WITH'", "'+'", "'-'", "'*'", "'/'", "':='", "','", "';'", "':'", "'='",
		"'<>'", "'<'", "'<='", "'>='", "'>'", "'('", "')'", "'['", "'(.'", "']'",
		"'.)'", "'^'", "'@'", "'.'", "'..'", "'{'", "'}'", "'UNIT'", "'INTERFACE'",
		"'USES'", "'STRING'", "'IMPLEMENTATION'", "'TRUE'", "'FALSE'", "'CLASS'",
		"'PRIVATE'", "'PROTECTED'", "'PUBLIC'", "'PUBLISHED'", "'STRICT'", "'OUT'",
		"'PROPERTY'", "'READ'", "'WRITE'", "'DEFAULT'", "'INDEX'", "'AS'", "'TRY'",
		"'FINALLY'", "'EXCEPT'", "'INITIALIZATION'", "'FINALIZATION'", "'OBJECT'",
		"'INHERITED'", "'ABSTRACT'", "'REINTRODUCE'", "'VIRTUAL'", "'OVERRIDE'",
		"'OVERLOAD'", "'INLINE'", "'CDECL'", "'stdcall'", "'STATIC'", "'CONSTRUCTOR'",
		"'DESTRUCTOR'", "'resourcestring'", "'FORWARD'", "'RAISE'", "'SHR'",
		"'SHL'", "'XOR'", "'Cardinal'", "'LONGBOOL'", "'LONGINT'", "'operator'",
		"'ON'", "", "", "", "", "", "", "", "", "", "", "'\\uFEFF'",
	}
	staticData.SymbolicNames = []string{
		"", "GUID_LITERAL", "AND", "ARRAY", "BEGIN", "BOOLEAN", "CASE", "CHAR",
		"CHR", "CONST", "DIV", "DO", "DOWNTO", "ELSE", "END", "FILE", "FOR",
		"FUNCTION", "GOTO", "HELPER", "IF", "IN", "INTEGER", "LABEL", "MOD",
		"NIL", "NOT", "OF", "OR", "PACKED", "PROCEDURE", "PROGRAM", "REAL",
		"RECORD", "REFERENCE", "REPEAT", "SET", "THEN", "TO", "TYPE", "UNTIL",
		"VAR", "WHILE", "WITH", "PLUS", "MINUS", "STAR", "SLASH", "ASSIGN",
		"COMMA", "SEMI", "COLON", "EQUAL", "NOT_EQUAL", "LT", "LE", "GE", "GT",
		"LPAREN", "RPAREN", "LBRACK", "LBRACK2", "RBRACK", "RBRACK2", "DEREFERENCE",
		"AT", "DOT", "DOTDOT", "LCURLY", "RCURLY", "UNIT", "INTERFACE", "USES",
		"STRING", "IMPLEMENTATION", "TRUE", "FALSE", "CLASS", "PRIVATE", "PROTECTED",
		"PUBLIC", "PUBLISHED", "STRICT", "OUT", "PROPERTY", "READ", "WRITE",
		"DEFAULT", "INDEX", "AS", "TRY", "FINALLY", "EXCEPT", "INITIALIZATION",
		"FINALIZATION", "OBJECT", "INHERITED", "ABSTRACT", "REINTRODUCE", "VIRTUAL",
		"OVERRIDE", "OVERLOAD", "INLINE", "CDECL", "STDCALL", "STATIC", "CONSTRUCTOR",
		"DESTRUCTOR", "RESOURCESTRING", "FORWARD", "RAISE", "SHR", "SHL", "XOR",
		"CARDINAL", "LONGBOOL", "LONGINT", "OPERATOR", "ON", "WS", "COMMENT_1",
		"COMMENT_2", "COMMENT_3", "IDENT", "HEX_LITERAL", "STRING_LITERAL",
		"STRING_CROSSHATCH_LITERAL", "NUM_INT", "NUM_REAL", "UTF8BOM",
	}
	staticData.RuleNames = []string{
		"source", "program", "unit", "interfaceSection", "implementationSection",
		"initializationSection", "finalizationSection", "identifier", "identifierPart",
		"interfaceBlock", "implementationBlock", "block", "usesUnits", "labelDeclarationPart",
		"label", "constantDefinitionPart", "constantDefinition", "constantChr",
		"hexConstant", "constant", "arrayConstant", "recordConstant", "recordField",
		"unsignedNumber", "unsignedInteger", "unsignedReal", "sign", "bool_",
		"string", "stringExpression", "resourceDefinitionPart", "resourceDefinition",
		"typeDefinitionPart", "typeDefinition", "functionType", "procedureType",
		"forwardClassType", "forwardInterfaceType", "classType", "classImplementsInterfaces",
		"accessSpecifier", "classDeclaration", "classImplicitPublishedDeclaration",
		"classDeclarationPart", "interfaceGuidConst", "interfaceType", "interfaceDeclaration",
		"interfaceDeclarationPart", "errorInterfaceDeclarationPart", "errorClassDeclarationPart",
		"propertyDeclaration", "propertyReadDeclaration", "propertyWriteDeclaration",
		"propertyDefaultValueDeclaration", "propertyIndexDeclaration", "propertyIndexParameters",
		"propertyIndexParametersList", "genericTemplate", "genericTemplateList",
		"genericTypeParameter", "genericConstraints", "genericConstraint", "type_",
		"simpleType", "scalarType", "scalerList", "scalerMember", "subrangeType",
		"typeIdentifier", "structuredType", "unpackedStructuredType", "stringtype",
		"arrayType", "typeList", "indexType", "recordType", "recordDeclaration",
		"recordImplicitPublishedDeclaration", "recordDeclarationPart", "errorRecordDeclarationPart",
		"recordParts", "recordFixedPart", "recordVariantPart", "tag", "recordVariant",
		"helperType", "helperDeclaration", "helperImplicitPublishedDeclaration",
		"helperDeclarationPart", "errorHelperDeclarationPart", "setType", "fileType",
		"pointerType", "variableDeclarationPart", "variableDeclaration", "procedureHeader",
		"functionHeader", "procedureOrFunctionHeader", "procedureOrFunctionHeaderModifiers",
		"procedureOrFunctionDeclaration", "procedureDeclaration", "functionDeclaration",
		"procedureLambdaDeclaration", "functionLambdaDeclaration", "resultType",
		"procedureOrFunctionBody", "classOperatorHeader", "classOperatorDeclaration",
		"formalParameterList", "formalParameterSection", "parameterGroup", "identifierList",
		"constList", "defaultValue", "typedIdentifierList", "statement", "errorStatement",
		"unlabelledStatement", "simpleStatement", "assignmentStatement", "raiseExceptionStatement",
		"variableDeclarationStatement", "variableDesignator", "typeCast", "propertyDesignator",
		"expression", "relationaloperator", "simpleExpression", "additiveoperator",
		"term", "multiplicativeoperator", "signedFactor", "factor", "unsignedConstant",
		"functionDesignator", "defaultDesignator", "parameterList", "set_",
		"elementList", "element", "procedureStatement", "methodCallStatement",
		"actualParameter", "parameterwidth", "gotoStatement", "inheritedStatement",
		"emptyStatement_", "empty_", "structuredStatement", "compoundStatement",
		"statements", "conditionalStatement", "ifStatement", "caseStatement",
		"caseListElement", "repetetiveStatement", "whileStatement", "repeatStatement",
		"forStatement", "forList", "initialValue", "finalValue", "withStatement",
		"tryExceptStatement", "exceptionCase", "exceptionElse", "tryFinallyStatement",
		"withStatementVariableList", "attributeSection", "attributeList", "attributeItem",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 129, 1849, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 1, 0, 1, 0,
		3, 0, 345, 8, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 353, 8, 1, 1,
		1, 1, 1, 3, 1, 357, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 371, 8, 2, 1, 2, 3, 2, 374, 8, 2, 1, 2,
		3, 2, 377, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 3, 1, 3, 3, 3, 385, 8, 3, 1,
		3, 1, 3, 1, 4, 1, 4, 3, 4, 391, 8, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 1,
		6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 5, 7, 404, 8, 7, 10, 7, 12, 7, 407, 9,
		7, 1, 8, 1, 8, 3, 8, 411, 8, 8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 5,
		9, 419, 8, 9, 10, 9, 12, 9, 422, 9, 9, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 5, 10, 435, 8, 10, 10, 10, 12,
		10, 438, 9, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 5, 11, 445, 8, 11, 10,
		11, 12, 11, 448, 9, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 13,
		1, 13, 5, 13, 458, 8, 13, 10, 13, 12, 13, 461, 9, 13, 1, 13, 1, 13, 1,
		14, 1, 14, 1, 15, 1, 15, 1, 15, 1, 15, 4, 15, 471, 8, 15, 11, 15, 12, 15,
		472, 1, 16, 1, 16, 1, 16, 3, 16, 478, 8, 16, 1, 16, 1, 16, 1, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1,
		16, 3, 16, 495, 8, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 18, 1, 18,
		1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 511, 8, 19, 5,
		19, 513, 8, 19, 10, 19, 12, 19, 516, 9, 19, 1, 19, 1, 19, 3, 19, 520, 8,
		19, 1, 20, 1, 20, 1, 20, 1, 20, 5, 20, 526, 8, 20, 10, 20, 12, 20, 529,
		9, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 5, 20, 537, 8, 20, 10,
		20, 12, 20, 540, 9, 20, 1, 20, 1, 20, 3, 20, 544, 8, 20, 1, 21, 1, 21,
		1, 21, 1, 21, 5, 21, 550, 8, 21, 10, 21, 12, 21, 553, 9, 21, 1, 21, 1,
		21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22,
		1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 571, 8, 22, 1, 23, 1, 23, 3, 23, 575,
		8, 23, 1, 24, 1, 24, 1, 25, 1, 25, 1, 26, 1, 26, 1, 27, 1, 27, 1, 28, 4,
		28, 586, 8, 28, 11, 28, 12, 28, 587, 1, 29, 1, 29, 1, 29, 1, 29, 3, 29,
		594, 8, 29, 5, 29, 596, 8, 29, 10, 29, 12, 29, 599, 9, 29, 1, 30, 1, 30,
		4, 30, 603, 8, 30, 11, 30, 12, 30, 604, 1, 31, 1, 31, 1, 31, 1, 31, 1,
		31, 1, 32, 1, 32, 1, 32, 1, 32, 4, 32, 616, 8, 32, 11, 32, 12, 32, 617,
		1, 33, 3, 33, 621, 8, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1,
		33, 3, 33, 630, 8, 33, 1, 34, 1, 34, 3, 34, 634, 8, 34, 1, 34, 1, 34, 1,
		34, 1, 34, 3, 34, 640, 8, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34,
		3, 34, 648, 8, 34, 1, 34, 1, 34, 1, 34, 1, 34, 3, 34, 654, 8, 34, 1, 35,
		1, 35, 3, 35, 658, 8, 35, 1, 35, 1, 35, 3, 35, 662, 8, 35, 1, 35, 1, 35,
		1, 35, 1, 35, 1, 35, 3, 35, 669, 8, 35, 1, 35, 3, 35, 672, 8, 35, 1, 36,
		1, 36, 1, 37, 1, 37, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 3, 38, 684,
		8, 38, 1, 38, 3, 38, 687, 8, 38, 1, 38, 1, 38, 5, 38, 691, 8, 38, 10, 38,
		12, 38, 694, 9, 38, 1, 38, 1, 38, 1, 39, 1, 39, 5, 39, 700, 8, 39, 10,
		39, 12, 39, 703, 9, 39, 1, 40, 3, 40, 706, 8, 40, 1, 40, 1, 40, 3, 40,
		710, 8, 40, 1, 40, 1, 40, 1, 40, 3, 40, 715, 8, 40, 1, 41, 1, 41, 5, 41,
		719, 8, 41, 10, 41, 12, 41, 722, 9, 41, 1, 42, 5, 42, 725, 8, 42, 10, 42,
		12, 42, 728, 9, 42, 1, 43, 3, 43, 731, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 744, 8, 43, 1,
		43, 1, 43, 1, 43, 3, 43, 749, 8, 43, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45,
		1, 45, 1, 45, 3, 45, 758, 8, 45, 1, 45, 3, 45, 761, 8, 45, 1, 45, 1, 45,
		1, 45, 1, 46, 5, 46, 767, 8, 46, 10, 46, 12, 46, 770, 9, 46, 1, 47, 1,
		47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 780, 8, 47, 1, 48,
		4, 48, 783, 8, 48, 11, 48, 12, 48, 784, 1, 49, 4, 49, 788, 8, 49, 11, 49,
		12, 49, 789, 1, 50, 1, 50, 1, 50, 3, 50, 795, 8, 50, 1, 50, 1, 50, 1, 50,
		3, 50, 800, 8, 50, 1, 50, 3, 50, 803, 8, 50, 1, 50, 3, 50, 806, 8, 50,
		1, 50, 3, 50, 809, 8, 50, 1, 50, 1, 50, 3, 50, 813, 8, 50, 1, 50, 1, 50,
		1, 50, 3, 50, 818, 8, 50, 3, 50, 820, 8, 50, 1, 51, 1, 51, 1, 51, 1, 52,
		1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1,
		55, 1, 55, 5, 55, 838, 8, 55, 10, 55, 12, 55, 841, 9, 55, 1, 55, 1, 55,
		1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 5, 56, 853, 8,
		56, 10, 56, 12, 56, 856, 9, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 58, 1, 58,
		1, 58, 5, 58, 865, 8, 58, 10, 58, 12, 58, 868, 9, 58, 1, 59, 1, 59, 1,
		59, 3, 59, 873, 8, 59, 1, 60, 1, 60, 1, 60, 5, 60, 878, 8, 60, 10, 60,
		12, 60, 881, 9, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 3,
		61, 890, 8, 61, 1, 62, 1, 62, 1, 62, 3, 62, 895, 8, 62, 1, 63, 1, 63, 1,
		63, 1, 63, 3, 63, 901, 8, 63, 1, 64, 1, 64, 1, 64, 1, 64, 1, 65, 1, 65,
		1, 65, 5, 65, 910, 8, 65, 10, 65, 12, 65, 913, 9, 65, 1, 66, 1, 66, 1,
		66, 3, 66, 918, 8, 66, 1, 67, 1, 67, 1, 67, 1, 67, 1, 68, 1, 68, 1, 68,
		3, 68, 927, 8, 68, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 3, 69, 935,
		8, 69, 1, 69, 1, 69, 3, 69, 939, 8, 69, 1, 70, 1, 70, 1, 70, 3, 70, 944,
		8, 70, 1, 71, 1, 71, 1, 71, 1, 71, 3, 71, 950, 8, 71, 1, 71, 1, 71, 1,
		72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 962, 8, 72,
		1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 972, 8,
		72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 980, 8, 72, 1, 73,
		1, 73, 1, 73, 5, 73, 985, 8, 73, 10, 73, 12, 73, 988, 9, 73, 1, 74, 1,
		74, 1, 75, 1, 75, 1, 75, 5, 75, 995, 8, 75, 10, 75, 12, 75, 998, 9, 75,
		1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 1004, 8, 75, 1, 75, 3, 75, 1007, 8,
		75, 1, 76, 1, 76, 5, 76, 1011, 8, 76, 10, 76, 12, 76, 1014, 9, 76, 1, 77,
		5, 77, 1017, 8, 77, 10, 77, 12, 77, 1020, 9, 77, 1, 78, 3, 78, 1023, 8,
		78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78,
		1, 78, 1, 78, 3, 78, 1037, 8, 78, 1, 78, 1, 78, 1, 78, 3, 78, 1042, 8,
		78, 1, 79, 4, 79, 1045, 8, 79, 11, 79, 12, 79, 1046, 1, 80, 1, 80, 1, 80,
		3, 80, 1052, 8, 80, 1, 80, 3, 80, 1055, 8, 80, 1, 81, 1, 81, 1, 81, 5,
		81, 1060, 8, 81, 10, 81, 12, 81, 1063, 9, 81, 1, 81, 3, 81, 1066, 8, 81,
		1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 5, 82, 1074, 8, 82, 10, 82, 12,
		82, 1077, 9, 82, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 3, 83, 1084, 8, 83,
		1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 85, 1, 85, 1, 85, 1, 85, 1,
		85, 1, 85, 5, 85, 1098, 8, 85, 10, 85, 12, 85, 1101, 9, 85, 1, 85, 1, 85,
		1, 86, 1, 86, 5, 86, 1107, 8, 86, 10, 86, 12, 86, 1110, 9, 86, 1, 87, 5,
		87, 1113, 8, 87, 10, 87, 12, 87, 1116, 9, 87, 1, 88, 1, 88, 1, 88, 1, 88,
		1, 88, 1, 88, 1, 88, 1, 88, 3, 88, 1126, 8, 88, 1, 88, 1, 88, 1, 88, 3,
		88, 1131, 8, 88, 1, 89, 4, 89, 1134, 8, 89, 11, 89, 12, 89, 1135, 1, 90,
		1, 90, 1, 90, 1, 90, 1, 91, 1, 91, 1, 91, 1, 91, 3, 91, 1146, 8, 91, 1,
		92, 1, 92, 1, 92, 1, 93, 1, 93, 1, 93, 1, 93, 5, 93, 1155, 8, 93, 10, 93,
		12, 93, 1158, 9, 93, 1, 93, 1, 93, 1, 94, 3, 94, 1163, 8, 94, 1, 94, 1,
		94, 1, 94, 3, 94, 1168, 8, 94, 1, 95, 3, 95, 1171, 8, 95, 1, 95, 3, 95,
		1174, 8, 95, 1, 95, 1, 95, 1, 95, 3, 95, 1179, 8, 95, 1, 95, 1, 95, 1,
		95, 1, 96, 3, 96, 1185, 8, 96, 1, 96, 3, 96, 1188, 8, 96, 1, 96, 1, 96,
		1, 96, 3, 96, 1193, 8, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 97, 1,
		97, 3, 97, 1202, 8, 97, 1, 98, 1, 98, 5, 98, 1206, 8, 98, 10, 98, 12, 98,
		1209, 9, 98, 1, 99, 1, 99, 3, 99, 1213, 8, 99, 1, 100, 1, 100, 1, 100,
		1, 100, 1, 101, 1, 101, 1, 101, 1, 101, 1, 102, 1, 102, 3, 102, 1225, 8,
		102, 1, 102, 1, 102, 1, 103, 1, 103, 3, 103, 1231, 8, 103, 1, 103, 1, 103,
		1, 103, 1, 103, 1, 104, 1, 104, 1, 105, 1, 105, 1, 105, 1, 106, 1, 106,
		1, 106, 1, 106, 3, 106, 1246, 8, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1,
		106, 1, 107, 1, 107, 1, 107, 1, 107, 1, 108, 1, 108, 1, 108, 1, 108, 5,
		108, 1261, 8, 108, 10, 108, 12, 108, 1264, 9, 108, 1, 108, 1, 108, 1, 109,
		3, 109, 1269, 8, 109, 1, 109, 1, 109, 3, 109, 1273, 8, 109, 1, 109, 1,
		109, 1, 109, 3, 109, 1278, 8, 109, 1, 109, 1, 109, 1, 109, 3, 109, 1283,
		8, 109, 1, 109, 1, 109, 1, 109, 3, 109, 1288, 8, 109, 1, 109, 1, 109, 1,
		109, 3, 109, 1293, 8, 109, 1, 109, 1, 109, 3, 109, 1297, 8, 109, 1, 110,
		1, 110, 1, 110, 3, 110, 1302, 8, 110, 1, 110, 3, 110, 1305, 8, 110, 1,
		111, 1, 111, 1, 111, 5, 111, 1310, 8, 111, 10, 111, 12, 111, 1313, 9, 111,
		1, 112, 1, 112, 1, 112, 5, 112, 1318, 8, 112, 10, 112, 12, 112, 1321, 9,
		112, 1, 113, 1, 113, 1, 113, 1, 114, 1, 114, 1, 114, 1, 114, 1, 115, 1,
		115, 1, 115, 1, 115, 1, 115, 1, 115, 3, 115, 1336, 8, 115, 1, 116, 4, 116,
		1339, 8, 116, 11, 116, 12, 116, 1340, 1, 117, 1, 117, 3, 117, 1345, 8,
		117, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1,
		118, 3, 118, 1356, 8, 118, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119,
		1, 119, 1, 119, 3, 119, 1366, 8, 119, 1, 120, 1, 120, 3, 120, 1370, 8,
		120, 1, 121, 1, 121, 1, 121, 1, 121, 3, 121, 1376, 8, 121, 1, 121, 1, 121,
		3, 121, 1380, 8, 121, 1, 122, 1, 122, 1, 122, 1, 122, 3, 122, 1386, 8,
		122, 1, 122, 1, 122, 1, 122, 1, 122, 5, 122, 1392, 8, 122, 10, 122, 12,
		122, 1395, 9, 122, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 5, 122,
		1403, 8, 122, 10, 122, 12, 122, 1406, 9, 122, 1, 122, 1, 122, 1, 122, 1,
		122, 1, 122, 4, 122, 1413, 8, 122, 11, 122, 12, 122, 1414, 5, 122, 1417,
		8, 122, 10, 122, 12, 122, 1420, 9, 122, 1, 123, 1, 123, 1, 123, 1, 123,
		1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 3, 123, 1433, 8,
		123, 1, 124, 1, 124, 1, 124, 5, 124, 1438, 8, 124, 10, 124, 12, 124, 1441,
		9, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 5, 124, 1449, 8,
		124, 10, 124, 12, 124, 1452, 9, 124, 1, 124, 1, 124, 3, 124, 1456, 8, 124,
		1, 125, 1, 125, 1, 125, 1, 125, 3, 125, 1462, 8, 125, 1, 126, 1, 126, 1,
		127, 1, 127, 1, 127, 1, 127, 3, 127, 1470, 8, 127, 1, 128, 1, 128, 1, 129,
		1, 129, 1, 129, 1, 129, 3, 129, 1478, 8, 129, 1, 130, 1, 130, 1, 131, 3,
		131, 1483, 8, 131, 1, 131, 1, 131, 1, 132, 1, 132, 3, 132, 1489, 8, 132,
		1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 3, 132, 1496, 8, 132, 1, 132, 1,
		132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 3,
		132, 1508, 8, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 3, 132, 1515,
		8, 132, 1, 132, 5, 132, 1518, 8, 132, 10, 132, 12, 132, 1521, 9, 132, 1,
		132, 1, 132, 1, 132, 3, 132, 1526, 8, 132, 1, 132, 1, 132, 1, 132, 1, 132,
		1, 132, 5, 132, 1533, 8, 132, 10, 132, 12, 132, 1536, 9, 132, 1, 132, 1,
		132, 1, 132, 1, 132, 1, 132, 4, 132, 1543, 8, 132, 11, 132, 12, 132, 1544,
		5, 132, 1547, 8, 132, 10, 132, 12, 132, 1550, 9, 132, 1, 133, 3, 133, 1553,
		8, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 3, 133, 1560, 8, 133, 1,
		134, 1, 134, 1, 134, 3, 134, 1565, 8, 134, 1, 134, 3, 134, 1568, 8, 134,
		1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 3, 135, 1575, 8, 135, 1, 136, 1,
		136, 1, 136, 5, 136, 1580, 8, 136, 10, 136, 12, 136, 1583, 9, 136, 1, 137,
		1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 3, 137, 1593, 8,
		137, 1, 138, 1, 138, 1, 138, 5, 138, 1598, 8, 138, 10, 138, 12, 138, 1601,
		9, 138, 1, 138, 3, 138, 1604, 8, 138, 1, 139, 1, 139, 1, 139, 3, 139, 1609,
		8, 139, 1, 140, 1, 140, 1, 140, 3, 140, 1614, 8, 140, 1, 140, 3, 140, 1617,
		8, 140, 1, 141, 1, 141, 1, 141, 5, 141, 1622, 8, 141, 10, 141, 12, 141,
		1625, 9, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 3, 141, 1633,
		8, 141, 1, 142, 1, 142, 5, 142, 1637, 8, 142, 10, 142, 12, 142, 1640, 9,
		142, 1, 142, 1, 142, 3, 142, 1644, 8, 142, 1, 143, 1, 143, 1, 143, 1, 144,
		1, 144, 1, 144, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 3, 145,
		1658, 8, 145, 3, 145, 1660, 8, 145, 1, 146, 1, 146, 1, 147, 1, 147, 1,
		148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 3, 148, 1672, 8, 148, 1, 149,
		1, 149, 1, 149, 1, 149, 1, 150, 1, 150, 1, 150, 5, 150, 1681, 8, 150, 10,
		150, 12, 150, 1684, 9, 150, 1, 151, 1, 151, 3, 151, 1688, 8, 151, 1, 152,
		1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 3, 152, 1696, 8, 152, 1, 152, 3,
		152, 1699, 8, 152, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 5, 153,
		1707, 8, 153, 10, 153, 12, 153, 1710, 9, 153, 1, 153, 1, 153, 1, 153, 3,
		153, 1715, 8, 153, 1, 153, 3, 153, 1718, 8, 153, 1, 153, 1, 153, 1, 154,
		1, 154, 1, 154, 1, 154, 1, 155, 1, 155, 1, 155, 3, 155, 1729, 8, 155, 1,
		156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 157, 1, 157, 1, 157, 1, 157, 1,
		157, 1, 158, 1, 158, 3, 158, 1743, 8, 158, 1, 158, 1, 158, 1, 158, 1, 158,
		1, 158, 1, 158, 1, 158, 1, 158, 3, 158, 1753, 8, 158, 1, 158, 1, 158, 1,
		158, 1, 158, 1, 158, 1, 158, 3, 158, 1761, 8, 158, 1, 159, 1, 159, 1, 159,
		1, 159, 1, 160, 1, 160, 1, 161, 1, 161, 1, 162, 1, 162, 1, 162, 1, 162,
		1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 3, 162, 1781, 8, 162, 1,
		163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1,
		163, 1, 163, 1, 163, 4, 163, 1795, 8, 163, 11, 163, 12, 163, 1796, 1, 163,
		3, 163, 1800, 8, 163, 1, 163, 1, 163, 3, 163, 1804, 8, 163, 1, 164, 1,
		164, 1, 164, 1, 164, 1, 164, 1, 164, 1, 164, 1, 165, 1, 165, 1, 165, 1,
		166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 167, 1, 167, 1, 167, 5,
		167, 1825, 8, 167, 10, 167, 12, 167, 1828, 9, 167, 1, 168, 1, 168, 1, 168,
		1, 168, 1, 169, 1, 169, 1, 169, 5, 169, 1837, 8, 169, 10, 169, 12, 169,
		1840, 9, 169, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 3, 170, 1847, 8,
		170, 1, 170, 0, 1, 264, 171, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22,
		24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58,
		60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94,
		96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124,
		126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154,
		156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184,
		186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214,
		216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244,
		246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274,
		276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304,
		306, 308, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 332, 334,
		336, 338, 340, 0, 14, 3, 0, 85, 86, 88, 88, 123, 123, 1, 0, 44, 45, 1,
		0, 75, 76, 1, 0, 125, 126, 1, 0, 14, 14, 2, 0, 14, 14, 78, 82, 6, 0, 5,
		5, 7, 7, 22, 22, 32, 32, 73, 73, 114, 116, 2, 0, 30, 30, 106, 107, 1, 0,
		97, 105, 2, 0, 14, 14, 50, 50, 2, 0, 21, 21, 52, 57, 2, 0, 28, 28, 44,
		45, 5, 0, 2, 2, 10, 10, 24, 24, 46, 47, 111, 113, 2, 0, 12, 12, 38, 38,
		1973, 0, 344, 1, 0, 0, 0, 2, 346, 1, 0, 0, 0, 4, 365, 1, 0, 0, 0, 6, 382,
		1, 0, 0, 0, 8, 388, 1, 0, 0, 0, 10, 394, 1, 0, 0, 0, 12, 397, 1, 0, 0,
		0, 14, 400, 1, 0, 0, 0, 16, 408, 1, 0, 0, 0, 18, 420, 1, 0, 0, 0, 20, 436,
		1, 0, 0, 0, 22, 446, 1, 0, 0, 0, 24, 449, 1, 0, 0, 0, 26, 453, 1, 0, 0,
		0, 28, 464, 1, 0, 0, 0, 30, 466, 1, 0, 0, 0, 32, 494, 1, 0, 0, 0, 34, 496,
		1, 0, 0, 0, 36, 501, 1, 0, 0, 0, 38, 519, 1, 0, 0, 0, 40, 543, 1, 0, 0,
		0, 42, 545, 1, 0, 0, 0, 44, 570, 1, 0, 0, 0, 46, 574, 1, 0, 0, 0, 48, 576,
		1, 0, 0, 0, 50, 578, 1, 0, 0, 0, 52, 580, 1, 0, 0, 0, 54, 582, 1, 0, 0,
		0, 56, 585, 1, 0, 0, 0, 58, 589, 1, 0, 0, 0, 60, 600, 1, 0, 0, 0, 62, 606,
		1, 0, 0, 0, 64, 611, 1, 0, 0, 0, 66, 620, 1, 0, 0, 0, 68, 653, 1, 0, 0,
		0, 70, 671, 1, 0, 0, 0, 72, 673, 1, 0, 0, 0, 74, 675, 1, 0, 0, 0, 76, 677,
		1, 0, 0, 0, 78, 701, 1, 0, 0, 0, 80, 714, 1, 0, 0, 0, 82, 716, 1, 0, 0,
		0, 84, 726, 1, 0, 0, 0, 86, 748, 1, 0, 0, 0, 88, 750, 1, 0, 0, 0, 90, 752,
		1, 0, 0, 0, 92, 768, 1, 0, 0, 0, 94, 779, 1, 0, 0, 0, 96, 782, 1, 0, 0,
		0, 98, 787, 1, 0, 0, 0, 100, 819, 1, 0, 0, 0, 102, 821, 1, 0, 0, 0, 104,
		824, 1, 0, 0, 0, 106, 827, 1, 0, 0, 0, 108, 830, 1, 0, 0, 0, 110, 833,
		1, 0, 0, 0, 112, 844, 1, 0, 0, 0, 114, 857, 1, 0, 0, 0, 116, 861, 1, 0,
		0, 0, 118, 869, 1, 0, 0, 0, 120, 874, 1, 0, 0, 0, 122, 889, 1, 0, 0, 0,
		124, 894, 1, 0, 0, 0, 126, 900, 1, 0, 0, 0, 128, 902, 1, 0, 0, 0, 130,
		906, 1, 0, 0, 0, 132, 914, 1, 0, 0, 0, 134, 919, 1, 0, 0, 0, 136, 926,
		1, 0, 0, 0, 138, 938, 1, 0, 0, 0, 140, 943, 1, 0, 0, 0, 142, 945, 1, 0,
		0, 0, 144, 979, 1, 0, 0, 0, 146, 981, 1, 0, 0, 0, 148, 989, 1, 0, 0, 0,
		150, 1006, 1, 0, 0, 0, 152, 1008, 1, 0, 0, 0, 154, 1018, 1, 0, 0, 0, 156,
		1041, 1, 0, 0, 0, 158, 1044, 1, 0, 0, 0, 160, 1054, 1, 0, 0, 0, 162, 1056,
		1, 0, 0, 0, 164, 1067, 1, 0, 0, 0, 166, 1083, 1, 0, 0, 0, 168, 1085, 1,
		0, 0, 0, 170, 1091, 1, 0, 0, 0, 172, 1104, 1, 0, 0, 0, 174, 1114, 1, 0,
		0, 0, 176, 1130, 1, 0, 0, 0, 178, 1133, 1, 0, 0, 0, 180, 1137, 1, 0, 0,
		0, 182, 1145, 1, 0, 0, 0, 184, 1147, 1, 0, 0, 0, 186, 1150, 1, 0, 0, 0,
		188, 1162, 1, 0, 0, 0, 190, 1170, 1, 0, 0, 0, 192, 1184, 1, 0, 0, 0, 194,
		1201, 1, 0, 0, 0, 196, 1207, 1, 0, 0, 0, 198, 1212, 1, 0, 0, 0, 200, 1214,
		1, 0, 0, 0, 202, 1218, 1, 0, 0, 0, 204, 1222, 1, 0, 0, 0, 206, 1228, 1,
		0, 0, 0, 208, 1236, 1, 0, 0, 0, 210, 1238, 1, 0, 0, 0, 212, 1241, 1, 0,
		0, 0, 214, 1252, 1, 0, 0, 0, 216, 1256, 1, 0, 0, 0, 218, 1296, 1, 0, 0,
		0, 220, 1298, 1, 0, 0, 0, 222, 1306, 1, 0, 0, 0, 224, 1314, 1, 0, 0, 0,
		226, 1322, 1, 0, 0, 0, 228, 1325, 1, 0, 0, 0, 230, 1335, 1, 0, 0, 0, 232,
		1338, 1, 0, 0, 0, 234, 1344, 1, 0, 0, 0, 236, 1355, 1, 0, 0, 0, 238, 1365,
		1, 0, 0, 0, 240, 1367, 1, 0, 0, 0, 242, 1371, 1, 0, 0, 0, 244, 1385, 1,
		0, 0, 0, 246, 1432, 1, 0, 0, 0, 248, 1434, 1, 0, 0, 0, 250, 1457, 1, 0,
		0, 0, 252, 1463, 1, 0, 0, 0, 254, 1465, 1, 0, 0, 0, 256, 1471, 1, 0, 0,
		0, 258, 1473, 1, 0, 0, 0, 260, 1479, 1, 0, 0, 0, 262, 1482, 1, 0, 0, 0,
		264, 1525, 1, 0, 0, 0, 266, 1559, 1, 0, 0, 0, 268, 1561, 1, 0, 0, 0, 270,
		1569, 1, 0, 0, 0, 272, 1576, 1, 0, 0, 0, 274, 1592, 1, 0, 0, 0, 276, 1603,
		1, 0, 0, 0, 278, 1605, 1, 0, 0, 0, 280, 1610, 1, 0, 0, 0, 282, 1618, 1,
		0, 0, 0, 284, 1643, 1, 0, 0, 0, 286, 1645, 1, 0, 0, 0, 288, 1648, 1, 0,
		0, 0, 290, 1651, 1, 0, 0, 0, 292, 1661, 1, 0, 0, 0, 294, 1663, 1, 0, 0,
		0, 296, 1671, 1, 0, 0, 0, 298, 1673, 1, 0, 0, 0, 300, 1677, 1, 0, 0, 0,
		302, 1687, 1, 0, 0, 0, 304, 1689, 1, 0, 0, 0, 306, 1700, 1, 0, 0, 0, 308,
		1721, 1, 0, 0, 0, 310, 1728, 1, 0, 0, 0, 312, 1730, 1, 0, 0, 0, 314, 1735,
		1, 0, 0, 0, 316, 1760, 1, 0, 0, 0, 318, 1762, 1, 0, 0, 0, 320, 1766, 1,
		0, 0, 0, 322, 1768, 1, 0, 0, 0, 324, 1780, 1, 0, 0, 0, 326, 1803, 1, 0,
		0, 0, 328, 1805, 1, 0, 0, 0, 330, 1812, 1, 0, 0, 0, 332, 1815, 1, 0, 0,
		0, 334, 1821, 1, 0, 0, 0, 336, 1829, 1, 0, 0, 0, 338, 1833, 1, 0, 0, 0,
		340, 1841, 1, 0, 0, 0, 342, 345, 3, 2, 1, 0, 343, 345, 3, 4, 2, 0, 344,
		342, 1, 0, 0, 0, 344, 343, 1, 0, 0, 0, 345, 1, 1, 0, 0, 0, 346, 347, 5,
		31, 0, 0, 347, 352, 3, 14, 7, 0, 348, 349, 5, 58, 0, 0, 349, 350, 3, 222,
		111, 0, 350, 351, 5, 59, 0, 0, 351, 353, 1, 0, 0, 0, 352, 348, 1, 0, 0,
		0, 352, 353, 1, 0, 0, 0, 353, 354, 1, 0, 0, 0, 354, 356, 5, 50, 0, 0, 355,
		357, 3, 24, 12, 0, 356, 355, 1, 0, 0, 0, 356, 357, 1, 0, 0, 0, 357, 358,
		1, 0, 0, 0, 358, 359, 3, 20, 10, 0, 359, 360, 5, 4, 0, 0, 360, 361, 3,
		300, 150, 0, 361, 362, 5, 14, 0, 0, 362, 363, 5, 66, 0, 0, 363, 364, 5,
		0, 0, 1, 364, 3, 1, 0, 0, 0, 365, 366, 5, 70, 0, 0, 366, 367, 3, 14, 7,
		0, 367, 368, 5, 50, 0, 0, 368, 370, 3, 6, 3, 0, 369, 371, 3, 8, 4, 0, 370,
		369, 1, 0, 0, 0, 370, 371, 1, 0, 0, 0, 371, 373, 1, 0, 0, 0, 372, 374,
		3, 10, 5, 0, 373, 372, 1, 0, 0, 0, 373, 374, 1, 0, 0, 0, 374, 376, 1, 0,
		0, 0, 375, 377, 3, 12, 6, 0, 376, 375, 1, 0, 0, 0, 376, 377, 1, 0, 0, 0,
		377, 378, 1, 0, 0, 0, 378, 379, 5, 14, 0, 0, 379, 380, 5, 66, 0, 0, 380,
		381, 5, 0, 0, 1, 381, 5, 1, 0, 0, 0, 382, 384, 5, 71, 0, 0, 383, 385, 3,
		24, 12, 0, 384, 383, 1, 0, 0, 0, 384, 385, 1, 0, 0, 0, 385, 386, 1, 0,
		0, 0, 386, 387, 3, 18, 9, 0, 387, 7, 1, 0, 0, 0, 388, 390, 5, 74, 0, 0,
		389, 391, 3, 24, 12, 0, 390, 389, 1, 0, 0, 0, 390, 391, 1, 0, 0, 0, 391,
		392, 1, 0, 0, 0, 392, 393, 3, 20, 10, 0, 393, 9, 1, 0, 0, 0, 394, 395,
		5, 93, 0, 0, 395, 396, 3, 300, 150, 0, 396, 11, 1, 0, 0, 0, 397, 398, 5,
		94, 0, 0, 398, 399, 3, 300, 150, 0, 399, 13, 1, 0, 0, 0, 400, 405, 3, 16,
		8, 0, 401, 402, 5, 66, 0, 0, 402, 404, 3, 16, 8, 0, 403, 401, 1, 0, 0,
		0, 404, 407, 1, 0, 0, 0, 405, 403, 1, 0, 0, 0, 405, 406, 1, 0, 0, 0, 406,
		15, 1, 0, 0, 0, 407, 405, 1, 0, 0, 0, 408, 410, 7, 0, 0, 0, 409, 411, 3,
		114, 57, 0, 410, 409, 1, 0, 0, 0, 410, 411, 1, 0, 0, 0, 411, 17, 1, 0,
		0, 0, 412, 419, 3, 26, 13, 0, 413, 419, 3, 30, 15, 0, 414, 419, 3, 60,
		30, 0, 415, 419, 3, 64, 32, 0, 416, 419, 3, 186, 93, 0, 417, 419, 3, 194,
		97, 0, 418, 412, 1, 0, 0, 0, 418, 413, 1, 0, 0, 0, 418, 414, 1, 0, 0, 0,
		418, 415, 1, 0, 0, 0, 418, 416, 1, 0, 0, 0, 418, 417, 1, 0, 0, 0, 419,
		422, 1, 0, 0, 0, 420, 418, 1, 0, 0, 0, 420, 421, 1, 0, 0, 0, 421, 19, 1,
		0, 0, 0, 422, 420, 1, 0, 0, 0, 423, 435, 3, 26, 13, 0, 424, 435, 3, 30,
		15, 0, 425, 435, 3, 60, 30, 0, 426, 435, 3, 64, 32, 0, 427, 435, 3, 186,
		93, 0, 428, 435, 3, 198, 99, 0, 429, 430, 3, 194, 97, 0, 430, 431, 5, 109,
		0, 0, 431, 432, 5, 50, 0, 0, 432, 435, 1, 0, 0, 0, 433, 435, 3, 214, 107,
		0, 434, 423, 1, 0, 0, 0, 434, 424, 1, 0, 0, 0, 434, 425, 1, 0, 0, 0, 434,
		426, 1, 0, 0, 0, 434, 427, 1, 0, 0, 0, 434, 428, 1, 0, 0, 0, 434, 429,
		1, 0, 0, 0, 434, 433, 1, 0, 0, 0, 435, 438, 1, 0, 0, 0, 436, 434, 1, 0,
		0, 0, 436, 437, 1, 0, 0, 0, 437, 21, 1, 0, 0, 0, 438, 436, 1, 0, 0, 0,
		439, 445, 3, 26, 13, 0, 440, 445, 3, 30, 15, 0, 441, 445, 3, 186, 93, 0,
		442, 445, 3, 198, 99, 0, 443, 445, 3, 214, 107, 0, 444, 439, 1, 0, 0, 0,
		444, 440, 1, 0, 0, 0, 444, 441, 1, 0, 0, 0, 444, 442, 1, 0, 0, 0, 444,
		443, 1, 0, 0, 0, 445, 448, 1, 0, 0, 0, 446, 444, 1, 0, 0, 0, 446, 447,
		1, 0, 0, 0, 447, 23, 1, 0, 0, 0, 448, 446, 1, 0, 0, 0, 449, 450, 5, 72,
		0, 0, 450, 451, 3, 222, 111, 0, 451, 452, 5, 50, 0, 0, 452, 25, 1, 0, 0,
		0, 453, 454, 5, 23, 0, 0, 454, 459, 3, 28, 14, 0, 455, 456, 5, 49, 0, 0,
		456, 458, 3, 28, 14, 0, 457, 455, 1, 0, 0, 0, 458, 461, 1, 0, 0, 0, 459,
		457, 1, 0, 0, 0, 459, 460, 1, 0, 0, 0, 460, 462, 1, 0, 0, 0, 461, 459,
		1, 0, 0, 0, 462, 463, 5, 50, 0, 0, 463, 27, 1, 0, 0, 0, 464, 465, 3, 48,
		24, 0, 465, 29, 1, 0, 0, 0, 466, 470, 5, 9, 0, 0, 467, 468, 3, 32, 16,
		0, 468, 469, 5, 50, 0, 0, 469, 471, 1, 0, 0, 0, 470, 467, 1, 0, 0, 0, 471,
		472, 1, 0, 0, 0, 472, 470, 1, 0, 0, 0, 472, 473, 1, 0, 0, 0, 473, 31, 1,
		0, 0, 0, 474, 477, 3, 14, 7, 0, 475, 476, 5, 51, 0, 0, 476, 478, 3, 136,
		68, 0, 477, 475, 1, 0, 0, 0, 477, 478, 1, 0, 0, 0, 478, 479, 1, 0, 0, 0,
		479, 480, 5, 52, 0, 0, 480, 481, 3, 38, 19, 0, 481, 495, 1, 0, 0, 0, 482,
		483, 3, 14, 7, 0, 483, 484, 5, 51, 0, 0, 484, 485, 3, 144, 72, 0, 485,
		486, 5, 52, 0, 0, 486, 487, 3, 38, 19, 0, 487, 495, 1, 0, 0, 0, 488, 489,
		3, 14, 7, 0, 489, 490, 5, 51, 0, 0, 490, 491, 3, 180, 90, 0, 491, 492,
		5, 52, 0, 0, 492, 493, 3, 38, 19, 0, 493, 495, 1, 0, 0, 0, 494, 474, 1,
		0, 0, 0, 494, 482, 1, 0, 0, 0, 494, 488, 1, 0, 0, 0, 495, 33, 1, 0, 0,
		0, 496, 497, 5, 8, 0, 0, 497, 498, 5, 58, 0, 0, 498, 499, 3, 48, 24, 0,
		499, 500, 5, 59, 0, 0, 500, 35, 1, 0, 0, 0, 501, 502, 5, 124, 0, 0, 502,
		37, 1, 0, 0, 0, 503, 520, 3, 266, 133, 0, 504, 520, 3, 14, 7, 0, 505, 520,
		3, 128, 64, 0, 506, 514, 3, 40, 20, 0, 507, 510, 5, 44, 0, 0, 508, 511,
		3, 40, 20, 0, 509, 511, 3, 14, 7, 0, 510, 508, 1, 0, 0, 0, 510, 509, 1,
		0, 0, 0, 511, 513, 1, 0, 0, 0, 512, 507, 1, 0, 0, 0, 513, 516, 1, 0, 0,
		0, 514, 512, 1, 0, 0, 0, 514, 515, 1, 0, 0, 0, 515, 520, 1, 0, 0, 0, 516,
		514, 1, 0, 0, 0, 517, 520, 3, 42, 21, 0, 518, 520, 3, 254, 127, 0, 519,
		503, 1, 0, 0, 0, 519, 504, 1, 0, 0, 0, 519, 505, 1, 0, 0, 0, 519, 506,
		1, 0, 0, 0, 519, 517, 1, 0, 0, 0, 519, 518, 1, 0, 0, 0, 520, 39, 1, 0,
		0, 0, 521, 522, 5, 60, 0, 0, 522, 527, 3, 38, 19, 0, 523, 524, 5, 49, 0,
		0, 524, 526, 3, 38, 19, 0, 525, 523, 1, 0, 0, 0, 526, 529, 1, 0, 0, 0,
		527, 525, 1, 0, 0, 0, 527, 528, 1, 0, 0, 0, 528, 530, 1, 0, 0, 0, 529,
		527, 1, 0, 0, 0, 530, 531, 5, 62, 0, 0, 531, 544, 1, 0, 0, 0, 532, 533,
		5, 58, 0, 0, 533, 538, 3, 38, 19, 0, 534, 535, 5, 49, 0, 0, 535, 537, 3,
		38, 19, 0, 536, 534, 1, 0, 0, 0, 537, 540, 1, 0, 0, 0, 538, 536, 1, 0,
		0, 0, 538, 539, 1, 0, 0, 0, 539, 541, 1, 0, 0, 0, 540, 538, 1, 0, 0, 0,
		541, 542, 5, 59, 0, 0, 542, 544, 1, 0, 0, 0, 543, 521, 1, 0, 0, 0, 543,
		532, 1, 0, 0, 0, 544, 41, 1, 0, 0, 0, 545, 546, 5, 58, 0, 0, 546, 551,
		3, 44, 22, 0, 547, 548, 5, 50, 0, 0, 548, 550, 3, 44, 22, 0, 549, 547,
		1, 0, 0, 0, 550, 553, 1, 0, 0, 0, 551, 549, 1, 0, 0, 0, 551, 552, 1, 0,
		0, 0, 552, 554, 1, 0, 0, 0, 553, 551, 1, 0, 0, 0, 554, 555, 5, 59, 0, 0,
		555, 43, 1, 0, 0, 0, 556, 557, 3, 14, 7, 0, 557, 558, 5, 51, 0, 0, 558,
		559, 3, 38, 19, 0, 559, 571, 1, 0, 0, 0, 560, 561, 3, 14, 7, 0, 561, 562,
		5, 51, 0, 0, 562, 563, 3, 38, 19, 0, 563, 564, 5, 67, 0, 0, 564, 565, 3,
		38, 19, 0, 565, 571, 1, 0, 0, 0, 566, 567, 3, 14, 7, 0, 567, 568, 5, 51,
		0, 0, 568, 569, 3, 40, 20, 0, 569, 571, 1, 0, 0, 0, 570, 556, 1, 0, 0,
		0, 570, 560, 1, 0, 0, 0, 570, 566, 1, 0, 0, 0, 571, 45, 1, 0, 0, 0, 572,
		575, 3, 48, 24, 0, 573, 575, 3, 50, 25, 0, 574, 572, 1, 0, 0, 0, 574, 573,
		1, 0, 0, 0, 575, 47, 1, 0, 0, 0, 576, 577, 5, 127, 0, 0, 577, 49, 1, 0,
		0, 0, 578, 579, 5, 128, 0, 0, 579, 51, 1, 0, 0, 0, 580, 581, 7, 1, 0, 0,
		581, 53, 1, 0, 0, 0, 582, 583, 7, 2, 0, 0, 583, 55, 1, 0, 0, 0, 584, 586,
		7, 3, 0, 0, 585, 584, 1, 0, 0, 0, 586, 587, 1, 0, 0, 0, 587, 585, 1, 0,
		0, 0, 587, 588, 1, 0, 0, 0, 588, 57, 1, 0, 0, 0, 589, 597, 3, 56, 28, 0,
		590, 593, 5, 44, 0, 0, 591, 594, 3, 56, 28, 0, 592, 594, 3, 14, 7, 0, 593,
		591, 1, 0, 0, 0, 593, 592, 1, 0, 0, 0, 594, 596, 1, 0, 0, 0, 595, 590,
		1, 0, 0, 0, 596, 599, 1, 0, 0, 0, 597, 595, 1, 0, 0, 0, 597, 598, 1, 0,
		0, 0, 598, 59, 1, 0, 0, 0, 599, 597, 1, 0, 0, 0, 600, 602, 5, 108, 0, 0,
		601, 603, 3, 62, 31, 0, 602, 601, 1, 0, 0, 0, 603, 604, 1, 0, 0, 0, 604,
		602, 1, 0, 0, 0, 604, 605, 1, 0, 0, 0, 605, 61, 1, 0, 0, 0, 606, 607, 3,
		14, 7, 0, 607, 608, 5, 52, 0, 0, 608, 609, 3, 58, 29, 0, 609, 610, 5, 50,
		0, 0, 610, 63, 1, 0, 0, 0, 611, 615, 5, 39, 0, 0, 612, 613, 3, 66, 33,
		0, 613, 614, 5, 50, 0, 0, 614, 616, 1, 0, 0, 0, 615, 612, 1, 0, 0, 0, 616,
		617, 1, 0, 0, 0, 617, 615, 1, 0, 0, 0, 617, 618, 1, 0, 0, 0, 618, 65, 1,
		0, 0, 0, 619, 621, 3, 336, 168, 0, 620, 619, 1, 0, 0, 0, 620, 621, 1, 0,
		0, 0, 621, 622, 1, 0, 0, 0, 622, 623, 3, 14, 7, 0, 623, 629, 5, 52, 0,
		0, 624, 630, 3, 72, 36, 0, 625, 630, 3, 74, 37, 0, 626, 630, 3, 68, 34,
		0, 627, 630, 3, 70, 35, 0, 628, 630, 3, 124, 62, 0, 629, 624, 1, 0, 0,
		0, 629, 625, 1, 0, 0, 0, 629, 626, 1, 0, 0, 0, 629, 627, 1, 0, 0, 0, 629,
		628, 1, 0, 0, 0, 630, 67, 1, 0, 0, 0, 631, 633, 5, 17, 0, 0, 632, 634,
		3, 216, 108, 0, 633, 632, 1, 0, 0, 0, 633, 634, 1, 0, 0, 0, 634, 635, 1,
		0, 0, 0, 635, 636, 5, 51, 0, 0, 636, 639, 3, 208, 104, 0, 637, 638, 5,
		27, 0, 0, 638, 640, 5, 95, 0, 0, 639, 637, 1, 0, 0, 0, 639, 640, 1, 0,
		0, 0, 640, 641, 1, 0, 0, 0, 641, 642, 3, 196, 98, 0, 642, 654, 1, 0, 0,
		0, 643, 644, 5, 34, 0, 0, 644, 645, 5, 38, 0, 0, 645, 647, 5, 17, 0, 0,
		646, 648, 3, 216, 108, 0, 647, 646, 1, 0, 0, 0, 647, 648, 1, 0, 0, 0, 648,
		649, 1, 0, 0, 0, 649, 650, 5, 51, 0, 0, 650, 651, 3, 208, 104, 0, 651,
		652, 3, 196, 98, 0, 652, 654, 1, 0, 0, 0, 653, 631, 1, 0, 0, 0, 653, 643,
		1, 0, 0, 0, 654, 69, 1, 0, 0, 0, 655, 657, 5, 30, 0, 0, 656, 658, 3, 216,
		108, 0, 657, 656, 1, 0, 0, 0, 657, 658, 1, 0, 0, 0, 658, 661, 1, 0, 0,
		0, 659, 660, 5, 27, 0, 0, 660, 662, 5, 95, 0, 0, 661, 659, 1, 0, 0, 0,
		661, 662, 1, 0, 0, 0, 662, 663, 1, 0, 0, 0, 663, 672, 3, 196, 98, 0, 664,
		665, 5, 34, 0, 0, 665, 666, 5, 38, 0, 0, 666, 668, 5, 30, 0, 0, 667, 669,
		3, 216, 108, 0, 668, 667, 1, 0, 0, 0, 668, 669, 1, 0, 0, 0, 669, 670, 1,
		0, 0, 0, 670, 672, 3, 196, 98, 0, 671, 655, 1, 0, 0, 0, 671, 664, 1, 0,
		0, 0, 672, 71, 1, 0, 0, 0, 673, 674, 5, 77, 0, 0, 674, 73, 1, 0, 0, 0,
		675, 676, 5, 71, 0, 0, 676, 75, 1, 0, 0, 0, 677, 683, 5, 77, 0, 0, 678,
		679, 5, 58, 0, 0, 679, 680, 3, 14, 7, 0, 680, 681, 3, 78, 39, 0, 681, 682,
		5, 59, 0, 0, 682, 684, 1, 0, 0, 0, 683, 678, 1, 0, 0, 0, 683, 684, 1, 0,
		0, 0, 684, 686, 1, 0, 0, 0, 685, 687, 5, 97, 0, 0, 686, 685, 1, 0, 0, 0,
		686, 687, 1, 0, 0, 0, 687, 688, 1, 0, 0, 0, 688, 692, 3, 84, 42, 0, 689,
		691, 3, 82, 41, 0, 690, 689, 1, 0, 0, 0, 691, 694, 1, 0, 0, 0, 692, 690,
		1, 0, 0, 0, 692, 693, 1, 0, 0, 0, 693, 695, 1, 0, 0, 0, 694, 692, 1, 0,
		0, 0, 695, 696, 5, 14, 0, 0, 696, 77, 1, 0, 0, 0, 697, 698, 5, 49, 0, 0,
		698, 700, 3, 136, 68, 0, 699, 697, 1, 0, 0, 0, 700, 703, 1, 0, 0, 0, 701,
		699, 1, 0, 0, 0, 701, 702, 1, 0, 0, 0, 702, 79, 1, 0, 0, 0, 703, 701, 1,
		0, 0, 0, 704, 706, 5, 82, 0, 0, 705, 704, 1, 0, 0, 0, 705, 706, 1, 0, 0,
		0, 706, 707, 1, 0, 0, 0, 707, 715, 5, 78, 0, 0, 708, 710, 5, 82, 0, 0,
		709, 708, 1, 0, 0, 0, 709, 710, 1, 0, 0, 0, 710, 711, 1, 0, 0, 0, 711,
		715, 5, 79, 0, 0, 712, 715, 5, 80, 0, 0, 713, 715, 5, 81, 0, 0, 714, 705,
		1, 0, 0, 0, 714, 709, 1, 0, 0, 0, 714, 712, 1, 0, 0, 0, 714, 713, 1, 0,
		0, 0, 715, 81, 1, 0, 0, 0, 716, 720, 3, 80, 40, 0, 717, 719, 3, 86, 43,
		0, 718, 717, 1, 0, 0, 0, 719, 722, 1, 0, 0, 0, 720, 718, 1, 0, 0, 0, 720,
		721, 1, 0, 0, 0, 721, 83, 1, 0, 0, 0, 722, 720, 1, 0, 0, 0, 723, 725, 3,
		86, 43, 0, 724, 723, 1, 0, 0, 0, 725, 728, 1, 0, 0, 0, 726, 724, 1, 0,
		0, 0, 726, 727, 1, 0, 0, 0, 727, 85, 1, 0, 0, 0, 728, 726, 1, 0, 0, 0,
		729, 731, 3, 336, 168, 0, 730, 729, 1, 0, 0, 0, 730, 731, 1, 0, 0, 0, 731,
		732, 1, 0, 0, 0, 732, 733, 3, 228, 114, 0, 733, 734, 5, 50, 0, 0, 734,
		749, 1, 0, 0, 0, 735, 749, 3, 64, 32, 0, 736, 749, 3, 30, 15, 0, 737, 749,
		3, 192, 96, 0, 738, 749, 3, 190, 95, 0, 739, 740, 3, 100, 50, 0, 740, 743,
		5, 50, 0, 0, 741, 742, 5, 87, 0, 0, 742, 744, 5, 50, 0, 0, 743, 741, 1,
		0, 0, 0, 743, 744, 1, 0, 0, 0, 744, 749, 1, 0, 0, 0, 745, 746, 3, 98, 49,
		0, 746, 747, 5, 50, 0, 0, 747, 749, 1, 0, 0, 0, 748, 730, 1, 0, 0, 0, 748,
		735, 1, 0, 0, 0, 748, 736, 1, 0, 0, 0, 748, 737, 1, 0, 0, 0, 748, 738,
		1, 0, 0, 0, 748, 739, 1, 0, 0, 0, 748, 745, 1, 0, 0, 0, 749, 87, 1, 0,
		0, 0, 750, 751, 5, 1, 0, 0, 751, 89, 1, 0, 0, 0, 752, 757, 5, 71, 0, 0,
		753, 754, 5, 58, 0, 0, 754, 755, 3, 14, 7, 0, 755, 756, 5, 59, 0, 0, 756,
		758, 1, 0, 0, 0, 757, 753, 1, 0, 0, 0, 757, 758, 1, 0, 0, 0, 758, 760,
		1, 0, 0, 0, 759, 761, 5, 1, 0, 0, 760, 759, 1, 0, 0, 0, 760, 761, 1, 0,
		0, 0, 761, 762, 1, 0, 0, 0, 762, 763, 3, 92, 46, 0, 763, 764, 5, 14, 0,
		0, 764, 91, 1, 0, 0, 0, 765, 767, 3, 94, 47, 0, 766, 765, 1, 0, 0, 0, 767,
		770, 1, 0, 0, 0, 768, 766, 1, 0, 0, 0, 768, 769, 1, 0, 0, 0, 769, 93, 1,
		0, 0, 0, 770, 768, 1, 0, 0, 0, 771, 780, 3, 192, 96, 0, 772, 780, 3, 190,
		95, 0, 773, 774, 3, 100, 50, 0, 774, 775, 5, 50, 0, 0, 775, 780, 1, 0,
		0, 0, 776, 777, 3, 96, 48, 0, 777, 778, 5, 50, 0, 0, 778, 780, 1, 0, 0,
		0, 779, 771, 1, 0, 0, 0, 779, 772, 1, 0, 0, 0, 779, 773, 1, 0, 0, 0, 779,
		776, 1, 0, 0, 0, 780, 95, 1, 0, 0, 0, 781, 783, 8, 4, 0, 0, 782, 781, 1,
		0, 0, 0, 783, 784, 1, 0, 0, 0, 784, 782, 1, 0, 0, 0, 784, 785, 1, 0, 0,
		0, 785, 97, 1, 0, 0, 0, 786, 788, 8, 5, 0, 0, 787, 786, 1, 0, 0, 0, 788,
		789, 1, 0, 0, 0, 789, 787, 1, 0, 0, 0, 789, 790, 1, 0, 0, 0, 790, 99, 1,
		0, 0, 0, 791, 792, 5, 84, 0, 0, 792, 794, 3, 14, 7, 0, 793, 795, 3, 110,
		55, 0, 794, 793, 1, 0, 0, 0, 794, 795, 1, 0, 0, 0, 795, 796, 1, 0, 0, 0,
		796, 797, 5, 51, 0, 0, 797, 799, 3, 136, 68, 0, 798, 800, 3, 102, 51, 0,
		799, 798, 1, 0, 0, 0, 799, 800, 1, 0, 0, 0, 800, 802, 1, 0, 0, 0, 801,
		803, 3, 104, 52, 0, 802, 801, 1, 0, 0, 0, 802, 803, 1, 0, 0, 0, 803, 805,
		1, 0, 0, 0, 804, 806, 3, 106, 53, 0, 805, 804, 1, 0, 0, 0, 805, 806, 1,
		0, 0, 0, 806, 808, 1, 0, 0, 0, 807, 809, 3, 108, 54, 0, 808, 807, 1, 0,
		0, 0, 808, 809, 1, 0, 0, 0, 809, 812, 1, 0, 0, 0, 810, 811, 5, 50, 0, 0,
		811, 813, 5, 87, 0, 0, 812, 810, 1, 0, 0, 0, 812, 813, 1, 0, 0, 0, 813,
		820, 1, 0, 0, 0, 814, 815, 5, 84, 0, 0, 815, 817, 3, 14, 7, 0, 816, 818,
		3, 106, 53, 0, 817, 816, 1, 0, 0, 0, 817, 818, 1, 0, 0, 0, 818, 820, 1,
		0, 0, 0, 819, 791, 1, 0, 0, 0, 819, 814, 1, 0, 0, 0, 820, 101, 1, 0, 0,
		0, 821, 822, 5, 85, 0, 0, 822, 823, 3, 14, 7, 0, 823, 103, 1, 0, 0, 0,
		824, 825, 5, 86, 0, 0, 825, 826, 3, 14, 7, 0, 826, 105, 1, 0, 0, 0, 827,
		828, 5, 87, 0, 0, 828, 829, 3, 250, 125, 0, 829, 107, 1, 0, 0, 0, 830,
		831, 5, 88, 0, 0, 831, 832, 3, 46, 23, 0, 832, 109, 1, 0, 0, 0, 833, 834,
		5, 60, 0, 0, 834, 839, 3, 218, 109, 0, 835, 836, 5, 49, 0, 0, 836, 838,
		3, 218, 109, 0, 837, 835, 1, 0, 0, 0, 838, 841, 1, 0, 0, 0, 839, 837, 1,
		0, 0, 0, 839, 840, 1, 0, 0, 0, 840, 842, 1, 0, 0, 0, 841, 839, 1, 0, 0,
		0, 842, 843, 5, 62, 0, 0, 843, 111, 1, 0, 0, 0, 844, 845, 3, 222, 111,
		0, 845, 846, 5, 51, 0, 0, 846, 854, 3, 148, 74, 0, 847, 848, 5, 50, 0,
		0, 848, 849, 3, 222, 111, 0, 849, 850, 5, 51, 0, 0, 850, 851, 3, 148, 74,
		0, 851, 853, 1, 0, 0, 0, 852, 847, 1, 0, 0, 0, 853, 856, 1, 0, 0, 0, 854,
		852, 1, 0, 0, 0, 854, 855, 1, 0, 0, 0, 855, 113, 1, 0, 0, 0, 856, 854,
		1, 0, 0, 0, 857, 858, 5, 54, 0, 0, 858, 859, 3, 116, 58, 0, 859, 860, 5,
		57, 0, 0, 860, 115, 1, 0, 0, 0, 861, 866, 3, 118, 59, 0, 862, 863, 5, 49,
		0, 0, 863, 865, 3, 118, 59, 0, 864, 862, 1, 0, 0, 0, 865, 868, 1, 0, 0,
		0, 866, 864, 1, 0, 0, 0, 866, 867, 1, 0, 0, 0, 867, 117, 1, 0, 0, 0, 868,
		866, 1, 0, 0, 0, 869, 872, 3, 136, 68, 0, 870, 871, 5, 51, 0, 0, 871, 873,
		3, 120, 60, 0, 872, 870, 1, 0, 0, 0, 872, 873, 1, 0, 0, 0, 873, 119, 1,
		0, 0, 0, 874, 879, 3, 122, 61, 0, 875, 876, 5, 49, 0, 0, 876, 878, 3, 122,
		61, 0, 877, 875, 1, 0, 0, 0, 878, 881, 1, 0, 0, 0, 879, 877, 1, 0, 0, 0,
		879, 880, 1, 0, 0, 0, 880, 121, 1, 0, 0, 0, 881, 879, 1, 0, 0, 0, 882,
		890, 5, 106, 0, 0, 883, 890, 5, 77, 0, 0, 884, 890, 5, 33, 0, 0, 885, 886,
		5, 77, 0, 0, 886, 887, 5, 27, 0, 0, 887, 890, 3, 136, 68, 0, 888, 890,
		3, 136, 68, 0, 889, 882, 1, 0, 0, 0, 889, 883, 1, 0, 0, 0, 889, 884, 1,
		0, 0, 0, 889, 885, 1, 0, 0, 0, 889, 888, 1, 0, 0, 0, 890, 123, 1, 0, 0,
		0, 891, 895, 3, 126, 63, 0, 892, 895, 3, 138, 69, 0, 893, 895, 3, 184,
		92, 0, 894, 891, 1, 0, 0, 0, 894, 892, 1, 0, 0, 0, 894, 893, 1, 0, 0, 0,
		895, 125, 1, 0, 0, 0, 896, 901, 3, 128, 64, 0, 897, 901, 3, 134, 67, 0,
		898, 901, 3, 136, 68, 0, 899, 901, 3, 142, 71, 0, 900, 896, 1, 0, 0, 0,
		900, 897, 1, 0, 0, 0, 900, 898, 1, 0, 0, 0, 900, 899, 1, 0, 0, 0, 901,
		127, 1, 0, 0, 0, 902, 903, 5, 58, 0, 0, 903, 904, 3, 130, 65, 0, 904, 905,
		5, 59, 0, 0, 905, 129, 1, 0, 0, 0, 906, 911, 3, 132, 66, 0, 907, 908, 5,
		49, 0, 0, 908, 910, 3, 132, 66, 0, 909, 907, 1, 0, 0, 0, 910, 913, 1, 0,
		0, 0, 911, 909, 1, 0, 0, 0, 911, 912, 1, 0, 0, 0, 912, 131, 1, 0, 0, 0,
		913, 911, 1, 0, 0, 0, 914, 917, 3, 14, 7, 0, 915, 916, 5, 52, 0, 0, 916,
		918, 3, 250, 125, 0, 917, 915, 1, 0, 0, 0, 917, 918, 1, 0, 0, 0, 918, 133,
		1, 0, 0, 0, 919, 920, 3, 254, 127, 0, 920, 921, 5, 67, 0, 0, 921, 922,
		3, 254, 127, 0, 922, 135, 1, 0, 0, 0, 923, 927, 3, 14, 7, 0, 924, 927,
		7, 6, 0, 0, 925, 927, 3, 144, 72, 0, 926, 923, 1, 0, 0, 0, 926, 924, 1,
		0, 0, 0, 926, 925, 1, 0, 0, 0, 927, 137, 1, 0, 0, 0, 928, 929, 5, 29, 0,
		0, 929, 939, 3, 140, 70, 0, 930, 939, 3, 140, 70, 0, 931, 939, 3, 170,
		85, 0, 932, 939, 3, 76, 38, 0, 933, 935, 5, 29, 0, 0, 934, 933, 1, 0, 0,
		0, 934, 935, 1, 0, 0, 0, 935, 936, 1, 0, 0, 0, 936, 939, 3, 150, 75, 0,
		937, 939, 3, 90, 45, 0, 938, 928, 1, 0, 0, 0, 938, 930, 1, 0, 0, 0, 938,
		931, 1, 0, 0, 0, 938, 932, 1, 0, 0, 0, 938, 934, 1, 0, 0, 0, 938, 937,
		1, 0, 0, 0, 939, 139, 1, 0, 0, 0, 940, 944, 3, 144, 72, 0, 941, 944, 3,
		180, 90, 0, 942, 944, 3, 182, 91, 0, 943, 940, 1, 0, 0, 0, 943, 941, 1,
		0, 0, 0, 943, 942, 1, 0, 0, 0, 944, 141, 1, 0, 0, 0, 945, 946, 5, 73, 0,
		0, 946, 949, 5, 60, 0, 0, 947, 950, 3, 14, 7, 0, 948, 950, 3, 46, 23, 0,
		949, 947, 1, 0, 0, 0, 949, 948, 1, 0, 0, 0, 950, 951, 1, 0, 0, 0, 951,
		952, 5, 62, 0, 0, 952, 143, 1, 0, 0, 0, 953, 954, 5, 3, 0, 0, 954, 955,
		5, 60, 0, 0, 955, 956, 3, 146, 73, 0, 956, 957, 5, 62, 0, 0, 957, 958,
		5, 27, 0, 0, 958, 961, 3, 124, 62, 0, 959, 960, 5, 52, 0, 0, 960, 962,
		3, 128, 64, 0, 961, 959, 1, 0, 0, 0, 961, 962, 1, 0, 0, 0, 962, 980, 1,
		0, 0, 0, 963, 964, 5, 3, 0, 0, 964, 965, 5, 61, 0, 0, 965, 966, 3, 146,
		73, 0, 966, 967, 5, 63, 0, 0, 967, 968, 5, 27, 0, 0, 968, 971, 3, 124,
		62, 0, 969, 970, 5, 52, 0, 0, 970, 972, 3, 128, 64, 0, 971, 969, 1, 0,
		0, 0, 971, 972, 1, 0, 0, 0, 972, 980, 1, 0, 0, 0, 973, 974, 5, 3, 0, 0,
		974, 975, 5, 27, 0, 0, 975, 980, 5, 9, 0, 0, 976, 977, 5, 3, 0, 0, 977,
		978, 5, 27, 0, 0, 978, 980, 3, 124, 62, 0, 979, 953, 1, 0, 0, 0, 979, 963,
		1, 0, 0, 0, 979, 973, 1, 0, 0, 0, 979, 976, 1, 0, 0, 0, 980, 145, 1, 0,
		0, 0, 981, 986, 3, 148, 74, 0, 982, 983, 5, 49, 0, 0, 983, 985, 3, 148,
		74, 0, 984, 982, 1, 0, 0, 0, 985, 988, 1, 0, 0, 0, 986, 984, 1, 0, 0, 0,
		986, 987, 1, 0, 0, 0, 987, 147, 1, 0, 0, 0, 988, 986, 1, 0, 0, 0, 989,
		990, 3, 126, 63, 0, 990, 149, 1, 0, 0, 0, 991, 992, 5, 33, 0, 0, 992, 996,
		3, 154, 77, 0, 993, 995, 3, 152, 76, 0, 994, 993, 1, 0, 0, 0, 995, 998,
		1, 0, 0, 0, 996, 994, 1, 0, 0, 0, 996, 997, 1, 0, 0, 0, 997, 999, 1, 0,
		0, 0, 998, 996, 1, 0, 0, 0, 999, 1000, 5, 14, 0, 0, 1000, 1007, 1, 0, 0,
		0, 1001, 1003, 5, 33, 0, 0, 1002, 1004, 3, 160, 80, 0, 1003, 1002, 1, 0,
		0, 0, 1003, 1004, 1, 0, 0, 0, 1004, 1005, 1, 0, 0, 0, 1005, 1007, 5, 14,
		0, 0, 1006, 991, 1, 0, 0, 0, 1006, 1001, 1, 0, 0, 0, 1007, 151, 1, 0, 0,
		0, 1008, 1012, 3, 80, 40, 0, 1009, 1011, 3, 156, 78, 0, 1010, 1009, 1,
		0, 0, 0, 1011, 1014, 1, 0, 0, 0, 1012, 1010, 1, 0, 0, 0, 1012, 1013, 1,
		0, 0, 0, 1013, 153, 1, 0, 0, 0, 1014, 1012, 1, 0, 0, 0, 1015, 1017, 3,
		156, 78, 0, 1016, 1015, 1, 0, 0, 0, 1017, 1020, 1, 0, 0, 0, 1018, 1016,
		1, 0, 0, 0, 1018, 1019, 1, 0, 0, 0, 1019, 155, 1, 0, 0, 0, 1020, 1018,
		1, 0, 0, 0, 1021, 1023, 3, 336, 168, 0, 1022, 1021, 1, 0, 0, 0, 1022, 1023,
		1, 0, 0, 0, 1023, 1024, 1, 0, 0, 0, 1024, 1025, 3, 228, 114, 0, 1025, 1026,
		5, 50, 0, 0, 1026, 1042, 1, 0, 0, 0, 1027, 1042, 3, 64, 32, 0, 1028, 1042,
		3, 30, 15, 0, 1029, 1042, 3, 192, 96, 0, 1030, 1042, 3, 190, 95, 0, 1031,
		1042, 3, 212, 106, 0, 1032, 1033, 3, 100, 50, 0, 1033, 1036, 5, 50, 0,
		0, 1034, 1035, 5, 87, 0, 0, 1035, 1037, 5, 50, 0, 0, 1036, 1034, 1, 0,
		0, 0, 1036, 1037, 1, 0, 0, 0, 1037, 1042, 1, 0, 0, 0, 1038, 1039, 3, 158,
		79, 0, 1039, 1040, 5, 50, 0, 0, 1040, 1042, 1, 0, 0, 0, 1041, 1022, 1,
		0, 0, 0, 1041, 1027, 1, 0, 0, 0, 1041, 1028, 1, 0, 0, 0, 1041, 1029, 1,
		0, 0, 0, 1041, 1030, 1, 0, 0, 0, 1041, 1031, 1, 0, 0, 0, 1041, 1032, 1,
		0, 0, 0, 1041, 1038, 1, 0, 0, 0, 1042, 157, 1, 0, 0, 0, 1043, 1045, 8,
		5, 0, 0, 1044, 1043, 1, 0, 0, 0, 1045, 1046, 1, 0, 0, 0, 1046, 1044, 1,
		0, 0, 0, 1046, 1047, 1, 0, 0, 0, 1047, 159, 1, 0, 0, 0, 1048, 1051, 3,
		162, 81, 0, 1049, 1050, 5, 50, 0, 0, 1050, 1052, 3, 164, 82, 0, 1051, 1049,
		1, 0, 0, 0, 1051, 1052, 1, 0, 0, 0, 1052, 1055, 1, 0, 0, 0, 1053, 1055,
		3, 164, 82, 0, 1054, 1048, 1, 0, 0, 0, 1054, 1053, 1, 0, 0, 0, 1055, 161,
		1, 0, 0, 0, 1056, 1061, 3, 228, 114, 0, 1057, 1058, 5, 50, 0, 0, 1058,
		1060, 3, 228, 114, 0, 1059, 1057, 1, 0, 0, 0, 1060, 1063, 1, 0, 0, 0, 1061,
		1059, 1, 0, 0, 0, 1061, 1062, 1, 0, 0, 0, 1062, 1065, 1, 0, 0, 0, 1063,
		1061, 1, 0, 0, 0, 1064, 1066, 5, 50, 0, 0, 1065, 1064, 1, 0, 0, 0, 1065,
		1066, 1, 0, 0, 0, 1066, 163, 1, 0, 0, 0, 1067, 1068, 5, 6, 0, 0, 1068,
		1069, 3, 166, 83, 0, 1069, 1070, 5, 27, 0, 0, 1070, 1075, 3, 168, 84, 0,
		1071, 1072, 5, 50, 0, 0, 1072, 1074, 3, 168, 84, 0, 1073, 1071, 1, 0, 0,
		0, 1074, 1077, 1, 0, 0, 0, 1075, 1073, 1, 0, 0, 0, 1075, 1076, 1, 0, 0,
		0, 1076, 165, 1, 0, 0, 0, 1077, 1075, 1, 0, 0, 0, 1078, 1079, 3, 14, 7,
		0, 1079, 1080, 5, 51, 0, 0, 1080, 1081, 3, 136, 68, 0, 1081, 1084, 1, 0,
		0, 0, 1082, 1084, 3, 136, 68, 0, 1083, 1078, 1, 0, 0, 0, 1083, 1082, 1,
		0, 0, 0, 1084, 167, 1, 0, 0, 0, 1085, 1086, 3, 224, 112, 0, 1086, 1087,
		5, 51, 0, 0, 1087, 1088, 5, 58, 0, 0, 1088, 1089, 3, 160, 80, 0, 1089,
		1090, 5, 59, 0, 0, 1090, 169, 1, 0, 0, 0, 1091, 1092, 5, 77, 0, 0, 1092,
		1093, 5, 19, 0, 0, 1093, 1094, 5, 16, 0, 0, 1094, 1095, 3, 136, 68, 0,
		1095, 1099, 3, 174, 87, 0, 1096, 1098, 3, 172, 86, 0, 1097, 1096, 1, 0,
		0, 0, 1098, 1101, 1, 0, 0, 0, 1099, 1097, 1, 0, 0, 0, 1099, 1100, 1, 0,
		0, 0, 1100, 1102, 1, 0, 0, 0, 1101, 1099, 1, 0, 0, 0, 1102, 1103, 5, 14,
		0, 0, 1103, 171, 1, 0, 0, 0, 1104, 1108, 3, 80, 40, 0, 1105, 1107, 3, 176,
		88, 0, 1106, 1105, 1, 0, 0, 0, 1107, 1110, 1, 0, 0, 0, 1108, 1106, 1, 0,
		0, 0, 1108, 1109, 1, 0, 0, 0, 1109, 173, 1, 0, 0, 0, 1110, 1108, 1, 0,
		0, 0, 1111, 1113, 3, 176, 88, 0, 1112, 1111, 1, 0, 0, 0, 1113, 1116, 1,
		0, 0, 0, 1114, 1112, 1, 0, 0, 0, 1114, 1115, 1, 0, 0, 0, 1115, 175, 1,
		0, 0, 0, 1116, 1114, 1, 0, 0, 0, 1117, 1131, 3, 64, 32, 0, 1118, 1131,
		3, 30, 15, 0, 1119, 1131, 3, 192, 96, 0, 1120, 1131, 3, 190, 95, 0, 1121,
		1122, 3, 100, 50, 0, 1122, 1125, 5, 50, 0, 0, 1123, 1124, 5, 87, 0, 0,
		1124, 1126, 5, 50, 0, 0, 1125, 1123, 1, 0, 0, 0, 1125, 1126, 1, 0, 0, 0,
		1126, 1131, 1, 0, 0, 0, 1127, 1128, 3, 178, 89, 0, 1128, 1129, 5, 50, 0,
		0, 1129, 1131, 1, 0, 0, 0, 1130, 1117, 1, 0, 0, 0, 1130, 1118, 1, 0, 0,
		0, 1130, 1119, 1, 0, 0, 0, 1130, 1120, 1, 0, 0, 0, 1130, 1121, 1, 0, 0,
		0, 1130, 1127, 1, 0, 0, 0, 1131, 177, 1, 0, 0, 0, 1132, 1134, 8, 5, 0,
		0, 1133, 1132, 1, 0, 0, 0, 1134, 1135, 1, 0, 0, 0, 1135, 1133, 1, 0, 0,
		0, 1135, 1136, 1, 0, 0, 0, 1136, 179, 1, 0, 0, 0, 1137, 1138, 5, 36, 0,
		0, 1138, 1139, 5, 27, 0, 0, 1139, 1140, 3, 126, 63, 0, 1140, 181, 1, 0,
		0, 0, 1141, 1142, 5, 15, 0, 0, 1142, 1143, 5, 27, 0, 0, 1143, 1146, 3,
		124, 62, 0, 1144, 1146, 5, 15, 0, 0, 1145, 1141, 1, 0, 0, 0, 1145, 1144,
		1, 0, 0, 0, 1146, 183, 1, 0, 0, 0, 1147, 1148, 5, 64, 0, 0, 1148, 1149,
		3, 136, 68, 0, 1149, 185, 1, 0, 0, 0, 1150, 1151, 5, 41, 0, 0, 1151, 1156,
		3, 188, 94, 0, 1152, 1153, 5, 50, 0, 0, 1153, 1155, 3, 188, 94, 0, 1154,
		1152, 1, 0, 0, 0, 1155, 1158, 1, 0, 0, 0, 1156, 1154, 1, 0, 0, 0, 1156,
		1157, 1, 0, 0, 0, 1157, 1159, 1, 0, 0, 0, 1158, 1156, 1, 0, 0, 0, 1159,
		1160, 5, 50, 0, 0, 1160, 187, 1, 0, 0, 0, 1161, 1163, 3, 336, 168, 0, 1162,
		1161, 1, 0, 0, 0, 1162, 1163, 1, 0, 0, 0, 1163, 1164, 1, 0, 0, 0, 1164,
		1167, 3, 228, 114, 0, 1165, 1166, 5, 52, 0, 0, 1166, 1168, 3, 254, 127,
		0, 1167, 1165, 1, 0, 0, 0, 1167, 1168, 1, 0, 0, 0, 1168, 189, 1, 0, 0,
		0, 1169, 1171, 3, 336, 168, 0, 1170, 1169, 1, 0, 0, 0, 1170, 1171, 1, 0,
		0, 0, 1171, 1173, 1, 0, 0, 0, 1172, 1174, 5, 77, 0, 0, 1173, 1172, 1, 0,
		0, 0, 1173, 1174, 1, 0, 0, 0, 1174, 1175, 1, 0, 0, 0, 1175, 1176, 7, 7,
		0, 0, 1176, 1178, 3, 14, 7, 0, 1177, 1179, 3, 216, 108, 0, 1178, 1177,
		1, 0, 0, 0, 1178, 1179, 1, 0, 0, 0, 1179, 1180, 1, 0, 0, 0, 1180, 1181,
		3, 196, 98, 0, 1181, 1182, 5, 50, 0, 0, 1182, 191, 1, 0, 0, 0, 1183, 1185,
		3, 336, 168, 0, 1184, 1183, 1, 0, 0, 0, 1184, 1185, 1, 0, 0, 0, 1185, 1187,
		1, 0, 0, 0, 1186, 1188, 5, 77, 0, 0, 1187, 1186, 1, 0, 0, 0, 1187, 1188,
		1, 0, 0, 0, 1188, 1189, 1, 0, 0, 0, 1189, 1190, 5, 17, 0, 0, 1190, 1192,
		3, 14, 7, 0, 1191, 1193, 3, 216, 108, 0, 1192, 1191, 1, 0, 0, 0, 1192,
		1193, 1, 0, 0, 0, 1193, 1194, 1, 0, 0, 0, 1194, 1195, 5, 51, 0, 0, 1195,
		1196, 3, 208, 104, 0, 1196, 1197, 3, 196, 98, 0, 1197, 1198, 5, 50, 0,
		0, 1198, 193, 1, 0, 0, 0, 1199, 1202, 3, 190, 95, 0, 1200, 1202, 3, 192,
		96, 0, 1201, 1199, 1, 0, 0, 0, 1201, 1200, 1, 0, 0, 0, 1202, 195, 1, 0,
		0, 0, 1203, 1204, 5, 50, 0, 0, 1204, 1206, 7, 8, 0, 0, 1205, 1203, 1, 0,
		0, 0, 1206, 1209, 1, 0, 0, 0, 1207, 1205, 1, 0, 0, 0, 1207, 1208, 1, 0,
		0, 0, 1208, 197, 1, 0, 0, 0, 1209, 1207, 1, 0, 0, 0, 1210, 1213, 3, 200,
		100, 0, 1211, 1213, 3, 202, 101, 0, 1212, 1210, 1, 0, 0, 0, 1212, 1211,
		1, 0, 0, 0, 1213, 199, 1, 0, 0, 0, 1214, 1215, 3, 190, 95, 0, 1215, 1216,
		3, 210, 105, 0, 1216, 1217, 5, 50, 0, 0, 1217, 201, 1, 0, 0, 0, 1218, 1219,
		3, 192, 96, 0, 1219, 1220, 3, 210, 105, 0, 1220, 1221, 5, 50, 0, 0, 1221,
		203, 1, 0, 0, 0, 1222, 1224, 5, 30, 0, 0, 1223, 1225, 3, 216, 108, 0, 1224,
		1223, 1, 0, 0, 0, 1224, 1225, 1, 0, 0, 0, 1225, 1226, 1, 0, 0, 0, 1226,
		1227, 3, 210, 105, 0, 1227, 205, 1, 0, 0, 0, 1228, 1230, 5, 17, 0, 0, 1229,
		1231, 3, 216, 108, 0, 1230, 1229, 1, 0, 0, 0, 1230, 1231, 1, 0, 0, 0, 1231,
		1232, 1, 0, 0, 0, 1232, 1233, 5, 51, 0, 0, 1233, 1234, 3, 208, 104, 0,
		1234, 1235, 3, 210, 105, 0, 1235, 207, 1, 0, 0, 0, 1236, 1237, 3, 136,
		68, 0, 1237, 209, 1, 0, 0, 0, 1238, 1239, 3, 22, 11, 0, 1239, 1240, 3,
		298, 149, 0, 1240, 211, 1, 0, 0, 0, 1241, 1242, 5, 77, 0, 0, 1242, 1243,
		5, 117, 0, 0, 1243, 1245, 3, 14, 7, 0, 1244, 1246, 3, 216, 108, 0, 1245,
		1244, 1, 0, 0, 0, 1245, 1246, 1, 0, 0, 0, 1246, 1247, 1, 0, 0, 0, 1247,
		1248, 5, 51, 0, 0, 1248, 1249, 3, 208, 104, 0, 1249, 1250, 3, 196, 98,
		0, 1250, 1251, 5, 50, 0, 0, 1251, 213, 1, 0, 0, 0, 1252, 1253, 3, 212,
		106, 0, 1253, 1254, 3, 210, 105, 0, 1254, 1255, 5, 50, 0, 0, 1255, 215,
		1, 0, 0, 0, 1256, 1257, 5, 58, 0, 0, 1257, 1262, 3, 218, 109, 0, 1258,
		1259, 5, 50, 0, 0, 1259, 1261, 3, 218, 109, 0, 1260, 1258, 1, 0, 0, 0,
		1261, 1264, 1, 0, 0, 0, 1262, 1260, 1, 0, 0, 0, 1262, 1263, 1, 0, 0, 0,
		1263, 1265, 1, 0, 0, 0, 1264, 1262, 1, 0, 0, 0, 1265, 1266, 5, 59, 0, 0,
		1266, 217, 1, 0, 0, 0, 1267, 1269, 3, 336, 168, 0, 1268, 1267, 1, 0, 0,
		0, 1268, 1269, 1, 0, 0, 0, 1269, 1270, 1, 0, 0, 0, 1270, 1297, 3, 220,
		110, 0, 1271, 1273, 3, 336, 168, 0, 1272, 1271, 1, 0, 0, 0, 1272, 1273,
		1, 0, 0, 0, 1273, 1274, 1, 0, 0, 0, 1274, 1275, 5, 41, 0, 0, 1275, 1297,
		3, 220, 110, 0, 1276, 1278, 3, 336, 168, 0, 1277, 1276, 1, 0, 0, 0, 1277,
		1278, 1, 0, 0, 0, 1278, 1279, 1, 0, 0, 0, 1279, 1280, 5, 9, 0, 0, 1280,
		1297, 3, 220, 110, 0, 1281, 1283, 3, 336, 168, 0, 1282, 1281, 1, 0, 0,
		0, 1282, 1283, 1, 0, 0, 0, 1283, 1284, 1, 0, 0, 0, 1284, 1285, 5, 83, 0,
		0, 1285, 1297, 3, 220, 110, 0, 1286, 1288, 3, 336, 168, 0, 1287, 1286,
		1, 0, 0, 0, 1287, 1288, 1, 0, 0, 0, 1288, 1289, 1, 0, 0, 0, 1289, 1290,
		5, 17, 0, 0, 1290, 1297, 3, 220, 110, 0, 1291, 1293, 3, 336, 168, 0, 1292,
		1291, 1, 0, 0, 0, 1292, 1293, 1, 0, 0, 0, 1293, 1294, 1, 0, 0, 0, 1294,
		1295, 5, 30, 0, 0, 1295, 1297, 3, 220, 110, 0, 1296, 1268, 1, 0, 0, 0,
		1296, 1272, 1, 0, 0, 0, 1296, 1277, 1, 0, 0, 0, 1296, 1282, 1, 0, 0, 0,
		1296, 1287, 1, 0, 0, 0, 1296, 1292, 1, 0, 0, 0, 1297, 219, 1, 0, 0, 0,
		1298, 1301, 3, 222, 111, 0, 1299, 1300, 5, 51, 0, 0, 1300, 1302, 3, 136,
		68, 0, 1301, 1299, 1, 0, 0, 0, 1301, 1302, 1, 0, 0, 0, 1302, 1304, 1, 0,
		0, 0, 1303, 1305, 3, 226, 113, 0, 1304, 1303, 1, 0, 0, 0, 1304, 1305, 1,
		0, 0, 0, 1305, 221, 1, 0, 0, 0, 1306, 1311, 3, 14, 7, 0, 1307, 1308, 5,
		49, 0, 0, 1308, 1310, 3, 14, 7, 0, 1309, 1307, 1, 0, 0, 0, 1310, 1313,
		1, 0, 0, 0, 1311, 1309, 1, 0, 0, 0, 1311, 1312, 1, 0, 0, 0, 1312, 223,
		1, 0, 0, 0, 1313, 1311, 1, 0, 0, 0, 1314, 1319, 3, 38, 19, 0, 1315, 1316,
		5, 49, 0, 0, 1316, 1318, 3, 38, 19, 0, 1317, 1315, 1, 0, 0, 0, 1318, 1321,
		1, 0, 0, 0, 1319, 1317, 1, 0, 0, 0, 1319, 1320, 1, 0, 0, 0, 1320, 225,
		1, 0, 0, 0, 1321, 1319, 1, 0, 0, 0, 1322, 1323, 5, 52, 0, 0, 1323, 1324,
		3, 250, 125, 0, 1324, 227, 1, 0, 0, 0, 1325, 1326, 3, 222, 111, 0, 1326,
		1327, 5, 51, 0, 0, 1327, 1328, 3, 124, 62, 0, 1328, 229, 1, 0, 0, 0, 1329,
		1330, 3, 28, 14, 0, 1330, 1331, 5, 51, 0, 0, 1331, 1332, 3, 234, 117, 0,
		1332, 1336, 1, 0, 0, 0, 1333, 1336, 3, 234, 117, 0, 1334, 1336, 3, 232,
		116, 0, 1335, 1329, 1, 0, 0, 0, 1335, 1333, 1, 0, 0, 0, 1335, 1334, 1,
		0, 0, 0, 1336, 231, 1, 0, 0, 0, 1337, 1339, 8, 9, 0, 0, 1338, 1337, 1,
		0, 0, 0, 1339, 1340, 1, 0, 0, 0, 1340, 1338, 1, 0, 0, 0, 1340, 1341, 1,
		0, 0, 0, 1341, 233, 1, 0, 0, 0, 1342, 1345, 3, 236, 118, 0, 1343, 1345,
		3, 296, 148, 0, 1344, 1342, 1, 0, 0, 0, 1344, 1343, 1, 0, 0, 0, 1345, 235,
		1, 0, 0, 0, 1346, 1356, 3, 238, 119, 0, 1347, 1356, 3, 282, 141, 0, 1348,
		1356, 3, 280, 140, 0, 1349, 1356, 3, 288, 144, 0, 1350, 1356, 3, 290, 145,
		0, 1351, 1356, 3, 246, 123, 0, 1352, 1356, 3, 292, 146, 0, 1353, 1356,
		3, 240, 120, 0, 1354, 1356, 3, 242, 121, 0, 1355, 1346, 1, 0, 0, 0, 1355,
		1347, 1, 0, 0, 0, 1355, 1348, 1, 0, 0, 0, 1355, 1349, 1, 0, 0, 0, 1355,
		1350, 1, 0, 0, 0, 1355, 1351, 1, 0, 0, 0, 1355, 1352, 1, 0, 0, 0, 1355,
		1353, 1, 0, 0, 0, 1355, 1354, 1, 0, 0, 0, 1356, 237, 1, 0, 0, 0, 1357,
		1358, 3, 244, 122, 0, 1358, 1359, 5, 48, 0, 0, 1359, 1360, 3, 250, 125,
		0, 1360, 1366, 1, 0, 0, 0, 1361, 1362, 3, 248, 124, 0, 1362, 1363, 5, 48,
		0, 0, 1363, 1364, 3, 250, 125, 0, 1364, 1366, 1, 0, 0, 0, 1365, 1357, 1,
		0, 0, 0, 1365, 1361, 1, 0, 0, 0, 1366, 239, 1, 0, 0, 0, 1367, 1369, 5,
		110, 0, 0, 1368, 1370, 3, 250, 125, 0, 1369, 1368, 1, 0, 0, 0, 1369, 1370,
		1, 0, 0, 0, 1370, 241, 1, 0, 0, 0, 1371, 1372, 5, 41, 0, 0, 1372, 1375,
		3, 222, 111, 0, 1373, 1374, 5, 51, 0, 0, 1374, 1376, 3, 124, 62, 0, 1375,
		1373, 1, 0, 0, 0, 1375, 1376, 1, 0, 0, 0, 1376, 1379, 1, 0, 0, 0, 1377,
		1378, 5, 48, 0, 0, 1378, 1380, 3, 250, 125, 0, 1379, 1377, 1, 0, 0, 0,
		1379, 1380, 1, 0, 0, 0, 1380, 243, 1, 0, 0, 0, 1381, 1386, 3, 246, 123,
		0, 1382, 1383, 5, 65, 0, 0, 1383, 1386, 3, 14, 7, 0, 1384, 1386, 3, 268,
		134, 0, 1385, 1381, 1, 0, 0, 0, 1385, 1382, 1, 0, 0, 0, 1385, 1384, 1,
		0, 0, 0, 1386, 1418, 1, 0, 0, 0, 1387, 1388, 5, 60, 0, 0, 1388, 1393, 3,
		250, 125, 0, 1389, 1390, 5, 49, 0, 0, 1390, 1392, 3, 250, 125, 0, 1391,
		1389, 1, 0, 0, 0, 1392, 1395, 1, 0, 0, 0, 1393, 1391, 1, 0, 0, 0, 1393,
		1394, 1, 0, 0, 0, 1394, 1396, 1, 0, 0, 0, 1395, 1393, 1, 0, 0, 0, 1396,
		1397, 5, 62, 0, 0, 1397, 1417, 1, 0, 0, 0, 1398, 1399, 5, 61, 0, 0, 1399,
		1404, 3, 250, 125, 0, 1400, 1401, 5, 49, 0, 0, 1401, 1403, 3, 250, 125,
		0, 1402, 1400, 1, 0, 0, 0, 1403, 1406, 1, 0, 0, 0, 1404, 1402, 1, 0, 0,
		0, 1404, 1405, 1, 0, 0, 0, 1405, 1407, 1, 0, 0, 0, 1406, 1404, 1, 0, 0,
		0, 1407, 1408, 5, 63, 0, 0, 1408, 1417, 1, 0, 0, 0, 1409, 1410, 5, 66,
		0, 0, 1410, 1417, 3, 268, 134, 0, 1411, 1413, 5, 64, 0, 0, 1412, 1411,
		1, 0, 0, 0, 1413, 1414, 1, 0, 0, 0, 1414, 1412, 1, 0, 0, 0, 1414, 1415,
		1, 0, 0, 0, 1415, 1417, 1, 0, 0, 0, 1416, 1387, 1, 0, 0, 0, 1416, 1398,
		1, 0, 0, 0, 1416, 1409, 1, 0, 0, 0, 1416, 1412, 1, 0, 0, 0, 1417, 1420,
		1, 0, 0, 0, 1418, 1416, 1, 0, 0, 0, 1418, 1419, 1, 0, 0, 0, 1419, 245,
		1, 0, 0, 0, 1420, 1418, 1, 0, 0, 0, 1421, 1422, 3, 136, 68, 0, 1422, 1423,
		5, 58, 0, 0, 1423, 1424, 3, 250, 125, 0, 1424, 1425, 5, 59, 0, 0, 1425,
		1433, 1, 0, 0, 0, 1426, 1427, 5, 58, 0, 0, 1427, 1428, 3, 250, 125, 0,
		1428, 1429, 5, 89, 0, 0, 1429, 1430, 3, 136, 68, 0, 1430, 1431, 5, 59,
		0, 0, 1431, 1433, 1, 0, 0, 0, 1432, 1421, 1, 0, 0, 0, 1432, 1426, 1, 0,
		0, 0, 1433, 247, 1, 0, 0, 0, 1434, 1439, 3, 268, 134, 0, 1435, 1436, 5,
		66, 0, 0, 1436, 1438, 3, 268, 134, 0, 1437, 1435, 1, 0, 0, 0, 1438, 1441,
		1, 0, 0, 0, 1439, 1437, 1, 0, 0, 0, 1439, 1440, 1, 0, 0, 0, 1440, 1442,
		1, 0, 0, 0, 1441, 1439, 1, 0, 0, 0, 1442, 1443, 5, 66, 0, 0, 1443, 1455,
		3, 14, 7, 0, 1444, 1445, 5, 60, 0, 0, 1445, 1450, 3, 250, 125, 0, 1446,
		1447, 5, 49, 0, 0, 1447, 1449, 3, 250, 125, 0, 1448, 1446, 1, 0, 0, 0,
		1449, 1452, 1, 0, 0, 0, 1450, 1448, 1, 0, 0, 0, 1450, 1451, 1, 0, 0, 0,
		1451, 1453, 1, 0, 0, 0, 1452, 1450, 1, 0, 0, 0, 1453, 1454, 5, 62, 0, 0,
		1454, 1456, 1, 0, 0, 0, 1455, 1444, 1, 0, 0, 0, 1455, 1456, 1, 0, 0, 0,
		1456, 249, 1, 0, 0, 0, 1457, 1461, 3, 254, 127, 0, 1458, 1459, 3, 252,
		126, 0, 1459, 1460, 3, 250, 125, 0, 1460, 1462, 1, 0, 0, 0, 1461, 1458,
		1, 0, 0, 0, 1461, 1462, 1, 0, 0, 0, 1462, 251, 1, 0, 0, 0, 1463, 1464,
		7, 10, 0, 0, 1464, 253, 1, 0, 0, 0, 1465, 1469, 3, 258, 129, 0, 1466, 1467,
		3, 256, 128, 0, 1467, 1468, 3, 254, 127, 0, 1468, 1470, 1, 0, 0, 0, 1469,
		1466, 1, 0, 0, 0, 1469, 1470, 1, 0, 0, 0, 1470, 255, 1, 0, 0, 0, 1471,
		1472, 7, 11, 0, 0, 1472, 257, 1, 0, 0, 0, 1473, 1477, 3, 262, 131, 0, 1474,
		1475, 3, 260, 130, 0, 1475, 1476, 3, 258, 129, 0, 1476, 1478, 1, 0, 0,
		0, 1477, 1474, 1, 0, 0, 0, 1477, 1478, 1, 0, 0, 0, 1478, 259, 1, 0, 0,
		0, 1479, 1480, 7, 12, 0, 0, 1480, 261, 1, 0, 0, 0, 1481, 1483, 7, 1, 0,
		0, 1482, 1481, 1, 0, 0, 0, 1482, 1483, 1, 0, 0, 0, 1483, 1484, 1, 0, 0,
		0, 1484, 1485, 3, 264, 132, 0, 1485, 263, 1, 0, 0, 0, 1486, 1488, 6, 132,
		-1, 0, 1487, 1489, 5, 96, 0, 0, 1488, 1487, 1, 0, 0, 0, 1488, 1489, 1,
		0, 0, 0, 1489, 1490, 1, 0, 0, 0, 1490, 1526, 3, 268, 134, 0, 1491, 1526,
		3, 270, 135, 0, 1492, 1495, 3, 244, 122, 0, 1493, 1494, 5, 89, 0, 0, 1494,
		1496, 3, 14, 7, 0, 1495, 1493, 1, 0, 0, 0, 1495, 1496, 1, 0, 0, 0, 1496,
		1526, 1, 0, 0, 0, 1497, 1498, 5, 58, 0, 0, 1498, 1499, 3, 250, 125, 0,
		1499, 1500, 5, 59, 0, 0, 1500, 1526, 1, 0, 0, 0, 1501, 1526, 3, 266, 133,
		0, 1502, 1526, 3, 274, 137, 0, 1503, 1504, 5, 26, 0, 0, 1504, 1526, 3,
		264, 132, 8, 1505, 1526, 3, 54, 27, 0, 1506, 1508, 5, 65, 0, 0, 1507, 1506,
		1, 0, 0, 0, 1507, 1508, 1, 0, 0, 0, 1508, 1509, 1, 0, 0, 0, 1509, 1514,
		3, 136, 68, 0, 1510, 1511, 5, 58, 0, 0, 1511, 1512, 3, 250, 125, 0, 1512,
		1513, 5, 59, 0, 0, 1513, 1515, 1, 0, 0, 0, 1514, 1510, 1, 0, 0, 0, 1514,
		1515, 1, 0, 0, 0, 1515, 1519, 1, 0, 0, 0, 1516, 1518, 5, 64, 0, 0, 1517,
		1516, 1, 0, 0, 0, 1518, 1521, 1, 0, 0, 0, 1519, 1517, 1, 0, 0, 0, 1519,
		1520, 1, 0, 0, 0, 1520, 1526, 1, 0, 0, 0, 1521, 1519, 1, 0, 0, 0, 1522,
		1526, 3, 14, 7, 0, 1523, 1526, 3, 206, 103, 0, 1524, 1526, 3, 204, 102,
		0, 1525, 1486, 1, 0, 0, 0, 1525, 1491, 1, 0, 0, 0, 1525, 1492, 1, 0, 0,
		0, 1525, 1497, 1, 0, 0, 0, 1525, 1501, 1, 0, 0, 0, 1525, 1502, 1, 0, 0,
		0, 1525, 1503, 1, 0, 0, 0, 1525, 1505, 1, 0, 0, 0, 1525, 1507, 1, 0, 0,
		0, 1525, 1522, 1, 0, 0, 0, 1525, 1523, 1, 0, 0, 0, 1525, 1524, 1, 0, 0,
		0, 1526, 1548, 1, 0, 0, 0, 1527, 1528, 10, 6, 0, 0, 1528, 1529, 5, 60,
		0, 0, 1529, 1534, 3, 250, 125, 0, 1530, 1531, 5, 49, 0, 0, 1531, 1533,
		3, 250, 125, 0, 1532, 1530, 1, 0, 0, 0, 1533, 1536, 1, 0, 0, 0, 1534, 1532,
		1, 0, 0, 0, 1534, 1535, 1, 0, 0, 0, 1535, 1537, 1, 0, 0, 0, 1536, 1534,
		1, 0, 0, 0, 1537, 1538, 5, 62, 0, 0, 1538, 1547, 1, 0, 0, 0, 1539, 1542,
		10, 4, 0, 0, 1540, 1541, 5, 66, 0, 0, 1541, 1543, 3, 250, 125, 0, 1542,
		1540, 1, 0, 0, 0, 1543, 1544, 1, 0, 0, 0, 1544, 1542, 1, 0, 0, 0, 1544,
		1545, 1, 0, 0, 0, 1545, 1547, 1, 0, 0, 0, 1546, 1527, 1, 0, 0, 0, 1546,
		1539, 1, 0, 0, 0, 1547, 1550, 1, 0, 0, 0, 1548, 1546, 1, 0, 0, 0, 1548,
		1549, 1, 0, 0, 0, 1549, 265, 1, 0, 0, 0, 1550, 1548, 1, 0, 0, 0, 1551,
		1553, 3, 52, 26, 0, 1552, 1551, 1, 0, 0, 0, 1552, 1553, 1, 0, 0, 0, 1553,
		1554, 1, 0, 0, 0, 1554, 1560, 3, 46, 23, 0, 1555, 1560, 3, 34, 17, 0, 1556,
		1560, 3, 36, 18, 0, 1557, 1560, 3, 56, 28, 0, 1558, 1560, 5, 25, 0, 0,
		1559, 1552, 1, 0, 0, 0, 1559, 1555, 1, 0, 0, 0, 1559, 1556, 1, 0, 0, 0,
		1559, 1557, 1, 0, 0, 0, 1559, 1558, 1, 0, 0, 0, 1560, 267, 1, 0, 0, 0,
		1561, 1567, 3, 14, 7, 0, 1562, 1564, 5, 58, 0, 0, 1563, 1565, 3, 272, 136,
		0, 1564, 1563, 1, 0, 0, 0, 1564, 1565, 1, 0, 0, 0, 1565, 1566, 1, 0, 0,
		0, 1566, 1568, 5, 59, 0, 0, 1567, 1562, 1, 0, 0, 0, 1567, 1568, 1, 0, 0,
		0, 1568, 269, 1, 0, 0, 0, 1569, 1574, 5, 87, 0, 0, 1570, 1571, 5, 58, 0,
		0, 1571, 1572, 3, 272, 136, 0, 1572, 1573, 5, 59, 0, 0, 1573, 1575, 1,
		0, 0, 0, 1574, 1570, 1, 0, 0, 0, 1574, 1575, 1, 0, 0, 0, 1575, 271, 1,
		0, 0, 0, 1576, 1581, 3, 284, 142, 0, 1577, 1578, 5, 49, 0, 0, 1578, 1580,
		3, 284, 142, 0, 1579, 1577, 1, 0, 0, 0, 1580, 1583, 1, 0, 0, 0, 1581, 1579,
		1, 0, 0, 0, 1581, 1582, 1, 0, 0, 0, 1582, 273, 1, 0, 0, 0, 1583, 1581,
		1, 0, 0, 0, 1584, 1585, 5, 60, 0, 0, 1585, 1586, 3, 276, 138, 0, 1586,
		1587, 5, 62, 0, 0, 1587, 1593, 1, 0, 0, 0, 1588, 1589, 5, 61, 0, 0, 1589,
		1590, 3, 276, 138, 0, 1590, 1591, 5, 63, 0, 0, 1591, 1593, 1, 0, 0, 0,
		1592, 1584, 1, 0, 0, 0, 1592, 1588, 1, 0, 0, 0, 1593, 275, 1, 0, 0, 0,
		1594, 1599, 3, 278, 139, 0, 1595, 1596, 5, 49, 0, 0, 1596, 1598, 3, 278,
		139, 0, 1597, 1595, 1, 0, 0, 0, 1598, 1601, 1, 0, 0, 0, 1599, 1597, 1,
		0, 0, 0, 1599, 1600, 1, 0, 0, 0, 1600, 1604, 1, 0, 0, 0, 1601, 1599, 1,
		0, 0, 0, 1602, 1604, 1, 0, 0, 0, 1603, 1594, 1, 0, 0, 0, 1603, 1602, 1,
		0, 0, 0, 1604, 277, 1, 0, 0, 0, 1605, 1608, 3, 250, 125, 0, 1606, 1607,
		5, 67, 0, 0, 1607, 1609, 3, 250, 125, 0, 1608, 1606, 1, 0, 0, 0, 1608,
		1609, 1, 0, 0, 0, 1609, 279, 1, 0, 0, 0, 1610, 1616, 3, 14, 7, 0, 1611,
		1613, 5, 58, 0, 0, 1612, 1614, 3, 272, 136, 0, 1613, 1612, 1, 0, 0, 0,
		1613, 1614, 1, 0, 0, 0, 1614, 1615, 1, 0, 0, 0, 1615, 1617, 5, 59, 0, 0,
		1616, 1611, 1, 0, 0, 0, 1616, 1617, 1, 0, 0, 0, 1617, 281, 1, 0, 0, 0,
		1618, 1623, 3, 244, 122, 0, 1619, 1620, 5, 66, 0, 0, 1620, 1622, 3, 244,
		122, 0, 1621, 1619, 1, 0, 0, 0, 1622, 1625, 1, 0, 0, 0, 1623, 1621, 1,
		0, 0, 0, 1623, 1624, 1, 0, 0, 0, 1624, 1626, 1, 0, 0, 0, 1625, 1623, 1,
		0, 0, 0, 1626, 1627, 5, 66, 0, 0, 1627, 1632, 3, 14, 7, 0, 1628, 1629,
		5, 58, 0, 0, 1629, 1630, 3, 272, 136, 0, 1630, 1631, 5, 59, 0, 0, 1631,
		1633, 1, 0, 0, 0, 1632, 1628, 1, 0, 0, 0, 1632, 1633, 1, 0, 0, 0, 1633,
		283, 1, 0, 0, 0, 1634, 1638, 3, 250, 125, 0, 1635, 1637, 3, 286, 143, 0,
		1636, 1635, 1, 0, 0, 0, 1637, 1640, 1, 0, 0, 0, 1638, 1636, 1, 0, 0, 0,
		1638, 1639, 1, 0, 0, 0, 1639, 1644, 1, 0, 0, 0, 1640, 1638, 1, 0, 0, 0,
		1641, 1644, 3, 204, 102, 0, 1642, 1644, 3, 206, 103, 0, 1643, 1634, 1,
		0, 0, 0, 1643, 1641, 1, 0, 0, 0, 1643, 1642, 1, 0, 0, 0, 1644, 285, 1,
		0, 0, 0, 1645, 1646, 5, 51, 0, 0, 1646, 1647, 3, 250, 125, 0, 1647, 287,
		1, 0, 0, 0, 1648, 1649, 5, 18, 0, 0, 1649, 1650, 3, 28, 14, 0, 1650, 289,
		1, 0, 0, 0, 1651, 1659, 5, 96, 0, 0, 1652, 1657, 3, 14, 7, 0, 1653, 1654,
		5, 58, 0, 0, 1654, 1655, 3, 272, 136, 0, 1655, 1656, 5, 59, 0, 0, 1656,
		1658, 1, 0, 0, 0, 1657, 1653, 1, 0, 0, 0, 1657, 1658, 1, 0, 0, 0, 1658,
		1660, 1, 0, 0, 0, 1659, 1652, 1, 0, 0, 0, 1659, 1660, 1, 0, 0, 0, 1660,
		291, 1, 0, 0, 0, 1661, 1662, 1, 0, 0, 0, 1662, 293, 1, 0, 0, 0, 1663, 1664,
		1, 0, 0, 0, 1664, 295, 1, 0, 0, 0, 1665, 1672, 3, 298, 149, 0, 1666, 1672,
		3, 302, 151, 0, 1667, 1672, 3, 310, 155, 0, 1668, 1672, 3, 324, 162, 0,
		1669, 1672, 3, 326, 163, 0, 1670, 1672, 3, 332, 166, 0, 1671, 1665, 1,
		0, 0, 0, 1671, 1666, 1, 0, 0, 0, 1671, 1667, 1, 0, 0, 0, 1671, 1668, 1,
		0, 0, 0, 1671, 1669, 1, 0, 0, 0, 1671, 1670, 1, 0, 0, 0, 1672, 297, 1,
		0, 0, 0, 1673, 1674, 5, 4, 0, 0, 1674, 1675, 3, 300, 150, 0, 1675, 1676,
		5, 14, 0, 0, 1676, 299, 1, 0, 0, 0, 1677, 1682, 3, 230, 115, 0, 1678, 1679,
		5, 50, 0, 0, 1679, 1681, 3, 230, 115, 0, 1680, 1678, 1, 0, 0, 0, 1681,
		1684, 1, 0, 0, 0, 1682, 1680, 1, 0, 0, 0, 1682, 1683, 1, 0, 0, 0, 1683,
		301, 1, 0, 0, 0, 1684, 1682, 1, 0, 0, 0, 1685, 1688, 3, 304, 152, 0, 1686,
		1688, 3, 306, 153, 0, 1687, 1685, 1, 0, 0, 0, 1687, 1686, 1, 0, 0, 0, 1688,
		303, 1, 0, 0, 0, 1689, 1690, 5, 20, 0, 0, 1690, 1691, 3, 250, 125, 0, 1691,
		1692, 5, 37, 0, 0, 1692, 1695, 3, 230, 115, 0, 1693, 1694, 5, 13, 0, 0,
		1694, 1696, 3, 230, 115, 0, 1695, 1693, 1, 0, 0, 0, 1695, 1696, 1, 0, 0,
		0, 1696, 1698, 1, 0, 0, 0, 1697, 1699, 5, 50, 0, 0, 1698, 1697, 1, 0, 0,
		0, 1698, 1699, 1, 0, 0, 0, 1699, 305, 1, 0, 0, 0, 1700, 1701, 5, 6, 0,
		0, 1701, 1702, 3, 250, 125, 0, 1702, 1703, 5, 27, 0, 0, 1703, 1708, 3,
		308, 154, 0, 1704, 1705, 5, 50, 0, 0, 1705, 1707, 3, 308, 154, 0, 1706,
		1704, 1, 0, 0, 0, 1707, 1710, 1, 0, 0, 0, 1708, 1706, 1, 0, 0, 0, 1708,
		1709, 1, 0, 0, 0, 1709, 1714, 1, 0, 0, 0, 1710, 1708, 1, 0, 0, 0, 1711,
		1712, 5, 50, 0, 0, 1712, 1713, 5, 13, 0, 0, 1713, 1715, 3, 300, 150, 0,
		1714, 1711, 1, 0, 0, 0, 1714, 1715, 1, 0, 0, 0, 1715, 1717, 1, 0, 0, 0,
		1716, 1718, 5, 50, 0, 0, 1717, 1716, 1, 0, 0, 0, 1717, 1718, 1, 0, 0, 0,
		1718, 1719, 1, 0, 0, 0, 1719, 1720, 5, 14, 0, 0, 1720, 307, 1, 0, 0, 0,
		1721, 1722, 3, 224, 112, 0, 1722, 1723, 5, 51, 0, 0, 1723, 1724, 3, 230,
		115, 0, 1724, 309, 1, 0, 0, 0, 1725, 1729, 3, 312, 156, 0, 1726, 1729,
		3, 314, 157, 0, 1727, 1729, 3, 316, 158, 0, 1728, 1725, 1, 0, 0, 0, 1728,
		1726, 1, 0, 0, 0, 1728, 1727, 1, 0, 0, 0, 1729, 311, 1, 0, 0, 0, 1730,
		1731, 5, 42, 0, 0, 1731, 1732, 3, 250, 125, 0, 1732, 1733, 5, 11, 0, 0,
		1733, 1734, 3, 230, 115, 0, 1734, 313, 1, 0, 0, 0, 1735, 1736, 5, 35, 0,
		0, 1736, 1737, 3, 300, 150, 0, 1737, 1738, 5, 40, 0, 0, 1738, 1739, 3,
		250, 125, 0, 1739, 315, 1, 0, 0, 0, 1740, 1742, 5, 16, 0, 0, 1741, 1743,
		5, 41, 0, 0, 1742, 1741, 1, 0, 0, 0, 1742, 1743, 1, 0, 0, 0, 1743, 1744,
		1, 0, 0, 0, 1744, 1745, 3, 14, 7, 0, 1745, 1746, 5, 48, 0, 0, 1746, 1747,
		3, 318, 159, 0, 1747, 1748, 5, 11, 0, 0, 1748, 1749, 3, 230, 115, 0, 1749,
		1761, 1, 0, 0, 0, 1750, 1752, 5, 16, 0, 0, 1751, 1753, 5, 41, 0, 0, 1752,
		1751, 1, 0, 0, 0, 1752, 1753, 1, 0, 0, 0, 1753, 1754, 1, 0, 0, 0, 1754,
		1755, 3, 14, 7, 0, 1755, 1756, 5, 21, 0, 0, 1756, 1757, 3, 250, 125, 0,
		1757, 1758, 5, 11, 0, 0, 1758, 1759, 3, 230, 115, 0, 1759, 1761, 1, 0,
		0, 0, 1760, 1740, 1, 0, 0, 0, 1760, 1750, 1, 0, 0, 0, 1761, 317, 1, 0,
		0, 0, 1762, 1763, 3, 320, 160, 0, 1763, 1764, 7, 13, 0, 0, 1764, 1765,
		3, 322, 161, 0, 1765, 319, 1, 0, 0, 0, 1766, 1767, 3, 250, 125, 0, 1767,
		321, 1, 0, 0, 0, 1768, 1769, 3, 250, 125, 0, 1769, 323, 1, 0, 0, 0, 1770,
		1771, 5, 43, 0, 0, 1771, 1772, 3, 334, 167, 0, 1772, 1773, 5, 11, 0, 0,
		1773, 1774, 3, 230, 115, 0, 1774, 1781, 1, 0, 0, 0, 1775, 1776, 5, 43,
		0, 0, 1776, 1777, 3, 250, 125, 0, 1777, 1778, 5, 11, 0, 0, 1778, 1779,
		3, 230, 115, 0, 1779, 1781, 1, 0, 0, 0, 1780, 1770, 1, 0, 0, 0, 1780, 1775,
		1, 0, 0, 0, 1781, 325, 1, 0, 0, 0, 1782, 1783, 5, 90, 0, 0, 1783, 1784,
		3, 300, 150, 0, 1784, 1785, 5, 92, 0, 0, 1785, 1786, 3, 300, 150, 0, 1786,
		1787, 5, 14, 0, 0, 1787, 1804, 1, 0, 0, 0, 1788, 1789, 5, 90, 0, 0, 1789,
		1790, 3, 300, 150, 0, 1790, 1794, 5, 92, 0, 0, 1791, 1792, 3, 328, 164,
		0, 1792, 1793, 5, 50, 0, 0, 1793, 1795, 1, 0, 0, 0, 1794, 1791, 1, 0, 0,
		0, 1795, 1796, 1, 0, 0, 0, 1796, 1794, 1, 0, 0, 0, 1796, 1797, 1, 0, 0,
		0, 1797, 1799, 1, 0, 0, 0, 1798, 1800, 3, 330, 165, 0, 1799, 1798, 1, 0,
		0, 0, 1799, 1800, 1, 0, 0, 0, 1800, 1801, 1, 0, 0, 0, 1801, 1802, 5, 14,
		0, 0, 1802, 1804, 1, 0, 0, 0, 1803, 1782, 1, 0, 0, 0, 1803, 1788, 1, 0,
		0, 0, 1804, 327, 1, 0, 0, 0, 1805, 1806, 5, 118, 0, 0, 1806, 1807, 3, 14,
		7, 0, 1807, 1808, 5, 51, 0, 0, 1808, 1809, 3, 136, 68, 0, 1809, 1810, 5,
		11, 0, 0, 1810, 1811, 3, 300, 150, 0, 1811, 329, 1, 0, 0, 0, 1812, 1813,
		5, 13, 0, 0, 1813, 1814, 3, 300, 150, 0, 1814, 331, 1, 0, 0, 0, 1815, 1816,
		5, 90, 0, 0, 1816, 1817, 3, 300, 150, 0, 1817, 1818, 5, 91, 0, 0, 1818,
		1819, 3, 300, 150, 0, 1819, 1820, 5, 14, 0, 0, 1820, 333, 1, 0, 0, 0, 1821,
		1826, 3, 244, 122, 0, 1822, 1823, 5, 49, 0, 0, 1823, 1825, 3, 244, 122,
		0, 1824, 1822, 1, 0, 0, 0, 1825, 1828, 1, 0, 0, 0, 1826, 1824, 1, 0, 0,
		0, 1826, 1827, 1, 0, 0, 0, 1827, 335, 1, 0, 0, 0, 1828, 1826, 1, 0, 0,
		0, 1829, 1830, 5, 60, 0, 0, 1830, 1831, 3, 338, 169, 0, 1831, 1832, 5,
		62, 0, 0, 1832, 337, 1, 0, 0, 0, 1833, 1838, 3, 340, 170, 0, 1834, 1835,
		5, 49, 0, 0, 1835, 1837, 3, 340, 170, 0, 1836, 1834, 1, 0, 0, 0, 1837,
		1840, 1, 0, 0, 0, 1838, 1836, 1, 0, 0, 0, 1838, 1839, 1, 0, 0, 0, 1839,
		339, 1, 0, 0, 0, 1840, 1838, 1, 0, 0, 0, 1841, 1846, 3, 14, 7, 0, 1842,
		1843, 5, 58, 0, 0, 1843, 1844, 3, 272, 136, 0, 1844, 1845, 5, 59, 0, 0,
		1845, 1847, 1, 0, 0, 0, 1846, 1842, 1, 0, 0, 0, 1846, 1847, 1, 0, 0, 0,
		1847, 341, 1, 0, 0, 0, 207, 344, 352, 356, 370, 373, 376, 384, 390, 405,
		410, 418, 420, 434, 436, 444, 446, 459, 472, 477, 494, 510, 514, 519, 527,
		538, 543, 551, 570, 574, 587, 593, 597, 604, 617, 620, 629, 633, 639, 647,
		653, 657, 661, 668, 671, 683, 686, 692, 701, 705, 709, 714, 720, 726, 730,
		743, 748, 757, 760, 768, 779, 784, 789, 794, 799, 802, 805, 808, 812, 817,
		819, 839, 854, 866, 872, 879, 889, 894, 900, 911, 917, 926, 934, 938, 943,
		949, 961, 971, 979, 986, 996, 1003, 1006, 1012, 1018, 1022, 1036, 1041,
		1046, 1051, 1054, 1061, 1065, 1075, 1083, 1099, 1108, 1114, 1125, 1130,
		1135, 1145, 1156, 1162, 1167, 1170, 1173, 1178, 1184, 1187, 1192, 1201,
		1207, 1212, 1224, 1230, 1245, 1262, 1268, 1272, 1277, 1282, 1287, 1292,
		1296, 1301, 1304, 1311, 1319, 1335, 1340, 1344, 1355, 1365, 1369, 1375,
		1379, 1385, 1393, 1404, 1414, 1416, 1418, 1432, 1439, 1450, 1455, 1461,
		1469, 1477, 1482, 1488, 1495, 1507, 1514, 1519, 1525, 1534, 1544, 1546,
		1548, 1552, 1559, 1564, 1567, 1574, 1581, 1592, 1599, 1603, 1608, 1613,
		1616, 1623, 1632, 1638, 1643, 1657, 1659, 1671, 1682, 1687, 1695, 1698,
		1708, 1714, 1717, 1728, 1742, 1752, 1760, 1780, 1796, 1799, 1803, 1826,
		1838, 1846,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// pascalParserInit initializes any static state used to implement pascalParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewpascalParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func PascalParserInit() {
	staticData := &PascalParserStaticData
	staticData.once.Do(pascalParserInit)
}

// NewpascalParser produces a new parser instance for the optional input antlr.TokenStream.
func NewpascalParser(input antlr.TokenStream) *pascalParser {
	PascalParserInit()
	this := new(pascalParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &PascalParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "pascal.g4"

	return this
}

// pascalParser tokens.
const (
	pascalParserEOF                       = antlr.TokenEOF
	pascalParserGUID_LITERAL              = 1
	pascalParserAND                       = 2
	pascalParserARRAY                     = 3
	pascalParserBEGIN                     = 4
	pascalParserBOOLEAN                   = 5
	pascalParserCASE                      = 6
	pascalParserCHAR                      = 7
	pascalParserCHR                       = 8
	pascalParserCONST                     = 9
	pascalParserDIV                       = 10
	pascalParserDO                        = 11
	pascalParserDOWNTO                    = 12
	pascalParserELSE                      = 13
	pascalParserEND                       = 14
	pascalParserFILE                      = 15
	pascalParserFOR                       = 16
	pascalParserFUNCTION                  = 17
	pascalParserGOTO                      = 18
	pascalParserHELPER                    = 19
	pascalParserIF                        = 20
	pascalParserIN                        = 21
	pascalParserINTEGER                   = 22
	pascalParserLABEL                     = 23
	pascalParserMOD                       = 24
	pascalParserNIL                       = 25
	pascalParserNOT                       = 26
	pascalParserOF                        = 27
	pascalParserOR                        = 28
	pascalParserPACKED                    = 29
	pascalParserPROCEDURE                 = 30
	pascalParserPROGRAM                   = 31
	pascalParserREAL                      = 32
	pascalParserRECORD                    = 33
	pascalParserREFERENCE                 = 34
	pascalParserREPEAT                    = 35
	pascalParserSET                       = 36
	pascalParserTHEN                      = 37
	pascalParserTO                        = 38
	pascalParserTYPE                      = 39
	pascalParserUNTIL                     = 40
	pascalParserVAR                       = 41
	pascalParserWHILE                     = 42
	pascalParserWITH                      = 43
	pascalParserPLUS                      = 44
	pascalParserMINUS                     = 45
	pascalParserSTAR                      = 46
	pascalParserSLASH                     = 47
	pascalParserASSIGN                    = 48
	pascalParserCOMMA                     = 49
	pascalParserSEMI                      = 50
	pascalParserCOLON                     = 51
	pascalParserEQUAL                     = 52
	pascalParserNOT_EQUAL                 = 53
	pascalParserLT                        = 54
	pascalParserLE                        = 55
	pascalParserGE                        = 56
	pascalParserGT                        = 57
	pascalParserLPAREN                    = 58
	pascalParserRPAREN                    = 59
	pascalParserLBRACK                    = 60
	pascalParserLBRACK2                   = 61
	pascalParserRBRACK                    = 62
	pascalParserRBRACK2                   = 63
	pascalParserDEREFERENCE               = 64
	pascalParserAT                        = 65
	pascalParserDOT                       = 66
	pascalParserDOTDOT                    = 67
	pascalParserLCURLY                    = 68
	pascalParserRCURLY                    = 69
	pascalParserUNIT                      = 70
	pascalParserINTERFACE                 = 71
	pascalParserUSES                      = 72
	pascalParserSTRING                    = 73
	pascalParserIMPLEMENTATION            = 74
	pascalParserTRUE                      = 75
	pascalParserFALSE                     = 76
	pascalParserCLASS                     = 77
	pascalParserPRIVATE                   = 78
	pascalParserPROTECTED                 = 79
	pascalParserPUBLIC                    = 80
	pascalParserPUBLISHED                 = 81
	pascalParserSTRICT                    = 82
	pascalParserOUT                       = 83
	pascalParserPROPERTY                  = 84
	pascalParserREAD                      = 85
	pascalParserWRITE                     = 86
	pascalParserDEFAULT                   = 87
	pascalParserINDEX                     = 88
	pascalParserAS                        = 89
	pascalParserTRY                       = 90
	pascalParserFINALLY                   = 91
	pascalParserEXCEPT                    = 92
	pascalParserINITIALIZATION            = 93
	pascalParserFINALIZATION              = 94
	pascalParserOBJECT                    = 95
	pascalParserINHERITED                 = 96
	pascalParserABSTRACT                  = 97
	pascalParserREINTRODUCE               = 98
	pascalParserVIRTUAL                   = 99
	pascalParserOVERRIDE                  = 100
	pascalParserOVERLOAD                  = 101
	pascalParserINLINE                    = 102
	pascalParserCDECL                     = 103
	pascalParserSTDCALL                   = 104
	pascalParserSTATIC                    = 105
	pascalParserCONSTRUCTOR               = 106
	pascalParserDESTRUCTOR                = 107
	pascalParserRESOURCESTRING            = 108
	pascalParserFORWARD                   = 109
	pascalParserRAISE                     = 110
	pascalParserSHR                       = 111
	pascalParserSHL                       = 112
	pascalParserXOR                       = 113
	pascalParserCARDINAL                  = 114
	pascalParserLONGBOOL                  = 115
	pascalParserLONGINT                   = 116
	pascalParserOPERATOR                  = 117
	pascalParserON                        = 118
	pascalParserWS                        = 119
	pascalParserCOMMENT_1                 = 120
	pascalParserCOMMENT_2                 = 121
	pascalParserCOMMENT_3                 = 122
	pascalParserIDENT                     = 123
	pascalParserHEX_LITERAL               = 124
	pascalParserSTRING_LITERAL            = 125
	pascalParserSTRING_CROSSHATCH_LITERAL = 126
	pascalParserNUM_INT                   = 127
	pascalParserNUM_REAL                  = 128
	pascalParserUTF8BOM                   = 129
)

// pascalParser rules.
const (
	pascalParserRULE_source                             = 0
	pascalParserRULE_program                            = 1
	pascalParserRULE_unit                               = 2
	pascalParserRULE_interfaceSection                   = 3
	pascalParserRULE_implementationSection              = 4
	pascalParserRULE_initializationSection              = 5
	pascalParserRULE_finalizationSection                = 6
	pascalParserRULE_identifier                         = 7
	pascalParserRULE_identifierPart                     = 8
	pascalParserRULE_interfaceBlock                     = 9
	pascalParserRULE_implementationBlock                = 10
	pascalParserRULE_block                              = 11
	pascalParserRULE_usesUnits                          = 12
	pascalParserRULE_labelDeclarationPart               = 13
	pascalParserRULE_label                              = 14
	pascalParserRULE_constantDefinitionPart             = 15
	pascalParserRULE_constantDefinition                 = 16
	pascalParserRULE_constantChr                        = 17
	pascalParserRULE_hexConstant                        = 18
	pascalParserRULE_constant                           = 19
	pascalParserRULE_arrayConstant                      = 20
	pascalParserRULE_recordConstant                     = 21
	pascalParserRULE_recordField                        = 22
	pascalParserRULE_unsignedNumber                     = 23
	pascalParserRULE_unsignedInteger                    = 24
	pascalParserRULE_unsignedReal                       = 25
	pascalParserRULE_sign                               = 26
	pascalParserRULE_bool_                              = 27
	pascalParserRULE_string                             = 28
	pascalParserRULE_stringExpression                   = 29
	pascalParserRULE_resourceDefinitionPart             = 30
	pascalParserRULE_resourceDefinition                 = 31
	pascalParserRULE_typeDefinitionPart                 = 32
	pascalParserRULE_typeDefinition                     = 33
	pascalParserRULE_functionType                       = 34
	pascalParserRULE_procedureType                      = 35
	pascalParserRULE_forwardClassType                   = 36
	pascalParserRULE_forwardInterfaceType               = 37
	pascalParserRULE_classType                          = 38
	pascalParserRULE_classImplementsInterfaces          = 39
	pascalParserRULE_accessSpecifier                    = 40
	pascalParserRULE_classDeclaration                   = 41
	pascalParserRULE_classImplicitPublishedDeclaration  = 42
	pascalParserRULE_classDeclarationPart               = 43
	pascalParserRULE_interfaceGuidConst                 = 44
	pascalParserRULE_interfaceType                      = 45
	pascalParserRULE_interfaceDeclaration               = 46
	pascalParserRULE_interfaceDeclarationPart           = 47
	pascalParserRULE_errorInterfaceDeclarationPart      = 48
	pascalParserRULE_errorClassDeclarationPart          = 49
	pascalParserRULE_propertyDeclaration                = 50
	pascalParserRULE_propertyReadDeclaration            = 51
	pascalParserRULE_propertyWriteDeclaration           = 52
	pascalParserRULE_propertyDefaultValueDeclaration    = 53
	pascalParserRULE_propertyIndexDeclaration           = 54
	pascalParserRULE_propertyIndexParameters            = 55
	pascalParserRULE_propertyIndexParametersList        = 56
	pascalParserRULE_genericTemplate                    = 57
	pascalParserRULE_genericTemplateList                = 58
	pascalParserRULE_genericTypeParameter               = 59
	pascalParserRULE_genericConstraints                 = 60
	pascalParserRULE_genericConstraint                  = 61
	pascalParserRULE_type_                              = 62
	pascalParserRULE_simpleType                         = 63
	pascalParserRULE_scalarType                         = 64
	pascalParserRULE_scalerList                         = 65
	pascalParserRULE_scalerMember                       = 66
	pascalParserRULE_subrangeType                       = 67
	pascalParserRULE_typeIdentifier                     = 68
	pascalParserRULE_structuredType                     = 69
	pascalParserRULE_unpackedStructuredType             = 70
	pascalParserRULE_stringtype                         = 71
	pascalParserRULE_arrayType                          = 72
	pascalParserRULE_typeList                           = 73
	pascalParserRULE_indexType                          = 74
	pascalParserRULE_recordType                         = 75
	pascalParserRULE_recordDeclaration                  = 76
	pascalParserRULE_recordImplicitPublishedDeclaration = 77
	pascalParserRULE_recordDeclarationPart              = 78
	pascalParserRULE_errorRecordDeclarationPart         = 79
	pascalParserRULE_recordParts                        = 80
	pascalParserRULE_recordFixedPart                    = 81
	pascalParserRULE_recordVariantPart                  = 82
	pascalParserRULE_tag                                = 83
	pascalParserRULE_recordVariant                      = 84
	pascalParserRULE_helperType                         = 85
	pascalParserRULE_helperDeclaration                  = 86
	pascalParserRULE_helperImplicitPublishedDeclaration = 87
	pascalParserRULE_helperDeclarationPart              = 88
	pascalParserRULE_errorHelperDeclarationPart         = 89
	pascalParserRULE_setType                            = 90
	pascalParserRULE_fileType                           = 91
	pascalParserRULE_pointerType                        = 92
	pascalParserRULE_variableDeclarationPart            = 93
	pascalParserRULE_variableDeclaration                = 94
	pascalParserRULE_procedureHeader                    = 95
	pascalParserRULE_functionHeader                     = 96
	pascalParserRULE_procedureOrFunctionHeader          = 97
	pascalParserRULE_procedureOrFunctionHeaderModifiers = 98
	pascalParserRULE_procedureOrFunctionDeclaration     = 99
	pascalParserRULE_procedureDeclaration               = 100
	pascalParserRULE_functionDeclaration                = 101
	pascalParserRULE_procedureLambdaDeclaration         = 102
	pascalParserRULE_functionLambdaDeclaration          = 103
	pascalParserRULE_resultType                         = 104
	pascalParserRULE_procedureOrFunctionBody            = 105
	pascalParserRULE_classOperatorHeader                = 106
	pascalParserRULE_classOperatorDeclaration           = 107
	pascalParserRULE_formalParameterList                = 108
	pascalParserRULE_formalParameterSection             = 109
	pascalParserRULE_parameterGroup                     = 110
	pascalParserRULE_identifierList                     = 111
	pascalParserRULE_constList                          = 112
	pascalParserRULE_defaultValue                       = 113
	pascalParserRULE_typedIdentifierList                = 114
	pascalParserRULE_statement                          = 115
	pascalParserRULE_errorStatement                     = 116
	pascalParserRULE_unlabelledStatement                = 117
	pascalParserRULE_simpleStatement                    = 118
	pascalParserRULE_assignmentStatement                = 119
	pascalParserRULE_raiseExceptionStatement            = 120
	pascalParserRULE_variableDeclarationStatement       = 121
	pascalParserRULE_variableDesignator                 = 122
	pascalParserRULE_typeCast                           = 123
	pascalParserRULE_propertyDesignator                 = 124
	pascalParserRULE_expression                         = 125
	pascalParserRULE_relationaloperator                 = 126
	pascalParserRULE_simpleExpression                   = 127
	pascalParserRULE_additiveoperator                   = 128
	pascalParserRULE_term                               = 129
	pascalParserRULE_multiplicativeoperator             = 130
	pascalParserRULE_signedFactor                       = 131
	pascalParserRULE_factor                             = 132
	pascalParserRULE_unsignedConstant                   = 133
	pascalParserRULE_functionDesignator                 = 134
	pascalParserRULE_defaultDesignator                  = 135
	pascalParserRULE_parameterList                      = 136
	pascalParserRULE_set_                               = 137
	pascalParserRULE_elementList                        = 138
	pascalParserRULE_element                            = 139
	pascalParserRULE_procedureStatement                 = 140
	pascalParserRULE_methodCallStatement                = 141
	pascalParserRULE_actualParameter                    = 142
	pascalParserRULE_parameterwidth                     = 143
	pascalParserRULE_gotoStatement                      = 144
	pascalParserRULE_inheritedStatement                 = 145
	pascalParserRULE_emptyStatement_                    = 146
	pascalParserRULE_empty_                             = 147
	pascalParserRULE_structuredStatement                = 148
	pascalParserRULE_compoundStatement                  = 149
	pascalParserRULE_statements                         = 150
	pascalParserRULE_conditionalStatement               = 151
	pascalParserRULE_ifStatement                        = 152
	pascalParserRULE_caseStatement                      = 153
	pascalParserRULE_caseListElement                    = 154
	pascalParserRULE_repetetiveStatement                = 155
	pascalParserRULE_whileStatement                     = 156
	pascalParserRULE_repeatStatement                    = 157
	pascalParserRULE_forStatement                       = 158
	pascalParserRULE_forList                            = 159
	pascalParserRULE_initialValue                       = 160
	pascalParserRULE_finalValue                         = 161
	pascalParserRULE_withStatement                      = 162
	pascalParserRULE_tryExceptStatement                 = 163
	pascalParserRULE_exceptionCase                      = 164
	pascalParserRULE_exceptionElse                      = 165
	pascalParserRULE_tryFinallyStatement                = 166
	pascalParserRULE_withStatementVariableList          = 167
	pascalParserRULE_attributeSection                   = 168
	pascalParserRULE_attributeList                      = 169
	pascalParserRULE_attributeItem                      = 170
)

// ISourceContext is an interface to support dynamic dispatch.
type ISourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Program() IProgramContext
	Unit() IUnitContext

	// IsSourceContext differentiates from other interfaces.
	IsSourceContext()
}

type SourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceContext() *SourceContext {
	var p = new(SourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_source
	return p
}

func InitEmptySourceContext(p *SourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_source
}

func (*SourceContext) IsSourceContext() {}

func NewSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceContext {
	var p = new(SourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_source

	return p
}

func (s *SourceContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceContext) Program() IProgramContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProgramContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProgramContext)
}

func (s *SourceContext) Unit() IUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitContext)
}

func (s *SourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSource(s)
	}
}

func (s *SourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSource(s)
	}
}

func (s *SourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSource(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Source() (localctx ISourceContext) {
	localctx = NewSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, pascalParserRULE_source)
	p.SetState(344)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserPROGRAM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(342)
			p.Program()
		}

	case pascalParserUNIT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(343)
			p.Unit()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROGRAM() antlr.TerminalNode
	Identifier() IIdentifierContext
	SEMI() antlr.TerminalNode
	ImplementationBlock() IImplementationBlockContext
	BEGIN() antlr.TerminalNode
	Statements() IStatementsContext
	END() antlr.TerminalNode
	DOT() antlr.TerminalNode
	EOF() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	RPAREN() antlr.TerminalNode
	UsesUnits() IUsesUnitsContext

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) PROGRAM() antlr.TerminalNode {
	return s.GetToken(pascalParserPROGRAM, 0)
}

func (s *ProgramContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ProgramContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ProgramContext) ImplementationBlock() IImplementationBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplementationBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplementationBlockContext)
}

func (s *ProgramContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(pascalParserBEGIN, 0)
}

func (s *ProgramContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *ProgramContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *ProgramContext) DOT() antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, 0)
}

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(pascalParserEOF, 0)
}

func (s *ProgramContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ProgramContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ProgramContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ProgramContext) UsesUnits() IUsesUnitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsesUnitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsesUnitsContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProgram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, pascalParserRULE_program)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(346)
		p.Match(pascalParserPROGRAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(347)
		p.Identifier()
	}
	p.SetState(352)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(348)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(349)
			p.IdentifierList()
		}
		{
			p.SetState(350)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(354)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(356)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserUSES {
		{
			p.SetState(355)
			p.UsesUnits()
		}

	}
	{
		p.SetState(358)
		p.ImplementationBlock()
	}
	{
		p.SetState(359)
		p.Match(pascalParserBEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(360)
		p.Statements()
	}
	{
		p.SetState(361)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(362)
		p.Match(pascalParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(363)
		p.Match(pascalParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitContext is an interface to support dynamic dispatch.
type IUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNIT() antlr.TerminalNode
	Identifier() IIdentifierContext
	SEMI() antlr.TerminalNode
	InterfaceSection() IInterfaceSectionContext
	END() antlr.TerminalNode
	DOT() antlr.TerminalNode
	EOF() antlr.TerminalNode
	ImplementationSection() IImplementationSectionContext
	InitializationSection() IInitializationSectionContext
	FinalizationSection() IFinalizationSectionContext

	// IsUnitContext differentiates from other interfaces.
	IsUnitContext()
}

type UnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitContext() *UnitContext {
	var p = new(UnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unit
	return p
}

func InitEmptyUnitContext(p *UnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unit
}

func (*UnitContext) IsUnitContext() {}

func NewUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitContext {
	var p = new(UnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unit

	return p
}

func (s *UnitContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitContext) UNIT() antlr.TerminalNode {
	return s.GetToken(pascalParserUNIT, 0)
}

func (s *UnitContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnitContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *UnitContext) InterfaceSection() IInterfaceSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceSectionContext)
}

func (s *UnitContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *UnitContext) DOT() antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, 0)
}

func (s *UnitContext) EOF() antlr.TerminalNode {
	return s.GetToken(pascalParserEOF, 0)
}

func (s *UnitContext) ImplementationSection() IImplementationSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplementationSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplementationSectionContext)
}

func (s *UnitContext) InitializationSection() IInitializationSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializationSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializationSectionContext)
}

func (s *UnitContext) FinalizationSection() IFinalizationSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinalizationSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinalizationSectionContext)
}

func (s *UnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnit(s)
	}
}

func (s *UnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnit(s)
	}
}

func (s *UnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Unit() (localctx IUnitContext) {
	localctx = NewUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, pascalParserRULE_unit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(365)
		p.Match(pascalParserUNIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(366)
		p.Identifier()
	}
	{
		p.SetState(367)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(368)
		p.InterfaceSection()
	}
	p.SetState(370)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserIMPLEMENTATION {
		{
			p.SetState(369)
			p.ImplementationSection()
		}

	}
	p.SetState(373)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserINITIALIZATION {
		{
			p.SetState(372)
			p.InitializationSection()
		}

	}
	p.SetState(376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserFINALIZATION {
		{
			p.SetState(375)
			p.FinalizationSection()
		}

	}
	{
		p.SetState(378)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(379)
		p.Match(pascalParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(380)
		p.Match(pascalParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceSectionContext is an interface to support dynamic dispatch.
type IInterfaceSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	InterfaceBlock() IInterfaceBlockContext
	UsesUnits() IUsesUnitsContext

	// IsInterfaceSectionContext differentiates from other interfaces.
	IsInterfaceSectionContext()
}

type InterfaceSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceSectionContext() *InterfaceSectionContext {
	var p = new(InterfaceSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceSection
	return p
}

func InitEmptyInterfaceSectionContext(p *InterfaceSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceSection
}

func (*InterfaceSectionContext) IsInterfaceSectionContext() {}

func NewInterfaceSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceSectionContext {
	var p = new(InterfaceSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceSection

	return p
}

func (s *InterfaceSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceSectionContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(pascalParserINTERFACE, 0)
}

func (s *InterfaceSectionContext) InterfaceBlock() IInterfaceBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceBlockContext)
}

func (s *InterfaceSectionContext) UsesUnits() IUsesUnitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsesUnitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsesUnitsContext)
}

func (s *InterfaceSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceSection(s)
	}
}

func (s *InterfaceSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceSection(s)
	}
}

func (s *InterfaceSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceSection() (localctx IInterfaceSectionContext) {
	localctx = NewInterfaceSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, pascalParserRULE_interfaceSection)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(382)
		p.Match(pascalParserINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(384)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserUSES {
		{
			p.SetState(383)
			p.UsesUnits()
		}

	}
	{
		p.SetState(386)
		p.InterfaceBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImplementationSectionContext is an interface to support dynamic dispatch.
type IImplementationSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPLEMENTATION() antlr.TerminalNode
	ImplementationBlock() IImplementationBlockContext
	UsesUnits() IUsesUnitsContext

	// IsImplementationSectionContext differentiates from other interfaces.
	IsImplementationSectionContext()
}

type ImplementationSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplementationSectionContext() *ImplementationSectionContext {
	var p = new(ImplementationSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_implementationSection
	return p
}

func InitEmptyImplementationSectionContext(p *ImplementationSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_implementationSection
}

func (*ImplementationSectionContext) IsImplementationSectionContext() {}

func NewImplementationSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplementationSectionContext {
	var p = new(ImplementationSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_implementationSection

	return p
}

func (s *ImplementationSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplementationSectionContext) IMPLEMENTATION() antlr.TerminalNode {
	return s.GetToken(pascalParserIMPLEMENTATION, 0)
}

func (s *ImplementationSectionContext) ImplementationBlock() IImplementationBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplementationBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplementationBlockContext)
}

func (s *ImplementationSectionContext) UsesUnits() IUsesUnitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsesUnitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsesUnitsContext)
}

func (s *ImplementationSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplementationSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplementationSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterImplementationSection(s)
	}
}

func (s *ImplementationSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitImplementationSection(s)
	}
}

func (s *ImplementationSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitImplementationSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ImplementationSection() (localctx IImplementationSectionContext) {
	localctx = NewImplementationSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, pascalParserRULE_implementationSection)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(388)
		p.Match(pascalParserIMPLEMENTATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(390)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserUSES {
		{
			p.SetState(389)
			p.UsesUnits()
		}

	}
	{
		p.SetState(392)
		p.ImplementationBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitializationSectionContext is an interface to support dynamic dispatch.
type IInitializationSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INITIALIZATION() antlr.TerminalNode
	Statements() IStatementsContext

	// IsInitializationSectionContext differentiates from other interfaces.
	IsInitializationSectionContext()
}

type InitializationSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializationSectionContext() *InitializationSectionContext {
	var p = new(InitializationSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_initializationSection
	return p
}

func InitEmptyInitializationSectionContext(p *InitializationSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_initializationSection
}

func (*InitializationSectionContext) IsInitializationSectionContext() {}

func NewInitializationSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializationSectionContext {
	var p = new(InitializationSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_initializationSection

	return p
}

func (s *InitializationSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializationSectionContext) INITIALIZATION() antlr.TerminalNode {
	return s.GetToken(pascalParserINITIALIZATION, 0)
}

func (s *InitializationSectionContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *InitializationSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializationSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializationSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInitializationSection(s)
	}
}

func (s *InitializationSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInitializationSection(s)
	}
}

func (s *InitializationSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInitializationSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InitializationSection() (localctx IInitializationSectionContext) {
	localctx = NewInitializationSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, pascalParserRULE_initializationSection)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(394)
		p.Match(pascalParserINITIALIZATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(395)
		p.Statements()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFinalizationSectionContext is an interface to support dynamic dispatch.
type IFinalizationSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FINALIZATION() antlr.TerminalNode
	Statements() IStatementsContext

	// IsFinalizationSectionContext differentiates from other interfaces.
	IsFinalizationSectionContext()
}

type FinalizationSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinalizationSectionContext() *FinalizationSectionContext {
	var p = new(FinalizationSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_finalizationSection
	return p
}

func InitEmptyFinalizationSectionContext(p *FinalizationSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_finalizationSection
}

func (*FinalizationSectionContext) IsFinalizationSectionContext() {}

func NewFinalizationSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinalizationSectionContext {
	var p = new(FinalizationSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_finalizationSection

	return p
}

func (s *FinalizationSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *FinalizationSectionContext) FINALIZATION() antlr.TerminalNode {
	return s.GetToken(pascalParserFINALIZATION, 0)
}

func (s *FinalizationSectionContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *FinalizationSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinalizationSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinalizationSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFinalizationSection(s)
	}
}

func (s *FinalizationSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFinalizationSection(s)
	}
}

func (s *FinalizationSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFinalizationSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FinalizationSection() (localctx IFinalizationSectionContext) {
	localctx = NewFinalizationSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, pascalParserRULE_finalizationSection)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(397)
		p.Match(pascalParserFINALIZATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(398)
		p.Statements()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierPart() []IIdentifierPartContext
	IdentifierPart(i int) IIdentifierPartContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) AllIdentifierPart() []IIdentifierPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierPartContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierPartContext); ok {
			tst[i] = t.(IIdentifierPartContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierContext) IdentifierPart(i int) IIdentifierPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierPartContext)
}

func (s *IdentifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDOT)
}

func (s *IdentifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, i)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, pascalParserRULE_identifier)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(400)
		p.IdentifierPart()
	}
	p.SetState(405)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(401)
				p.Match(pascalParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(402)
				p.IdentifierPart()
			}

		}
		p.SetState(407)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierPartContext is an interface to support dynamic dispatch.
type IIdentifierPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENT() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	READ() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	GenericTemplate() IGenericTemplateContext

	// IsIdentifierPartContext differentiates from other interfaces.
	IsIdentifierPartContext()
}

type IdentifierPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierPartContext() *IdentifierPartContext {
	var p = new(IdentifierPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifierPart
	return p
}

func InitEmptyIdentifierPartContext(p *IdentifierPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifierPart
}

func (*IdentifierPartContext) IsIdentifierPartContext() {}

func NewIdentifierPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierPartContext {
	var p = new(IdentifierPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_identifierPart

	return p
}

func (s *IdentifierPartContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierPartContext) IDENT() antlr.TerminalNode {
	return s.GetToken(pascalParserIDENT, 0)
}

func (s *IdentifierPartContext) INDEX() antlr.TerminalNode {
	return s.GetToken(pascalParserINDEX, 0)
}

func (s *IdentifierPartContext) READ() antlr.TerminalNode {
	return s.GetToken(pascalParserREAD, 0)
}

func (s *IdentifierPartContext) WRITE() antlr.TerminalNode {
	return s.GetToken(pascalParserWRITE, 0)
}

func (s *IdentifierPartContext) GenericTemplate() IGenericTemplateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericTemplateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericTemplateContext)
}

func (s *IdentifierPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterIdentifierPart(s)
	}
}

func (s *IdentifierPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitIdentifierPart(s)
	}
}

func (s *IdentifierPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitIdentifierPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) IdentifierPart() (localctx IIdentifierPartContext) {
	localctx = NewIdentifierPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, pascalParserRULE_identifierPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(408)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-85)) & ^0x3f) == 0 && ((int64(1)<<(_la-85))&274877906955) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(410)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(409)
			p.GenericTemplate()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceBlockContext is an interface to support dynamic dispatch.
type IInterfaceBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLabelDeclarationPart() []ILabelDeclarationPartContext
	LabelDeclarationPart(i int) ILabelDeclarationPartContext
	AllConstantDefinitionPart() []IConstantDefinitionPartContext
	ConstantDefinitionPart(i int) IConstantDefinitionPartContext
	AllResourceDefinitionPart() []IResourceDefinitionPartContext
	ResourceDefinitionPart(i int) IResourceDefinitionPartContext
	AllTypeDefinitionPart() []ITypeDefinitionPartContext
	TypeDefinitionPart(i int) ITypeDefinitionPartContext
	AllVariableDeclarationPart() []IVariableDeclarationPartContext
	VariableDeclarationPart(i int) IVariableDeclarationPartContext
	AllProcedureOrFunctionHeader() []IProcedureOrFunctionHeaderContext
	ProcedureOrFunctionHeader(i int) IProcedureOrFunctionHeaderContext

	// IsInterfaceBlockContext differentiates from other interfaces.
	IsInterfaceBlockContext()
}

type InterfaceBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceBlockContext() *InterfaceBlockContext {
	var p = new(InterfaceBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceBlock
	return p
}

func InitEmptyInterfaceBlockContext(p *InterfaceBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceBlock
}

func (*InterfaceBlockContext) IsInterfaceBlockContext() {}

func NewInterfaceBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceBlockContext {
	var p = new(InterfaceBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceBlock

	return p
}

func (s *InterfaceBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceBlockContext) AllLabelDeclarationPart() []ILabelDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]ILabelDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelDeclarationPartContext); ok {
			tst[i] = t.(ILabelDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) LabelDeclarationPart(i int) ILabelDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelDeclarationPartContext)
}

func (s *InterfaceBlockContext) AllConstantDefinitionPart() []IConstantDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IConstantDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantDefinitionPartContext); ok {
			tst[i] = t.(IConstantDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) ConstantDefinitionPart(i int) IConstantDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *InterfaceBlockContext) AllResourceDefinitionPart() []IResourceDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResourceDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IResourceDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResourceDefinitionPartContext); ok {
			tst[i] = t.(IResourceDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) ResourceDefinitionPart(i int) IResourceDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceDefinitionPartContext)
}

func (s *InterfaceBlockContext) AllTypeDefinitionPart() []ITypeDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]ITypeDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeDefinitionPartContext); ok {
			tst[i] = t.(ITypeDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) TypeDefinitionPart(i int) ITypeDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionPartContext)
}

func (s *InterfaceBlockContext) AllVariableDeclarationPart() []IVariableDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationPartContext); ok {
			tst[i] = t.(IVariableDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) VariableDeclarationPart(i int) IVariableDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationPartContext)
}

func (s *InterfaceBlockContext) AllProcedureOrFunctionHeader() []IProcedureOrFunctionHeaderContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			len++
		}
	}

	tst := make([]IProcedureOrFunctionHeaderContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			tst[i] = t.(IProcedureOrFunctionHeaderContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceBlockContext) ProcedureOrFunctionHeader(i int) IProcedureOrFunctionHeaderContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderContext)
}

func (s *InterfaceBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceBlock(s)
	}
}

func (s *InterfaceBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceBlock(s)
	}
}

func (s *InterfaceBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceBlock() (localctx IInterfaceBlockContext) {
	localctx = NewInterfaceBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, pascalParserRULE_interfaceBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(420)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1152924254468178432) != 0) || ((int64((_la-77)) & ^0x3f) == 0 && ((int64(1)<<(_la-77))&3758096385) != 0) {
		p.SetState(418)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case pascalParserLABEL:
			{
				p.SetState(412)
				p.LabelDeclarationPart()
			}

		case pascalParserCONST:
			{
				p.SetState(413)
				p.ConstantDefinitionPart()
			}

		case pascalParserRESOURCESTRING:
			{
				p.SetState(414)
				p.ResourceDefinitionPart()
			}

		case pascalParserTYPE:
			{
				p.SetState(415)
				p.TypeDefinitionPart()
			}

		case pascalParserVAR:
			{
				p.SetState(416)
				p.VariableDeclarationPart()
			}

		case pascalParserFUNCTION, pascalParserPROCEDURE, pascalParserLBRACK, pascalParserCLASS, pascalParserCONSTRUCTOR, pascalParserDESTRUCTOR:
			{
				p.SetState(417)
				p.ProcedureOrFunctionHeader()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(422)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImplementationBlockContext is an interface to support dynamic dispatch.
type IImplementationBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLabelDeclarationPart() []ILabelDeclarationPartContext
	LabelDeclarationPart(i int) ILabelDeclarationPartContext
	AllConstantDefinitionPart() []IConstantDefinitionPartContext
	ConstantDefinitionPart(i int) IConstantDefinitionPartContext
	AllResourceDefinitionPart() []IResourceDefinitionPartContext
	ResourceDefinitionPart(i int) IResourceDefinitionPartContext
	AllTypeDefinitionPart() []ITypeDefinitionPartContext
	TypeDefinitionPart(i int) ITypeDefinitionPartContext
	AllVariableDeclarationPart() []IVariableDeclarationPartContext
	VariableDeclarationPart(i int) IVariableDeclarationPartContext
	AllProcedureOrFunctionDeclaration() []IProcedureOrFunctionDeclarationContext
	ProcedureOrFunctionDeclaration(i int) IProcedureOrFunctionDeclarationContext
	AllProcedureOrFunctionHeader() []IProcedureOrFunctionHeaderContext
	ProcedureOrFunctionHeader(i int) IProcedureOrFunctionHeaderContext
	AllFORWARD() []antlr.TerminalNode
	FORWARD(i int) antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AllClassOperatorDeclaration() []IClassOperatorDeclarationContext
	ClassOperatorDeclaration(i int) IClassOperatorDeclarationContext

	// IsImplementationBlockContext differentiates from other interfaces.
	IsImplementationBlockContext()
}

type ImplementationBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplementationBlockContext() *ImplementationBlockContext {
	var p = new(ImplementationBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_implementationBlock
	return p
}

func InitEmptyImplementationBlockContext(p *ImplementationBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_implementationBlock
}

func (*ImplementationBlockContext) IsImplementationBlockContext() {}

func NewImplementationBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplementationBlockContext {
	var p = new(ImplementationBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_implementationBlock

	return p
}

func (s *ImplementationBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplementationBlockContext) AllLabelDeclarationPart() []ILabelDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]ILabelDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelDeclarationPartContext); ok {
			tst[i] = t.(ILabelDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) LabelDeclarationPart(i int) ILabelDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelDeclarationPartContext)
}

func (s *ImplementationBlockContext) AllConstantDefinitionPart() []IConstantDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IConstantDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantDefinitionPartContext); ok {
			tst[i] = t.(IConstantDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) ConstantDefinitionPart(i int) IConstantDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *ImplementationBlockContext) AllResourceDefinitionPart() []IResourceDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResourceDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IResourceDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResourceDefinitionPartContext); ok {
			tst[i] = t.(IResourceDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) ResourceDefinitionPart(i int) IResourceDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceDefinitionPartContext)
}

func (s *ImplementationBlockContext) AllTypeDefinitionPart() []ITypeDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]ITypeDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeDefinitionPartContext); ok {
			tst[i] = t.(ITypeDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) TypeDefinitionPart(i int) ITypeDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionPartContext)
}

func (s *ImplementationBlockContext) AllVariableDeclarationPart() []IVariableDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationPartContext); ok {
			tst[i] = t.(IVariableDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) VariableDeclarationPart(i int) IVariableDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationPartContext)
}

func (s *ImplementationBlockContext) AllProcedureOrFunctionDeclaration() []IProcedureOrFunctionDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IProcedureOrFunctionDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			tst[i] = t.(IProcedureOrFunctionDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) ProcedureOrFunctionDeclaration(i int) IProcedureOrFunctionDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionDeclarationContext)
}

func (s *ImplementationBlockContext) AllProcedureOrFunctionHeader() []IProcedureOrFunctionHeaderContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			len++
		}
	}

	tst := make([]IProcedureOrFunctionHeaderContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			tst[i] = t.(IProcedureOrFunctionHeaderContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) ProcedureOrFunctionHeader(i int) IProcedureOrFunctionHeaderContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderContext)
}

func (s *ImplementationBlockContext) AllFORWARD() []antlr.TerminalNode {
	return s.GetTokens(pascalParserFORWARD)
}

func (s *ImplementationBlockContext) FORWARD(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserFORWARD, i)
}

func (s *ImplementationBlockContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ImplementationBlockContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ImplementationBlockContext) AllClassOperatorDeclaration() []IClassOperatorDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassOperatorDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassOperatorDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassOperatorDeclarationContext); ok {
			tst[i] = t.(IClassOperatorDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ImplementationBlockContext) ClassOperatorDeclaration(i int) IClassOperatorDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOperatorDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOperatorDeclarationContext)
}

func (s *ImplementationBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplementationBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplementationBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterImplementationBlock(s)
	}
}

func (s *ImplementationBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitImplementationBlock(s)
	}
}

func (s *ImplementationBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitImplementationBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ImplementationBlock() (localctx IImplementationBlockContext) {
	localctx = NewImplementationBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, pascalParserRULE_implementationBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(436)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1152924254468178432) != 0) || ((int64((_la-77)) & ^0x3f) == 0 && ((int64(1)<<(_la-77))&3758096385) != 0) {
		p.SetState(434)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(423)
				p.LabelDeclarationPart()
			}

		case 2:
			{
				p.SetState(424)
				p.ConstantDefinitionPart()
			}

		case 3:
			{
				p.SetState(425)
				p.ResourceDefinitionPart()
			}

		case 4:
			{
				p.SetState(426)
				p.TypeDefinitionPart()
			}

		case 5:
			{
				p.SetState(427)
				p.VariableDeclarationPart()
			}

		case 6:
			{
				p.SetState(428)
				p.ProcedureOrFunctionDeclaration()
			}

		case 7:
			{
				p.SetState(429)
				p.ProcedureOrFunctionHeader()
			}
			{
				p.SetState(430)
				p.Match(pascalParserFORWARD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(431)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 8:
			{
				p.SetState(433)
				p.ClassOperatorDeclaration()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(438)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLabelDeclarationPart() []ILabelDeclarationPartContext
	LabelDeclarationPart(i int) ILabelDeclarationPartContext
	AllConstantDefinitionPart() []IConstantDefinitionPartContext
	ConstantDefinitionPart(i int) IConstantDefinitionPartContext
	AllVariableDeclarationPart() []IVariableDeclarationPartContext
	VariableDeclarationPart(i int) IVariableDeclarationPartContext
	AllProcedureOrFunctionDeclaration() []IProcedureOrFunctionDeclarationContext
	ProcedureOrFunctionDeclaration(i int) IProcedureOrFunctionDeclarationContext
	AllClassOperatorDeclaration() []IClassOperatorDeclarationContext
	ClassOperatorDeclaration(i int) IClassOperatorDeclarationContext

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) AllLabelDeclarationPart() []ILabelDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]ILabelDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelDeclarationPartContext); ok {
			tst[i] = t.(ILabelDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) LabelDeclarationPart(i int) ILabelDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelDeclarationPartContext)
}

func (s *BlockContext) AllConstantDefinitionPart() []IConstantDefinitionPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			len++
		}
	}

	tst := make([]IConstantDefinitionPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantDefinitionPartContext); ok {
			tst[i] = t.(IConstantDefinitionPartContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) ConstantDefinitionPart(i int) IConstantDefinitionPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *BlockContext) AllVariableDeclarationPart() []IVariableDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationPartContext); ok {
			tst[i] = t.(IVariableDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) VariableDeclarationPart(i int) IVariableDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationPartContext)
}

func (s *BlockContext) AllProcedureOrFunctionDeclaration() []IProcedureOrFunctionDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IProcedureOrFunctionDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			tst[i] = t.(IProcedureOrFunctionDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) ProcedureOrFunctionDeclaration(i int) IProcedureOrFunctionDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionDeclarationContext)
}

func (s *BlockContext) AllClassOperatorDeclaration() []IClassOperatorDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassOperatorDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassOperatorDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassOperatorDeclarationContext); ok {
			tst[i] = t.(IClassOperatorDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) ClassOperatorDeclaration(i int) IClassOperatorDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOperatorDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOperatorDeclarationContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (s *BlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, pascalParserRULE_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(446)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1152923704712364544) != 0) || ((int64((_la-77)) & ^0x3f) == 0 && ((int64(1)<<(_la-77))&1610612737) != 0) {
		p.SetState(444)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(439)
				p.LabelDeclarationPart()
			}

		case 2:
			{
				p.SetState(440)
				p.ConstantDefinitionPart()
			}

		case 3:
			{
				p.SetState(441)
				p.VariableDeclarationPart()
			}

		case 4:
			{
				p.SetState(442)
				p.ProcedureOrFunctionDeclaration()
			}

		case 5:
			{
				p.SetState(443)
				p.ClassOperatorDeclaration()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(448)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsesUnitsContext is an interface to support dynamic dispatch.
type IUsesUnitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USES() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	SEMI() antlr.TerminalNode

	// IsUsesUnitsContext differentiates from other interfaces.
	IsUsesUnitsContext()
}

type UsesUnitsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsesUnitsContext() *UsesUnitsContext {
	var p = new(UsesUnitsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_usesUnits
	return p
}

func InitEmptyUsesUnitsContext(p *UsesUnitsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_usesUnits
}

func (*UsesUnitsContext) IsUsesUnitsContext() {}

func NewUsesUnitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsesUnitsContext {
	var p = new(UsesUnitsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_usesUnits

	return p
}

func (s *UsesUnitsContext) GetParser() antlr.Parser { return s.parser }

func (s *UsesUnitsContext) USES() antlr.TerminalNode {
	return s.GetToken(pascalParserUSES, 0)
}

func (s *UsesUnitsContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *UsesUnitsContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *UsesUnitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsesUnitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsesUnitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUsesUnits(s)
	}
}

func (s *UsesUnitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUsesUnits(s)
	}
}

func (s *UsesUnitsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUsesUnits(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UsesUnits() (localctx IUsesUnitsContext) {
	localctx = NewUsesUnitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, pascalParserRULE_usesUnits)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(449)
		p.Match(pascalParserUSES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(450)
		p.IdentifierList()
	}
	{
		p.SetState(451)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelDeclarationPartContext is an interface to support dynamic dispatch.
type ILabelDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LABEL() antlr.TerminalNode
	AllLabel() []ILabelContext
	Label(i int) ILabelContext
	SEMI() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLabelDeclarationPartContext differentiates from other interfaces.
	IsLabelDeclarationPartContext()
}

type LabelDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelDeclarationPartContext() *LabelDeclarationPartContext {
	var p = new(LabelDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_labelDeclarationPart
	return p
}

func InitEmptyLabelDeclarationPartContext(p *LabelDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_labelDeclarationPart
}

func (*LabelDeclarationPartContext) IsLabelDeclarationPartContext() {}

func NewLabelDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelDeclarationPartContext {
	var p = new(LabelDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_labelDeclarationPart

	return p
}

func (s *LabelDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelDeclarationPartContext) LABEL() antlr.TerminalNode {
	return s.GetToken(pascalParserLABEL, 0)
}

func (s *LabelDeclarationPartContext) AllLabel() []ILabelContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelContext); ok {
			len++
		}
	}

	tst := make([]ILabelContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelContext); ok {
			tst[i] = t.(ILabelContext)
			i++
		}
	}

	return tst
}

func (s *LabelDeclarationPartContext) Label(i int) ILabelContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *LabelDeclarationPartContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *LabelDeclarationPartContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *LabelDeclarationPartContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *LabelDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterLabelDeclarationPart(s)
	}
}

func (s *LabelDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitLabelDeclarationPart(s)
	}
}

func (s *LabelDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitLabelDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) LabelDeclarationPart() (localctx ILabelDeclarationPartContext) {
	localctx = NewLabelDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, pascalParserRULE_labelDeclarationPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(453)
		p.Match(pascalParserLABEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(454)
		p.Label()
	}
	p.SetState(459)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(455)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(456)
			p.Label()
		}

		p.SetState(461)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(462)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelContext is an interface to support dynamic dispatch.
type ILabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedInteger() IUnsignedIntegerContext

	// IsLabelContext differentiates from other interfaces.
	IsLabelContext()
}

type LabelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelContext() *LabelContext {
	var p = new(LabelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_label
	return p
}

func InitEmptyLabelContext(p *LabelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_label
}

func (*LabelContext) IsLabelContext() {}

func NewLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelContext {
	var p = new(LabelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_label

	return p
}

func (s *LabelContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelContext) UnsignedInteger() IUnsignedIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerContext)
}

func (s *LabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterLabel(s)
	}
}

func (s *LabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitLabel(s)
	}
}

func (s *LabelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitLabel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Label() (localctx ILabelContext) {
	localctx = NewLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, pascalParserRULE_label)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(464)
		p.UnsignedInteger()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantDefinitionPartContext is an interface to support dynamic dispatch.
type IConstantDefinitionPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONST() antlr.TerminalNode
	AllConstantDefinition() []IConstantDefinitionContext
	ConstantDefinition(i int) IConstantDefinitionContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsConstantDefinitionPartContext differentiates from other interfaces.
	IsConstantDefinitionPartContext()
}

type ConstantDefinitionPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantDefinitionPartContext() *ConstantDefinitionPartContext {
	var p = new(ConstantDefinitionPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantDefinitionPart
	return p
}

func InitEmptyConstantDefinitionPartContext(p *ConstantDefinitionPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantDefinitionPart
}

func (*ConstantDefinitionPartContext) IsConstantDefinitionPartContext() {}

func NewConstantDefinitionPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantDefinitionPartContext {
	var p = new(ConstantDefinitionPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constantDefinitionPart

	return p
}

func (s *ConstantDefinitionPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantDefinitionPartContext) CONST() antlr.TerminalNode {
	return s.GetToken(pascalParserCONST, 0)
}

func (s *ConstantDefinitionPartContext) AllConstantDefinition() []IConstantDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IConstantDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantDefinitionContext); ok {
			tst[i] = t.(IConstantDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *ConstantDefinitionPartContext) ConstantDefinition(i int) IConstantDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionContext)
}

func (s *ConstantDefinitionPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ConstantDefinitionPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ConstantDefinitionPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantDefinitionPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantDefinitionPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstantDefinitionPart(s)
	}
}

func (s *ConstantDefinitionPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstantDefinitionPart(s)
	}
}

func (s *ConstantDefinitionPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstantDefinitionPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConstantDefinitionPart() (localctx IConstantDefinitionPartContext) {
	localctx = NewConstantDefinitionPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, pascalParserRULE_constantDefinitionPart)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(466)
		p.Match(pascalParserCONST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(470)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(467)
				p.ConstantDefinition()
			}
			{
				p.SetState(468)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(472)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantDefinitionContext is an interface to support dynamic dispatch.
type IConstantDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQUAL() antlr.TerminalNode
	Constant() IConstantContext
	COLON() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	ArrayType() IArrayTypeContext
	SetType() ISetTypeContext

	// IsConstantDefinitionContext differentiates from other interfaces.
	IsConstantDefinitionContext()
}

type ConstantDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantDefinitionContext() *ConstantDefinitionContext {
	var p = new(ConstantDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantDefinition
	return p
}

func InitEmptyConstantDefinitionContext(p *ConstantDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantDefinition
}

func (*ConstantDefinitionContext) IsConstantDefinitionContext() {}

func NewConstantDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantDefinitionContext {
	var p = new(ConstantDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constantDefinition

	return p
}

func (s *ConstantDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConstantDefinitionContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *ConstantDefinitionContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantDefinitionContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *ConstantDefinitionContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ConstantDefinitionContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *ConstantDefinitionContext) SetType() ISetTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetTypeContext)
}

func (s *ConstantDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstantDefinition(s)
	}
}

func (s *ConstantDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstantDefinition(s)
	}
}

func (s *ConstantDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstantDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConstantDefinition() (localctx IConstantDefinitionContext) {
	localctx = NewConstantDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, pascalParserRULE_constantDefinition)
	var _la int

	p.SetState(494)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(474)
			p.Identifier()
		}
		p.SetState(477)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserCOLON {
			{
				p.SetState(475)
				p.Match(pascalParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(476)
				p.TypeIdentifier()
			}

		}
		{
			p.SetState(479)
			p.Match(pascalParserEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(480)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(482)
			p.Identifier()
		}
		{
			p.SetState(483)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(484)
			p.ArrayType()
		}
		{
			p.SetState(485)
			p.Match(pascalParserEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(486)
			p.Constant()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(488)
			p.Identifier()
		}
		{
			p.SetState(489)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(490)
			p.SetType()
		}
		{
			p.SetState(491)
			p.Match(pascalParserEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(492)
			p.Constant()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantChrContext is an interface to support dynamic dispatch.
type IConstantChrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHR() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	UnsignedInteger() IUnsignedIntegerContext
	RPAREN() antlr.TerminalNode

	// IsConstantChrContext differentiates from other interfaces.
	IsConstantChrContext()
}

type ConstantChrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantChrContext() *ConstantChrContext {
	var p = new(ConstantChrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantChr
	return p
}

func InitEmptyConstantChrContext(p *ConstantChrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constantChr
}

func (*ConstantChrContext) IsConstantChrContext() {}

func NewConstantChrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantChrContext {
	var p = new(ConstantChrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constantChr

	return p
}

func (s *ConstantChrContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantChrContext) CHR() antlr.TerminalNode {
	return s.GetToken(pascalParserCHR, 0)
}

func (s *ConstantChrContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ConstantChrContext) UnsignedInteger() IUnsignedIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerContext)
}

func (s *ConstantChrContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ConstantChrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantChrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantChrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstantChr(s)
	}
}

func (s *ConstantChrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstantChr(s)
	}
}

func (s *ConstantChrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstantChr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConstantChr() (localctx IConstantChrContext) {
	localctx = NewConstantChrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, pascalParserRULE_constantChr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(496)
		p.Match(pascalParserCHR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(497)
		p.Match(pascalParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(498)
		p.UnsignedInteger()
	}
	{
		p.SetState(499)
		p.Match(pascalParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHexConstantContext is an interface to support dynamic dispatch.
type IHexConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HEX_LITERAL() antlr.TerminalNode

	// IsHexConstantContext differentiates from other interfaces.
	IsHexConstantContext()
}

type HexConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexConstantContext() *HexConstantContext {
	var p = new(HexConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_hexConstant
	return p
}

func InitEmptyHexConstantContext(p *HexConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_hexConstant
}

func (*HexConstantContext) IsHexConstantContext() {}

func NewHexConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexConstantContext {
	var p = new(HexConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_hexConstant

	return p
}

func (s *HexConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *HexConstantContext) HEX_LITERAL() antlr.TerminalNode {
	return s.GetToken(pascalParserHEX_LITERAL, 0)
}

func (s *HexConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterHexConstant(s)
	}
}

func (s *HexConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitHexConstant(s)
	}
}

func (s *HexConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitHexConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) HexConstant() (localctx IHexConstantContext) {
	localctx = NewHexConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, pascalParserRULE_hexConstant)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(501)
		p.Match(pascalParserHEX_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedConstant() IUnsignedConstantContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	ScalarType() IScalarTypeContext
	AllArrayConstant() []IArrayConstantContext
	ArrayConstant(i int) IArrayConstantContext
	AllPLUS() []antlr.TerminalNode
	PLUS(i int) antlr.TerminalNode
	RecordConstant() IRecordConstantContext
	SimpleExpression() ISimpleExpressionContext

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constant
	return p
}

func InitEmptyConstantContext(p *ConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constant
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) UnsignedConstant() IUnsignedConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedConstantContext)
}

func (s *ConstantContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ConstantContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConstantContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ConstantContext) AllArrayConstant() []IArrayConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayConstantContext); ok {
			len++
		}
	}

	tst := make([]IArrayConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayConstantContext); ok {
			tst[i] = t.(IArrayConstantContext)
			i++
		}
	}

	return tst
}

func (s *ConstantContext) ArrayConstant(i int) IArrayConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayConstantContext)
}

func (s *ConstantContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPLUS)
}

func (s *ConstantContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPLUS, i)
}

func (s *ConstantContext) RecordConstant() IRecordConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordConstantContext)
}

func (s *ConstantContext) SimpleExpression() ISimpleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExpressionContext)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstant(s)
	}
}

func (s *ConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, pascalParserRULE_constant)
	var _la int

	p.SetState(519)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(503)
			p.UnsignedConstant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(504)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(505)
			p.ScalarType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(506)
			p.ArrayConstant()
		}
		p.SetState(514)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == pascalParserPLUS {
			{
				p.SetState(507)
				p.Match(pascalParserPLUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(510)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case pascalParserLPAREN, pascalParserLBRACK:
				{
					p.SetState(508)
					p.ArrayConstant()
				}

			case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
				{
					p.SetState(509)
					p.Identifier()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(516)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(517)
			p.RecordConstant()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(518)
			p.SimpleExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayConstantContext is an interface to support dynamic dispatch.
type IArrayConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	RBRACK() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsArrayConstantContext differentiates from other interfaces.
	IsArrayConstantContext()
}

type ArrayConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayConstantContext() *ArrayConstantContext {
	var p = new(ArrayConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_arrayConstant
	return p
}

func InitEmptyArrayConstantContext(p *ArrayConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_arrayConstant
}

func (*ArrayConstantContext) IsArrayConstantContext() {}

func NewArrayConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayConstantContext {
	var p = new(ArrayConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_arrayConstant

	return p
}

func (s *ArrayConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayConstantContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *ArrayConstantContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *ArrayConstantContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ArrayConstantContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *ArrayConstantContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ArrayConstantContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ArrayConstantContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ArrayConstantContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ArrayConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterArrayConstant(s)
	}
}

func (s *ArrayConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitArrayConstant(s)
	}
}

func (s *ArrayConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitArrayConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ArrayConstant() (localctx IArrayConstantContext) {
	localctx = NewArrayConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, pascalParserRULE_arrayConstant)
	var _la int

	p.SetState(543)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserLBRACK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(521)
			p.Match(pascalParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(522)
			p.Constant()
		}
		p.SetState(527)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == pascalParserCOMMA {
			{
				p.SetState(523)
				p.Match(pascalParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(524)
				p.Constant()
			}

			p.SetState(529)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(530)
			p.Match(pascalParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case pascalParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(532)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(533)
			p.Constant()
		}
		p.SetState(538)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == pascalParserCOMMA {
			{
				p.SetState(534)
				p.Match(pascalParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(535)
				p.Constant()
			}

			p.SetState(540)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(541)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordConstantContext is an interface to support dynamic dispatch.
type IRecordConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllRecordField() []IRecordFieldContext
	RecordField(i int) IRecordFieldContext
	RPAREN() antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsRecordConstantContext differentiates from other interfaces.
	IsRecordConstantContext()
}

type RecordConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordConstantContext() *RecordConstantContext {
	var p = new(RecordConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordConstant
	return p
}

func InitEmptyRecordConstantContext(p *RecordConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordConstant
}

func (*RecordConstantContext) IsRecordConstantContext() {}

func NewRecordConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordConstantContext {
	var p = new(RecordConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordConstant

	return p
}

func (s *RecordConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordConstantContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *RecordConstantContext) AllRecordField() []IRecordFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordFieldContext); ok {
			len++
		}
	}

	tst := make([]IRecordFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordFieldContext); ok {
			tst[i] = t.(IRecordFieldContext)
			i++
		}
	}

	return tst
}

func (s *RecordConstantContext) RecordField(i int) IRecordFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordFieldContext)
}

func (s *RecordConstantContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *RecordConstantContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *RecordConstantContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *RecordConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordConstant(s)
	}
}

func (s *RecordConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordConstant(s)
	}
}

func (s *RecordConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordConstant() (localctx IRecordConstantContext) {
	localctx = NewRecordConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, pascalParserRULE_recordConstant)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(545)
		p.Match(pascalParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(546)
		p.RecordField()
	}
	p.SetState(551)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserSEMI {
		{
			p.SetState(547)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(548)
			p.RecordField()
		}

		p.SetState(553)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(554)
		p.Match(pascalParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordFieldContext is an interface to support dynamic dispatch.
type IRecordFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	DOTDOT() antlr.TerminalNode
	ArrayConstant() IArrayConstantContext

	// IsRecordFieldContext differentiates from other interfaces.
	IsRecordFieldContext()
}

type RecordFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordFieldContext() *RecordFieldContext {
	var p = new(RecordFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordField
	return p
}

func InitEmptyRecordFieldContext(p *RecordFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordField
}

func (*RecordFieldContext) IsRecordFieldContext() {}

func NewRecordFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordFieldContext {
	var p = new(RecordFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordField

	return p
}

func (s *RecordFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordFieldContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RecordFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *RecordFieldContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *RecordFieldContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *RecordFieldContext) DOTDOT() antlr.TerminalNode {
	return s.GetToken(pascalParserDOTDOT, 0)
}

func (s *RecordFieldContext) ArrayConstant() IArrayConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayConstantContext)
}

func (s *RecordFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordField(s)
	}
}

func (s *RecordFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordField(s)
	}
}

func (s *RecordFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordField() (localctx IRecordFieldContext) {
	localctx = NewRecordFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, pascalParserRULE_recordField)
	p.SetState(570)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(556)
			p.Identifier()
		}
		{
			p.SetState(557)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(558)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(560)
			p.Identifier()
		}
		{
			p.SetState(561)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(562)
			p.Constant()
		}
		{
			p.SetState(563)
			p.Match(pascalParserDOTDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(564)
			p.Constant()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(566)
			p.Identifier()
		}
		{
			p.SetState(567)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(568)
			p.ArrayConstant()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedNumberContext is an interface to support dynamic dispatch.
type IUnsignedNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedInteger() IUnsignedIntegerContext
	UnsignedReal() IUnsignedRealContext

	// IsUnsignedNumberContext differentiates from other interfaces.
	IsUnsignedNumberContext()
}

type UnsignedNumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedNumberContext() *UnsignedNumberContext {
	var p = new(UnsignedNumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedNumber
	return p
}

func InitEmptyUnsignedNumberContext(p *UnsignedNumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedNumber
}

func (*UnsignedNumberContext) IsUnsignedNumberContext() {}

func NewUnsignedNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedNumberContext {
	var p = new(UnsignedNumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unsignedNumber

	return p
}

func (s *UnsignedNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedNumberContext) UnsignedInteger() IUnsignedIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerContext)
}

func (s *UnsignedNumberContext) UnsignedReal() IUnsignedRealContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedRealContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedRealContext)
}

func (s *UnsignedNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnsignedNumber(s)
	}
}

func (s *UnsignedNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnsignedNumber(s)
	}
}

func (s *UnsignedNumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnsignedNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnsignedNumber() (localctx IUnsignedNumberContext) {
	localctx = NewUnsignedNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, pascalParserRULE_unsignedNumber)
	p.SetState(574)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserNUM_INT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(572)
			p.UnsignedInteger()
		}

	case pascalParserNUM_REAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(573)
			p.UnsignedReal()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedIntegerContext is an interface to support dynamic dispatch.
type IUnsignedIntegerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUM_INT() antlr.TerminalNode

	// IsUnsignedIntegerContext differentiates from other interfaces.
	IsUnsignedIntegerContext()
}

type UnsignedIntegerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedIntegerContext() *UnsignedIntegerContext {
	var p = new(UnsignedIntegerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedInteger
	return p
}

func InitEmptyUnsignedIntegerContext(p *UnsignedIntegerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedInteger
}

func (*UnsignedIntegerContext) IsUnsignedIntegerContext() {}

func NewUnsignedIntegerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedIntegerContext {
	var p = new(UnsignedIntegerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unsignedInteger

	return p
}

func (s *UnsignedIntegerContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedIntegerContext) NUM_INT() antlr.TerminalNode {
	return s.GetToken(pascalParserNUM_INT, 0)
}

func (s *UnsignedIntegerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedIntegerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedIntegerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnsignedInteger(s)
	}
}

func (s *UnsignedIntegerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnsignedInteger(s)
	}
}

func (s *UnsignedIntegerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnsignedInteger(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnsignedInteger() (localctx IUnsignedIntegerContext) {
	localctx = NewUnsignedIntegerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, pascalParserRULE_unsignedInteger)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(576)
		p.Match(pascalParserNUM_INT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedRealContext is an interface to support dynamic dispatch.
type IUnsignedRealContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUM_REAL() antlr.TerminalNode

	// IsUnsignedRealContext differentiates from other interfaces.
	IsUnsignedRealContext()
}

type UnsignedRealContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedRealContext() *UnsignedRealContext {
	var p = new(UnsignedRealContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedReal
	return p
}

func InitEmptyUnsignedRealContext(p *UnsignedRealContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedReal
}

func (*UnsignedRealContext) IsUnsignedRealContext() {}

func NewUnsignedRealContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedRealContext {
	var p = new(UnsignedRealContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unsignedReal

	return p
}

func (s *UnsignedRealContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedRealContext) NUM_REAL() antlr.TerminalNode {
	return s.GetToken(pascalParserNUM_REAL, 0)
}

func (s *UnsignedRealContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedRealContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedRealContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnsignedReal(s)
	}
}

func (s *UnsignedRealContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnsignedReal(s)
	}
}

func (s *UnsignedRealContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnsignedReal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnsignedReal() (localctx IUnsignedRealContext) {
	localctx = NewUnsignedRealContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, pascalParserRULE_unsignedReal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(578)
		p.Match(pascalParserNUM_REAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignContext is an interface to support dynamic dispatch.
type ISignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsSignContext differentiates from other interfaces.
	IsSignContext()
}

type SignContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignContext() *SignContext {
	var p = new(SignContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_sign
	return p
}

func InitEmptySignContext(p *SignContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_sign
}

func (*SignContext) IsSignContext() {}

func NewSignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignContext {
	var p = new(SignContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_sign

	return p
}

func (s *SignContext) GetParser() antlr.Parser { return s.parser }

func (s *SignContext) PLUS() antlr.TerminalNode {
	return s.GetToken(pascalParserPLUS, 0)
}

func (s *SignContext) MINUS() antlr.TerminalNode {
	return s.GetToken(pascalParserMINUS, 0)
}

func (s *SignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSign(s)
	}
}

func (s *SignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSign(s)
	}
}

func (s *SignContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSign(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Sign() (localctx ISignContext) {
	localctx = NewSignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, pascalParserRULE_sign)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(580)
		_la = p.GetTokenStream().LA(1)

		if !(_la == pascalParserPLUS || _la == pascalParserMINUS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_Context is an interface to support dynamic dispatch.
type IBool_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBool_Context differentiates from other interfaces.
	IsBool_Context()
}

type Bool_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_Context() *Bool_Context {
	var p = new(Bool_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_bool_
	return p
}

func InitEmptyBool_Context(p *Bool_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_bool_
}

func (*Bool_Context) IsBool_Context() {}

func NewBool_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_Context {
	var p = new(Bool_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_bool_

	return p
}

func (s *Bool_Context) GetParser() antlr.Parser { return s.parser }

func (s *Bool_Context) TRUE() antlr.TerminalNode {
	return s.GetToken(pascalParserTRUE, 0)
}

func (s *Bool_Context) FALSE() antlr.TerminalNode {
	return s.GetToken(pascalParserFALSE, 0)
}

func (s *Bool_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterBool_(s)
	}
}

func (s *Bool_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitBool_(s)
	}
}

func (s *Bool_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitBool_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Bool_() (localctx IBool_Context) {
	localctx = NewBool_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, pascalParserRULE_bool_)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(582)
		_la = p.GetTokenStream().LA(1)

		if !(_la == pascalParserTRUE || _la == pascalParserFALSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringContext is an interface to support dynamic dispatch.
type IStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	AllSTRING_CROSSHATCH_LITERAL() []antlr.TerminalNode
	STRING_CROSSHATCH_LITERAL(i int) antlr.TerminalNode

	// IsStringContext differentiates from other interfaces.
	IsStringContext()
}

type StringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringContext() *StringContext {
	var p = new(StringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_string
	return p
}

func InitEmptyStringContext(p *StringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_string
}

func (*StringContext) IsStringContext() {}

func NewStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringContext {
	var p = new(StringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_string

	return p
}

func (s *StringContext) GetParser() antlr.Parser { return s.parser }

func (s *StringContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTRING_LITERAL)
}

func (s *StringContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTRING_LITERAL, i)
}

func (s *StringContext) AllSTRING_CROSSHATCH_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTRING_CROSSHATCH_LITERAL)
}

func (s *StringContext) STRING_CROSSHATCH_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTRING_CROSSHATCH_LITERAL, i)
}

func (s *StringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterString(s)
	}
}

func (s *StringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitString(s)
	}
}

func (s *StringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) String_() (localctx IStringContext) {
	localctx = NewStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, pascalParserRULE_string)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(585)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(584)
				_la = p.GetTokenStream().LA(1)

				if !(_la == pascalParserSTRING_LITERAL || _la == pascalParserSTRING_CROSSHATCH_LITERAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(587)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringExpressionContext is an interface to support dynamic dispatch.
type IStringExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllString_() []IStringContext
	String_(i int) IStringContext
	AllPLUS() []antlr.TerminalNode
	PLUS(i int) antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsStringExpressionContext differentiates from other interfaces.
	IsStringExpressionContext()
}

type StringExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringExpressionContext() *StringExpressionContext {
	var p = new(StringExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_stringExpression
	return p
}

func InitEmptyStringExpressionContext(p *StringExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_stringExpression
}

func (*StringExpressionContext) IsStringExpressionContext() {}

func NewStringExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringExpressionContext {
	var p = new(StringExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_stringExpression

	return p
}

func (s *StringExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *StringExpressionContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *StringExpressionContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *StringExpressionContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPLUS)
}

func (s *StringExpressionContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPLUS, i)
}

func (s *StringExpressionContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *StringExpressionContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStringExpression(s)
	}
}

func (s *StringExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStringExpression(s)
	}
}

func (s *StringExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStringExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) StringExpression() (localctx IStringExpressionContext) {
	localctx = NewStringExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, pascalParserRULE_stringExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(589)
		p.String_()
	}
	p.SetState(597)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserPLUS {
		{
			p.SetState(590)
			p.Match(pascalParserPLUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(593)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case pascalParserSTRING_LITERAL, pascalParserSTRING_CROSSHATCH_LITERAL:
			{
				p.SetState(591)
				p.String_()
			}

		case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
			{
				p.SetState(592)
				p.Identifier()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(599)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceDefinitionPartContext is an interface to support dynamic dispatch.
type IResourceDefinitionPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESOURCESTRING() antlr.TerminalNode
	AllResourceDefinition() []IResourceDefinitionContext
	ResourceDefinition(i int) IResourceDefinitionContext

	// IsResourceDefinitionPartContext differentiates from other interfaces.
	IsResourceDefinitionPartContext()
}

type ResourceDefinitionPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceDefinitionPartContext() *ResourceDefinitionPartContext {
	var p = new(ResourceDefinitionPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resourceDefinitionPart
	return p
}

func InitEmptyResourceDefinitionPartContext(p *ResourceDefinitionPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resourceDefinitionPart
}

func (*ResourceDefinitionPartContext) IsResourceDefinitionPartContext() {}

func NewResourceDefinitionPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceDefinitionPartContext {
	var p = new(ResourceDefinitionPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_resourceDefinitionPart

	return p
}

func (s *ResourceDefinitionPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceDefinitionPartContext) RESOURCESTRING() antlr.TerminalNode {
	return s.GetToken(pascalParserRESOURCESTRING, 0)
}

func (s *ResourceDefinitionPartContext) AllResourceDefinition() []IResourceDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResourceDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IResourceDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResourceDefinitionContext); ok {
			tst[i] = t.(IResourceDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *ResourceDefinitionPartContext) ResourceDefinition(i int) IResourceDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceDefinitionContext)
}

func (s *ResourceDefinitionPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceDefinitionPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceDefinitionPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterResourceDefinitionPart(s)
	}
}

func (s *ResourceDefinitionPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitResourceDefinitionPart(s)
	}
}

func (s *ResourceDefinitionPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitResourceDefinitionPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ResourceDefinitionPart() (localctx IResourceDefinitionPartContext) {
	localctx = NewResourceDefinitionPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, pascalParserRULE_resourceDefinitionPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(600)
		p.Match(pascalParserRESOURCESTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64((_la-85)) & ^0x3f) == 0 && ((int64(1)<<(_la-85))&274877906955) != 0) {
		{
			p.SetState(601)
			p.ResourceDefinition()
		}

		p.SetState(604)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceDefinitionContext is an interface to support dynamic dispatch.
type IResourceDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQUAL() antlr.TerminalNode
	StringExpression() IStringExpressionContext
	SEMI() antlr.TerminalNode

	// IsResourceDefinitionContext differentiates from other interfaces.
	IsResourceDefinitionContext()
}

type ResourceDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceDefinitionContext() *ResourceDefinitionContext {
	var p = new(ResourceDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resourceDefinition
	return p
}

func InitEmptyResourceDefinitionContext(p *ResourceDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resourceDefinition
}

func (*ResourceDefinitionContext) IsResourceDefinitionContext() {}

func NewResourceDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceDefinitionContext {
	var p = new(ResourceDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_resourceDefinition

	return p
}

func (s *ResourceDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ResourceDefinitionContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *ResourceDefinitionContext) StringExpression() IStringExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringExpressionContext)
}

func (s *ResourceDefinitionContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ResourceDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterResourceDefinition(s)
	}
}

func (s *ResourceDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitResourceDefinition(s)
	}
}

func (s *ResourceDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitResourceDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ResourceDefinition() (localctx IResourceDefinitionContext) {
	localctx = NewResourceDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, pascalParserRULE_resourceDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(606)
		p.Identifier()
	}
	{
		p.SetState(607)
		p.Match(pascalParserEQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(608)
		p.StringExpression()
	}
	{
		p.SetState(609)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDefinitionPartContext is an interface to support dynamic dispatch.
type ITypeDefinitionPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE() antlr.TerminalNode
	AllTypeDefinition() []ITypeDefinitionContext
	TypeDefinition(i int) ITypeDefinitionContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsTypeDefinitionPartContext differentiates from other interfaces.
	IsTypeDefinitionPartContext()
}

type TypeDefinitionPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDefinitionPartContext() *TypeDefinitionPartContext {
	var p = new(TypeDefinitionPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeDefinitionPart
	return p
}

func InitEmptyTypeDefinitionPartContext(p *TypeDefinitionPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeDefinitionPart
}

func (*TypeDefinitionPartContext) IsTypeDefinitionPartContext() {}

func NewTypeDefinitionPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDefinitionPartContext {
	var p = new(TypeDefinitionPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typeDefinitionPart

	return p
}

func (s *TypeDefinitionPartContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDefinitionPartContext) TYPE() antlr.TerminalNode {
	return s.GetToken(pascalParserTYPE, 0)
}

func (s *TypeDefinitionPartContext) AllTypeDefinition() []ITypeDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ITypeDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeDefinitionContext); ok {
			tst[i] = t.(ITypeDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *TypeDefinitionPartContext) TypeDefinition(i int) ITypeDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionContext)
}

func (s *TypeDefinitionPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *TypeDefinitionPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *TypeDefinitionPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDefinitionPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDefinitionPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypeDefinitionPart(s)
	}
}

func (s *TypeDefinitionPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypeDefinitionPart(s)
	}
}

func (s *TypeDefinitionPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypeDefinitionPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypeDefinitionPart() (localctx ITypeDefinitionPartContext) {
	localctx = NewTypeDefinitionPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, pascalParserRULE_typeDefinitionPart)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(611)
		p.Match(pascalParserTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(615)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(612)
				p.TypeDefinition()
			}
			{
				p.SetState(613)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(617)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDefinitionContext is an interface to support dynamic dispatch.
type ITypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQUAL() antlr.TerminalNode
	ForwardClassType() IForwardClassTypeContext
	ForwardInterfaceType() IForwardInterfaceTypeContext
	FunctionType() IFunctionTypeContext
	ProcedureType() IProcedureTypeContext
	Type_() IType_Context
	AttributeSection() IAttributeSectionContext

	// IsTypeDefinitionContext differentiates from other interfaces.
	IsTypeDefinitionContext()
}

type TypeDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDefinitionContext() *TypeDefinitionContext {
	var p = new(TypeDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeDefinition
	return p
}

func InitEmptyTypeDefinitionContext(p *TypeDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeDefinition
}

func (*TypeDefinitionContext) IsTypeDefinitionContext() {}

func NewTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDefinitionContext {
	var p = new(TypeDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typeDefinition

	return p
}

func (s *TypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeDefinitionContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *TypeDefinitionContext) ForwardClassType() IForwardClassTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForwardClassTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForwardClassTypeContext)
}

func (s *TypeDefinitionContext) ForwardInterfaceType() IForwardInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForwardInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForwardInterfaceTypeContext)
}

func (s *TypeDefinitionContext) FunctionType() IFunctionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *TypeDefinitionContext) ProcedureType() IProcedureTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureTypeContext)
}

func (s *TypeDefinitionContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypeDefinitionContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *TypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypeDefinition(s)
	}
}

func (s *TypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypeDefinition(s)
	}
}

func (s *TypeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypeDefinition() (localctx ITypeDefinitionContext) {
	localctx = NewTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, pascalParserRULE_typeDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(620)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLBRACK {
		{
			p.SetState(619)
			p.AttributeSection()
		}

	}
	{
		p.SetState(622)
		p.Identifier()
	}
	{
		p.SetState(623)
		p.Match(pascalParserEQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(629)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(624)
			p.ForwardClassType()
		}

	case 2:
		{
			p.SetState(625)
			p.ForwardInterfaceType()
		}

	case 3:
		{
			p.SetState(626)
			p.FunctionType()
		}

	case 4:
		{
			p.SetState(627)
			p.ProcedureType()
		}

	case 5:
		{
			p.SetState(628)
			p.Type_()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTypeContext is an interface to support dynamic dispatch.
type IFunctionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNCTION() antlr.TerminalNode
	COLON() antlr.TerminalNode
	ResultType() IResultTypeContext
	ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext
	FormalParameterList() IFormalParameterListContext
	OF() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	REFERENCE() antlr.TerminalNode
	TO() antlr.TerminalNode

	// IsFunctionTypeContext differentiates from other interfaces.
	IsFunctionTypeContext()
}

type FunctionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeContext() *FunctionTypeContext {
	var p = new(FunctionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionType
	return p
}

func InitEmptyFunctionTypeContext(p *FunctionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionType
}

func (*FunctionTypeContext) IsFunctionTypeContext() {}

func NewFunctionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeContext {
	var p = new(FunctionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_functionType

	return p
}

func (s *FunctionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(pascalParserFUNCTION, 0)
}

func (s *FunctionTypeContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *FunctionTypeContext) ResultType() IResultTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultTypeContext)
}

func (s *FunctionTypeContext) ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderModifiersContext)
}

func (s *FunctionTypeContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *FunctionTypeContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(pascalParserOBJECT, 0)
}

func (s *FunctionTypeContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(pascalParserREFERENCE, 0)
}

func (s *FunctionTypeContext) TO() antlr.TerminalNode {
	return s.GetToken(pascalParserTO, 0)
}

func (s *FunctionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFunctionType(s)
	}
}

func (s *FunctionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFunctionType(s)
	}
}

func (s *FunctionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFunctionType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FunctionType() (localctx IFunctionTypeContext) {
	localctx = NewFunctionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, pascalParserRULE_functionType)
	var _la int

	p.SetState(653)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserFUNCTION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(631)
			p.Match(pascalParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(633)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLPAREN {
			{
				p.SetState(632)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(635)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(636)
			p.ResultType()
		}
		p.SetState(639)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserOF {
			{
				p.SetState(637)
				p.Match(pascalParserOF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(638)
				p.Match(pascalParserOBJECT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(641)
			p.ProcedureOrFunctionHeaderModifiers()
		}

	case pascalParserREFERENCE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(643)
			p.Match(pascalParserREFERENCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(644)
			p.Match(pascalParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(645)
			p.Match(pascalParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(647)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLPAREN {
			{
				p.SetState(646)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(649)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(650)
			p.ResultType()
		}
		{
			p.SetState(651)
			p.ProcedureOrFunctionHeaderModifiers()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureTypeContext is an interface to support dynamic dispatch.
type IProcedureTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROCEDURE() antlr.TerminalNode
	ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext
	FormalParameterList() IFormalParameterListContext
	OF() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	REFERENCE() antlr.TerminalNode
	TO() antlr.TerminalNode

	// IsProcedureTypeContext differentiates from other interfaces.
	IsProcedureTypeContext()
}

type ProcedureTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureTypeContext() *ProcedureTypeContext {
	var p = new(ProcedureTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureType
	return p
}

func InitEmptyProcedureTypeContext(p *ProcedureTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureType
}

func (*ProcedureTypeContext) IsProcedureTypeContext() {}

func NewProcedureTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureTypeContext {
	var p = new(ProcedureTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureType

	return p
}

func (s *ProcedureTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureTypeContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(pascalParserPROCEDURE, 0)
}

func (s *ProcedureTypeContext) ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderModifiersContext)
}

func (s *ProcedureTypeContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ProcedureTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *ProcedureTypeContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(pascalParserOBJECT, 0)
}

func (s *ProcedureTypeContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(pascalParserREFERENCE, 0)
}

func (s *ProcedureTypeContext) TO() antlr.TerminalNode {
	return s.GetToken(pascalParserTO, 0)
}

func (s *ProcedureTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureType(s)
	}
}

func (s *ProcedureTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureType(s)
	}
}

func (s *ProcedureTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureType() (localctx IProcedureTypeContext) {
	localctx = NewProcedureTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, pascalParserRULE_procedureType)
	var _la int

	p.SetState(671)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserPROCEDURE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(655)
			p.Match(pascalParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(657)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLPAREN {
			{
				p.SetState(656)
				p.FormalParameterList()
			}

		}
		p.SetState(661)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserOF {
			{
				p.SetState(659)
				p.Match(pascalParserOF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(660)
				p.Match(pascalParserOBJECT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(663)
			p.ProcedureOrFunctionHeaderModifiers()
		}

	case pascalParserREFERENCE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(664)
			p.Match(pascalParserREFERENCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(665)
			p.Match(pascalParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(666)
			p.Match(pascalParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(668)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLPAREN {
			{
				p.SetState(667)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(670)
			p.ProcedureOrFunctionHeaderModifiers()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForwardClassTypeContext is an interface to support dynamic dispatch.
type IForwardClassTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode

	// IsForwardClassTypeContext differentiates from other interfaces.
	IsForwardClassTypeContext()
}

type ForwardClassTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForwardClassTypeContext() *ForwardClassTypeContext {
	var p = new(ForwardClassTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forwardClassType
	return p
}

func InitEmptyForwardClassTypeContext(p *ForwardClassTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forwardClassType
}

func (*ForwardClassTypeContext) IsForwardClassTypeContext() {}

func NewForwardClassTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForwardClassTypeContext {
	var p = new(ForwardClassTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_forwardClassType

	return p
}

func (s *ForwardClassTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ForwardClassTypeContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *ForwardClassTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForwardClassTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForwardClassTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterForwardClassType(s)
	}
}

func (s *ForwardClassTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitForwardClassType(s)
	}
}

func (s *ForwardClassTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitForwardClassType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ForwardClassType() (localctx IForwardClassTypeContext) {
	localctx = NewForwardClassTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, pascalParserRULE_forwardClassType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(673)
		p.Match(pascalParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForwardInterfaceTypeContext is an interface to support dynamic dispatch.
type IForwardInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode

	// IsForwardInterfaceTypeContext differentiates from other interfaces.
	IsForwardInterfaceTypeContext()
}

type ForwardInterfaceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForwardInterfaceTypeContext() *ForwardInterfaceTypeContext {
	var p = new(ForwardInterfaceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forwardInterfaceType
	return p
}

func InitEmptyForwardInterfaceTypeContext(p *ForwardInterfaceTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forwardInterfaceType
}

func (*ForwardInterfaceTypeContext) IsForwardInterfaceTypeContext() {}

func NewForwardInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForwardInterfaceTypeContext {
	var p = new(ForwardInterfaceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_forwardInterfaceType

	return p
}

func (s *ForwardInterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ForwardInterfaceTypeContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(pascalParserINTERFACE, 0)
}

func (s *ForwardInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForwardInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForwardInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterForwardInterfaceType(s)
	}
}

func (s *ForwardInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitForwardInterfaceType(s)
	}
}

func (s *ForwardInterfaceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitForwardInterfaceType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ForwardInterfaceType() (localctx IForwardInterfaceTypeContext) {
	localctx = NewForwardInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, pascalParserRULE_forwardInterfaceType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(675)
		p.Match(pascalParserINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassTypeContext is an interface to support dynamic dispatch.
type IClassTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	ClassImplicitPublishedDeclaration() IClassImplicitPublishedDeclarationContext
	END() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	ClassImplementsInterfaces() IClassImplementsInterfacesContext
	RPAREN() antlr.TerminalNode
	ABSTRACT() antlr.TerminalNode
	AllClassDeclaration() []IClassDeclarationContext
	ClassDeclaration(i int) IClassDeclarationContext

	// IsClassTypeContext differentiates from other interfaces.
	IsClassTypeContext()
}

type ClassTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassTypeContext() *ClassTypeContext {
	var p = new(ClassTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classType
	return p
}

func InitEmptyClassTypeContext(p *ClassTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classType
}

func (*ClassTypeContext) IsClassTypeContext() {}

func NewClassTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassTypeContext {
	var p = new(ClassTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classType

	return p
}

func (s *ClassTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassTypeContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *ClassTypeContext) ClassImplicitPublishedDeclaration() IClassImplicitPublishedDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassImplicitPublishedDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassImplicitPublishedDeclarationContext)
}

func (s *ClassTypeContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *ClassTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ClassTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassTypeContext) ClassImplementsInterfaces() IClassImplementsInterfacesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassImplementsInterfacesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassImplementsInterfacesContext)
}

func (s *ClassTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ClassTypeContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(pascalParserABSTRACT, 0)
}

func (s *ClassTypeContext) AllClassDeclaration() []IClassDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassDeclarationContext); ok {
			tst[i] = t.(IClassDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ClassTypeContext) ClassDeclaration(i int) IClassDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *ClassTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassType(s)
	}
}

func (s *ClassTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassType(s)
	}
}

func (s *ClassTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassType() (localctx IClassTypeContext) {
	localctx = NewClassTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, pascalParserRULE_classType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(677)
		p.Match(pascalParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(683)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(678)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(679)
			p.Identifier()
		}
		{
			p.SetState(680)
			p.ClassImplementsInterfaces()
		}
		{
			p.SetState(681)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(686)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(685)
			p.Match(pascalParserABSTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(688)
		p.ClassImplicitPublishedDeclaration()
	}
	p.SetState(692)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&31) != 0 {
		{
			p.SetState(689)
			p.ClassDeclaration()
		}

		p.SetState(694)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(695)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassImplementsInterfacesContext is an interface to support dynamic dispatch.
type IClassImplementsInterfacesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllTypeIdentifier() []ITypeIdentifierContext
	TypeIdentifier(i int) ITypeIdentifierContext

	// IsClassImplementsInterfacesContext differentiates from other interfaces.
	IsClassImplementsInterfacesContext()
}

type ClassImplementsInterfacesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassImplementsInterfacesContext() *ClassImplementsInterfacesContext {
	var p = new(ClassImplementsInterfacesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classImplementsInterfaces
	return p
}

func InitEmptyClassImplementsInterfacesContext(p *ClassImplementsInterfacesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classImplementsInterfaces
}

func (*ClassImplementsInterfacesContext) IsClassImplementsInterfacesContext() {}

func NewClassImplementsInterfacesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassImplementsInterfacesContext {
	var p = new(ClassImplementsInterfacesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classImplementsInterfaces

	return p
}

func (s *ClassImplementsInterfacesContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassImplementsInterfacesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ClassImplementsInterfacesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ClassImplementsInterfacesContext) AllTypeIdentifier() []ITypeIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			len++
		}
	}

	tst := make([]ITypeIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeIdentifierContext); ok {
			tst[i] = t.(ITypeIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ClassImplementsInterfacesContext) TypeIdentifier(i int) ITypeIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ClassImplementsInterfacesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassImplementsInterfacesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassImplementsInterfacesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassImplementsInterfaces(s)
	}
}

func (s *ClassImplementsInterfacesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassImplementsInterfaces(s)
	}
}

func (s *ClassImplementsInterfacesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassImplementsInterfaces(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassImplementsInterfaces() (localctx IClassImplementsInterfacesContext) {
	localctx = NewClassImplementsInterfacesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, pascalParserRULE_classImplementsInterfaces)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(701)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(697)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(698)
			p.TypeIdentifier()
		}

		p.SetState(703)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAccessSpecifierContext is an interface to support dynamic dispatch.
type IAccessSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRIVATE() antlr.TerminalNode
	STRICT() antlr.TerminalNode
	PROTECTED() antlr.TerminalNode
	PUBLIC() antlr.TerminalNode
	PUBLISHED() antlr.TerminalNode

	// IsAccessSpecifierContext differentiates from other interfaces.
	IsAccessSpecifierContext()
}

type AccessSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccessSpecifierContext() *AccessSpecifierContext {
	var p = new(AccessSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_accessSpecifier
	return p
}

func InitEmptyAccessSpecifierContext(p *AccessSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_accessSpecifier
}

func (*AccessSpecifierContext) IsAccessSpecifierContext() {}

func NewAccessSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccessSpecifierContext {
	var p = new(AccessSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_accessSpecifier

	return p
}

func (s *AccessSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AccessSpecifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(pascalParserPRIVATE, 0)
}

func (s *AccessSpecifierContext) STRICT() antlr.TerminalNode {
	return s.GetToken(pascalParserSTRICT, 0)
}

func (s *AccessSpecifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(pascalParserPROTECTED, 0)
}

func (s *AccessSpecifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLIC, 0)
}

func (s *AccessSpecifierContext) PUBLISHED() antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLISHED, 0)
}

func (s *AccessSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccessSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AccessSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAccessSpecifier(s)
	}
}

func (s *AccessSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAccessSpecifier(s)
	}
}

func (s *AccessSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAccessSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) AccessSpecifier() (localctx IAccessSpecifierContext) {
	localctx = NewAccessSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, pascalParserRULE_accessSpecifier)
	var _la int

	p.SetState(714)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(705)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserSTRICT {
			{
				p.SetState(704)
				p.Match(pascalParserSTRICT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(707)
			p.Match(pascalParserPRIVATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(709)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserSTRICT {
			{
				p.SetState(708)
				p.Match(pascalParserSTRICT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(711)
			p.Match(pascalParserPROTECTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(712)
			p.Match(pascalParserPUBLIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(713)
			p.Match(pascalParserPUBLISHED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AccessSpecifier() IAccessSpecifierContext
	AllClassDeclarationPart() []IClassDeclarationPartContext
	ClassDeclarationPart(i int) IClassDeclarationPartContext

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classDeclaration
	return p
}

func InitEmptyClassDeclarationContext(p *ClassDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classDeclaration
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) AccessSpecifier() IAccessSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessSpecifierContext)
}

func (s *ClassDeclarationContext) AllClassDeclarationPart() []IClassDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IClassDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassDeclarationPartContext); ok {
			tst[i] = t.(IClassDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ClassDeclarationContext) ClassDeclarationPart(i int) IClassDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationPartContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, pascalParserRULE_classDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(716)
		p.AccessSpecifier()
	}
	p.SetState(720)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-16386) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-507905) != 0) || _la == pascalParserNUM_REAL || _la == pascalParserUTF8BOM {
		{
			p.SetState(717)
			p.ClassDeclarationPart()
		}

		p.SetState(722)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassImplicitPublishedDeclarationContext is an interface to support dynamic dispatch.
type IClassImplicitPublishedDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllClassDeclarationPart() []IClassDeclarationPartContext
	ClassDeclarationPart(i int) IClassDeclarationPartContext

	// IsClassImplicitPublishedDeclarationContext differentiates from other interfaces.
	IsClassImplicitPublishedDeclarationContext()
}

type ClassImplicitPublishedDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassImplicitPublishedDeclarationContext() *ClassImplicitPublishedDeclarationContext {
	var p = new(ClassImplicitPublishedDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classImplicitPublishedDeclaration
	return p
}

func InitEmptyClassImplicitPublishedDeclarationContext(p *ClassImplicitPublishedDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classImplicitPublishedDeclaration
}

func (*ClassImplicitPublishedDeclarationContext) IsClassImplicitPublishedDeclarationContext() {}

func NewClassImplicitPublishedDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassImplicitPublishedDeclarationContext {
	var p = new(ClassImplicitPublishedDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classImplicitPublishedDeclaration

	return p
}

func (s *ClassImplicitPublishedDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassImplicitPublishedDeclarationContext) AllClassDeclarationPart() []IClassDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IClassDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassDeclarationPartContext); ok {
			tst[i] = t.(IClassDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *ClassImplicitPublishedDeclarationContext) ClassDeclarationPart(i int) IClassDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationPartContext)
}

func (s *ClassImplicitPublishedDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassImplicitPublishedDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassImplicitPublishedDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassImplicitPublishedDeclaration(s)
	}
}

func (s *ClassImplicitPublishedDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassImplicitPublishedDeclaration(s)
	}
}

func (s *ClassImplicitPublishedDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassImplicitPublishedDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassImplicitPublishedDeclaration() (localctx IClassImplicitPublishedDeclarationContext) {
	localctx = NewClassImplicitPublishedDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, pascalParserRULE_classImplicitPublishedDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(726)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-16386) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-507905) != 0) || _la == pascalParserNUM_REAL || _la == pascalParserUTF8BOM {
		{
			p.SetState(723)
			p.ClassDeclarationPart()
		}

		p.SetState(728)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassDeclarationPartContext is an interface to support dynamic dispatch.
type IClassDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypedIdentifierList() ITypedIdentifierListContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AttributeSection() IAttributeSectionContext
	TypeDefinitionPart() ITypeDefinitionPartContext
	ConstantDefinitionPart() IConstantDefinitionPartContext
	FunctionHeader() IFunctionHeaderContext
	ProcedureHeader() IProcedureHeaderContext
	PropertyDeclaration() IPropertyDeclarationContext
	DEFAULT() antlr.TerminalNode
	ErrorClassDeclarationPart() IErrorClassDeclarationPartContext

	// IsClassDeclarationPartContext differentiates from other interfaces.
	IsClassDeclarationPartContext()
}

type ClassDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationPartContext() *ClassDeclarationPartContext {
	var p = new(ClassDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classDeclarationPart
	return p
}

func InitEmptyClassDeclarationPartContext(p *ClassDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classDeclarationPart
}

func (*ClassDeclarationPartContext) IsClassDeclarationPartContext() {}

func NewClassDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationPartContext {
	var p = new(ClassDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classDeclarationPart

	return p
}

func (s *ClassDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationPartContext) TypedIdentifierList() ITypedIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIdentifierListContext)
}

func (s *ClassDeclarationPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ClassDeclarationPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ClassDeclarationPartContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *ClassDeclarationPartContext) TypeDefinitionPart() ITypeDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionPartContext)
}

func (s *ClassDeclarationPartContext) ConstantDefinitionPart() IConstantDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *ClassDeclarationPartContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *ClassDeclarationPartContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *ClassDeclarationPartContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *ClassDeclarationPartContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *ClassDeclarationPartContext) ErrorClassDeclarationPart() IErrorClassDeclarationPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorClassDeclarationPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorClassDeclarationPartContext)
}

func (s *ClassDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassDeclarationPart(s)
	}
}

func (s *ClassDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassDeclarationPart(s)
	}
}

func (s *ClassDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassDeclarationPart() (localctx IClassDeclarationPartContext) {
	localctx = NewClassDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, pascalParserRULE_classDeclarationPart)
	var _la int

	p.SetState(748)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(730)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(729)
				p.AttributeSection()
			}

		}
		{
			p.SetState(732)
			p.TypedIdentifierList()
		}
		{
			p.SetState(733)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(735)
			p.TypeDefinitionPart()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(736)
			p.ConstantDefinitionPart()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(737)
			p.FunctionHeader()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(738)
			p.ProcedureHeader()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(739)
			p.PropertyDeclaration()
		}
		{
			p.SetState(740)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(743)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(741)
				p.Match(pascalParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(742)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(745)
			p.ErrorClassDeclarationPart()
		}
		{
			p.SetState(746)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceGuidConstContext is an interface to support dynamic dispatch.
type IInterfaceGuidConstContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GUID_LITERAL() antlr.TerminalNode

	// IsInterfaceGuidConstContext differentiates from other interfaces.
	IsInterfaceGuidConstContext()
}

type InterfaceGuidConstContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceGuidConstContext() *InterfaceGuidConstContext {
	var p = new(InterfaceGuidConstContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceGuidConst
	return p
}

func InitEmptyInterfaceGuidConstContext(p *InterfaceGuidConstContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceGuidConst
}

func (*InterfaceGuidConstContext) IsInterfaceGuidConstContext() {}

func NewInterfaceGuidConstContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceGuidConstContext {
	var p = new(InterfaceGuidConstContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceGuidConst

	return p
}

func (s *InterfaceGuidConstContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceGuidConstContext) GUID_LITERAL() antlr.TerminalNode {
	return s.GetToken(pascalParserGUID_LITERAL, 0)
}

func (s *InterfaceGuidConstContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceGuidConstContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceGuidConstContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceGuidConst(s)
	}
}

func (s *InterfaceGuidConstContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceGuidConst(s)
	}
}

func (s *InterfaceGuidConstContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceGuidConst(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceGuidConst() (localctx IInterfaceGuidConstContext) {
	localctx = NewInterfaceGuidConstContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, pascalParserRULE_interfaceGuidConst)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(750)
		p.Match(pascalParserGUID_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceTypeContext is an interface to support dynamic dispatch.
type IInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	InterfaceDeclaration() IInterfaceDeclarationContext
	END() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	RPAREN() antlr.TerminalNode
	GUID_LITERAL() antlr.TerminalNode

	// IsInterfaceTypeContext differentiates from other interfaces.
	IsInterfaceTypeContext()
}

type InterfaceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceTypeContext() *InterfaceTypeContext {
	var p = new(InterfaceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceType
	return p
}

func InitEmptyInterfaceTypeContext(p *InterfaceTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceType
}

func (*InterfaceTypeContext) IsInterfaceTypeContext() {}

func NewInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceTypeContext {
	var p = new(InterfaceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceType

	return p
}

func (s *InterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceTypeContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(pascalParserINTERFACE, 0)
}

func (s *InterfaceTypeContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *InterfaceTypeContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *InterfaceTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *InterfaceTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InterfaceTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *InterfaceTypeContext) GUID_LITERAL() antlr.TerminalNode {
	return s.GetToken(pascalParserGUID_LITERAL, 0)
}

func (s *InterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceType(s)
	}
}

func (s *InterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceType(s)
	}
}

func (s *InterfaceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceType() (localctx IInterfaceTypeContext) {
	localctx = NewInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, pascalParserRULE_interfaceType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(752)
		p.Match(pascalParserINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(757)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(753)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(754)
			p.Identifier()
		}
		{
			p.SetState(755)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(760)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(759)
			p.Match(pascalParserGUID_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(762)
		p.InterfaceDeclaration()
	}
	{
		p.SetState(763)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInterfaceDeclarationPart() []IInterfaceDeclarationPartContext
	InterfaceDeclarationPart(i int) IInterfaceDeclarationPartContext

	// IsInterfaceDeclarationContext differentiates from other interfaces.
	IsInterfaceDeclarationContext()
}

type InterfaceDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclarationContext() *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceDeclaration
	return p
}

func InitEmptyInterfaceDeclarationContext(p *InterfaceDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceDeclaration
}

func (*InterfaceDeclarationContext) IsInterfaceDeclarationContext() {}

func NewInterfaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceDeclaration

	return p
}

func (s *InterfaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclarationContext) AllInterfaceDeclarationPart() []IInterfaceDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceDeclarationPartContext); ok {
			tst[i] = t.(IInterfaceDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceDeclarationContext) InterfaceDeclarationPart(i int) IInterfaceDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationPartContext)
}

func (s *InterfaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceDeclaration(s)
	}
}

func (s *InterfaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceDeclaration(s)
	}
}

func (s *InterfaceDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceDeclaration() (localctx IInterfaceDeclarationContext) {
	localctx = NewInterfaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, pascalParserRULE_interfaceDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(768)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-16386) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || _la == pascalParserNUM_REAL || _la == pascalParserUTF8BOM {
		{
			p.SetState(765)
			p.InterfaceDeclarationPart()
		}

		p.SetState(770)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceDeclarationPartContext is an interface to support dynamic dispatch.
type IInterfaceDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionHeader() IFunctionHeaderContext
	ProcedureHeader() IProcedureHeaderContext
	PropertyDeclaration() IPropertyDeclarationContext
	SEMI() antlr.TerminalNode
	ErrorInterfaceDeclarationPart() IErrorInterfaceDeclarationPartContext

	// IsInterfaceDeclarationPartContext differentiates from other interfaces.
	IsInterfaceDeclarationPartContext()
}

type InterfaceDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclarationPartContext() *InterfaceDeclarationPartContext {
	var p = new(InterfaceDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceDeclarationPart
	return p
}

func InitEmptyInterfaceDeclarationPartContext(p *InterfaceDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_interfaceDeclarationPart
}

func (*InterfaceDeclarationPartContext) IsInterfaceDeclarationPartContext() {}

func NewInterfaceDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclarationPartContext {
	var p = new(InterfaceDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_interfaceDeclarationPart

	return p
}

func (s *InterfaceDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclarationPartContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *InterfaceDeclarationPartContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *InterfaceDeclarationPartContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *InterfaceDeclarationPartContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *InterfaceDeclarationPartContext) ErrorInterfaceDeclarationPart() IErrorInterfaceDeclarationPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorInterfaceDeclarationPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorInterfaceDeclarationPartContext)
}

func (s *InterfaceDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInterfaceDeclarationPart(s)
	}
}

func (s *InterfaceDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInterfaceDeclarationPart(s)
	}
}

func (s *InterfaceDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInterfaceDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InterfaceDeclarationPart() (localctx IInterfaceDeclarationPartContext) {
	localctx = NewInterfaceDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, pascalParserRULE_interfaceDeclarationPart)
	p.SetState(779)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(771)
			p.FunctionHeader()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(772)
			p.ProcedureHeader()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(773)
			p.PropertyDeclaration()
		}
		{
			p.SetState(774)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(776)
			p.ErrorInterfaceDeclarationPart()
		}
		{
			p.SetState(777)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorInterfaceDeclarationPartContext is an interface to support dynamic dispatch.
type IErrorInterfaceDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEND() []antlr.TerminalNode
	END(i int) antlr.TerminalNode

	// IsErrorInterfaceDeclarationPartContext differentiates from other interfaces.
	IsErrorInterfaceDeclarationPartContext()
}

type ErrorInterfaceDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorInterfaceDeclarationPartContext() *ErrorInterfaceDeclarationPartContext {
	var p = new(ErrorInterfaceDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorInterfaceDeclarationPart
	return p
}

func InitEmptyErrorInterfaceDeclarationPartContext(p *ErrorInterfaceDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorInterfaceDeclarationPart
}

func (*ErrorInterfaceDeclarationPartContext) IsErrorInterfaceDeclarationPartContext() {}

func NewErrorInterfaceDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorInterfaceDeclarationPartContext {
	var p = new(ErrorInterfaceDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_errorInterfaceDeclarationPart

	return p
}

func (s *ErrorInterfaceDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorInterfaceDeclarationPartContext) AllEND() []antlr.TerminalNode {
	return s.GetTokens(pascalParserEND)
}

func (s *ErrorInterfaceDeclarationPartContext) END(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserEND, i)
}

func (s *ErrorInterfaceDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorInterfaceDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorInterfaceDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterErrorInterfaceDeclarationPart(s)
	}
}

func (s *ErrorInterfaceDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitErrorInterfaceDeclarationPart(s)
	}
}

func (s *ErrorInterfaceDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitErrorInterfaceDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ErrorInterfaceDeclarationPart() (localctx IErrorInterfaceDeclarationPartContext) {
	localctx = NewErrorInterfaceDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, pascalParserRULE_errorInterfaceDeclarationPart)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(782)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(781)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || _la == pascalParserEND {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(784)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorClassDeclarationPartContext is an interface to support dynamic dispatch.
type IErrorClassDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRICT() []antlr.TerminalNode
	STRICT(i int) antlr.TerminalNode
	AllPRIVATE() []antlr.TerminalNode
	PRIVATE(i int) antlr.TerminalNode
	AllPROTECTED() []antlr.TerminalNode
	PROTECTED(i int) antlr.TerminalNode
	AllPUBLIC() []antlr.TerminalNode
	PUBLIC(i int) antlr.TerminalNode
	AllPUBLISHED() []antlr.TerminalNode
	PUBLISHED(i int) antlr.TerminalNode
	AllEND() []antlr.TerminalNode
	END(i int) antlr.TerminalNode

	// IsErrorClassDeclarationPartContext differentiates from other interfaces.
	IsErrorClassDeclarationPartContext()
}

type ErrorClassDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorClassDeclarationPartContext() *ErrorClassDeclarationPartContext {
	var p = new(ErrorClassDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorClassDeclarationPart
	return p
}

func InitEmptyErrorClassDeclarationPartContext(p *ErrorClassDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorClassDeclarationPart
}

func (*ErrorClassDeclarationPartContext) IsErrorClassDeclarationPartContext() {}

func NewErrorClassDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorClassDeclarationPartContext {
	var p = new(ErrorClassDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_errorClassDeclarationPart

	return p
}

func (s *ErrorClassDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorClassDeclarationPartContext) AllSTRICT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTRICT)
}

func (s *ErrorClassDeclarationPartContext) STRICT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTRICT, i)
}

func (s *ErrorClassDeclarationPartContext) AllPRIVATE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPRIVATE)
}

func (s *ErrorClassDeclarationPartContext) PRIVATE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPRIVATE, i)
}

func (s *ErrorClassDeclarationPartContext) AllPROTECTED() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPROTECTED)
}

func (s *ErrorClassDeclarationPartContext) PROTECTED(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPROTECTED, i)
}

func (s *ErrorClassDeclarationPartContext) AllPUBLIC() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPUBLIC)
}

func (s *ErrorClassDeclarationPartContext) PUBLIC(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLIC, i)
}

func (s *ErrorClassDeclarationPartContext) AllPUBLISHED() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPUBLISHED)
}

func (s *ErrorClassDeclarationPartContext) PUBLISHED(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLISHED, i)
}

func (s *ErrorClassDeclarationPartContext) AllEND() []antlr.TerminalNode {
	return s.GetTokens(pascalParserEND)
}

func (s *ErrorClassDeclarationPartContext) END(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserEND, i)
}

func (s *ErrorClassDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorClassDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorClassDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterErrorClassDeclarationPart(s)
	}
}

func (s *ErrorClassDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitErrorClassDeclarationPart(s)
	}
}

func (s *ErrorClassDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitErrorClassDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ErrorClassDeclarationPart() (localctx IErrorClassDeclarationPartContext) {
	localctx = NewErrorClassDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, pascalParserRULE_errorClassDeclarationPart)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(787)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(786)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || _la == pascalParserEND || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&31) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(789)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyDeclarationContext is an interface to support dynamic dispatch.
type IPropertyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROPERTY() antlr.TerminalNode
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	PropertyIndexParameters() IPropertyIndexParametersContext
	PropertyReadDeclaration() IPropertyReadDeclarationContext
	PropertyWriteDeclaration() IPropertyWriteDeclarationContext
	PropertyDefaultValueDeclaration() IPropertyDefaultValueDeclarationContext
	PropertyIndexDeclaration() IPropertyIndexDeclarationContext
	SEMI() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode

	// IsPropertyDeclarationContext differentiates from other interfaces.
	IsPropertyDeclarationContext()
}

type PropertyDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDeclarationContext() *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDeclaration
	return p
}

func InitEmptyPropertyDeclarationContext(p *PropertyDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDeclaration
}

func (*PropertyDeclarationContext) IsPropertyDeclarationContext() {}

func NewPropertyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyDeclaration

	return p
}

func (s *PropertyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDeclarationContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(pascalParserPROPERTY, 0)
}

func (s *PropertyDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *PropertyDeclarationContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *PropertyDeclarationContext) PropertyIndexParameters() IPropertyIndexParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyIndexParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyIndexParametersContext)
}

func (s *PropertyDeclarationContext) PropertyReadDeclaration() IPropertyReadDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyReadDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyReadDeclarationContext)
}

func (s *PropertyDeclarationContext) PropertyWriteDeclaration() IPropertyWriteDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyWriteDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyWriteDeclarationContext)
}

func (s *PropertyDeclarationContext) PropertyDefaultValueDeclaration() IPropertyDefaultValueDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDefaultValueDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDefaultValueDeclarationContext)
}

func (s *PropertyDeclarationContext) PropertyIndexDeclaration() IPropertyIndexDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyIndexDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyIndexDeclarationContext)
}

func (s *PropertyDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *PropertyDeclarationContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *PropertyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyDeclaration(s)
	}
}

func (s *PropertyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyDeclaration(s)
	}
}

func (s *PropertyDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyDeclaration() (localctx IPropertyDeclarationContext) {
	localctx = NewPropertyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, pascalParserRULE_propertyDeclaration)
	var _la int

	p.SetState(819)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(791)
			p.Match(pascalParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(792)
			p.Identifier()
		}
		p.SetState(794)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(793)
				p.PropertyIndexParameters()
			}

		}
		{
			p.SetState(796)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(797)
			p.TypeIdentifier()
		}
		p.SetState(799)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserREAD {
			{
				p.SetState(798)
				p.PropertyReadDeclaration()
			}

		}
		p.SetState(802)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserWRITE {
			{
				p.SetState(801)
				p.PropertyWriteDeclaration()
			}

		}
		p.SetState(805)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserDEFAULT {
			{
				p.SetState(804)
				p.PropertyDefaultValueDeclaration()
			}

		}
		p.SetState(808)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserINDEX {
			{
				p.SetState(807)
				p.PropertyIndexDeclaration()
			}

		}
		p.SetState(812)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(810)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(811)
				p.Match(pascalParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(814)
			p.Match(pascalParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(815)
			p.Identifier()
		}
		p.SetState(817)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserDEFAULT {
			{
				p.SetState(816)
				p.PropertyDefaultValueDeclaration()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyReadDeclarationContext is an interface to support dynamic dispatch.
type IPropertyReadDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsPropertyReadDeclarationContext differentiates from other interfaces.
	IsPropertyReadDeclarationContext()
}

type PropertyReadDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyReadDeclarationContext() *PropertyReadDeclarationContext {
	var p = new(PropertyReadDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyReadDeclaration
	return p
}

func InitEmptyPropertyReadDeclarationContext(p *PropertyReadDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyReadDeclaration
}

func (*PropertyReadDeclarationContext) IsPropertyReadDeclarationContext() {}

func NewPropertyReadDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyReadDeclarationContext {
	var p = new(PropertyReadDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyReadDeclaration

	return p
}

func (s *PropertyReadDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyReadDeclarationContext) READ() antlr.TerminalNode {
	return s.GetToken(pascalParserREAD, 0)
}

func (s *PropertyReadDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyReadDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyReadDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyReadDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyReadDeclaration(s)
	}
}

func (s *PropertyReadDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyReadDeclaration(s)
	}
}

func (s *PropertyReadDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyReadDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyReadDeclaration() (localctx IPropertyReadDeclarationContext) {
	localctx = NewPropertyReadDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, pascalParserRULE_propertyReadDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(821)
		p.Match(pascalParserREAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(822)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyWriteDeclarationContext is an interface to support dynamic dispatch.
type IPropertyWriteDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WRITE() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsPropertyWriteDeclarationContext differentiates from other interfaces.
	IsPropertyWriteDeclarationContext()
}

type PropertyWriteDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyWriteDeclarationContext() *PropertyWriteDeclarationContext {
	var p = new(PropertyWriteDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyWriteDeclaration
	return p
}

func InitEmptyPropertyWriteDeclarationContext(p *PropertyWriteDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyWriteDeclaration
}

func (*PropertyWriteDeclarationContext) IsPropertyWriteDeclarationContext() {}

func NewPropertyWriteDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyWriteDeclarationContext {
	var p = new(PropertyWriteDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyWriteDeclaration

	return p
}

func (s *PropertyWriteDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyWriteDeclarationContext) WRITE() antlr.TerminalNode {
	return s.GetToken(pascalParserWRITE, 0)
}

func (s *PropertyWriteDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyWriteDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyWriteDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyWriteDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyWriteDeclaration(s)
	}
}

func (s *PropertyWriteDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyWriteDeclaration(s)
	}
}

func (s *PropertyWriteDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyWriteDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyWriteDeclaration() (localctx IPropertyWriteDeclarationContext) {
	localctx = NewPropertyWriteDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, pascalParserRULE_propertyWriteDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(824)
		p.Match(pascalParserWRITE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(825)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyDefaultValueDeclarationContext is an interface to support dynamic dispatch.
type IPropertyDefaultValueDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	Expression() IExpressionContext

	// IsPropertyDefaultValueDeclarationContext differentiates from other interfaces.
	IsPropertyDefaultValueDeclarationContext()
}

type PropertyDefaultValueDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDefaultValueDeclarationContext() *PropertyDefaultValueDeclarationContext {
	var p = new(PropertyDefaultValueDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDefaultValueDeclaration
	return p
}

func InitEmptyPropertyDefaultValueDeclarationContext(p *PropertyDefaultValueDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDefaultValueDeclaration
}

func (*PropertyDefaultValueDeclarationContext) IsPropertyDefaultValueDeclarationContext() {}

func NewPropertyDefaultValueDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDefaultValueDeclarationContext {
	var p = new(PropertyDefaultValueDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyDefaultValueDeclaration

	return p
}

func (s *PropertyDefaultValueDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDefaultValueDeclarationContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *PropertyDefaultValueDeclarationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PropertyDefaultValueDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDefaultValueDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyDefaultValueDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyDefaultValueDeclaration(s)
	}
}

func (s *PropertyDefaultValueDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyDefaultValueDeclaration(s)
	}
}

func (s *PropertyDefaultValueDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyDefaultValueDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyDefaultValueDeclaration() (localctx IPropertyDefaultValueDeclarationContext) {
	localctx = NewPropertyDefaultValueDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, pascalParserRULE_propertyDefaultValueDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(827)
		p.Match(pascalParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(828)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyIndexDeclarationContext is an interface to support dynamic dispatch.
type IPropertyIndexDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INDEX() antlr.TerminalNode
	UnsignedNumber() IUnsignedNumberContext

	// IsPropertyIndexDeclarationContext differentiates from other interfaces.
	IsPropertyIndexDeclarationContext()
}

type PropertyIndexDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyIndexDeclarationContext() *PropertyIndexDeclarationContext {
	var p = new(PropertyIndexDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexDeclaration
	return p
}

func InitEmptyPropertyIndexDeclarationContext(p *PropertyIndexDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexDeclaration
}

func (*PropertyIndexDeclarationContext) IsPropertyIndexDeclarationContext() {}

func NewPropertyIndexDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyIndexDeclarationContext {
	var p = new(PropertyIndexDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyIndexDeclaration

	return p
}

func (s *PropertyIndexDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyIndexDeclarationContext) INDEX() antlr.TerminalNode {
	return s.GetToken(pascalParserINDEX, 0)
}

func (s *PropertyIndexDeclarationContext) UnsignedNumber() IUnsignedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedNumberContext)
}

func (s *PropertyIndexDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyIndexDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyIndexDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyIndexDeclaration(s)
	}
}

func (s *PropertyIndexDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyIndexDeclaration(s)
	}
}

func (s *PropertyIndexDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyIndexDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyIndexDeclaration() (localctx IPropertyIndexDeclarationContext) {
	localctx = NewPropertyIndexDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, pascalParserRULE_propertyIndexDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(830)
		p.Match(pascalParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(831)
		p.UnsignedNumber()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyIndexParametersContext is an interface to support dynamic dispatch.
type IPropertyIndexParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	AllFormalParameterSection() []IFormalParameterSectionContext
	FormalParameterSection(i int) IFormalParameterSectionContext
	RBRACK() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPropertyIndexParametersContext differentiates from other interfaces.
	IsPropertyIndexParametersContext()
}

type PropertyIndexParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyIndexParametersContext() *PropertyIndexParametersContext {
	var p = new(PropertyIndexParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexParameters
	return p
}

func InitEmptyPropertyIndexParametersContext(p *PropertyIndexParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexParameters
}

func (*PropertyIndexParametersContext) IsPropertyIndexParametersContext() {}

func NewPropertyIndexParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyIndexParametersContext {
	var p = new(PropertyIndexParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyIndexParameters

	return p
}

func (s *PropertyIndexParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyIndexParametersContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *PropertyIndexParametersContext) AllFormalParameterSection() []IFormalParameterSectionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormalParameterSectionContext); ok {
			len++
		}
	}

	tst := make([]IFormalParameterSectionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormalParameterSectionContext); ok {
			tst[i] = t.(IFormalParameterSectionContext)
			i++
		}
	}

	return tst
}

func (s *PropertyIndexParametersContext) FormalParameterSection(i int) IFormalParameterSectionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterSectionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterSectionContext)
}

func (s *PropertyIndexParametersContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *PropertyIndexParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *PropertyIndexParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *PropertyIndexParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyIndexParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyIndexParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyIndexParameters(s)
	}
}

func (s *PropertyIndexParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyIndexParameters(s)
	}
}

func (s *PropertyIndexParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyIndexParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyIndexParameters() (localctx IPropertyIndexParametersContext) {
	localctx = NewPropertyIndexParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, pascalParserRULE_propertyIndexParameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(833)
		p.Match(pascalParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(834)
		p.FormalParameterSection()
	}
	p.SetState(839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(835)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(836)
			p.FormalParameterSection()
		}

		p.SetState(841)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(842)
		p.Match(pascalParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyIndexParametersListContext is an interface to support dynamic dispatch.
type IPropertyIndexParametersListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierList() []IIdentifierListContext
	IdentifierList(i int) IIdentifierListContext
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllIndexType() []IIndexTypeContext
	IndexType(i int) IIndexTypeContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsPropertyIndexParametersListContext differentiates from other interfaces.
	IsPropertyIndexParametersListContext()
}

type PropertyIndexParametersListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyIndexParametersListContext() *PropertyIndexParametersListContext {
	var p = new(PropertyIndexParametersListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexParametersList
	return p
}

func InitEmptyPropertyIndexParametersListContext(p *PropertyIndexParametersListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyIndexParametersList
}

func (*PropertyIndexParametersListContext) IsPropertyIndexParametersListContext() {}

func NewPropertyIndexParametersListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyIndexParametersListContext {
	var p = new(PropertyIndexParametersListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyIndexParametersList

	return p
}

func (s *PropertyIndexParametersListContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyIndexParametersListContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *PropertyIndexParametersListContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PropertyIndexParametersListContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOLON)
}

func (s *PropertyIndexParametersListContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, i)
}

func (s *PropertyIndexParametersListContext) AllIndexType() []IIndexTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexTypeContext); ok {
			len++
		}
	}

	tst := make([]IIndexTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexTypeContext); ok {
			tst[i] = t.(IIndexTypeContext)
			i++
		}
	}

	return tst
}

func (s *PropertyIndexParametersListContext) IndexType(i int) IIndexTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *PropertyIndexParametersListContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *PropertyIndexParametersListContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *PropertyIndexParametersListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyIndexParametersListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyIndexParametersListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyIndexParametersList(s)
	}
}

func (s *PropertyIndexParametersListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyIndexParametersList(s)
	}
}

func (s *PropertyIndexParametersListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyIndexParametersList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyIndexParametersList() (localctx IPropertyIndexParametersListContext) {
	localctx = NewPropertyIndexParametersListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, pascalParserRULE_propertyIndexParametersList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(844)
		p.IdentifierList()
	}
	{
		p.SetState(845)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(846)
		p.IndexType()
	}
	p.SetState(854)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserSEMI {
		{
			p.SetState(847)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(848)
			p.IdentifierList()
		}
		{
			p.SetState(849)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(850)
			p.IndexType()
		}

		p.SetState(856)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericTemplateContext is an interface to support dynamic dispatch.
type IGenericTemplateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	GenericTemplateList() IGenericTemplateListContext
	GT() antlr.TerminalNode

	// IsGenericTemplateContext differentiates from other interfaces.
	IsGenericTemplateContext()
}

type GenericTemplateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericTemplateContext() *GenericTemplateContext {
	var p = new(GenericTemplateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericTemplate
	return p
}

func InitEmptyGenericTemplateContext(p *GenericTemplateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericTemplate
}

func (*GenericTemplateContext) IsGenericTemplateContext() {}

func NewGenericTemplateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericTemplateContext {
	var p = new(GenericTemplateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_genericTemplate

	return p
}

func (s *GenericTemplateContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericTemplateContext) LT() antlr.TerminalNode {
	return s.GetToken(pascalParserLT, 0)
}

func (s *GenericTemplateContext) GenericTemplateList() IGenericTemplateListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericTemplateListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericTemplateListContext)
}

func (s *GenericTemplateContext) GT() antlr.TerminalNode {
	return s.GetToken(pascalParserGT, 0)
}

func (s *GenericTemplateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericTemplateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericTemplateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterGenericTemplate(s)
	}
}

func (s *GenericTemplateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitGenericTemplate(s)
	}
}

func (s *GenericTemplateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitGenericTemplate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) GenericTemplate() (localctx IGenericTemplateContext) {
	localctx = NewGenericTemplateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, pascalParserRULE_genericTemplate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(857)
		p.Match(pascalParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(858)
		p.GenericTemplateList()
	}
	{
		p.SetState(859)
		p.Match(pascalParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericTemplateListContext is an interface to support dynamic dispatch.
type IGenericTemplateListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGenericTypeParameter() []IGenericTypeParameterContext
	GenericTypeParameter(i int) IGenericTypeParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGenericTemplateListContext differentiates from other interfaces.
	IsGenericTemplateListContext()
}

type GenericTemplateListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericTemplateListContext() *GenericTemplateListContext {
	var p = new(GenericTemplateListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericTemplateList
	return p
}

func InitEmptyGenericTemplateListContext(p *GenericTemplateListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericTemplateList
}

func (*GenericTemplateListContext) IsGenericTemplateListContext() {}

func NewGenericTemplateListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericTemplateListContext {
	var p = new(GenericTemplateListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_genericTemplateList

	return p
}

func (s *GenericTemplateListContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericTemplateListContext) AllGenericTypeParameter() []IGenericTypeParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGenericTypeParameterContext); ok {
			len++
		}
	}

	tst := make([]IGenericTypeParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGenericTypeParameterContext); ok {
			tst[i] = t.(IGenericTypeParameterContext)
			i++
		}
	}

	return tst
}

func (s *GenericTemplateListContext) GenericTypeParameter(i int) IGenericTypeParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericTypeParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericTypeParameterContext)
}

func (s *GenericTemplateListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *GenericTemplateListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *GenericTemplateListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericTemplateListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericTemplateListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterGenericTemplateList(s)
	}
}

func (s *GenericTemplateListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitGenericTemplateList(s)
	}
}

func (s *GenericTemplateListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitGenericTemplateList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) GenericTemplateList() (localctx IGenericTemplateListContext) {
	localctx = NewGenericTemplateListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, pascalParserRULE_genericTemplateList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(861)
		p.GenericTypeParameter()
	}
	p.SetState(866)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(862)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(863)
			p.GenericTypeParameter()
		}

		p.SetState(868)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericTypeParameterContext is an interface to support dynamic dispatch.
type IGenericTypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIdentifier() ITypeIdentifierContext
	COLON() antlr.TerminalNode
	GenericConstraints() IGenericConstraintsContext

	// IsGenericTypeParameterContext differentiates from other interfaces.
	IsGenericTypeParameterContext()
}

type GenericTypeParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericTypeParameterContext() *GenericTypeParameterContext {
	var p = new(GenericTypeParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericTypeParameter
	return p
}

func InitEmptyGenericTypeParameterContext(p *GenericTypeParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericTypeParameter
}

func (*GenericTypeParameterContext) IsGenericTypeParameterContext() {}

func NewGenericTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericTypeParameterContext {
	var p = new(GenericTypeParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_genericTypeParameter

	return p
}

func (s *GenericTypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericTypeParameterContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *GenericTypeParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *GenericTypeParameterContext) GenericConstraints() IGenericConstraintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericConstraintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericConstraintsContext)
}

func (s *GenericTypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericTypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericTypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterGenericTypeParameter(s)
	}
}

func (s *GenericTypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitGenericTypeParameter(s)
	}
}

func (s *GenericTypeParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitGenericTypeParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) GenericTypeParameter() (localctx IGenericTypeParameterContext) {
	localctx = NewGenericTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, pascalParserRULE_genericTypeParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(869)
		p.TypeIdentifier()
	}
	p.SetState(872)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserCOLON {
		{
			p.SetState(870)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(871)
			p.GenericConstraints()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericConstraintsContext is an interface to support dynamic dispatch.
type IGenericConstraintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGenericConstraint() []IGenericConstraintContext
	GenericConstraint(i int) IGenericConstraintContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGenericConstraintsContext differentiates from other interfaces.
	IsGenericConstraintsContext()
}

type GenericConstraintsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericConstraintsContext() *GenericConstraintsContext {
	var p = new(GenericConstraintsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericConstraints
	return p
}

func InitEmptyGenericConstraintsContext(p *GenericConstraintsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericConstraints
}

func (*GenericConstraintsContext) IsGenericConstraintsContext() {}

func NewGenericConstraintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericConstraintsContext {
	var p = new(GenericConstraintsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_genericConstraints

	return p
}

func (s *GenericConstraintsContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericConstraintsContext) AllGenericConstraint() []IGenericConstraintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGenericConstraintContext); ok {
			len++
		}
	}

	tst := make([]IGenericConstraintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGenericConstraintContext); ok {
			tst[i] = t.(IGenericConstraintContext)
			i++
		}
	}

	return tst
}

func (s *GenericConstraintsContext) GenericConstraint(i int) IGenericConstraintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericConstraintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericConstraintContext)
}

func (s *GenericConstraintsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *GenericConstraintsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *GenericConstraintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericConstraintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericConstraintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterGenericConstraints(s)
	}
}

func (s *GenericConstraintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitGenericConstraints(s)
	}
}

func (s *GenericConstraintsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitGenericConstraints(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) GenericConstraints() (localctx IGenericConstraintsContext) {
	localctx = NewGenericConstraintsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, pascalParserRULE_genericConstraints)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(874)
		p.GenericConstraint()
	}
	p.SetState(879)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(875)
				p.Match(pascalParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(876)
				p.GenericConstraint()
			}

		}
		p.SetState(881)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericConstraintContext is an interface to support dynamic dispatch.
type IGenericConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONSTRUCTOR() antlr.TerminalNode
	CLASS() antlr.TerminalNode
	RECORD() antlr.TerminalNode
	OF() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext

	// IsGenericConstraintContext differentiates from other interfaces.
	IsGenericConstraintContext()
}

type GenericConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericConstraintContext() *GenericConstraintContext {
	var p = new(GenericConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericConstraint
	return p
}

func InitEmptyGenericConstraintContext(p *GenericConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_genericConstraint
}

func (*GenericConstraintContext) IsGenericConstraintContext() {}

func NewGenericConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericConstraintContext {
	var p = new(GenericConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_genericConstraint

	return p
}

func (s *GenericConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericConstraintContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(pascalParserCONSTRUCTOR, 0)
}

func (s *GenericConstraintContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *GenericConstraintContext) RECORD() antlr.TerminalNode {
	return s.GetToken(pascalParserRECORD, 0)
}

func (s *GenericConstraintContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *GenericConstraintContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *GenericConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterGenericConstraint(s)
	}
}

func (s *GenericConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitGenericConstraint(s)
	}
}

func (s *GenericConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitGenericConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) GenericConstraint() (localctx IGenericConstraintContext) {
	localctx = NewGenericConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, pascalParserRULE_genericConstraint)
	p.SetState(889)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(882)
			p.Match(pascalParserCONSTRUCTOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(883)
			p.Match(pascalParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(884)
			p.Match(pascalParserRECORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(885)
			p.Match(pascalParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(886)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(887)
			p.TypeIdentifier()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(888)
			p.TypeIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_Context is an interface to support dynamic dispatch.
type IType_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleType() ISimpleTypeContext
	StructuredType() IStructuredTypeContext
	PointerType() IPointerTypeContext

	// IsType_Context differentiates from other interfaces.
	IsType_Context()
}

type Type_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_Context() *Type_Context {
	var p = new(Type_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_type_
	return p
}

func InitEmptyType_Context(p *Type_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_type_
}

func (*Type_Context) IsType_Context() {}

func NewType_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_Context {
	var p = new(Type_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_type_

	return p
}

func (s *Type_Context) GetParser() antlr.Parser { return s.parser }

func (s *Type_Context) SimpleType() ISimpleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeContext)
}

func (s *Type_Context) StructuredType() IStructuredTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructuredTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructuredTypeContext)
}

func (s *Type_Context) PointerType() IPointerTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerTypeContext)
}

func (s *Type_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterType_(s)
	}
}

func (s *Type_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitType_(s)
	}
}

func (s *Type_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitType_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Type_() (localctx IType_Context) {
	localctx = NewType_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, pascalParserRULE_type_)
	p.SetState(894)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(891)
			p.SimpleType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(892)
			p.StructuredType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(893)
			p.PointerType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleTypeContext is an interface to support dynamic dispatch.
type ISimpleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ScalarType() IScalarTypeContext
	SubrangeType() ISubrangeTypeContext
	TypeIdentifier() ITypeIdentifierContext
	Stringtype() IStringtypeContext

	// IsSimpleTypeContext differentiates from other interfaces.
	IsSimpleTypeContext()
}

type SimpleTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleTypeContext() *SimpleTypeContext {
	var p = new(SimpleTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleType
	return p
}

func InitEmptySimpleTypeContext(p *SimpleTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleType
}

func (*SimpleTypeContext) IsSimpleTypeContext() {}

func NewSimpleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleTypeContext {
	var p = new(SimpleTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_simpleType

	return p
}

func (s *SimpleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleTypeContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *SimpleTypeContext) SubrangeType() ISubrangeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubrangeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubrangeTypeContext)
}

func (s *SimpleTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *SimpleTypeContext) Stringtype() IStringtypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringtypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringtypeContext)
}

func (s *SimpleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSimpleType(s)
	}
}

func (s *SimpleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSimpleType(s)
	}
}

func (s *SimpleTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSimpleType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SimpleType() (localctx ISimpleTypeContext) {
	localctx = NewSimpleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, pascalParserRULE_simpleType)
	p.SetState(900)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(896)
			p.ScalarType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(897)
			p.SubrangeType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(898)
			p.TypeIdentifier()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(899)
			p.Stringtype()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScalarTypeContext is an interface to support dynamic dispatch.
type IScalarTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	ScalerList() IScalerListContext
	RPAREN() antlr.TerminalNode

	// IsScalarTypeContext differentiates from other interfaces.
	IsScalarTypeContext()
}

type ScalarTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalarTypeContext() *ScalarTypeContext {
	var p = new(ScalarTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalarType
	return p
}

func InitEmptyScalarTypeContext(p *ScalarTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalarType
}

func (*ScalarTypeContext) IsScalarTypeContext() {}

func NewScalarTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalarTypeContext {
	var p = new(ScalarTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_scalarType

	return p
}

func (s *ScalarTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalarTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ScalarTypeContext) ScalerList() IScalerListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalerListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalerListContext)
}

func (s *ScalarTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ScalarTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalarTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterScalarType(s)
	}
}

func (s *ScalarTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitScalarType(s)
	}
}

func (s *ScalarTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitScalarType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ScalarType() (localctx IScalarTypeContext) {
	localctx = NewScalarTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, pascalParserRULE_scalarType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(902)
		p.Match(pascalParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(903)
		p.ScalerList()
	}
	{
		p.SetState(904)
		p.Match(pascalParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScalerListContext is an interface to support dynamic dispatch.
type IScalerListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllScalerMember() []IScalerMemberContext
	ScalerMember(i int) IScalerMemberContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsScalerListContext differentiates from other interfaces.
	IsScalerListContext()
}

type ScalerListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalerListContext() *ScalerListContext {
	var p = new(ScalerListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalerList
	return p
}

func InitEmptyScalerListContext(p *ScalerListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalerList
}

func (*ScalerListContext) IsScalerListContext() {}

func NewScalerListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalerListContext {
	var p = new(ScalerListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_scalerList

	return p
}

func (s *ScalerListContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalerListContext) AllScalerMember() []IScalerMemberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScalerMemberContext); ok {
			len++
		}
	}

	tst := make([]IScalerMemberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScalerMemberContext); ok {
			tst[i] = t.(IScalerMemberContext)
			i++
		}
	}

	return tst
}

func (s *ScalerListContext) ScalerMember(i int) IScalerMemberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalerMemberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalerMemberContext)
}

func (s *ScalerListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ScalerListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ScalerListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalerListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalerListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterScalerList(s)
	}
}

func (s *ScalerListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitScalerList(s)
	}
}

func (s *ScalerListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitScalerList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ScalerList() (localctx IScalerListContext) {
	localctx = NewScalerListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, pascalParserRULE_scalerList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(906)
		p.ScalerMember()
	}
	p.SetState(911)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(907)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(908)
			p.ScalerMember()
		}

		p.SetState(913)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScalerMemberContext is an interface to support dynamic dispatch.
type IScalerMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQUAL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsScalerMemberContext differentiates from other interfaces.
	IsScalerMemberContext()
}

type ScalerMemberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalerMemberContext() *ScalerMemberContext {
	var p = new(ScalerMemberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalerMember
	return p
}

func InitEmptyScalerMemberContext(p *ScalerMemberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_scalerMember
}

func (*ScalerMemberContext) IsScalerMemberContext() {}

func NewScalerMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalerMemberContext {
	var p = new(ScalerMemberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_scalerMember

	return p
}

func (s *ScalerMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalerMemberContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScalerMemberContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *ScalerMemberContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ScalerMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalerMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalerMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterScalerMember(s)
	}
}

func (s *ScalerMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitScalerMember(s)
	}
}

func (s *ScalerMemberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitScalerMember(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ScalerMember() (localctx IScalerMemberContext) {
	localctx = NewScalerMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, pascalParserRULE_scalerMember)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(914)
		p.Identifier()
	}
	p.SetState(917)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserEQUAL {
		{
			p.SetState(915)
			p.Match(pascalParserEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(916)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubrangeTypeContext is an interface to support dynamic dispatch.
type ISubrangeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSimpleExpression() []ISimpleExpressionContext
	SimpleExpression(i int) ISimpleExpressionContext
	DOTDOT() antlr.TerminalNode

	// IsSubrangeTypeContext differentiates from other interfaces.
	IsSubrangeTypeContext()
}

type SubrangeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubrangeTypeContext() *SubrangeTypeContext {
	var p = new(SubrangeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_subrangeType
	return p
}

func InitEmptySubrangeTypeContext(p *SubrangeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_subrangeType
}

func (*SubrangeTypeContext) IsSubrangeTypeContext() {}

func NewSubrangeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubrangeTypeContext {
	var p = new(SubrangeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_subrangeType

	return p
}

func (s *SubrangeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SubrangeTypeContext) AllSimpleExpression() []ISimpleExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			len++
		}
	}

	tst := make([]ISimpleExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleExpressionContext); ok {
			tst[i] = t.(ISimpleExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SubrangeTypeContext) SimpleExpression(i int) ISimpleExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExpressionContext)
}

func (s *SubrangeTypeContext) DOTDOT() antlr.TerminalNode {
	return s.GetToken(pascalParserDOTDOT, 0)
}

func (s *SubrangeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubrangeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubrangeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSubrangeType(s)
	}
}

func (s *SubrangeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSubrangeType(s)
	}
}

func (s *SubrangeTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSubrangeType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SubrangeType() (localctx ISubrangeTypeContext) {
	localctx = NewSubrangeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, pascalParserRULE_subrangeType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(919)
		p.SimpleExpression()
	}
	{
		p.SetState(920)
		p.Match(pascalParserDOTDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(921)
		p.SimpleExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeIdentifierContext is an interface to support dynamic dispatch.
type ITypeIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	CHAR() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	REAL() antlr.TerminalNode
	STRING() antlr.TerminalNode
	CARDINAL() antlr.TerminalNode
	LONGBOOL() antlr.TerminalNode
	LONGINT() antlr.TerminalNode
	ArrayType() IArrayTypeContext

	// IsTypeIdentifierContext differentiates from other interfaces.
	IsTypeIdentifierContext()
}

type TypeIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeIdentifierContext() *TypeIdentifierContext {
	var p = new(TypeIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeIdentifier
	return p
}

func InitEmptyTypeIdentifierContext(p *TypeIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeIdentifier
}

func (*TypeIdentifierContext) IsTypeIdentifierContext() {}

func NewTypeIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeIdentifierContext {
	var p = new(TypeIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typeIdentifier

	return p
}

func (s *TypeIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeIdentifierContext) CHAR() antlr.TerminalNode {
	return s.GetToken(pascalParserCHAR, 0)
}

func (s *TypeIdentifierContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(pascalParserBOOLEAN, 0)
}

func (s *TypeIdentifierContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(pascalParserINTEGER, 0)
}

func (s *TypeIdentifierContext) REAL() antlr.TerminalNode {
	return s.GetToken(pascalParserREAL, 0)
}

func (s *TypeIdentifierContext) STRING() antlr.TerminalNode {
	return s.GetToken(pascalParserSTRING, 0)
}

func (s *TypeIdentifierContext) CARDINAL() antlr.TerminalNode {
	return s.GetToken(pascalParserCARDINAL, 0)
}

func (s *TypeIdentifierContext) LONGBOOL() antlr.TerminalNode {
	return s.GetToken(pascalParserLONGBOOL, 0)
}

func (s *TypeIdentifierContext) LONGINT() antlr.TerminalNode {
	return s.GetToken(pascalParserLONGINT, 0)
}

func (s *TypeIdentifierContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *TypeIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypeIdentifier(s)
	}
}

func (s *TypeIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypeIdentifier(s)
	}
}

func (s *TypeIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypeIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypeIdentifier() (localctx ITypeIdentifierContext) {
	localctx = NewTypeIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, pascalParserRULE_typeIdentifier)
	var _la int

	p.SetState(926)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(923)
			p.Identifier()
		}

	case pascalParserBOOLEAN, pascalParserCHAR, pascalParserINTEGER, pascalParserREAL, pascalParserSTRING, pascalParserCARDINAL, pascalParserLONGBOOL, pascalParserLONGINT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(924)
			_la = p.GetTokenStream().LA(1)

			if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4299161760) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&15393162788865) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case pascalParserARRAY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(925)
			p.ArrayType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructuredTypeContext is an interface to support dynamic dispatch.
type IStructuredTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PACKED() antlr.TerminalNode
	UnpackedStructuredType() IUnpackedStructuredTypeContext
	HelperType() IHelperTypeContext
	ClassType() IClassTypeContext
	RecordType() IRecordTypeContext
	InterfaceType() IInterfaceTypeContext

	// IsStructuredTypeContext differentiates from other interfaces.
	IsStructuredTypeContext()
}

type StructuredTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructuredTypeContext() *StructuredTypeContext {
	var p = new(StructuredTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_structuredType
	return p
}

func InitEmptyStructuredTypeContext(p *StructuredTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_structuredType
}

func (*StructuredTypeContext) IsStructuredTypeContext() {}

func NewStructuredTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructuredTypeContext {
	var p = new(StructuredTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_structuredType

	return p
}

func (s *StructuredTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StructuredTypeContext) PACKED() antlr.TerminalNode {
	return s.GetToken(pascalParserPACKED, 0)
}

func (s *StructuredTypeContext) UnpackedStructuredType() IUnpackedStructuredTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnpackedStructuredTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnpackedStructuredTypeContext)
}

func (s *StructuredTypeContext) HelperType() IHelperTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelperTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelperTypeContext)
}

func (s *StructuredTypeContext) ClassType() IClassTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassTypeContext)
}

func (s *StructuredTypeContext) RecordType() IRecordTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordTypeContext)
}

func (s *StructuredTypeContext) InterfaceType() IInterfaceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceTypeContext)
}

func (s *StructuredTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructuredTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructuredTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStructuredType(s)
	}
}

func (s *StructuredTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStructuredType(s)
	}
}

func (s *StructuredTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStructuredType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) StructuredType() (localctx IStructuredTypeContext) {
	localctx = NewStructuredTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, pascalParserRULE_structuredType)
	var _la int

	p.SetState(938)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(928)
			p.Match(pascalParserPACKED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(929)
			p.UnpackedStructuredType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(930)
			p.UnpackedStructuredType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(931)
			p.HelperType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(932)
			p.ClassType()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(934)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserPACKED {
			{
				p.SetState(933)
				p.Match(pascalParserPACKED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(936)
			p.RecordType()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(937)
			p.InterfaceType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnpackedStructuredTypeContext is an interface to support dynamic dispatch.
type IUnpackedStructuredTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ArrayType() IArrayTypeContext
	SetType() ISetTypeContext
	FileType() IFileTypeContext

	// IsUnpackedStructuredTypeContext differentiates from other interfaces.
	IsUnpackedStructuredTypeContext()
}

type UnpackedStructuredTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnpackedStructuredTypeContext() *UnpackedStructuredTypeContext {
	var p = new(UnpackedStructuredTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unpackedStructuredType
	return p
}

func InitEmptyUnpackedStructuredTypeContext(p *UnpackedStructuredTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unpackedStructuredType
}

func (*UnpackedStructuredTypeContext) IsUnpackedStructuredTypeContext() {}

func NewUnpackedStructuredTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnpackedStructuredTypeContext {
	var p = new(UnpackedStructuredTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unpackedStructuredType

	return p
}

func (s *UnpackedStructuredTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnpackedStructuredTypeContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *UnpackedStructuredTypeContext) SetType() ISetTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetTypeContext)
}

func (s *UnpackedStructuredTypeContext) FileType() IFileTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileTypeContext)
}

func (s *UnpackedStructuredTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnpackedStructuredTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnpackedStructuredTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnpackedStructuredType(s)
	}
}

func (s *UnpackedStructuredTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnpackedStructuredType(s)
	}
}

func (s *UnpackedStructuredTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnpackedStructuredType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnpackedStructuredType() (localctx IUnpackedStructuredTypeContext) {
	localctx = NewUnpackedStructuredTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, pascalParserRULE_unpackedStructuredType)
	p.SetState(943)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserARRAY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(940)
			p.ArrayType()
		}

	case pascalParserSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(941)
			p.SetType()
		}

	case pascalParserFILE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(942)
			p.FileType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringtypeContext is an interface to support dynamic dispatch.
type IStringtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	Identifier() IIdentifierContext
	UnsignedNumber() IUnsignedNumberContext

	// IsStringtypeContext differentiates from other interfaces.
	IsStringtypeContext()
}

type StringtypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringtypeContext() *StringtypeContext {
	var p = new(StringtypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_stringtype
	return p
}

func InitEmptyStringtypeContext(p *StringtypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_stringtype
}

func (*StringtypeContext) IsStringtypeContext() {}

func NewStringtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringtypeContext {
	var p = new(StringtypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_stringtype

	return p
}

func (s *StringtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StringtypeContext) STRING() antlr.TerminalNode {
	return s.GetToken(pascalParserSTRING, 0)
}

func (s *StringtypeContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *StringtypeContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *StringtypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StringtypeContext) UnsignedNumber() IUnsignedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedNumberContext)
}

func (s *StringtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStringtype(s)
	}
}

func (s *StringtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStringtype(s)
	}
}

func (s *StringtypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStringtype(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Stringtype() (localctx IStringtypeContext) {
	localctx = NewStringtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, pascalParserRULE_stringtype)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(945)
		p.Match(pascalParserSTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(946)
		p.Match(pascalParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(949)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
		{
			p.SetState(947)
			p.Identifier()
		}

	case pascalParserNUM_INT, pascalParserNUM_REAL:
		{
			p.SetState(948)
			p.UnsignedNumber()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(951)
		p.Match(pascalParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY() antlr.TerminalNode
	LBRACK() antlr.TerminalNode
	TypeList() ITypeListContext
	RBRACK() antlr.TerminalNode
	OF() antlr.TerminalNode
	Type_() IType_Context
	EQUAL() antlr.TerminalNode
	ScalarType() IScalarTypeContext
	LBRACK2() antlr.TerminalNode
	RBRACK2() antlr.TerminalNode
	CONST() antlr.TerminalNode

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_arrayType
	return p
}

func InitEmptyArrayTypeContext(p *ArrayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_arrayType
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(pascalParserARRAY, 0)
}

func (s *ArrayTypeContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *ArrayTypeContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *ArrayTypeContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *ArrayTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *ArrayTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *ArrayTypeContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *ArrayTypeContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ArrayTypeContext) LBRACK2() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK2, 0)
}

func (s *ArrayTypeContext) RBRACK2() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK2, 0)
}

func (s *ArrayTypeContext) CONST() antlr.TerminalNode {
	return s.GetToken(pascalParserCONST, 0)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (s *ArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, pascalParserRULE_arrayType)
	p.SetState(979)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(953)
			p.Match(pascalParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(954)
			p.Match(pascalParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(955)
			p.TypeList()
		}
		{
			p.SetState(956)
			p.Match(pascalParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(957)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(958)
			p.Type_()
		}
		p.SetState(961)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(959)
				p.Match(pascalParserEQUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(960)
				p.ScalarType()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(963)
			p.Match(pascalParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(964)
			p.Match(pascalParserLBRACK2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(965)
			p.TypeList()
		}
		{
			p.SetState(966)
			p.Match(pascalParserRBRACK2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(967)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(968)
			p.Type_()
		}
		p.SetState(971)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(969)
				p.Match(pascalParserEQUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(970)
				p.ScalarType()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(973)
			p.Match(pascalParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(974)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(975)
			p.Match(pascalParserCONST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(976)
			p.Match(pascalParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(977)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(978)
			p.Type_()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIndexType() []IIndexTypeContext
	IndexType(i int) IIndexTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeList
	return p
}

func InitEmptyTypeListContext(p *TypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeList
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllIndexType() []IIndexTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexTypeContext); ok {
			len++
		}
	}

	tst := make([]IIndexTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexTypeContext); ok {
			tst[i] = t.(IIndexTypeContext)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) IndexType(i int) IIndexTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *TypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *TypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypeList(s)
	}
}

func (s *TypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypeList(s)
	}
}

func (s *TypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, pascalParserRULE_typeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(981)
		p.IndexType()
	}
	p.SetState(986)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(982)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(983)
			p.IndexType()
		}

		p.SetState(988)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexTypeContext is an interface to support dynamic dispatch.
type IIndexTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleType() ISimpleTypeContext

	// IsIndexTypeContext differentiates from other interfaces.
	IsIndexTypeContext()
}

type IndexTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexTypeContext() *IndexTypeContext {
	var p = new(IndexTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_indexType
	return p
}

func InitEmptyIndexTypeContext(p *IndexTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_indexType
}

func (*IndexTypeContext) IsIndexTypeContext() {}

func NewIndexTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexTypeContext {
	var p = new(IndexTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_indexType

	return p
}

func (s *IndexTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexTypeContext) SimpleType() ISimpleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeContext)
}

func (s *IndexTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterIndexType(s)
	}
}

func (s *IndexTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitIndexType(s)
	}
}

func (s *IndexTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitIndexType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) IndexType() (localctx IIndexTypeContext) {
	localctx = NewIndexTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, pascalParserRULE_indexType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(989)
		p.SimpleType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordTypeContext is an interface to support dynamic dispatch.
type IRecordTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RECORD() antlr.TerminalNode
	RecordImplicitPublishedDeclaration() IRecordImplicitPublishedDeclarationContext
	END() antlr.TerminalNode
	AllRecordDeclaration() []IRecordDeclarationContext
	RecordDeclaration(i int) IRecordDeclarationContext
	RecordParts() IRecordPartsContext

	// IsRecordTypeContext differentiates from other interfaces.
	IsRecordTypeContext()
}

type RecordTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordTypeContext() *RecordTypeContext {
	var p = new(RecordTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordType
	return p
}

func InitEmptyRecordTypeContext(p *RecordTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordType
}

func (*RecordTypeContext) IsRecordTypeContext() {}

func NewRecordTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordTypeContext {
	var p = new(RecordTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordType

	return p
}

func (s *RecordTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordTypeContext) RECORD() antlr.TerminalNode {
	return s.GetToken(pascalParserRECORD, 0)
}

func (s *RecordTypeContext) RecordImplicitPublishedDeclaration() IRecordImplicitPublishedDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordImplicitPublishedDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordImplicitPublishedDeclarationContext)
}

func (s *RecordTypeContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *RecordTypeContext) AllRecordDeclaration() []IRecordDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IRecordDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordDeclarationContext); ok {
			tst[i] = t.(IRecordDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *RecordTypeContext) RecordDeclaration(i int) IRecordDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDeclarationContext)
}

func (s *RecordTypeContext) RecordParts() IRecordPartsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordPartsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordPartsContext)
}

func (s *RecordTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordType(s)
	}
}

func (s *RecordTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordType(s)
	}
}

func (s *RecordTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordType() (localctx IRecordTypeContext) {
	localctx = NewRecordTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, pascalParserRULE_recordType)
	var _la int

	p.SetState(1006)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(991)
			p.Match(pascalParserRECORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(992)
			p.RecordImplicitPublishedDeclaration()
		}
		p.SetState(996)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&31) != 0 {
			{
				p.SetState(993)
				p.RecordDeclaration()
			}

			p.SetState(998)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(999)
			p.Match(pascalParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1001)
			p.Match(pascalParserRECORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1003)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserCASE || ((int64((_la-85)) & ^0x3f) == 0 && ((int64(1)<<(_la-85))&274877906955) != 0) {
			{
				p.SetState(1002)
				p.RecordParts()
			}

		}
		{
			p.SetState(1005)
			p.Match(pascalParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordDeclarationContext is an interface to support dynamic dispatch.
type IRecordDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AccessSpecifier() IAccessSpecifierContext
	AllRecordDeclarationPart() []IRecordDeclarationPartContext
	RecordDeclarationPart(i int) IRecordDeclarationPartContext

	// IsRecordDeclarationContext differentiates from other interfaces.
	IsRecordDeclarationContext()
}

type RecordDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordDeclarationContext() *RecordDeclarationContext {
	var p = new(RecordDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordDeclaration
	return p
}

func InitEmptyRecordDeclarationContext(p *RecordDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordDeclaration
}

func (*RecordDeclarationContext) IsRecordDeclarationContext() {}

func NewRecordDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordDeclarationContext {
	var p = new(RecordDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordDeclaration

	return p
}

func (s *RecordDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordDeclarationContext) AccessSpecifier() IAccessSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessSpecifierContext)
}

func (s *RecordDeclarationContext) AllRecordDeclarationPart() []IRecordDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IRecordDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordDeclarationPartContext); ok {
			tst[i] = t.(IRecordDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *RecordDeclarationContext) RecordDeclarationPart(i int) IRecordDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDeclarationPartContext)
}

func (s *RecordDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordDeclaration(s)
	}
}

func (s *RecordDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordDeclaration(s)
	}
}

func (s *RecordDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordDeclaration() (localctx IRecordDeclarationContext) {
	localctx = NewRecordDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, pascalParserRULE_recordDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1008)
		p.AccessSpecifier()
	}
	p.SetState(1012)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-16386) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-507905) != 0) || _la == pascalParserNUM_REAL || _la == pascalParserUTF8BOM {
		{
			p.SetState(1009)
			p.RecordDeclarationPart()
		}

		p.SetState(1014)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordImplicitPublishedDeclarationContext is an interface to support dynamic dispatch.
type IRecordImplicitPublishedDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRecordDeclarationPart() []IRecordDeclarationPartContext
	RecordDeclarationPart(i int) IRecordDeclarationPartContext

	// IsRecordImplicitPublishedDeclarationContext differentiates from other interfaces.
	IsRecordImplicitPublishedDeclarationContext()
}

type RecordImplicitPublishedDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordImplicitPublishedDeclarationContext() *RecordImplicitPublishedDeclarationContext {
	var p = new(RecordImplicitPublishedDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordImplicitPublishedDeclaration
	return p
}

func InitEmptyRecordImplicitPublishedDeclarationContext(p *RecordImplicitPublishedDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordImplicitPublishedDeclaration
}

func (*RecordImplicitPublishedDeclarationContext) IsRecordImplicitPublishedDeclarationContext() {}

func NewRecordImplicitPublishedDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordImplicitPublishedDeclarationContext {
	var p = new(RecordImplicitPublishedDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordImplicitPublishedDeclaration

	return p
}

func (s *RecordImplicitPublishedDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordImplicitPublishedDeclarationContext) AllRecordDeclarationPart() []IRecordDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IRecordDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordDeclarationPartContext); ok {
			tst[i] = t.(IRecordDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *RecordImplicitPublishedDeclarationContext) RecordDeclarationPart(i int) IRecordDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDeclarationPartContext)
}

func (s *RecordImplicitPublishedDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordImplicitPublishedDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordImplicitPublishedDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordImplicitPublishedDeclaration(s)
	}
}

func (s *RecordImplicitPublishedDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordImplicitPublishedDeclaration(s)
	}
}

func (s *RecordImplicitPublishedDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordImplicitPublishedDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordImplicitPublishedDeclaration() (localctx IRecordImplicitPublishedDeclarationContext) {
	localctx = NewRecordImplicitPublishedDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, pascalParserRULE_recordImplicitPublishedDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1018)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-16386) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-507905) != 0) || _la == pascalParserNUM_REAL || _la == pascalParserUTF8BOM {
		{
			p.SetState(1015)
			p.RecordDeclarationPart()
		}

		p.SetState(1020)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordDeclarationPartContext is an interface to support dynamic dispatch.
type IRecordDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypedIdentifierList() ITypedIdentifierListContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AttributeSection() IAttributeSectionContext
	TypeDefinitionPart() ITypeDefinitionPartContext
	ConstantDefinitionPart() IConstantDefinitionPartContext
	FunctionHeader() IFunctionHeaderContext
	ProcedureHeader() IProcedureHeaderContext
	ClassOperatorHeader() IClassOperatorHeaderContext
	PropertyDeclaration() IPropertyDeclarationContext
	DEFAULT() antlr.TerminalNode
	ErrorRecordDeclarationPart() IErrorRecordDeclarationPartContext

	// IsRecordDeclarationPartContext differentiates from other interfaces.
	IsRecordDeclarationPartContext()
}

type RecordDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordDeclarationPartContext() *RecordDeclarationPartContext {
	var p = new(RecordDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordDeclarationPart
	return p
}

func InitEmptyRecordDeclarationPartContext(p *RecordDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordDeclarationPart
}

func (*RecordDeclarationPartContext) IsRecordDeclarationPartContext() {}

func NewRecordDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordDeclarationPartContext {
	var p = new(RecordDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordDeclarationPart

	return p
}

func (s *RecordDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordDeclarationPartContext) TypedIdentifierList() ITypedIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIdentifierListContext)
}

func (s *RecordDeclarationPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *RecordDeclarationPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *RecordDeclarationPartContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *RecordDeclarationPartContext) TypeDefinitionPart() ITypeDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionPartContext)
}

func (s *RecordDeclarationPartContext) ConstantDefinitionPart() IConstantDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *RecordDeclarationPartContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *RecordDeclarationPartContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *RecordDeclarationPartContext) ClassOperatorHeader() IClassOperatorHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOperatorHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOperatorHeaderContext)
}

func (s *RecordDeclarationPartContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *RecordDeclarationPartContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *RecordDeclarationPartContext) ErrorRecordDeclarationPart() IErrorRecordDeclarationPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorRecordDeclarationPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorRecordDeclarationPartContext)
}

func (s *RecordDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordDeclarationPart(s)
	}
}

func (s *RecordDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordDeclarationPart(s)
	}
}

func (s *RecordDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordDeclarationPart() (localctx IRecordDeclarationPartContext) {
	localctx = NewRecordDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, pascalParserRULE_recordDeclarationPart)
	var _la int

	p.SetState(1041)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1022)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1021)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1024)
			p.TypedIdentifierList()
		}
		{
			p.SetState(1025)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1027)
			p.TypeDefinitionPart()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1028)
			p.ConstantDefinitionPart()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1029)
			p.FunctionHeader()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1030)
			p.ProcedureHeader()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1031)
			p.ClassOperatorHeader()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1032)
			p.PropertyDeclaration()
		}
		{
			p.SetState(1033)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1036)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1034)
				p.Match(pascalParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1035)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1038)
			p.ErrorRecordDeclarationPart()
		}
		{
			p.SetState(1039)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorRecordDeclarationPartContext is an interface to support dynamic dispatch.
type IErrorRecordDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRICT() []antlr.TerminalNode
	STRICT(i int) antlr.TerminalNode
	AllPRIVATE() []antlr.TerminalNode
	PRIVATE(i int) antlr.TerminalNode
	AllPROTECTED() []antlr.TerminalNode
	PROTECTED(i int) antlr.TerminalNode
	AllPUBLIC() []antlr.TerminalNode
	PUBLIC(i int) antlr.TerminalNode
	AllPUBLISHED() []antlr.TerminalNode
	PUBLISHED(i int) antlr.TerminalNode
	AllEND() []antlr.TerminalNode
	END(i int) antlr.TerminalNode

	// IsErrorRecordDeclarationPartContext differentiates from other interfaces.
	IsErrorRecordDeclarationPartContext()
}

type ErrorRecordDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorRecordDeclarationPartContext() *ErrorRecordDeclarationPartContext {
	var p = new(ErrorRecordDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorRecordDeclarationPart
	return p
}

func InitEmptyErrorRecordDeclarationPartContext(p *ErrorRecordDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorRecordDeclarationPart
}

func (*ErrorRecordDeclarationPartContext) IsErrorRecordDeclarationPartContext() {}

func NewErrorRecordDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorRecordDeclarationPartContext {
	var p = new(ErrorRecordDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_errorRecordDeclarationPart

	return p
}

func (s *ErrorRecordDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorRecordDeclarationPartContext) AllSTRICT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTRICT)
}

func (s *ErrorRecordDeclarationPartContext) STRICT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTRICT, i)
}

func (s *ErrorRecordDeclarationPartContext) AllPRIVATE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPRIVATE)
}

func (s *ErrorRecordDeclarationPartContext) PRIVATE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPRIVATE, i)
}

func (s *ErrorRecordDeclarationPartContext) AllPROTECTED() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPROTECTED)
}

func (s *ErrorRecordDeclarationPartContext) PROTECTED(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPROTECTED, i)
}

func (s *ErrorRecordDeclarationPartContext) AllPUBLIC() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPUBLIC)
}

func (s *ErrorRecordDeclarationPartContext) PUBLIC(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLIC, i)
}

func (s *ErrorRecordDeclarationPartContext) AllPUBLISHED() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPUBLISHED)
}

func (s *ErrorRecordDeclarationPartContext) PUBLISHED(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLISHED, i)
}

func (s *ErrorRecordDeclarationPartContext) AllEND() []antlr.TerminalNode {
	return s.GetTokens(pascalParserEND)
}

func (s *ErrorRecordDeclarationPartContext) END(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserEND, i)
}

func (s *ErrorRecordDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorRecordDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorRecordDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterErrorRecordDeclarationPart(s)
	}
}

func (s *ErrorRecordDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitErrorRecordDeclarationPart(s)
	}
}

func (s *ErrorRecordDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitErrorRecordDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ErrorRecordDeclarationPart() (localctx IErrorRecordDeclarationPartContext) {
	localctx = NewErrorRecordDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, pascalParserRULE_errorRecordDeclarationPart)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1044)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1043)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || _la == pascalParserEND || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&31) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1046)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordPartsContext is an interface to support dynamic dispatch.
type IRecordPartsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RecordFixedPart() IRecordFixedPartContext
	SEMI() antlr.TerminalNode
	RecordVariantPart() IRecordVariantPartContext

	// IsRecordPartsContext differentiates from other interfaces.
	IsRecordPartsContext()
}

type RecordPartsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordPartsContext() *RecordPartsContext {
	var p = new(RecordPartsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordParts
	return p
}

func InitEmptyRecordPartsContext(p *RecordPartsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordParts
}

func (*RecordPartsContext) IsRecordPartsContext() {}

func NewRecordPartsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordPartsContext {
	var p = new(RecordPartsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordParts

	return p
}

func (s *RecordPartsContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordPartsContext) RecordFixedPart() IRecordFixedPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordFixedPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordFixedPartContext)
}

func (s *RecordPartsContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *RecordPartsContext) RecordVariantPart() IRecordVariantPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordVariantPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordVariantPartContext)
}

func (s *RecordPartsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordPartsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordPartsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordParts(s)
	}
}

func (s *RecordPartsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordParts(s)
	}
}

func (s *RecordPartsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordParts(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordParts() (localctx IRecordPartsContext) {
	localctx = NewRecordPartsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, pascalParserRULE_recordParts)
	var _la int

	p.SetState(1054)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserIDENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1048)
			p.RecordFixedPart()
		}
		p.SetState(1051)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserSEMI {
			{
				p.SetState(1049)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1050)
				p.RecordVariantPart()
			}

		}

	case pascalParserCASE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1053)
			p.RecordVariantPart()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordFixedPartContext is an interface to support dynamic dispatch.
type IRecordFixedPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypedIdentifierList() []ITypedIdentifierListContext
	TypedIdentifierList(i int) ITypedIdentifierListContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsRecordFixedPartContext differentiates from other interfaces.
	IsRecordFixedPartContext()
}

type RecordFixedPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordFixedPartContext() *RecordFixedPartContext {
	var p = new(RecordFixedPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordFixedPart
	return p
}

func InitEmptyRecordFixedPartContext(p *RecordFixedPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordFixedPart
}

func (*RecordFixedPartContext) IsRecordFixedPartContext() {}

func NewRecordFixedPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordFixedPartContext {
	var p = new(RecordFixedPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordFixedPart

	return p
}

func (s *RecordFixedPartContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordFixedPartContext) AllTypedIdentifierList() []ITypedIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypedIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]ITypedIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypedIdentifierListContext); ok {
			tst[i] = t.(ITypedIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *RecordFixedPartContext) TypedIdentifierList(i int) ITypedIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIdentifierListContext)
}

func (s *RecordFixedPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *RecordFixedPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *RecordFixedPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordFixedPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordFixedPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordFixedPart(s)
	}
}

func (s *RecordFixedPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordFixedPart(s)
	}
}

func (s *RecordFixedPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordFixedPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordFixedPart() (localctx IRecordFixedPartContext) {
	localctx = NewRecordFixedPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, pascalParserRULE_recordFixedPart)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1056)
		p.TypedIdentifierList()
	}
	p.SetState(1061)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1057)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1058)
				p.TypedIdentifierList()
			}

		}
		p.SetState(1063)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1065)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1064)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordVariantPartContext is an interface to support dynamic dispatch.
type IRecordVariantPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	Tag() ITagContext
	OF() antlr.TerminalNode
	AllRecordVariant() []IRecordVariantContext
	RecordVariant(i int) IRecordVariantContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsRecordVariantPartContext differentiates from other interfaces.
	IsRecordVariantPartContext()
}

type RecordVariantPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordVariantPartContext() *RecordVariantPartContext {
	var p = new(RecordVariantPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordVariantPart
	return p
}

func InitEmptyRecordVariantPartContext(p *RecordVariantPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordVariantPart
}

func (*RecordVariantPartContext) IsRecordVariantPartContext() {}

func NewRecordVariantPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordVariantPartContext {
	var p = new(RecordVariantPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordVariantPart

	return p
}

func (s *RecordVariantPartContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordVariantPartContext) CASE() antlr.TerminalNode {
	return s.GetToken(pascalParserCASE, 0)
}

func (s *RecordVariantPartContext) Tag() ITagContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITagContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITagContext)
}

func (s *RecordVariantPartContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *RecordVariantPartContext) AllRecordVariant() []IRecordVariantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRecordVariantContext); ok {
			len++
		}
	}

	tst := make([]IRecordVariantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRecordVariantContext); ok {
			tst[i] = t.(IRecordVariantContext)
			i++
		}
	}

	return tst
}

func (s *RecordVariantPartContext) RecordVariant(i int) IRecordVariantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordVariantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordVariantContext)
}

func (s *RecordVariantPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *RecordVariantPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *RecordVariantPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordVariantPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordVariantPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordVariantPart(s)
	}
}

func (s *RecordVariantPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordVariantPart(s)
	}
}

func (s *RecordVariantPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordVariantPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordVariantPart() (localctx IRecordVariantPartContext) {
	localctx = NewRecordVariantPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, pascalParserRULE_recordVariantPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1067)
		p.Match(pascalParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1068)
		p.Tag()
	}
	{
		p.SetState(1069)
		p.Match(pascalParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1070)
		p.RecordVariant()
	}
	p.SetState(1075)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserSEMI {
		{
			p.SetState(1071)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1072)
			p.RecordVariant()
		}

		p.SetState(1077)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITagContext is an interface to support dynamic dispatch.
type ITagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext

	// IsTagContext differentiates from other interfaces.
	IsTagContext()
}

type TagContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTagContext() *TagContext {
	var p = new(TagContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tag
	return p
}

func InitEmptyTagContext(p *TagContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tag
}

func (*TagContext) IsTagContext() {}

func NewTagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TagContext {
	var p = new(TagContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_tag

	return p
}

func (s *TagContext) GetParser() antlr.Parser { return s.parser }

func (s *TagContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TagContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *TagContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *TagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTag(s)
	}
}

func (s *TagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTag(s)
	}
}

func (s *TagContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTag(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Tag() (localctx ITagContext) {
	localctx = NewTagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, pascalParserRULE_tag)
	p.SetState(1083)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1078)
			p.Identifier()
		}
		{
			p.SetState(1079)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1080)
			p.TypeIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1082)
			p.TypeIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordVariantContext is an interface to support dynamic dispatch.
type IRecordVariantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConstList() IConstListContext
	COLON() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RecordParts() IRecordPartsContext
	RPAREN() antlr.TerminalNode

	// IsRecordVariantContext differentiates from other interfaces.
	IsRecordVariantContext()
}

type RecordVariantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordVariantContext() *RecordVariantContext {
	var p = new(RecordVariantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordVariant
	return p
}

func InitEmptyRecordVariantContext(p *RecordVariantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_recordVariant
}

func (*RecordVariantContext) IsRecordVariantContext() {}

func NewRecordVariantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordVariantContext {
	var p = new(RecordVariantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_recordVariant

	return p
}

func (s *RecordVariantContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordVariantContext) ConstList() IConstListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstListContext)
}

func (s *RecordVariantContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *RecordVariantContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *RecordVariantContext) RecordParts() IRecordPartsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordPartsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordPartsContext)
}

func (s *RecordVariantContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *RecordVariantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordVariantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordVariantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRecordVariant(s)
	}
}

func (s *RecordVariantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRecordVariant(s)
	}
}

func (s *RecordVariantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRecordVariant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RecordVariant() (localctx IRecordVariantContext) {
	localctx = NewRecordVariantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, pascalParserRULE_recordVariant)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1085)
		p.ConstList()
	}
	{
		p.SetState(1086)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1087)
		p.Match(pascalParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1088)
		p.RecordParts()
	}
	{
		p.SetState(1089)
		p.Match(pascalParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHelperTypeContext is an interface to support dynamic dispatch.
type IHelperTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	HELPER() antlr.TerminalNode
	FOR() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	HelperImplicitPublishedDeclaration() IHelperImplicitPublishedDeclarationContext
	END() antlr.TerminalNode
	AllHelperDeclaration() []IHelperDeclarationContext
	HelperDeclaration(i int) IHelperDeclarationContext

	// IsHelperTypeContext differentiates from other interfaces.
	IsHelperTypeContext()
}

type HelperTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelperTypeContext() *HelperTypeContext {
	var p = new(HelperTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperType
	return p
}

func InitEmptyHelperTypeContext(p *HelperTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperType
}

func (*HelperTypeContext) IsHelperTypeContext() {}

func NewHelperTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelperTypeContext {
	var p = new(HelperTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_helperType

	return p
}

func (s *HelperTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *HelperTypeContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *HelperTypeContext) HELPER() antlr.TerminalNode {
	return s.GetToken(pascalParserHELPER, 0)
}

func (s *HelperTypeContext) FOR() antlr.TerminalNode {
	return s.GetToken(pascalParserFOR, 0)
}

func (s *HelperTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *HelperTypeContext) HelperImplicitPublishedDeclaration() IHelperImplicitPublishedDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelperImplicitPublishedDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelperImplicitPublishedDeclarationContext)
}

func (s *HelperTypeContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *HelperTypeContext) AllHelperDeclaration() []IHelperDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHelperDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IHelperDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHelperDeclarationContext); ok {
			tst[i] = t.(IHelperDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *HelperTypeContext) HelperDeclaration(i int) IHelperDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelperDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelperDeclarationContext)
}

func (s *HelperTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelperTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelperTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterHelperType(s)
	}
}

func (s *HelperTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitHelperType(s)
	}
}

func (s *HelperTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitHelperType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) HelperType() (localctx IHelperTypeContext) {
	localctx = NewHelperTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, pascalParserRULE_helperType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1091)
		p.Match(pascalParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1092)
		p.Match(pascalParserHELPER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1093)
		p.Match(pascalParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1094)
		p.TypeIdentifier()
	}
	{
		p.SetState(1095)
		p.HelperImplicitPublishedDeclaration()
	}
	p.SetState(1099)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&31) != 0 {
		{
			p.SetState(1096)
			p.HelperDeclaration()
		}

		p.SetState(1101)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1102)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHelperDeclarationContext is an interface to support dynamic dispatch.
type IHelperDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AccessSpecifier() IAccessSpecifierContext
	AllHelperDeclarationPart() []IHelperDeclarationPartContext
	HelperDeclarationPart(i int) IHelperDeclarationPartContext

	// IsHelperDeclarationContext differentiates from other interfaces.
	IsHelperDeclarationContext()
}

type HelperDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelperDeclarationContext() *HelperDeclarationContext {
	var p = new(HelperDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperDeclaration
	return p
}

func InitEmptyHelperDeclarationContext(p *HelperDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperDeclaration
}

func (*HelperDeclarationContext) IsHelperDeclarationContext() {}

func NewHelperDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelperDeclarationContext {
	var p = new(HelperDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_helperDeclaration

	return p
}

func (s *HelperDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *HelperDeclarationContext) AccessSpecifier() IAccessSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessSpecifierContext)
}

func (s *HelperDeclarationContext) AllHelperDeclarationPart() []IHelperDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHelperDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IHelperDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHelperDeclarationPartContext); ok {
			tst[i] = t.(IHelperDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *HelperDeclarationContext) HelperDeclarationPart(i int) IHelperDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelperDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelperDeclarationPartContext)
}

func (s *HelperDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelperDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelperDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterHelperDeclaration(s)
	}
}

func (s *HelperDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitHelperDeclaration(s)
	}
}

func (s *HelperDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitHelperDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) HelperDeclaration() (localctx IHelperDeclarationContext) {
	localctx = NewHelperDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, pascalParserRULE_helperDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1104)
		p.AccessSpecifier()
	}
	p.SetState(1108)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-16386) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-507905) != 0) || _la == pascalParserNUM_REAL || _la == pascalParserUTF8BOM {
		{
			p.SetState(1105)
			p.HelperDeclarationPart()
		}

		p.SetState(1110)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHelperImplicitPublishedDeclarationContext is an interface to support dynamic dispatch.
type IHelperImplicitPublishedDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllHelperDeclarationPart() []IHelperDeclarationPartContext
	HelperDeclarationPart(i int) IHelperDeclarationPartContext

	// IsHelperImplicitPublishedDeclarationContext differentiates from other interfaces.
	IsHelperImplicitPublishedDeclarationContext()
}

type HelperImplicitPublishedDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelperImplicitPublishedDeclarationContext() *HelperImplicitPublishedDeclarationContext {
	var p = new(HelperImplicitPublishedDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperImplicitPublishedDeclaration
	return p
}

func InitEmptyHelperImplicitPublishedDeclarationContext(p *HelperImplicitPublishedDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperImplicitPublishedDeclaration
}

func (*HelperImplicitPublishedDeclarationContext) IsHelperImplicitPublishedDeclarationContext() {}

func NewHelperImplicitPublishedDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelperImplicitPublishedDeclarationContext {
	var p = new(HelperImplicitPublishedDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_helperImplicitPublishedDeclaration

	return p
}

func (s *HelperImplicitPublishedDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *HelperImplicitPublishedDeclarationContext) AllHelperDeclarationPart() []IHelperDeclarationPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHelperDeclarationPartContext); ok {
			len++
		}
	}

	tst := make([]IHelperDeclarationPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHelperDeclarationPartContext); ok {
			tst[i] = t.(IHelperDeclarationPartContext)
			i++
		}
	}

	return tst
}

func (s *HelperImplicitPublishedDeclarationContext) HelperDeclarationPart(i int) IHelperDeclarationPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelperDeclarationPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelperDeclarationPartContext)
}

func (s *HelperImplicitPublishedDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelperImplicitPublishedDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelperImplicitPublishedDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterHelperImplicitPublishedDeclaration(s)
	}
}

func (s *HelperImplicitPublishedDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitHelperImplicitPublishedDeclaration(s)
	}
}

func (s *HelperImplicitPublishedDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitHelperImplicitPublishedDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) HelperImplicitPublishedDeclaration() (localctx IHelperImplicitPublishedDeclarationContext) {
	localctx = NewHelperImplicitPublishedDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, pascalParserRULE_helperImplicitPublishedDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1114)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-16386) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-507905) != 0) || _la == pascalParserNUM_REAL || _la == pascalParserUTF8BOM {
		{
			p.SetState(1111)
			p.HelperDeclarationPart()
		}

		p.SetState(1116)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHelperDeclarationPartContext is an interface to support dynamic dispatch.
type IHelperDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeDefinitionPart() ITypeDefinitionPartContext
	ConstantDefinitionPart() IConstantDefinitionPartContext
	FunctionHeader() IFunctionHeaderContext
	ProcedureHeader() IProcedureHeaderContext
	PropertyDeclaration() IPropertyDeclarationContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	ErrorHelperDeclarationPart() IErrorHelperDeclarationPartContext

	// IsHelperDeclarationPartContext differentiates from other interfaces.
	IsHelperDeclarationPartContext()
}

type HelperDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelperDeclarationPartContext() *HelperDeclarationPartContext {
	var p = new(HelperDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperDeclarationPart
	return p
}

func InitEmptyHelperDeclarationPartContext(p *HelperDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_helperDeclarationPart
}

func (*HelperDeclarationPartContext) IsHelperDeclarationPartContext() {}

func NewHelperDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelperDeclarationPartContext {
	var p = new(HelperDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_helperDeclarationPart

	return p
}

func (s *HelperDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *HelperDeclarationPartContext) TypeDefinitionPart() ITypeDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefinitionPartContext)
}

func (s *HelperDeclarationPartContext) ConstantDefinitionPart() IConstantDefinitionPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantDefinitionPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantDefinitionPartContext)
}

func (s *HelperDeclarationPartContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *HelperDeclarationPartContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *HelperDeclarationPartContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *HelperDeclarationPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *HelperDeclarationPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *HelperDeclarationPartContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *HelperDeclarationPartContext) ErrorHelperDeclarationPart() IErrorHelperDeclarationPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorHelperDeclarationPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorHelperDeclarationPartContext)
}

func (s *HelperDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelperDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelperDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterHelperDeclarationPart(s)
	}
}

func (s *HelperDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitHelperDeclarationPart(s)
	}
}

func (s *HelperDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitHelperDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) HelperDeclarationPart() (localctx IHelperDeclarationPartContext) {
	localctx = NewHelperDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, pascalParserRULE_helperDeclarationPart)
	p.SetState(1130)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 108, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1117)
			p.TypeDefinitionPart()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1118)
			p.ConstantDefinitionPart()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1119)
			p.FunctionHeader()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1120)
			p.ProcedureHeader()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1121)
			p.PropertyDeclaration()
		}
		{
			p.SetState(1122)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1125)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1123)
				p.Match(pascalParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1124)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1127)
			p.ErrorHelperDeclarationPart()
		}
		{
			p.SetState(1128)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorHelperDeclarationPartContext is an interface to support dynamic dispatch.
type IErrorHelperDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRICT() []antlr.TerminalNode
	STRICT(i int) antlr.TerminalNode
	AllPRIVATE() []antlr.TerminalNode
	PRIVATE(i int) antlr.TerminalNode
	AllPROTECTED() []antlr.TerminalNode
	PROTECTED(i int) antlr.TerminalNode
	AllPUBLIC() []antlr.TerminalNode
	PUBLIC(i int) antlr.TerminalNode
	AllPUBLISHED() []antlr.TerminalNode
	PUBLISHED(i int) antlr.TerminalNode
	AllEND() []antlr.TerminalNode
	END(i int) antlr.TerminalNode

	// IsErrorHelperDeclarationPartContext differentiates from other interfaces.
	IsErrorHelperDeclarationPartContext()
}

type ErrorHelperDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorHelperDeclarationPartContext() *ErrorHelperDeclarationPartContext {
	var p = new(ErrorHelperDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorHelperDeclarationPart
	return p
}

func InitEmptyErrorHelperDeclarationPartContext(p *ErrorHelperDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorHelperDeclarationPart
}

func (*ErrorHelperDeclarationPartContext) IsErrorHelperDeclarationPartContext() {}

func NewErrorHelperDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorHelperDeclarationPartContext {
	var p = new(ErrorHelperDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_errorHelperDeclarationPart

	return p
}

func (s *ErrorHelperDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorHelperDeclarationPartContext) AllSTRICT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTRICT)
}

func (s *ErrorHelperDeclarationPartContext) STRICT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTRICT, i)
}

func (s *ErrorHelperDeclarationPartContext) AllPRIVATE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPRIVATE)
}

func (s *ErrorHelperDeclarationPartContext) PRIVATE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPRIVATE, i)
}

func (s *ErrorHelperDeclarationPartContext) AllPROTECTED() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPROTECTED)
}

func (s *ErrorHelperDeclarationPartContext) PROTECTED(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPROTECTED, i)
}

func (s *ErrorHelperDeclarationPartContext) AllPUBLIC() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPUBLIC)
}

func (s *ErrorHelperDeclarationPartContext) PUBLIC(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLIC, i)
}

func (s *ErrorHelperDeclarationPartContext) AllPUBLISHED() []antlr.TerminalNode {
	return s.GetTokens(pascalParserPUBLISHED)
}

func (s *ErrorHelperDeclarationPartContext) PUBLISHED(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserPUBLISHED, i)
}

func (s *ErrorHelperDeclarationPartContext) AllEND() []antlr.TerminalNode {
	return s.GetTokens(pascalParserEND)
}

func (s *ErrorHelperDeclarationPartContext) END(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserEND, i)
}

func (s *ErrorHelperDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorHelperDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorHelperDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterErrorHelperDeclarationPart(s)
	}
}

func (s *ErrorHelperDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitErrorHelperDeclarationPart(s)
	}
}

func (s *ErrorHelperDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitErrorHelperDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ErrorHelperDeclarationPart() (localctx IErrorHelperDeclarationPartContext) {
	localctx = NewErrorHelperDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, pascalParserRULE_errorHelperDeclarationPart)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1133)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1132)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || _la == pascalParserEND || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&31) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1135)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 109, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetTypeContext is an interface to support dynamic dispatch.
type ISetTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	OF() antlr.TerminalNode
	SimpleType() ISimpleTypeContext

	// IsSetTypeContext differentiates from other interfaces.
	IsSetTypeContext()
}

type SetTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetTypeContext() *SetTypeContext {
	var p = new(SetTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_setType
	return p
}

func InitEmptySetTypeContext(p *SetTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_setType
}

func (*SetTypeContext) IsSetTypeContext() {}

func NewSetTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetTypeContext {
	var p = new(SetTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_setType

	return p
}

func (s *SetTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SetTypeContext) SET() antlr.TerminalNode {
	return s.GetToken(pascalParserSET, 0)
}

func (s *SetTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *SetTypeContext) SimpleType() ISimpleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeContext)
}

func (s *SetTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSetType(s)
	}
}

func (s *SetTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSetType(s)
	}
}

func (s *SetTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSetType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SetType() (localctx ISetTypeContext) {
	localctx = NewSetTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, pascalParserRULE_setType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1137)
		p.Match(pascalParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1138)
		p.Match(pascalParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1139)
		p.SimpleType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFileTypeContext is an interface to support dynamic dispatch.
type IFileTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FILE() antlr.TerminalNode
	OF() antlr.TerminalNode
	Type_() IType_Context

	// IsFileTypeContext differentiates from other interfaces.
	IsFileTypeContext()
}

type FileTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileTypeContext() *FileTypeContext {
	var p = new(FileTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_fileType
	return p
}

func InitEmptyFileTypeContext(p *FileTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_fileType
}

func (*FileTypeContext) IsFileTypeContext() {}

func NewFileTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileTypeContext {
	var p = new(FileTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_fileType

	return p
}

func (s *FileTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FileTypeContext) FILE() antlr.TerminalNode {
	return s.GetToken(pascalParserFILE, 0)
}

func (s *FileTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *FileTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *FileTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFileType(s)
	}
}

func (s *FileTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFileType(s)
	}
}

func (s *FileTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFileType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FileType() (localctx IFileTypeContext) {
	localctx = NewFileTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, pascalParserRULE_fileType)
	p.SetState(1145)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1141)
			p.Match(pascalParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1142)
			p.Match(pascalParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1143)
			p.Type_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1144)
			p.Match(pascalParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPointerTypeContext is an interface to support dynamic dispatch.
type IPointerTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEREFERENCE() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext

	// IsPointerTypeContext differentiates from other interfaces.
	IsPointerTypeContext()
}

type PointerTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPointerTypeContext() *PointerTypeContext {
	var p = new(PointerTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_pointerType
	return p
}

func InitEmptyPointerTypeContext(p *PointerTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_pointerType
}

func (*PointerTypeContext) IsPointerTypeContext() {}

func NewPointerTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PointerTypeContext {
	var p = new(PointerTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_pointerType

	return p
}

func (s *PointerTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PointerTypeContext) DEREFERENCE() antlr.TerminalNode {
	return s.GetToken(pascalParserDEREFERENCE, 0)
}

func (s *PointerTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *PointerTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PointerTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PointerTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPointerType(s)
	}
}

func (s *PointerTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPointerType(s)
	}
}

func (s *PointerTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPointerType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PointerType() (localctx IPointerTypeContext) {
	localctx = NewPointerTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, pascalParserRULE_pointerType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1147)
		p.Match(pascalParserDEREFERENCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1148)
		p.TypeIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationPartContext is an interface to support dynamic dispatch.
type IVariableDeclarationPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VAR() antlr.TerminalNode
	AllVariableDeclaration() []IVariableDeclarationContext
	VariableDeclaration(i int) IVariableDeclarationContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsVariableDeclarationPartContext differentiates from other interfaces.
	IsVariableDeclarationPartContext()
}

type VariableDeclarationPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationPartContext() *VariableDeclarationPartContext {
	var p = new(VariableDeclarationPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclarationPart
	return p
}

func InitEmptyVariableDeclarationPartContext(p *VariableDeclarationPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclarationPart
}

func (*VariableDeclarationPartContext) IsVariableDeclarationPartContext() {}

func NewVariableDeclarationPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationPartContext {
	var p = new(VariableDeclarationPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_variableDeclarationPart

	return p
}

func (s *VariableDeclarationPartContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationPartContext) VAR() antlr.TerminalNode {
	return s.GetToken(pascalParserVAR, 0)
}

func (s *VariableDeclarationPartContext) AllVariableDeclaration() []IVariableDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationContext); ok {
			tst[i] = t.(IVariableDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclarationPartContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *VariableDeclarationPartContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *VariableDeclarationPartContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *VariableDeclarationPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterVariableDeclarationPart(s)
	}
}

func (s *VariableDeclarationPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitVariableDeclarationPart(s)
	}
}

func (s *VariableDeclarationPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitVariableDeclarationPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) VariableDeclarationPart() (localctx IVariableDeclarationPartContext) {
	localctx = NewVariableDeclarationPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, pascalParserRULE_variableDeclarationPart)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1150)
		p.Match(pascalParserVAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1151)
		p.VariableDeclaration()
	}
	p.SetState(1156)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 111, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1152)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1153)
				p.VariableDeclaration()
			}

		}
		p.SetState(1158)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 111, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1159)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypedIdentifierList() ITypedIdentifierListContext
	AttributeSection() IAttributeSectionContext
	EQUAL() antlr.TerminalNode
	SimpleExpression() ISimpleExpressionContext

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclaration
	return p
}

func InitEmptyVariableDeclarationContext(p *VariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclaration
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) TypedIdentifierList() ITypedIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIdentifierListContext)
}

func (s *VariableDeclarationContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *VariableDeclarationContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *VariableDeclarationContext) SimpleExpression() ISimpleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExpressionContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitVariableDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, pascalParserRULE_variableDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1162)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLBRACK {
		{
			p.SetState(1161)
			p.AttributeSection()
		}

	}
	{
		p.SetState(1164)
		p.TypedIdentifierList()
	}
	p.SetState(1167)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserEQUAL {
		{
			p.SetState(1165)
			p.Match(pascalParserEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1166)
			p.SimpleExpression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureHeaderContext is an interface to support dynamic dispatch.
type IProcedureHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext
	SEMI() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	CONSTRUCTOR() antlr.TerminalNode
	DESTRUCTOR() antlr.TerminalNode
	AttributeSection() IAttributeSectionContext
	CLASS() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext

	// IsProcedureHeaderContext differentiates from other interfaces.
	IsProcedureHeaderContext()
}

type ProcedureHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureHeaderContext() *ProcedureHeaderContext {
	var p = new(ProcedureHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureHeader
	return p
}

func InitEmptyProcedureHeaderContext(p *ProcedureHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureHeader
}

func (*ProcedureHeaderContext) IsProcedureHeaderContext() {}

func NewProcedureHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureHeaderContext {
	var p = new(ProcedureHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureHeader

	return p
}

func (s *ProcedureHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureHeaderContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ProcedureHeaderContext) ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderModifiersContext)
}

func (s *ProcedureHeaderContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ProcedureHeaderContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(pascalParserPROCEDURE, 0)
}

func (s *ProcedureHeaderContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(pascalParserCONSTRUCTOR, 0)
}

func (s *ProcedureHeaderContext) DESTRUCTOR() antlr.TerminalNode {
	return s.GetToken(pascalParserDESTRUCTOR, 0)
}

func (s *ProcedureHeaderContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *ProcedureHeaderContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *ProcedureHeaderContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ProcedureHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureHeader(s)
	}
}

func (s *ProcedureHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureHeader(s)
	}
}

func (s *ProcedureHeaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureHeader(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureHeader() (localctx IProcedureHeaderContext) {
	localctx = NewProcedureHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, pascalParserRULE_procedureHeader)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1170)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLBRACK {
		{
			p.SetState(1169)
			p.AttributeSection()
		}

	}
	p.SetState(1173)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserCLASS {
		{
			p.SetState(1172)
			p.Match(pascalParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1175)
		_la = p.GetTokenStream().LA(1)

		if !(_la == pascalParserPROCEDURE || _la == pascalParserCONSTRUCTOR || _la == pascalParserDESTRUCTOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1176)
		p.Identifier()
	}
	p.SetState(1178)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1177)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1180)
		p.ProcedureOrFunctionHeaderModifiers()
	}
	{
		p.SetState(1181)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionHeaderContext is an interface to support dynamic dispatch.
type IFunctionHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNCTION() antlr.TerminalNode
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	ResultType() IResultTypeContext
	ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext
	SEMI() antlr.TerminalNode
	AttributeSection() IAttributeSectionContext
	CLASS() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext

	// IsFunctionHeaderContext differentiates from other interfaces.
	IsFunctionHeaderContext()
}

type FunctionHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionHeaderContext() *FunctionHeaderContext {
	var p = new(FunctionHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionHeader
	return p
}

func InitEmptyFunctionHeaderContext(p *FunctionHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionHeader
}

func (*FunctionHeaderContext) IsFunctionHeaderContext() {}

func NewFunctionHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionHeaderContext {
	var p = new(FunctionHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_functionHeader

	return p
}

func (s *FunctionHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionHeaderContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(pascalParserFUNCTION, 0)
}

func (s *FunctionHeaderContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionHeaderContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *FunctionHeaderContext) ResultType() IResultTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultTypeContext)
}

func (s *FunctionHeaderContext) ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderModifiersContext)
}

func (s *FunctionHeaderContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *FunctionHeaderContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *FunctionHeaderContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *FunctionHeaderContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFunctionHeader(s)
	}
}

func (s *FunctionHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFunctionHeader(s)
	}
}

func (s *FunctionHeaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFunctionHeader(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FunctionHeader() (localctx IFunctionHeaderContext) {
	localctx = NewFunctionHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, pascalParserRULE_functionHeader)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1184)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLBRACK {
		{
			p.SetState(1183)
			p.AttributeSection()
		}

	}
	p.SetState(1187)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserCLASS {
		{
			p.SetState(1186)
			p.Match(pascalParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1189)
		p.Match(pascalParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1190)
		p.Identifier()
	}
	p.SetState(1192)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1191)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1194)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1195)
		p.ResultType()
	}
	{
		p.SetState(1196)
		p.ProcedureOrFunctionHeaderModifiers()
	}
	{
		p.SetState(1197)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureOrFunctionHeaderContext is an interface to support dynamic dispatch.
type IProcedureOrFunctionHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ProcedureHeader() IProcedureHeaderContext
	FunctionHeader() IFunctionHeaderContext

	// IsProcedureOrFunctionHeaderContext differentiates from other interfaces.
	IsProcedureOrFunctionHeaderContext()
}

type ProcedureOrFunctionHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureOrFunctionHeaderContext() *ProcedureOrFunctionHeaderContext {
	var p = new(ProcedureOrFunctionHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeader
	return p
}

func InitEmptyProcedureOrFunctionHeaderContext(p *ProcedureOrFunctionHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeader
}

func (*ProcedureOrFunctionHeaderContext) IsProcedureOrFunctionHeaderContext() {}

func NewProcedureOrFunctionHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureOrFunctionHeaderContext {
	var p = new(ProcedureOrFunctionHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeader

	return p
}

func (s *ProcedureOrFunctionHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureOrFunctionHeaderContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *ProcedureOrFunctionHeaderContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *ProcedureOrFunctionHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureOrFunctionHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureOrFunctionHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureOrFunctionHeader(s)
	}
}

func (s *ProcedureOrFunctionHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureOrFunctionHeader(s)
	}
}

func (s *ProcedureOrFunctionHeaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureOrFunctionHeader(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureOrFunctionHeader() (localctx IProcedureOrFunctionHeaderContext) {
	localctx = NewProcedureOrFunctionHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, pascalParserRULE_procedureOrFunctionHeader)
	p.SetState(1201)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1199)
			p.ProcedureHeader()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1200)
			p.FunctionHeader()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureOrFunctionHeaderModifiersContext is an interface to support dynamic dispatch.
type IProcedureOrFunctionHeaderModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AllABSTRACT() []antlr.TerminalNode
	ABSTRACT(i int) antlr.TerminalNode
	AllVIRTUAL() []antlr.TerminalNode
	VIRTUAL(i int) antlr.TerminalNode
	AllOVERRIDE() []antlr.TerminalNode
	OVERRIDE(i int) antlr.TerminalNode
	AllREINTRODUCE() []antlr.TerminalNode
	REINTRODUCE(i int) antlr.TerminalNode
	AllOVERLOAD() []antlr.TerminalNode
	OVERLOAD(i int) antlr.TerminalNode
	AllINLINE() []antlr.TerminalNode
	INLINE(i int) antlr.TerminalNode
	AllSTDCALL() []antlr.TerminalNode
	STDCALL(i int) antlr.TerminalNode
	AllCDECL() []antlr.TerminalNode
	CDECL(i int) antlr.TerminalNode
	AllSTATIC() []antlr.TerminalNode
	STATIC(i int) antlr.TerminalNode

	// IsProcedureOrFunctionHeaderModifiersContext differentiates from other interfaces.
	IsProcedureOrFunctionHeaderModifiersContext()
}

type ProcedureOrFunctionHeaderModifiersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureOrFunctionHeaderModifiersContext() *ProcedureOrFunctionHeaderModifiersContext {
	var p = new(ProcedureOrFunctionHeaderModifiersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeaderModifiers
	return p
}

func InitEmptyProcedureOrFunctionHeaderModifiersContext(p *ProcedureOrFunctionHeaderModifiersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeaderModifiers
}

func (*ProcedureOrFunctionHeaderModifiersContext) IsProcedureOrFunctionHeaderModifiersContext() {}

func NewProcedureOrFunctionHeaderModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureOrFunctionHeaderModifiersContext {
	var p = new(ProcedureOrFunctionHeaderModifiersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureOrFunctionHeaderModifiers

	return p
}

func (s *ProcedureOrFunctionHeaderModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureOrFunctionHeaderModifiersContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllABSTRACT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserABSTRACT)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) ABSTRACT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserABSTRACT, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllVIRTUAL() []antlr.TerminalNode {
	return s.GetTokens(pascalParserVIRTUAL)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) VIRTUAL(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserVIRTUAL, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllOVERRIDE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserOVERRIDE)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) OVERRIDE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserOVERRIDE, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllREINTRODUCE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserREINTRODUCE)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) REINTRODUCE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserREINTRODUCE, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllOVERLOAD() []antlr.TerminalNode {
	return s.GetTokens(pascalParserOVERLOAD)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) OVERLOAD(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserOVERLOAD, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllINLINE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserINLINE)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) INLINE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserINLINE, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllSTDCALL() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTDCALL)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) STDCALL(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTDCALL, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllCDECL() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCDECL)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) CDECL(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCDECL, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) AllSTATIC() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSTATIC)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) STATIC(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSTATIC, i)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureOrFunctionHeaderModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureOrFunctionHeaderModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureOrFunctionHeaderModifiers(s)
	}
}

func (s *ProcedureOrFunctionHeaderModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureOrFunctionHeaderModifiers(s)
	}
}

func (s *ProcedureOrFunctionHeaderModifiersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureOrFunctionHeaderModifiers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureOrFunctionHeaderModifiers() (localctx IProcedureOrFunctionHeaderModifiersContext) {
	localctx = NewProcedureOrFunctionHeaderModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, pascalParserRULE_procedureOrFunctionHeaderModifiers)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1207)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1203)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1204)
				_la = p.GetTokenStream().LA(1)

				if !((int64((_la-97)) & ^0x3f) == 0 && ((int64(1)<<(_la-97))&511) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1209)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureOrFunctionDeclarationContext is an interface to support dynamic dispatch.
type IProcedureOrFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ProcedureDeclaration() IProcedureDeclarationContext
	FunctionDeclaration() IFunctionDeclarationContext

	// IsProcedureOrFunctionDeclarationContext differentiates from other interfaces.
	IsProcedureOrFunctionDeclarationContext()
}

type ProcedureOrFunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureOrFunctionDeclarationContext() *ProcedureOrFunctionDeclarationContext {
	var p = new(ProcedureOrFunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionDeclaration
	return p
}

func InitEmptyProcedureOrFunctionDeclarationContext(p *ProcedureOrFunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionDeclaration
}

func (*ProcedureOrFunctionDeclarationContext) IsProcedureOrFunctionDeclarationContext() {}

func NewProcedureOrFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureOrFunctionDeclarationContext {
	var p = new(ProcedureOrFunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureOrFunctionDeclaration

	return p
}

func (s *ProcedureOrFunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureOrFunctionDeclarationContext) ProcedureDeclaration() IProcedureDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureDeclarationContext)
}

func (s *ProcedureOrFunctionDeclarationContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *ProcedureOrFunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureOrFunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureOrFunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureOrFunctionDeclaration(s)
	}
}

func (s *ProcedureOrFunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureOrFunctionDeclaration(s)
	}
}

func (s *ProcedureOrFunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureOrFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureOrFunctionDeclaration() (localctx IProcedureOrFunctionDeclarationContext) {
	localctx = NewProcedureOrFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, pascalParserRULE_procedureOrFunctionDeclaration)
	p.SetState(1212)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1210)
			p.ProcedureDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1211)
			p.FunctionDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureDeclarationContext is an interface to support dynamic dispatch.
type IProcedureDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ProcedureHeader() IProcedureHeaderContext
	ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext
	SEMI() antlr.TerminalNode

	// IsProcedureDeclarationContext differentiates from other interfaces.
	IsProcedureDeclarationContext()
}

type ProcedureDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDeclarationContext() *ProcedureDeclarationContext {
	var p = new(ProcedureDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureDeclaration
	return p
}

func InitEmptyProcedureDeclarationContext(p *ProcedureDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureDeclaration
}

func (*ProcedureDeclarationContext) IsProcedureDeclarationContext() {}

func NewProcedureDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDeclarationContext {
	var p = new(ProcedureDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureDeclaration

	return p
}

func (s *ProcedureDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDeclarationContext) ProcedureHeader() IProcedureHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureHeaderContext)
}

func (s *ProcedureDeclarationContext) ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionBodyContext)
}

func (s *ProcedureDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ProcedureDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureDeclaration(s)
	}
}

func (s *ProcedureDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureDeclaration(s)
	}
}

func (s *ProcedureDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureDeclaration() (localctx IProcedureDeclarationContext) {
	localctx = NewProcedureDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, pascalParserRULE_procedureDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1214)
		p.ProcedureHeader()
	}
	{
		p.SetState(1215)
		p.ProcedureOrFunctionBody()
	}
	{
		p.SetState(1216)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionHeader() IFunctionHeaderContext
	ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext
	SEMI() antlr.TerminalNode

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionDeclaration
	return p
}

func InitEmptyFunctionDeclarationContext(p *FunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionDeclaration
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) FunctionHeader() IFunctionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionHeaderContext)
}

func (s *FunctionDeclarationContext) ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionBodyContext)
}

func (s *FunctionDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, pascalParserRULE_functionDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1218)
		p.FunctionHeader()
	}
	{
		p.SetState(1219)
		p.ProcedureOrFunctionBody()
	}
	{
		p.SetState(1220)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureLambdaDeclarationContext is an interface to support dynamic dispatch.
type IProcedureLambdaDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROCEDURE() antlr.TerminalNode
	ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext
	FormalParameterList() IFormalParameterListContext

	// IsProcedureLambdaDeclarationContext differentiates from other interfaces.
	IsProcedureLambdaDeclarationContext()
}

type ProcedureLambdaDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureLambdaDeclarationContext() *ProcedureLambdaDeclarationContext {
	var p = new(ProcedureLambdaDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureLambdaDeclaration
	return p
}

func InitEmptyProcedureLambdaDeclarationContext(p *ProcedureLambdaDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureLambdaDeclaration
}

func (*ProcedureLambdaDeclarationContext) IsProcedureLambdaDeclarationContext() {}

func NewProcedureLambdaDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureLambdaDeclarationContext {
	var p = new(ProcedureLambdaDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureLambdaDeclaration

	return p
}

func (s *ProcedureLambdaDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureLambdaDeclarationContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(pascalParserPROCEDURE, 0)
}

func (s *ProcedureLambdaDeclarationContext) ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionBodyContext)
}

func (s *ProcedureLambdaDeclarationContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ProcedureLambdaDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureLambdaDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureLambdaDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureLambdaDeclaration(s)
	}
}

func (s *ProcedureLambdaDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureLambdaDeclaration(s)
	}
}

func (s *ProcedureLambdaDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureLambdaDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureLambdaDeclaration() (localctx IProcedureLambdaDeclarationContext) {
	localctx = NewProcedureLambdaDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, pascalParserRULE_procedureLambdaDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1222)
		p.Match(pascalParserPROCEDURE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1224)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1223)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1226)
		p.ProcedureOrFunctionBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionLambdaDeclarationContext is an interface to support dynamic dispatch.
type IFunctionLambdaDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNCTION() antlr.TerminalNode
	COLON() antlr.TerminalNode
	ResultType() IResultTypeContext
	ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext
	FormalParameterList() IFormalParameterListContext

	// IsFunctionLambdaDeclarationContext differentiates from other interfaces.
	IsFunctionLambdaDeclarationContext()
}

type FunctionLambdaDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionLambdaDeclarationContext() *FunctionLambdaDeclarationContext {
	var p = new(FunctionLambdaDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionLambdaDeclaration
	return p
}

func InitEmptyFunctionLambdaDeclarationContext(p *FunctionLambdaDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionLambdaDeclaration
}

func (*FunctionLambdaDeclarationContext) IsFunctionLambdaDeclarationContext() {}

func NewFunctionLambdaDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionLambdaDeclarationContext {
	var p = new(FunctionLambdaDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_functionLambdaDeclaration

	return p
}

func (s *FunctionLambdaDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionLambdaDeclarationContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(pascalParserFUNCTION, 0)
}

func (s *FunctionLambdaDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *FunctionLambdaDeclarationContext) ResultType() IResultTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultTypeContext)
}

func (s *FunctionLambdaDeclarationContext) ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionBodyContext)
}

func (s *FunctionLambdaDeclarationContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionLambdaDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionLambdaDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionLambdaDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFunctionLambdaDeclaration(s)
	}
}

func (s *FunctionLambdaDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFunctionLambdaDeclaration(s)
	}
}

func (s *FunctionLambdaDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFunctionLambdaDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FunctionLambdaDeclaration() (localctx IFunctionLambdaDeclarationContext) {
	localctx = NewFunctionLambdaDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, pascalParserRULE_functionLambdaDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1228)
		p.Match(pascalParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1230)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1229)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1232)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1233)
		p.ResultType()
	}
	{
		p.SetState(1234)
		p.ProcedureOrFunctionBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResultTypeContext is an interface to support dynamic dispatch.
type IResultTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIdentifier() ITypeIdentifierContext

	// IsResultTypeContext differentiates from other interfaces.
	IsResultTypeContext()
}

type ResultTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResultTypeContext() *ResultTypeContext {
	var p = new(ResultTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resultType
	return p
}

func InitEmptyResultTypeContext(p *ResultTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_resultType
}

func (*ResultTypeContext) IsResultTypeContext() {}

func NewResultTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResultTypeContext {
	var p = new(ResultTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_resultType

	return p
}

func (s *ResultTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ResultTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ResultTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResultTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResultTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterResultType(s)
	}
}

func (s *ResultTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitResultType(s)
	}
}

func (s *ResultTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitResultType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ResultType() (localctx IResultTypeContext) {
	localctx = NewResultTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, pascalParserRULE_resultType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1236)
		p.TypeIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureOrFunctionBodyContext is an interface to support dynamic dispatch.
type IProcedureOrFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	CompoundStatement() ICompoundStatementContext

	// IsProcedureOrFunctionBodyContext differentiates from other interfaces.
	IsProcedureOrFunctionBodyContext()
}

type ProcedureOrFunctionBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureOrFunctionBodyContext() *ProcedureOrFunctionBodyContext {
	var p = new(ProcedureOrFunctionBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionBody
	return p
}

func InitEmptyProcedureOrFunctionBodyContext(p *ProcedureOrFunctionBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureOrFunctionBody
}

func (*ProcedureOrFunctionBodyContext) IsProcedureOrFunctionBodyContext() {}

func NewProcedureOrFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureOrFunctionBodyContext {
	var p = new(ProcedureOrFunctionBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureOrFunctionBody

	return p
}

func (s *ProcedureOrFunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureOrFunctionBodyContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ProcedureOrFunctionBodyContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *ProcedureOrFunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureOrFunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureOrFunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureOrFunctionBody(s)
	}
}

func (s *ProcedureOrFunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureOrFunctionBody(s)
	}
}

func (s *ProcedureOrFunctionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureOrFunctionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureOrFunctionBody() (localctx IProcedureOrFunctionBodyContext) {
	localctx = NewProcedureOrFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, pascalParserRULE_procedureOrFunctionBody)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1238)
		p.Block()
	}
	{
		p.SetState(1239)
		p.CompoundStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassOperatorHeaderContext is an interface to support dynamic dispatch.
type IClassOperatorHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	OPERATOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	ResultType() IResultTypeContext
	ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext
	SEMI() antlr.TerminalNode
	FormalParameterList() IFormalParameterListContext

	// IsClassOperatorHeaderContext differentiates from other interfaces.
	IsClassOperatorHeaderContext()
}

type ClassOperatorHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOperatorHeaderContext() *ClassOperatorHeaderContext {
	var p = new(ClassOperatorHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classOperatorHeader
	return p
}

func InitEmptyClassOperatorHeaderContext(p *ClassOperatorHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classOperatorHeader
}

func (*ClassOperatorHeaderContext) IsClassOperatorHeaderContext() {}

func NewClassOperatorHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOperatorHeaderContext {
	var p = new(ClassOperatorHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classOperatorHeader

	return p
}

func (s *ClassOperatorHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOperatorHeaderContext) CLASS() antlr.TerminalNode {
	return s.GetToken(pascalParserCLASS, 0)
}

func (s *ClassOperatorHeaderContext) OPERATOR() antlr.TerminalNode {
	return s.GetToken(pascalParserOPERATOR, 0)
}

func (s *ClassOperatorHeaderContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassOperatorHeaderContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *ClassOperatorHeaderContext) ResultType() IResultTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultTypeContext)
}

func (s *ClassOperatorHeaderContext) ProcedureOrFunctionHeaderModifiers() IProcedureOrFunctionHeaderModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionHeaderModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionHeaderModifiersContext)
}

func (s *ClassOperatorHeaderContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ClassOperatorHeaderContext) FormalParameterList() IFormalParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ClassOperatorHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOperatorHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOperatorHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassOperatorHeader(s)
	}
}

func (s *ClassOperatorHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassOperatorHeader(s)
	}
}

func (s *ClassOperatorHeaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassOperatorHeader(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassOperatorHeader() (localctx IClassOperatorHeaderContext) {
	localctx = NewClassOperatorHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, pascalParserRULE_classOperatorHeader)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1241)
		p.Match(pascalParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1242)
		p.Match(pascalParserOPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1243)
		p.Identifier()
	}
	p.SetState(1245)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1244)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(1247)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1248)
		p.ResultType()
	}
	{
		p.SetState(1249)
		p.ProcedureOrFunctionHeaderModifiers()
	}
	{
		p.SetState(1250)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassOperatorDeclarationContext is an interface to support dynamic dispatch.
type IClassOperatorDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassOperatorHeader() IClassOperatorHeaderContext
	ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext
	SEMI() antlr.TerminalNode

	// IsClassOperatorDeclarationContext differentiates from other interfaces.
	IsClassOperatorDeclarationContext()
}

type ClassOperatorDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOperatorDeclarationContext() *ClassOperatorDeclarationContext {
	var p = new(ClassOperatorDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classOperatorDeclaration
	return p
}

func InitEmptyClassOperatorDeclarationContext(p *ClassOperatorDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_classOperatorDeclaration
}

func (*ClassOperatorDeclarationContext) IsClassOperatorDeclarationContext() {}

func NewClassOperatorDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOperatorDeclarationContext {
	var p = new(ClassOperatorDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_classOperatorDeclaration

	return p
}

func (s *ClassOperatorDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOperatorDeclarationContext) ClassOperatorHeader() IClassOperatorHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOperatorHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOperatorHeaderContext)
}

func (s *ClassOperatorDeclarationContext) ProcedureOrFunctionBody() IProcedureOrFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureOrFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureOrFunctionBodyContext)
}

func (s *ClassOperatorDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *ClassOperatorDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOperatorDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOperatorDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterClassOperatorDeclaration(s)
	}
}

func (s *ClassOperatorDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitClassOperatorDeclaration(s)
	}
}

func (s *ClassOperatorDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitClassOperatorDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ClassOperatorDeclaration() (localctx IClassOperatorDeclarationContext) {
	localctx = NewClassOperatorDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, pascalParserRULE_classOperatorDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1252)
		p.ClassOperatorHeader()
	}
	{
		p.SetState(1253)
		p.ProcedureOrFunctionBody()
	}
	{
		p.SetState(1254)
		p.Match(pascalParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllFormalParameterSection() []IFormalParameterSectionContext
	FormalParameterSection(i int) IFormalParameterSectionContext
	RPAREN() antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_formalParameterList
	return p
}

func InitEmptyFormalParameterListContext(p *FormalParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_formalParameterList
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *FormalParameterListContext) AllFormalParameterSection() []IFormalParameterSectionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFormalParameterSectionContext); ok {
			len++
		}
	}

	tst := make([]IFormalParameterSectionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFormalParameterSectionContext); ok {
			tst[i] = t.(IFormalParameterSectionContext)
			i++
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameterSection(i int) IFormalParameterSectionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormalParameterSectionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormalParameterSectionContext)
}

func (s *FormalParameterListContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *FormalParameterListContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *FormalParameterListContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFormalParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FormalParameterList() (localctx IFormalParameterListContext) {
	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, pascalParserRULE_formalParameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1256)
		p.Match(pascalParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1257)
		p.FormalParameterSection()
	}
	p.SetState(1262)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserSEMI {
		{
			p.SetState(1258)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1259)
			p.FormalParameterSection()
		}

		p.SetState(1264)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1265)
		p.Match(pascalParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormalParameterSectionContext is an interface to support dynamic dispatch.
type IFormalParameterSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParameterGroup() IParameterGroupContext
	AttributeSection() IAttributeSectionContext
	VAR() antlr.TerminalNode
	CONST() antlr.TerminalNode
	OUT() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode

	// IsFormalParameterSectionContext differentiates from other interfaces.
	IsFormalParameterSectionContext()
}

type FormalParameterSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterSectionContext() *FormalParameterSectionContext {
	var p = new(FormalParameterSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_formalParameterSection
	return p
}

func InitEmptyFormalParameterSectionContext(p *FormalParameterSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_formalParameterSection
}

func (*FormalParameterSectionContext) IsFormalParameterSectionContext() {}

func NewFormalParameterSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterSectionContext {
	var p = new(FormalParameterSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_formalParameterSection

	return p
}

func (s *FormalParameterSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterSectionContext) ParameterGroup() IParameterGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterGroupContext)
}

func (s *FormalParameterSectionContext) AttributeSection() IAttributeSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSectionContext)
}

func (s *FormalParameterSectionContext) VAR() antlr.TerminalNode {
	return s.GetToken(pascalParserVAR, 0)
}

func (s *FormalParameterSectionContext) CONST() antlr.TerminalNode {
	return s.GetToken(pascalParserCONST, 0)
}

func (s *FormalParameterSectionContext) OUT() antlr.TerminalNode {
	return s.GetToken(pascalParserOUT, 0)
}

func (s *FormalParameterSectionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(pascalParserFUNCTION, 0)
}

func (s *FormalParameterSectionContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(pascalParserPROCEDURE, 0)
}

func (s *FormalParameterSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFormalParameterSection(s)
	}
}

func (s *FormalParameterSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFormalParameterSection(s)
	}
}

func (s *FormalParameterSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFormalParameterSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FormalParameterSection() (localctx IFormalParameterSectionContext) {
	localctx = NewFormalParameterSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, pascalParserRULE_formalParameterSection)
	var _la int

	p.SetState(1296)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1268)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1267)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1270)
			p.ParameterGroup()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1272)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1271)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1274)
			p.Match(pascalParserVAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1275)
			p.ParameterGroup()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1277)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1276)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1279)
			p.Match(pascalParserCONST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1280)
			p.ParameterGroup()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1282)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1281)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1284)
			p.Match(pascalParserOUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1285)
			p.ParameterGroup()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1287)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1286)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1289)
			p.Match(pascalParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1290)
			p.ParameterGroup()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1292)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLBRACK {
			{
				p.SetState(1291)
				p.AttributeSection()
			}

		}
		{
			p.SetState(1294)
			p.Match(pascalParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1295)
			p.ParameterGroup()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterGroupContext is an interface to support dynamic dispatch.
type IParameterGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierList() IIdentifierListContext
	COLON() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	DefaultValue() IDefaultValueContext

	// IsParameterGroupContext differentiates from other interfaces.
	IsParameterGroupContext()
}

type ParameterGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterGroupContext() *ParameterGroupContext {
	var p = new(ParameterGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterGroup
	return p
}

func InitEmptyParameterGroupContext(p *ParameterGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterGroup
}

func (*ParameterGroupContext) IsParameterGroupContext() {}

func NewParameterGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterGroupContext {
	var p = new(ParameterGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_parameterGroup

	return p
}

func (s *ParameterGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterGroupContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ParameterGroupContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *ParameterGroupContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ParameterGroupContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *ParameterGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterParameterGroup(s)
	}
}

func (s *ParameterGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitParameterGroup(s)
	}
}

func (s *ParameterGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitParameterGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ParameterGroup() (localctx IParameterGroupContext) {
	localctx = NewParameterGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, pascalParserRULE_parameterGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1298)
		p.IdentifierList()
	}
	p.SetState(1301)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserCOLON {
		{
			p.SetState(1299)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1300)
			p.TypeIdentifier()
		}

	}
	p.SetState(1304)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserEQUAL {
		{
			p.SetState(1303)
			p.DefaultValue()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifierList
	return p
}

func InitEmptyIdentifierListContext(p *IdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_identifierList
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierListContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *IdentifierListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (s *IdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, pascalParserRULE_identifierList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1306)
		p.Identifier()
	}
	p.SetState(1311)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1307)
				p.Match(pascalParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1308)
				p.Identifier()
			}

		}
		p.SetState(1313)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstListContext is an interface to support dynamic dispatch.
type IConstListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsConstListContext differentiates from other interfaces.
	IsConstListContext()
}

type ConstListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstListContext() *ConstListContext {
	var p = new(ConstListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constList
	return p
}

func InitEmptyConstListContext(p *ConstListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_constList
}

func (*ConstListContext) IsConstListContext() {}

func NewConstListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstListContext {
	var p = new(ConstListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_constList

	return p
}

func (s *ConstListContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstListContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *ConstListContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ConstListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ConstListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConstList(s)
	}
}

func (s *ConstListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConstList(s)
	}
}

func (s *ConstListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConstList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConstList() (localctx IConstListContext) {
	localctx = NewConstListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, pascalParserRULE_constList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1314)
		p.Constant()
	}
	p.SetState(1319)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(1315)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1316)
			p.Constant()
		}

		p.SetState(1321)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultValueContext is an interface to support dynamic dispatch.
type IDefaultValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsDefaultValueContext differentiates from other interfaces.
	IsDefaultValueContext()
}

type DefaultValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultValueContext() *DefaultValueContext {
	var p = new(DefaultValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_defaultValue
	return p
}

func InitEmptyDefaultValueContext(p *DefaultValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_defaultValue
}

func (*DefaultValueContext) IsDefaultValueContext() {}

func NewDefaultValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultValueContext {
	var p = new(DefaultValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_defaultValue

	return p
}

func (s *DefaultValueContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultValueContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *DefaultValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DefaultValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterDefaultValue(s)
	}
}

func (s *DefaultValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitDefaultValue(s)
	}
}

func (s *DefaultValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitDefaultValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) DefaultValue() (localctx IDefaultValueContext) {
	localctx = NewDefaultValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, pascalParserRULE_defaultValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1322)
		p.Match(pascalParserEQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1323)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypedIdentifierListContext is an interface to support dynamic dispatch.
type ITypedIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierList() IIdentifierListContext
	COLON() antlr.TerminalNode
	Type_() IType_Context

	// IsTypedIdentifierListContext differentiates from other interfaces.
	IsTypedIdentifierListContext()
}

type TypedIdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedIdentifierListContext() *TypedIdentifierListContext {
	var p = new(TypedIdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typedIdentifierList
	return p
}

func InitEmptyTypedIdentifierListContext(p *TypedIdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typedIdentifierList
}

func (*TypedIdentifierListContext) IsTypedIdentifierListContext() {}

func NewTypedIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedIdentifierListContext {
	var p = new(TypedIdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typedIdentifierList

	return p
}

func (s *TypedIdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedIdentifierListContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *TypedIdentifierListContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *TypedIdentifierListContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *TypedIdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedIdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedIdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypedIdentifierList(s)
	}
}

func (s *TypedIdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypedIdentifierList(s)
	}
}

func (s *TypedIdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypedIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypedIdentifierList() (localctx ITypedIdentifierListContext) {
	localctx = NewTypedIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, pascalParserRULE_typedIdentifierList)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1325)
		p.IdentifierList()
	}
	{
		p.SetState(1326)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1327)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Label() ILabelContext
	COLON() antlr.TerminalNode
	UnlabelledStatement() IUnlabelledStatementContext
	ErrorStatement() IErrorStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Label() ILabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *StatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *StatementContext) UnlabelledStatement() IUnlabelledStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnlabelledStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnlabelledStatementContext)
}

func (s *StatementContext) ErrorStatement() IErrorStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, pascalParserRULE_statement)
	p.SetState(1335)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 138, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1329)
			p.Label()
		}
		{
			p.SetState(1330)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1331)
			p.UnlabelledStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1333)
			p.UnlabelledStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1334)
			p.ErrorStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorStatementContext is an interface to support dynamic dispatch.
type IErrorStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEND() []antlr.TerminalNode
	END(i int) antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsErrorStatementContext differentiates from other interfaces.
	IsErrorStatementContext()
}

type ErrorStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorStatementContext() *ErrorStatementContext {
	var p = new(ErrorStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorStatement
	return p
}

func InitEmptyErrorStatementContext(p *ErrorStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_errorStatement
}

func (*ErrorStatementContext) IsErrorStatementContext() {}

func NewErrorStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorStatementContext {
	var p = new(ErrorStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_errorStatement

	return p
}

func (s *ErrorStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorStatementContext) AllEND() []antlr.TerminalNode {
	return s.GetTokens(pascalParserEND)
}

func (s *ErrorStatementContext) END(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserEND, i)
}

func (s *ErrorStatementContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *ErrorStatementContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *ErrorStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterErrorStatement(s)
	}
}

func (s *ErrorStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitErrorStatement(s)
	}
}

func (s *ErrorStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitErrorStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ErrorStatement() (localctx IErrorStatementContext) {
	localctx = NewErrorStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, pascalParserRULE_errorStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1338)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1337)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || _la == pascalParserEND || _la == pascalParserSEMI {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1340)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 139, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnlabelledStatementContext is an interface to support dynamic dispatch.
type IUnlabelledStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleStatement() ISimpleStatementContext
	StructuredStatement() IStructuredStatementContext

	// IsUnlabelledStatementContext differentiates from other interfaces.
	IsUnlabelledStatementContext()
}

type UnlabelledStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnlabelledStatementContext() *UnlabelledStatementContext {
	var p = new(UnlabelledStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unlabelledStatement
	return p
}

func InitEmptyUnlabelledStatementContext(p *UnlabelledStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unlabelledStatement
}

func (*UnlabelledStatementContext) IsUnlabelledStatementContext() {}

func NewUnlabelledStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnlabelledStatementContext {
	var p = new(UnlabelledStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unlabelledStatement

	return p
}

func (s *UnlabelledStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnlabelledStatementContext) SimpleStatement() ISimpleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStatementContext)
}

func (s *UnlabelledStatementContext) StructuredStatement() IStructuredStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructuredStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructuredStatementContext)
}

func (s *UnlabelledStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnlabelledStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnlabelledStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnlabelledStatement(s)
	}
}

func (s *UnlabelledStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnlabelledStatement(s)
	}
}

func (s *UnlabelledStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnlabelledStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnlabelledStatement() (localctx IUnlabelledStatementContext) {
	localctx = NewUnlabelledStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, pascalParserRULE_unlabelledStatement)
	p.SetState(1344)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserARRAY, pascalParserBOOLEAN, pascalParserCHAR, pascalParserELSE, pascalParserEND, pascalParserGOTO, pascalParserINTEGER, pascalParserREAL, pascalParserUNTIL, pascalParserVAR, pascalParserSEMI, pascalParserLPAREN, pascalParserAT, pascalParserSTRING, pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserFINALLY, pascalParserEXCEPT, pascalParserFINALIZATION, pascalParserINHERITED, pascalParserRAISE, pascalParserCARDINAL, pascalParserLONGBOOL, pascalParserLONGINT, pascalParserIDENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1342)
			p.SimpleStatement()
		}

	case pascalParserBEGIN, pascalParserCASE, pascalParserFOR, pascalParserIF, pascalParserREPEAT, pascalParserWHILE, pascalParserWITH, pascalParserTRY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1343)
			p.StructuredStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleStatementContext is an interface to support dynamic dispatch.
type ISimpleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssignmentStatement() IAssignmentStatementContext
	MethodCallStatement() IMethodCallStatementContext
	ProcedureStatement() IProcedureStatementContext
	GotoStatement() IGotoStatementContext
	InheritedStatement() IInheritedStatementContext
	TypeCast() ITypeCastContext
	EmptyStatement_() IEmptyStatement_Context
	RaiseExceptionStatement() IRaiseExceptionStatementContext
	VariableDeclarationStatement() IVariableDeclarationStatementContext

	// IsSimpleStatementContext differentiates from other interfaces.
	IsSimpleStatementContext()
}

type SimpleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleStatementContext() *SimpleStatementContext {
	var p = new(SimpleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleStatement
	return p
}

func InitEmptySimpleStatementContext(p *SimpleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleStatement
}

func (*SimpleStatementContext) IsSimpleStatementContext() {}

func NewSimpleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleStatementContext {
	var p = new(SimpleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_simpleStatement

	return p
}

func (s *SimpleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleStatementContext) AssignmentStatement() IAssignmentStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentStatementContext)
}

func (s *SimpleStatementContext) MethodCallStatement() IMethodCallStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodCallStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodCallStatementContext)
}

func (s *SimpleStatementContext) ProcedureStatement() IProcedureStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureStatementContext)
}

func (s *SimpleStatementContext) GotoStatement() IGotoStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGotoStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGotoStatementContext)
}

func (s *SimpleStatementContext) InheritedStatement() IInheritedStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInheritedStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInheritedStatementContext)
}

func (s *SimpleStatementContext) TypeCast() ITypeCastContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeCastContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeCastContext)
}

func (s *SimpleStatementContext) EmptyStatement_() IEmptyStatement_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatement_Context)
}

func (s *SimpleStatementContext) RaiseExceptionStatement() IRaiseExceptionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRaiseExceptionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRaiseExceptionStatementContext)
}

func (s *SimpleStatementContext) VariableDeclarationStatement() IVariableDeclarationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationStatementContext)
}

func (s *SimpleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSimpleStatement(s)
	}
}

func (s *SimpleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSimpleStatement(s)
	}
}

func (s *SimpleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSimpleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SimpleStatement() (localctx ISimpleStatementContext) {
	localctx = NewSimpleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, pascalParserRULE_simpleStatement)
	p.SetState(1355)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 141, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1346)
			p.AssignmentStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1347)
			p.MethodCallStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1348)
			p.ProcedureStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1349)
			p.GotoStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1350)
			p.InheritedStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1351)
			p.TypeCast()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1352)
			p.EmptyStatement_()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1353)
			p.RaiseExceptionStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1354)
			p.VariableDeclarationStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentStatementContext is an interface to support dynamic dispatch.
type IAssignmentStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableDesignator() IVariableDesignatorContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext
	PropertyDesignator() IPropertyDesignatorContext

	// IsAssignmentStatementContext differentiates from other interfaces.
	IsAssignmentStatementContext()
}

type AssignmentStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentStatementContext() *AssignmentStatementContext {
	var p = new(AssignmentStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_assignmentStatement
	return p
}

func InitEmptyAssignmentStatementContext(p *AssignmentStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_assignmentStatement
}

func (*AssignmentStatementContext) IsAssignmentStatementContext() {}

func NewAssignmentStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentStatementContext {
	var p = new(AssignmentStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_assignmentStatement

	return p
}

func (s *AssignmentStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentStatementContext) VariableDesignator() IVariableDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDesignatorContext)
}

func (s *AssignmentStatementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(pascalParserASSIGN, 0)
}

func (s *AssignmentStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentStatementContext) PropertyDesignator() IPropertyDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDesignatorContext)
}

func (s *AssignmentStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAssignmentStatement(s)
	}
}

func (s *AssignmentStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAssignmentStatement(s)
	}
}

func (s *AssignmentStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAssignmentStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) AssignmentStatement() (localctx IAssignmentStatementContext) {
	localctx = NewAssignmentStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, pascalParserRULE_assignmentStatement)
	p.SetState(1365)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1357)
			p.VariableDesignator()
		}
		{
			p.SetState(1358)
			p.Match(pascalParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1359)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1361)
			p.PropertyDesignator()
		}
		{
			p.SetState(1362)
			p.Match(pascalParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1363)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRaiseExceptionStatementContext is an interface to support dynamic dispatch.
type IRaiseExceptionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RAISE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsRaiseExceptionStatementContext differentiates from other interfaces.
	IsRaiseExceptionStatementContext()
}

type RaiseExceptionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaiseExceptionStatementContext() *RaiseExceptionStatementContext {
	var p = new(RaiseExceptionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_raiseExceptionStatement
	return p
}

func InitEmptyRaiseExceptionStatementContext(p *RaiseExceptionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_raiseExceptionStatement
}

func (*RaiseExceptionStatementContext) IsRaiseExceptionStatementContext() {}

func NewRaiseExceptionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RaiseExceptionStatementContext {
	var p = new(RaiseExceptionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_raiseExceptionStatement

	return p
}

func (s *RaiseExceptionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RaiseExceptionStatementContext) RAISE() antlr.TerminalNode {
	return s.GetToken(pascalParserRAISE, 0)
}

func (s *RaiseExceptionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RaiseExceptionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RaiseExceptionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RaiseExceptionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRaiseExceptionStatement(s)
	}
}

func (s *RaiseExceptionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRaiseExceptionStatement(s)
	}
}

func (s *RaiseExceptionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRaiseExceptionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RaiseExceptionStatement() (localctx IRaiseExceptionStatementContext) {
	localctx = NewRaiseExceptionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, pascalParserRULE_raiseExceptionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1367)
		p.Match(pascalParserRAISE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1369)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3747047672004084136) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-284289724314546943) != 0) {
		{
			p.SetState(1368)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationStatementContext is an interface to support dynamic dispatch.
type IVariableDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VAR() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	COLON() antlr.TerminalNode
	Type_() IType_Context
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsVariableDeclarationStatementContext differentiates from other interfaces.
	IsVariableDeclarationStatementContext()
}

type VariableDeclarationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationStatementContext() *VariableDeclarationStatementContext {
	var p = new(VariableDeclarationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclarationStatement
	return p
}

func InitEmptyVariableDeclarationStatementContext(p *VariableDeclarationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDeclarationStatement
}

func (*VariableDeclarationStatementContext) IsVariableDeclarationStatementContext() {}

func NewVariableDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationStatementContext {
	var p = new(VariableDeclarationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_variableDeclarationStatement

	return p
}

func (s *VariableDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationStatementContext) VAR() antlr.TerminalNode {
	return s.GetToken(pascalParserVAR, 0)
}

func (s *VariableDeclarationStatementContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *VariableDeclarationStatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *VariableDeclarationStatementContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *VariableDeclarationStatementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(pascalParserASSIGN, 0)
}

func (s *VariableDeclarationStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterVariableDeclarationStatement(s)
	}
}

func (s *VariableDeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitVariableDeclarationStatement(s)
	}
}

func (s *VariableDeclarationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitVariableDeclarationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) VariableDeclarationStatement() (localctx IVariableDeclarationStatementContext) {
	localctx = NewVariableDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, pascalParserRULE_variableDeclarationStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1371)
		p.Match(pascalParserVAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1372)
		p.IdentifierList()
	}
	p.SetState(1375)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserCOLON {
		{
			p.SetState(1373)
			p.Match(pascalParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1374)
			p.Type_()
		}

	}
	p.SetState(1379)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserASSIGN {
		{
			p.SetState(1377)
			p.Match(pascalParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1378)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDesignatorContext is an interface to support dynamic dispatch.
type IVariableDesignatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeCast() ITypeCastContext
	AT() antlr.TerminalNode
	Identifier() IIdentifierContext
	AllFunctionDesignator() []IFunctionDesignatorContext
	FunctionDesignator(i int) IFunctionDesignatorContext
	AllLBRACK() []antlr.TerminalNode
	LBRACK(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllRBRACK() []antlr.TerminalNode
	RBRACK(i int) antlr.TerminalNode
	AllLBRACK2() []antlr.TerminalNode
	LBRACK2(i int) antlr.TerminalNode
	AllRBRACK2() []antlr.TerminalNode
	RBRACK2(i int) antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllDEREFERENCE() []antlr.TerminalNode
	DEREFERENCE(i int) antlr.TerminalNode

	// IsVariableDesignatorContext differentiates from other interfaces.
	IsVariableDesignatorContext()
}

type VariableDesignatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDesignatorContext() *VariableDesignatorContext {
	var p = new(VariableDesignatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDesignator
	return p
}

func InitEmptyVariableDesignatorContext(p *VariableDesignatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_variableDesignator
}

func (*VariableDesignatorContext) IsVariableDesignatorContext() {}

func NewVariableDesignatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDesignatorContext {
	var p = new(VariableDesignatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_variableDesignator

	return p
}

func (s *VariableDesignatorContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDesignatorContext) TypeCast() ITypeCastContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeCastContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeCastContext)
}

func (s *VariableDesignatorContext) AT() antlr.TerminalNode {
	return s.GetToken(pascalParserAT, 0)
}

func (s *VariableDesignatorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableDesignatorContext) AllFunctionDesignator() []IFunctionDesignatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionDesignatorContext); ok {
			len++
		}
	}

	tst := make([]IFunctionDesignatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionDesignatorContext); ok {
			tst[i] = t.(IFunctionDesignatorContext)
			i++
		}
	}

	return tst
}

func (s *VariableDesignatorContext) FunctionDesignator(i int) IFunctionDesignatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDesignatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDesignatorContext)
}

func (s *VariableDesignatorContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(pascalParserLBRACK)
}

func (s *VariableDesignatorContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, i)
}

func (s *VariableDesignatorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *VariableDesignatorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableDesignatorContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(pascalParserRBRACK)
}

func (s *VariableDesignatorContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, i)
}

func (s *VariableDesignatorContext) AllLBRACK2() []antlr.TerminalNode {
	return s.GetTokens(pascalParserLBRACK2)
}

func (s *VariableDesignatorContext) LBRACK2(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK2, i)
}

func (s *VariableDesignatorContext) AllRBRACK2() []antlr.TerminalNode {
	return s.GetTokens(pascalParserRBRACK2)
}

func (s *VariableDesignatorContext) RBRACK2(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK2, i)
}

func (s *VariableDesignatorContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDOT)
}

func (s *VariableDesignatorContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, i)
}

func (s *VariableDesignatorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *VariableDesignatorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *VariableDesignatorContext) AllDEREFERENCE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDEREFERENCE)
}

func (s *VariableDesignatorContext) DEREFERENCE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDEREFERENCE, i)
}

func (s *VariableDesignatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDesignatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDesignatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterVariableDesignator(s)
	}
}

func (s *VariableDesignatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitVariableDesignator(s)
	}
}

func (s *VariableDesignatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitVariableDesignator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) VariableDesignator() (localctx IVariableDesignatorContext) {
	localctx = NewVariableDesignatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, pascalParserRULE_variableDesignator)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1385)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1381)
			p.TypeCast()
		}

	case 2:
		{
			p.SetState(1382)
			p.Match(pascalParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1383)
			p.Identifier()
		}

	case 3:
		{
			p.SetState(1384)
			p.FunctionDesignator()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(1418)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 151, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1416)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case pascalParserLBRACK:
				{
					p.SetState(1387)
					p.Match(pascalParserLBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1388)
					p.Expression()
				}
				p.SetState(1393)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == pascalParserCOMMA {
					{
						p.SetState(1389)
						p.Match(pascalParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1390)
						p.Expression()
					}

					p.SetState(1395)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1396)
					p.Match(pascalParserRBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case pascalParserLBRACK2:
				{
					p.SetState(1398)
					p.Match(pascalParserLBRACK2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1399)
					p.Expression()
				}
				p.SetState(1404)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == pascalParserCOMMA {
					{
						p.SetState(1400)
						p.Match(pascalParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1401)
						p.Expression()
					}

					p.SetState(1406)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1407)
					p.Match(pascalParserRBRACK2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case pascalParserDOT:
				{
					p.SetState(1409)
					p.Match(pascalParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1410)
					p.FunctionDesignator()
				}

			case pascalParserDEREFERENCE:
				p.SetState(1412)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = 1
				for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					switch _alt {
					case 1:
						{
							p.SetState(1411)
							p.Match(pascalParserDEREFERENCE)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					default:
						p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
						goto errorExit
					}

					p.SetState(1414)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 149, p.GetParserRuleContext())
					if p.HasError() {
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(1420)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 151, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeCastContext is an interface to support dynamic dispatch.
type ITypeCastContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeIdentifier() ITypeIdentifierContext
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsTypeCastContext differentiates from other interfaces.
	IsTypeCastContext()
}

type TypeCastContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeCastContext() *TypeCastContext {
	var p = new(TypeCastContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeCast
	return p
}

func InitEmptyTypeCastContext(p *TypeCastContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_typeCast
}

func (*TypeCastContext) IsTypeCastContext() {}

func NewTypeCastContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeCastContext {
	var p = new(TypeCastContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_typeCast

	return p
}

func (s *TypeCastContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeCastContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *TypeCastContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *TypeCastContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TypeCastContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *TypeCastContext) AS() antlr.TerminalNode {
	return s.GetToken(pascalParserAS, 0)
}

func (s *TypeCastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeCastContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeCastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTypeCast(s)
	}
}

func (s *TypeCastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTypeCast(s)
	}
}

func (s *TypeCastContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTypeCast(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TypeCast() (localctx ITypeCastContext) {
	localctx = NewTypeCastContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, pascalParserRULE_typeCast)
	p.SetState(1432)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserARRAY, pascalParserBOOLEAN, pascalParserCHAR, pascalParserINTEGER, pascalParserREAL, pascalParserSTRING, pascalParserREAD, pascalParserWRITE, pascalParserINDEX, pascalParserCARDINAL, pascalParserLONGBOOL, pascalParserLONGINT, pascalParserIDENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1421)
			p.TypeIdentifier()
		}
		{
			p.SetState(1422)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1423)
			p.Expression()
		}
		{
			p.SetState(1424)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case pascalParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1426)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1427)
			p.Expression()
		}
		{
			p.SetState(1428)
			p.Match(pascalParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1429)
			p.TypeIdentifier()
		}
		{
			p.SetState(1430)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyDesignatorContext is an interface to support dynamic dispatch.
type IPropertyDesignatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFunctionDesignator() []IFunctionDesignatorContext
	FunctionDesignator(i int) IFunctionDesignatorContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	Identifier() IIdentifierContext
	LBRACK() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	RBRACK() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPropertyDesignatorContext differentiates from other interfaces.
	IsPropertyDesignatorContext()
}

type PropertyDesignatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDesignatorContext() *PropertyDesignatorContext {
	var p = new(PropertyDesignatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDesignator
	return p
}

func InitEmptyPropertyDesignatorContext(p *PropertyDesignatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_propertyDesignator
}

func (*PropertyDesignatorContext) IsPropertyDesignatorContext() {}

func NewPropertyDesignatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDesignatorContext {
	var p = new(PropertyDesignatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_propertyDesignator

	return p
}

func (s *PropertyDesignatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDesignatorContext) AllFunctionDesignator() []IFunctionDesignatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionDesignatorContext); ok {
			len++
		}
	}

	tst := make([]IFunctionDesignatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionDesignatorContext); ok {
			tst[i] = t.(IFunctionDesignatorContext)
			i++
		}
	}

	return tst
}

func (s *PropertyDesignatorContext) FunctionDesignator(i int) IFunctionDesignatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDesignatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDesignatorContext)
}

func (s *PropertyDesignatorContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDOT)
}

func (s *PropertyDesignatorContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, i)
}

func (s *PropertyDesignatorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyDesignatorContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *PropertyDesignatorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PropertyDesignatorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PropertyDesignatorContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *PropertyDesignatorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *PropertyDesignatorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *PropertyDesignatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDesignatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyDesignatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterPropertyDesignator(s)
	}
}

func (s *PropertyDesignatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitPropertyDesignator(s)
	}
}

func (s *PropertyDesignatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitPropertyDesignator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) PropertyDesignator() (localctx IPropertyDesignatorContext) {
	localctx = NewPropertyDesignatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, pascalParserRULE_propertyDesignator)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1434)
		p.FunctionDesignator()
	}
	p.SetState(1439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 153, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1435)
				p.Match(pascalParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1436)
				p.FunctionDesignator()
			}

		}
		p.SetState(1441)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 153, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1442)
		p.Match(pascalParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1443)
		p.Identifier()
	}
	p.SetState(1455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLBRACK {
		{
			p.SetState(1444)
			p.Match(pascalParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1445)
			p.Expression()
		}
		p.SetState(1450)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == pascalParserCOMMA {
			{
				p.SetState(1446)
				p.Match(pascalParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1447)
				p.Expression()
			}

			p.SetState(1452)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1453)
			p.Match(pascalParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleExpression() ISimpleExpressionContext
	Relationaloperator() IRelationaloperatorContext
	Expression() IExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) SimpleExpression() ISimpleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExpressionContext)
}

func (s *ExpressionContext) Relationaloperator() IRelationaloperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationaloperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationaloperatorContext)
}

func (s *ExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, pascalParserRULE_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1457)
		p.SimpleExpression()
	}
	p.SetState(1461)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 156, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1458)
			p.Relationaloperator()
		}
		{
			p.SetState(1459)
			p.Expression()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationaloperatorContext is an interface to support dynamic dispatch.
type IRelationaloperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL() antlr.TerminalNode
	NOT_EQUAL() antlr.TerminalNode
	LT() antlr.TerminalNode
	LE() antlr.TerminalNode
	GE() antlr.TerminalNode
	GT() antlr.TerminalNode
	IN() antlr.TerminalNode

	// IsRelationaloperatorContext differentiates from other interfaces.
	IsRelationaloperatorContext()
}

type RelationaloperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationaloperatorContext() *RelationaloperatorContext {
	var p = new(RelationaloperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_relationaloperator
	return p
}

func InitEmptyRelationaloperatorContext(p *RelationaloperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_relationaloperator
}

func (*RelationaloperatorContext) IsRelationaloperatorContext() {}

func NewRelationaloperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationaloperatorContext {
	var p = new(RelationaloperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_relationaloperator

	return p
}

func (s *RelationaloperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationaloperatorContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserEQUAL, 0)
}

func (s *RelationaloperatorContext) NOT_EQUAL() antlr.TerminalNode {
	return s.GetToken(pascalParserNOT_EQUAL, 0)
}

func (s *RelationaloperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(pascalParserLT, 0)
}

func (s *RelationaloperatorContext) LE() antlr.TerminalNode {
	return s.GetToken(pascalParserLE, 0)
}

func (s *RelationaloperatorContext) GE() antlr.TerminalNode {
	return s.GetToken(pascalParserGE, 0)
}

func (s *RelationaloperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(pascalParserGT, 0)
}

func (s *RelationaloperatorContext) IN() antlr.TerminalNode {
	return s.GetToken(pascalParserIN, 0)
}

func (s *RelationaloperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationaloperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationaloperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRelationaloperator(s)
	}
}

func (s *RelationaloperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRelationaloperator(s)
	}
}

func (s *RelationaloperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRelationaloperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Relationaloperator() (localctx IRelationaloperatorContext) {
	localctx = NewRelationaloperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, pascalParserRULE_relationaloperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1463)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&283726776526438400) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleExpressionContext is an interface to support dynamic dispatch.
type ISimpleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Term() ITermContext
	Additiveoperator() IAdditiveoperatorContext
	SimpleExpression() ISimpleExpressionContext

	// IsSimpleExpressionContext differentiates from other interfaces.
	IsSimpleExpressionContext()
}

type SimpleExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleExpressionContext() *SimpleExpressionContext {
	var p = new(SimpleExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleExpression
	return p
}

func InitEmptySimpleExpressionContext(p *SimpleExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_simpleExpression
}

func (*SimpleExpressionContext) IsSimpleExpressionContext() {}

func NewSimpleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleExpressionContext {
	var p = new(SimpleExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_simpleExpression

	return p
}

func (s *SimpleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleExpressionContext) Term() ITermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *SimpleExpressionContext) Additiveoperator() IAdditiveoperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveoperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveoperatorContext)
}

func (s *SimpleExpressionContext) SimpleExpression() ISimpleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExpressionContext)
}

func (s *SimpleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSimpleExpression(s)
	}
}

func (s *SimpleExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSimpleExpression(s)
	}
}

func (s *SimpleExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSimpleExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SimpleExpression() (localctx ISimpleExpressionContext) {
	localctx = NewSimpleExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, pascalParserRULE_simpleExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1465)
		p.Term()
	}
	p.SetState(1469)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 157, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1466)
			p.Additiveoperator()
		}
		{
			p.SetState(1467)
			p.SimpleExpression()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdditiveoperatorContext is an interface to support dynamic dispatch.
type IAdditiveoperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	OR() antlr.TerminalNode

	// IsAdditiveoperatorContext differentiates from other interfaces.
	IsAdditiveoperatorContext()
}

type AdditiveoperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveoperatorContext() *AdditiveoperatorContext {
	var p = new(AdditiveoperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_additiveoperator
	return p
}

func InitEmptyAdditiveoperatorContext(p *AdditiveoperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_additiveoperator
}

func (*AdditiveoperatorContext) IsAdditiveoperatorContext() {}

func NewAdditiveoperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveoperatorContext {
	var p = new(AdditiveoperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_additiveoperator

	return p
}

func (s *AdditiveoperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveoperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(pascalParserPLUS, 0)
}

func (s *AdditiveoperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(pascalParserMINUS, 0)
}

func (s *AdditiveoperatorContext) OR() antlr.TerminalNode {
	return s.GetToken(pascalParserOR, 0)
}

func (s *AdditiveoperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveoperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveoperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAdditiveoperator(s)
	}
}

func (s *AdditiveoperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAdditiveoperator(s)
	}
}

func (s *AdditiveoperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAdditiveoperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Additiveoperator() (localctx IAdditiveoperatorContext) {
	localctx = NewAdditiveoperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, pascalParserRULE_additiveoperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1471)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&52776826568704) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SignedFactor() ISignedFactorContext
	Multiplicativeoperator() IMultiplicativeoperatorContext
	Term() ITermContext

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_term
	return p
}

func InitEmptyTermContext(p *TermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_term
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) SignedFactor() ISignedFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignedFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignedFactorContext)
}

func (s *TermContext) Multiplicativeoperator() IMultiplicativeoperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeoperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeoperatorContext)
}

func (s *TermContext) Term() ITermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTerm(s)
	}
}

func (s *TermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTerm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, pascalParserRULE_term)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1473)
		p.SignedFactor()
	}
	p.SetState(1477)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 158, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1474)
			p.Multiplicativeoperator()
		}
		{
			p.SetState(1475)
			p.Term()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplicativeoperatorContext is an interface to support dynamic dispatch.
type IMultiplicativeoperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	SLASH() antlr.TerminalNode
	DIV() antlr.TerminalNode
	MOD() antlr.TerminalNode
	AND() antlr.TerminalNode
	SHR() antlr.TerminalNode
	SHL() antlr.TerminalNode
	XOR() antlr.TerminalNode

	// IsMultiplicativeoperatorContext differentiates from other interfaces.
	IsMultiplicativeoperatorContext()
}

type MultiplicativeoperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeoperatorContext() *MultiplicativeoperatorContext {
	var p = new(MultiplicativeoperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_multiplicativeoperator
	return p
}

func InitEmptyMultiplicativeoperatorContext(p *MultiplicativeoperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_multiplicativeoperator
}

func (*MultiplicativeoperatorContext) IsMultiplicativeoperatorContext() {}

func NewMultiplicativeoperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeoperatorContext {
	var p = new(MultiplicativeoperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_multiplicativeoperator

	return p
}

func (s *MultiplicativeoperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeoperatorContext) STAR() antlr.TerminalNode {
	return s.GetToken(pascalParserSTAR, 0)
}

func (s *MultiplicativeoperatorContext) SLASH() antlr.TerminalNode {
	return s.GetToken(pascalParserSLASH, 0)
}

func (s *MultiplicativeoperatorContext) DIV() antlr.TerminalNode {
	return s.GetToken(pascalParserDIV, 0)
}

func (s *MultiplicativeoperatorContext) MOD() antlr.TerminalNode {
	return s.GetToken(pascalParserMOD, 0)
}

func (s *MultiplicativeoperatorContext) AND() antlr.TerminalNode {
	return s.GetToken(pascalParserAND, 0)
}

func (s *MultiplicativeoperatorContext) SHR() antlr.TerminalNode {
	return s.GetToken(pascalParserSHR, 0)
}

func (s *MultiplicativeoperatorContext) SHL() antlr.TerminalNode {
	return s.GetToken(pascalParserSHL, 0)
}

func (s *MultiplicativeoperatorContext) XOR() antlr.TerminalNode {
	return s.GetToken(pascalParserXOR, 0)
}

func (s *MultiplicativeoperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeoperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeoperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterMultiplicativeoperator(s)
	}
}

func (s *MultiplicativeoperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitMultiplicativeoperator(s)
	}
}

func (s *MultiplicativeoperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitMultiplicativeoperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Multiplicativeoperator() (localctx IMultiplicativeoperatorContext) {
	localctx = NewMultiplicativeoperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, pascalParserRULE_multiplicativeoperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1479)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&211106249311236) != 0) || ((int64((_la-111)) & ^0x3f) == 0 && ((int64(1)<<(_la-111))&7) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignedFactorContext is an interface to support dynamic dispatch.
type ISignedFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Factor() IFactorContext
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsSignedFactorContext differentiates from other interfaces.
	IsSignedFactorContext()
}

type SignedFactorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignedFactorContext() *SignedFactorContext {
	var p = new(SignedFactorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_signedFactor
	return p
}

func InitEmptySignedFactorContext(p *SignedFactorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_signedFactor
}

func (*SignedFactorContext) IsSignedFactorContext() {}

func NewSignedFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignedFactorContext {
	var p = new(SignedFactorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_signedFactor

	return p
}

func (s *SignedFactorContext) GetParser() antlr.Parser { return s.parser }

func (s *SignedFactorContext) Factor() IFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *SignedFactorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(pascalParserPLUS, 0)
}

func (s *SignedFactorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(pascalParserMINUS, 0)
}

func (s *SignedFactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignedFactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignedFactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSignedFactor(s)
	}
}

func (s *SignedFactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSignedFactor(s)
	}
}

func (s *SignedFactorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSignedFactor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) SignedFactor() (localctx ISignedFactorContext) {
	localctx = NewSignedFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, pascalParserRULE_signedFactor)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1482)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1481)
			_la = p.GetTokenStream().LA(1)

			if !(_la == pascalParserPLUS || _la == pascalParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1484)
		p.factor(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFactorContext is an interface to support dynamic dispatch.
type IFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionDesignator() IFunctionDesignatorContext
	INHERITED() antlr.TerminalNode
	DefaultDesignator() IDefaultDesignatorContext
	VariableDesignator() IVariableDesignatorContext
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	RPAREN() antlr.TerminalNode
	UnsignedConstant() IUnsignedConstantContext
	Set_() ISet_Context
	NOT() antlr.TerminalNode
	Factor() IFactorContext
	Bool_() IBool_Context
	TypeIdentifier() ITypeIdentifierContext
	AT() antlr.TerminalNode
	AllDEREFERENCE() []antlr.TerminalNode
	DEREFERENCE(i int) antlr.TerminalNode
	FunctionLambdaDeclaration() IFunctionLambdaDeclarationContext
	ProcedureLambdaDeclaration() IProcedureLambdaDeclarationContext
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsFactorContext differentiates from other interfaces.
	IsFactorContext()
}

type FactorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFactorContext() *FactorContext {
	var p = new(FactorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_factor
	return p
}

func InitEmptyFactorContext(p *FactorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_factor
}

func (*FactorContext) IsFactorContext() {}

func NewFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FactorContext {
	var p = new(FactorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_factor

	return p
}

func (s *FactorContext) GetParser() antlr.Parser { return s.parser }

func (s *FactorContext) FunctionDesignator() IFunctionDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDesignatorContext)
}

func (s *FactorContext) INHERITED() antlr.TerminalNode {
	return s.GetToken(pascalParserINHERITED, 0)
}

func (s *FactorContext) DefaultDesignator() IDefaultDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultDesignatorContext)
}

func (s *FactorContext) VariableDesignator() IVariableDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDesignatorContext)
}

func (s *FactorContext) AS() antlr.TerminalNode {
	return s.GetToken(pascalParserAS, 0)
}

func (s *FactorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FactorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *FactorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *FactorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FactorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *FactorContext) UnsignedConstant() IUnsignedConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedConstantContext)
}

func (s *FactorContext) Set_() ISet_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_Context)
}

func (s *FactorContext) NOT() antlr.TerminalNode {
	return s.GetToken(pascalParserNOT, 0)
}

func (s *FactorContext) Factor() IFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *FactorContext) Bool_() IBool_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_Context)
}

func (s *FactorContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *FactorContext) AT() antlr.TerminalNode {
	return s.GetToken(pascalParserAT, 0)
}

func (s *FactorContext) AllDEREFERENCE() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDEREFERENCE)
}

func (s *FactorContext) DEREFERENCE(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDEREFERENCE, i)
}

func (s *FactorContext) FunctionLambdaDeclaration() IFunctionLambdaDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionLambdaDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionLambdaDeclarationContext)
}

func (s *FactorContext) ProcedureLambdaDeclaration() IProcedureLambdaDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureLambdaDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureLambdaDeclarationContext)
}

func (s *FactorContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *FactorContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *FactorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *FactorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *FactorContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDOT)
}

func (s *FactorContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, i)
}

func (s *FactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFactor(s)
	}
}

func (s *FactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFactor(s)
	}
}

func (s *FactorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFactor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Factor() (localctx IFactorContext) {
	return p.factor(0)
}

func (p *pascalParser) factor(_p int) (localctx IFactorContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewFactorContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IFactorContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 264
	p.EnterRecursionRule(localctx, 264, pascalParserRULE_factor, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1525)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 165, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1488)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserINHERITED {
			{
				p.SetState(1487)
				p.Match(pascalParserINHERITED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1490)
			p.FunctionDesignator()
		}

	case 2:
		{
			p.SetState(1491)
			p.DefaultDesignator()
		}

	case 3:
		{
			p.SetState(1492)
			p.VariableDesignator()
		}
		p.SetState(1495)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 161, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1493)
				p.Match(pascalParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1494)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		{
			p.SetState(1497)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1498)
			p.Expression()
		}
		{
			p.SetState(1499)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		{
			p.SetState(1501)
			p.UnsignedConstant()
		}

	case 6:
		{
			p.SetState(1502)
			p.Set_()
		}

	case 7:
		{
			p.SetState(1503)
			p.Match(pascalParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1504)
			p.factor(8)
		}

	case 8:
		{
			p.SetState(1505)
			p.Bool_()
		}

	case 9:
		p.SetState(1507)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserAT {
			{
				p.SetState(1506)
				p.Match(pascalParserAT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1509)
			p.TypeIdentifier()
		}
		p.SetState(1514)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 163, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1510)
				p.Match(pascalParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1511)
				p.Expression()
			}
			{
				p.SetState(1512)
				p.Match(pascalParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 164, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1516)
					p.Match(pascalParserDEREFERENCE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1521)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 164, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 10:
		{
			p.SetState(1522)
			p.Identifier()
		}

	case 11:
		{
			p.SetState(1523)
			p.FunctionLambdaDeclaration()
		}

	case 12:
		{
			p.SetState(1524)
			p.ProcedureLambdaDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1548)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 169, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1546)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext()) {
			case 1:
				localctx = NewFactorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, pascalParserRULE_factor)
				p.SetState(1527)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(1528)
					p.Match(pascalParserLBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1529)
					p.Expression()
				}
				p.SetState(1534)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == pascalParserCOMMA {
					{
						p.SetState(1530)
						p.Match(pascalParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1531)
						p.Expression()
					}

					p.SetState(1536)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1537)
					p.Match(pascalParserRBRACK)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				localctx = NewFactorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, pascalParserRULE_factor)
				p.SetState(1539)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				p.SetState(1542)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = 1
				for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					switch _alt {
					case 1:
						{
							p.SetState(1540)
							p.Match(pascalParserDOT)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(1541)
							p.Expression()
						}

					default:
						p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
						goto errorExit
					}

					p.SetState(1544)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 167, p.GetParserRuleContext())
					if p.HasError() {
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1550)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 169, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedConstantContext is an interface to support dynamic dispatch.
type IUnsignedConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedNumber() IUnsignedNumberContext
	Sign() ISignContext
	ConstantChr() IConstantChrContext
	HexConstant() IHexConstantContext
	String_() IStringContext
	NIL() antlr.TerminalNode

	// IsUnsignedConstantContext differentiates from other interfaces.
	IsUnsignedConstantContext()
}

type UnsignedConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedConstantContext() *UnsignedConstantContext {
	var p = new(UnsignedConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedConstant
	return p
}

func InitEmptyUnsignedConstantContext(p *UnsignedConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_unsignedConstant
}

func (*UnsignedConstantContext) IsUnsignedConstantContext() {}

func NewUnsignedConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedConstantContext {
	var p = new(UnsignedConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_unsignedConstant

	return p
}

func (s *UnsignedConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedConstantContext) UnsignedNumber() IUnsignedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedNumberContext)
}

func (s *UnsignedConstantContext) Sign() ISignContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignContext)
}

func (s *UnsignedConstantContext) ConstantChr() IConstantChrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantChrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantChrContext)
}

func (s *UnsignedConstantContext) HexConstant() IHexConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexConstantContext)
}

func (s *UnsignedConstantContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *UnsignedConstantContext) NIL() antlr.TerminalNode {
	return s.GetToken(pascalParserNIL, 0)
}

func (s *UnsignedConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterUnsignedConstant(s)
	}
}

func (s *UnsignedConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitUnsignedConstant(s)
	}
}

func (s *UnsignedConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitUnsignedConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) UnsignedConstant() (localctx IUnsignedConstantContext) {
	localctx = NewUnsignedConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, pascalParserRULE_unsignedConstant)
	var _la int

	p.SetState(1559)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserPLUS, pascalParserMINUS, pascalParserNUM_INT, pascalParserNUM_REAL:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1552)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserPLUS || _la == pascalParserMINUS {
			{
				p.SetState(1551)
				p.Sign()
			}

		}
		{
			p.SetState(1554)
			p.UnsignedNumber()
		}

	case pascalParserCHR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1555)
			p.ConstantChr()
		}

	case pascalParserHEX_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1556)
			p.HexConstant()
		}

	case pascalParserSTRING_LITERAL, pascalParserSTRING_CROSSHATCH_LITERAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1557)
			p.String_()
		}

	case pascalParserNIL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1558)
			p.Match(pascalParserNIL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDesignatorContext is an interface to support dynamic dispatch.
type IFunctionDesignatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext

	// IsFunctionDesignatorContext differentiates from other interfaces.
	IsFunctionDesignatorContext()
}

type FunctionDesignatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDesignatorContext() *FunctionDesignatorContext {
	var p = new(FunctionDesignatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionDesignator
	return p
}

func InitEmptyFunctionDesignatorContext(p *FunctionDesignatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_functionDesignator
}

func (*FunctionDesignatorContext) IsFunctionDesignatorContext() {}

func NewFunctionDesignatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDesignatorContext {
	var p = new(FunctionDesignatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_functionDesignator

	return p
}

func (s *FunctionDesignatorContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDesignatorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionDesignatorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *FunctionDesignatorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *FunctionDesignatorContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *FunctionDesignatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDesignatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDesignatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFunctionDesignator(s)
	}
}

func (s *FunctionDesignatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFunctionDesignator(s)
	}
}

func (s *FunctionDesignatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFunctionDesignator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FunctionDesignator() (localctx IFunctionDesignatorContext) {
	localctx = NewFunctionDesignatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, pascalParserRULE_functionDesignator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1561)
		p.Identifier()
	}

	p.SetState(1567)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 173, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1562)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1564)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3747047672004084136) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-284289724314546943) != 0) {
			{
				p.SetState(1563)
				p.ParameterList()
			}

		}
		{
			p.SetState(1566)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultDesignatorContext is an interface to support dynamic dispatch.
type IDefaultDesignatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext
	RPAREN() antlr.TerminalNode

	// IsDefaultDesignatorContext differentiates from other interfaces.
	IsDefaultDesignatorContext()
}

type DefaultDesignatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultDesignatorContext() *DefaultDesignatorContext {
	var p = new(DefaultDesignatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_defaultDesignator
	return p
}

func InitEmptyDefaultDesignatorContext(p *DefaultDesignatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_defaultDesignator
}

func (*DefaultDesignatorContext) IsDefaultDesignatorContext() {}

func NewDefaultDesignatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultDesignatorContext {
	var p = new(DefaultDesignatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_defaultDesignator

	return p
}

func (s *DefaultDesignatorContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultDesignatorContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(pascalParserDEFAULT, 0)
}

func (s *DefaultDesignatorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *DefaultDesignatorContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *DefaultDesignatorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *DefaultDesignatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultDesignatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultDesignatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterDefaultDesignator(s)
	}
}

func (s *DefaultDesignatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitDefaultDesignator(s)
	}
}

func (s *DefaultDesignatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitDefaultDesignator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) DefaultDesignator() (localctx IDefaultDesignatorContext) {
	localctx = NewDefaultDesignatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, pascalParserRULE_defaultDesignator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1569)
		p.Match(pascalParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1574)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 174, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1570)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1571)
			p.ParameterList()
		}
		{
			p.SetState(1572)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterListContext is an interface to support dynamic dispatch.
type IParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllActualParameter() []IActualParameterContext
	ActualParameter(i int) IActualParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsParameterListContext differentiates from other interfaces.
	IsParameterListContext()
}

type ParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterListContext() *ParameterListContext {
	var p = new(ParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterList
	return p
}

func InitEmptyParameterListContext(p *ParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterList
}

func (*ParameterListContext) IsParameterListContext() {}

func NewParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterListContext {
	var p = new(ParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_parameterList

	return p
}

func (s *ParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterListContext) AllActualParameter() []IActualParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IActualParameterContext); ok {
			len++
		}
	}

	tst := make([]IActualParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IActualParameterContext); ok {
			tst[i] = t.(IActualParameterContext)
			i++
		}
	}

	return tst
}

func (s *ParameterListContext) ActualParameter(i int) IActualParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IActualParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IActualParameterContext)
}

func (s *ParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterParameterList(s)
	}
}

func (s *ParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitParameterList(s)
	}
}

func (s *ParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ParameterList() (localctx IParameterListContext) {
	localctx = NewParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, pascalParserRULE_parameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1576)
		p.ActualParameter()
	}
	p.SetState(1581)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(1577)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1578)
			p.ActualParameter()
		}

		p.SetState(1583)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_Context is an interface to support dynamic dispatch.
type ISet_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	ElementList() IElementListContext
	RBRACK() antlr.TerminalNode
	LBRACK2() antlr.TerminalNode
	RBRACK2() antlr.TerminalNode

	// IsSet_Context differentiates from other interfaces.
	IsSet_Context()
}

type Set_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_Context() *Set_Context {
	var p = new(Set_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_set_
	return p
}

func InitEmptySet_Context(p *Set_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_set_
}

func (*Set_Context) IsSet_Context() {}

func NewSet_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_Context {
	var p = new(Set_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_set_

	return p
}

func (s *Set_Context) GetParser() antlr.Parser { return s.parser }

func (s *Set_Context) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *Set_Context) ElementList() IElementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementListContext)
}

func (s *Set_Context) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *Set_Context) LBRACK2() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK2, 0)
}

func (s *Set_Context) RBRACK2() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK2, 0)
}

func (s *Set_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterSet_(s)
	}
}

func (s *Set_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitSet_(s)
	}
}

func (s *Set_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitSet_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Set_() (localctx ISet_Context) {
	localctx = NewSet_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, pascalParserRULE_set_)
	p.SetState(1592)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserLBRACK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1584)
			p.Match(pascalParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1585)
			p.ElementList()
		}
		{
			p.SetState(1586)
			p.Match(pascalParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case pascalParserLBRACK2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1588)
			p.Match(pascalParserLBRACK2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1589)
			p.ElementList()
		}
		{
			p.SetState(1590)
			p.Match(pascalParserRBRACK2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementListContext is an interface to support dynamic dispatch.
type IElementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllElement() []IElementContext
	Element(i int) IElementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsElementListContext differentiates from other interfaces.
	IsElementListContext()
}

type ElementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementListContext() *ElementListContext {
	var p = new(ElementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_elementList
	return p
}

func InitEmptyElementListContext(p *ElementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_elementList
}

func (*ElementListContext) IsElementListContext() {}

func NewElementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementListContext {
	var p = new(ElementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_elementList

	return p
}

func (s *ElementListContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementListContext) AllElement() []IElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElementContext); ok {
			len++
		}
	}

	tst := make([]IElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElementContext); ok {
			tst[i] = t.(IElementContext)
			i++
		}
	}

	return tst
}

func (s *ElementListContext) Element(i int) IElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementContext)
}

func (s *ElementListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *ElementListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *ElementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterElementList(s)
	}
}

func (s *ElementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitElementList(s)
	}
}

func (s *ElementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitElementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ElementList() (localctx IElementListContext) {
	localctx = NewElementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, pascalParserRULE_elementList)
	var _la int

	p.SetState(1603)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserARRAY, pascalParserBOOLEAN, pascalParserCHAR, pascalParserCHR, pascalParserFUNCTION, pascalParserINTEGER, pascalParserNIL, pascalParserNOT, pascalParserPROCEDURE, pascalParserREAL, pascalParserPLUS, pascalParserMINUS, pascalParserLPAREN, pascalParserLBRACK, pascalParserLBRACK2, pascalParserAT, pascalParserSTRING, pascalParserTRUE, pascalParserFALSE, pascalParserREAD, pascalParserWRITE, pascalParserDEFAULT, pascalParserINDEX, pascalParserINHERITED, pascalParserCARDINAL, pascalParserLONGBOOL, pascalParserLONGINT, pascalParserIDENT, pascalParserHEX_LITERAL, pascalParserSTRING_LITERAL, pascalParserSTRING_CROSSHATCH_LITERAL, pascalParserNUM_INT, pascalParserNUM_REAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1594)
			p.Element()
		}
		p.SetState(1599)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == pascalParserCOMMA {
			{
				p.SetState(1595)
				p.Match(pascalParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1596)
				p.Element()
			}

			p.SetState(1601)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case pascalParserRBRACK, pascalParserRBRACK2:
		p.EnterOuterAlt(localctx, 2)

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementContext is an interface to support dynamic dispatch.
type IElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	DOTDOT() antlr.TerminalNode

	// IsElementContext differentiates from other interfaces.
	IsElementContext()
}

type ElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementContext() *ElementContext {
	var p = new(ElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_element
	return p
}

func InitEmptyElementContext(p *ElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_element
}

func (*ElementContext) IsElementContext() {}

func NewElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementContext {
	var p = new(ElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_element

	return p
}

func (s *ElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ElementContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ElementContext) DOTDOT() antlr.TerminalNode {
	return s.GetToken(pascalParserDOTDOT, 0)
}

func (s *ElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterElement(s)
	}
}

func (s *ElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitElement(s)
	}
}

func (s *ElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Element() (localctx IElementContext) {
	localctx = NewElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, pascalParserRULE_element)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1605)
		p.Expression()
	}
	p.SetState(1608)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserDOTDOT {
		{
			p.SetState(1606)
			p.Match(pascalParserDOTDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1607)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureStatementContext is an interface to support dynamic dispatch.
type IProcedureStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext

	// IsProcedureStatementContext differentiates from other interfaces.
	IsProcedureStatementContext()
}

type ProcedureStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureStatementContext() *ProcedureStatementContext {
	var p = new(ProcedureStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureStatement
	return p
}

func InitEmptyProcedureStatementContext(p *ProcedureStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_procedureStatement
}

func (*ProcedureStatementContext) IsProcedureStatementContext() {}

func NewProcedureStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureStatementContext {
	var p = new(ProcedureStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_procedureStatement

	return p
}

func (s *ProcedureStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ProcedureStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *ProcedureStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *ProcedureStatementContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *ProcedureStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterProcedureStatement(s)
	}
}

func (s *ProcedureStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitProcedureStatement(s)
	}
}

func (s *ProcedureStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitProcedureStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ProcedureStatement() (localctx IProcedureStatementContext) {
	localctx = NewProcedureStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, pascalParserRULE_procedureStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1610)
		p.Identifier()
	}
	p.SetState(1616)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1611)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1613)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3747047672004084136) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&-284289724314546943) != 0) {
			{
				p.SetState(1612)
				p.ParameterList()
			}

		}
		{
			p.SetState(1615)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodCallStatementContext is an interface to support dynamic dispatch.
type IMethodCallStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariableDesignator() []IVariableDesignatorContext
	VariableDesignator(i int) IVariableDesignatorContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext
	RPAREN() antlr.TerminalNode

	// IsMethodCallStatementContext differentiates from other interfaces.
	IsMethodCallStatementContext()
}

type MethodCallStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodCallStatementContext() *MethodCallStatementContext {
	var p = new(MethodCallStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_methodCallStatement
	return p
}

func InitEmptyMethodCallStatementContext(p *MethodCallStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_methodCallStatement
}

func (*MethodCallStatementContext) IsMethodCallStatementContext() {}

func NewMethodCallStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodCallStatementContext {
	var p = new(MethodCallStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_methodCallStatement

	return p
}

func (s *MethodCallStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodCallStatementContext) AllVariableDesignator() []IVariableDesignatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDesignatorContext); ok {
			len++
		}
	}

	tst := make([]IVariableDesignatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDesignatorContext); ok {
			tst[i] = t.(IVariableDesignatorContext)
			i++
		}
	}

	return tst
}

func (s *MethodCallStatementContext) VariableDesignator(i int) IVariableDesignatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDesignatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDesignatorContext)
}

func (s *MethodCallStatementContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(pascalParserDOT)
}

func (s *MethodCallStatementContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserDOT, i)
}

func (s *MethodCallStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MethodCallStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *MethodCallStatementContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *MethodCallStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *MethodCallStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodCallStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodCallStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterMethodCallStatement(s)
	}
}

func (s *MethodCallStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitMethodCallStatement(s)
	}
}

func (s *MethodCallStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitMethodCallStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) MethodCallStatement() (localctx IMethodCallStatementContext) {
	localctx = NewMethodCallStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, pascalParserRULE_methodCallStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1618)
		p.VariableDesignator()
	}
	p.SetState(1623)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 182, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1619)
				p.Match(pascalParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1620)
				p.VariableDesignator()
			}

		}
		p.SetState(1625)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 182, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1626)
		p.Match(pascalParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1627)
		p.Identifier()
	}
	p.SetState(1632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1628)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1629)
			p.ParameterList()
		}
		{
			p.SetState(1630)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IActualParameterContext is an interface to support dynamic dispatch.
type IActualParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	AllParameterwidth() []IParameterwidthContext
	Parameterwidth(i int) IParameterwidthContext
	ProcedureLambdaDeclaration() IProcedureLambdaDeclarationContext
	FunctionLambdaDeclaration() IFunctionLambdaDeclarationContext

	// IsActualParameterContext differentiates from other interfaces.
	IsActualParameterContext()
}

type ActualParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActualParameterContext() *ActualParameterContext {
	var p = new(ActualParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_actualParameter
	return p
}

func InitEmptyActualParameterContext(p *ActualParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_actualParameter
}

func (*ActualParameterContext) IsActualParameterContext() {}

func NewActualParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ActualParameterContext {
	var p = new(ActualParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_actualParameter

	return p
}

func (s *ActualParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ActualParameterContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ActualParameterContext) AllParameterwidth() []IParameterwidthContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterwidthContext); ok {
			len++
		}
	}

	tst := make([]IParameterwidthContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterwidthContext); ok {
			tst[i] = t.(IParameterwidthContext)
			i++
		}
	}

	return tst
}

func (s *ActualParameterContext) Parameterwidth(i int) IParameterwidthContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterwidthContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterwidthContext)
}

func (s *ActualParameterContext) ProcedureLambdaDeclaration() IProcedureLambdaDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureLambdaDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureLambdaDeclarationContext)
}

func (s *ActualParameterContext) FunctionLambdaDeclaration() IFunctionLambdaDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionLambdaDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionLambdaDeclarationContext)
}

func (s *ActualParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ActualParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ActualParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterActualParameter(s)
	}
}

func (s *ActualParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitActualParameter(s)
	}
}

func (s *ActualParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitActualParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ActualParameter() (localctx IActualParameterContext) {
	localctx = NewActualParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, pascalParserRULE_actualParameter)
	var _la int

	p.SetState(1643)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 185, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1634)
			p.Expression()
		}
		p.SetState(1638)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == pascalParserCOLON {
			{
				p.SetState(1635)
				p.Parameterwidth()
			}

			p.SetState(1640)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1641)
			p.ProcedureLambdaDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1642)
			p.FunctionLambdaDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterwidthContext is an interface to support dynamic dispatch.
type IParameterwidthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode
	Expression() IExpressionContext

	// IsParameterwidthContext differentiates from other interfaces.
	IsParameterwidthContext()
}

type ParameterwidthContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterwidthContext() *ParameterwidthContext {
	var p = new(ParameterwidthContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterwidth
	return p
}

func InitEmptyParameterwidthContext(p *ParameterwidthContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_parameterwidth
}

func (*ParameterwidthContext) IsParameterwidthContext() {}

func NewParameterwidthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterwidthContext {
	var p = new(ParameterwidthContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_parameterwidth

	return p
}

func (s *ParameterwidthContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterwidthContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *ParameterwidthContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParameterwidthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterwidthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterwidthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterParameterwidth(s)
	}
}

func (s *ParameterwidthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitParameterwidth(s)
	}
}

func (s *ParameterwidthContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitParameterwidth(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Parameterwidth() (localctx IParameterwidthContext) {
	localctx = NewParameterwidthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, pascalParserRULE_parameterwidth)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1645)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1646)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGotoStatementContext is an interface to support dynamic dispatch.
type IGotoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GOTO() antlr.TerminalNode
	Label() ILabelContext

	// IsGotoStatementContext differentiates from other interfaces.
	IsGotoStatementContext()
}

type GotoStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGotoStatementContext() *GotoStatementContext {
	var p = new(GotoStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_gotoStatement
	return p
}

func InitEmptyGotoStatementContext(p *GotoStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_gotoStatement
}

func (*GotoStatementContext) IsGotoStatementContext() {}

func NewGotoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GotoStatementContext {
	var p = new(GotoStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_gotoStatement

	return p
}

func (s *GotoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GotoStatementContext) GOTO() antlr.TerminalNode {
	return s.GetToken(pascalParserGOTO, 0)
}

func (s *GotoStatementContext) Label() ILabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *GotoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GotoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GotoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterGotoStatement(s)
	}
}

func (s *GotoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitGotoStatement(s)
	}
}

func (s *GotoStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitGotoStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) GotoStatement() (localctx IGotoStatementContext) {
	localctx = NewGotoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, pascalParserRULE_gotoStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1648)
		p.Match(pascalParserGOTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1649)
		p.Label()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInheritedStatementContext is an interface to support dynamic dispatch.
type IInheritedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INHERITED() antlr.TerminalNode
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext
	RPAREN() antlr.TerminalNode

	// IsInheritedStatementContext differentiates from other interfaces.
	IsInheritedStatementContext()
}

type InheritedStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInheritedStatementContext() *InheritedStatementContext {
	var p = new(InheritedStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_inheritedStatement
	return p
}

func InitEmptyInheritedStatementContext(p *InheritedStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_inheritedStatement
}

func (*InheritedStatementContext) IsInheritedStatementContext() {}

func NewInheritedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InheritedStatementContext {
	var p = new(InheritedStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_inheritedStatement

	return p
}

func (s *InheritedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InheritedStatementContext) INHERITED() antlr.TerminalNode {
	return s.GetToken(pascalParserINHERITED, 0)
}

func (s *InheritedStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InheritedStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *InheritedStatementContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *InheritedStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *InheritedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InheritedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InheritedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInheritedStatement(s)
	}
}

func (s *InheritedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInheritedStatement(s)
	}
}

func (s *InheritedStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInheritedStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InheritedStatement() (localctx IInheritedStatementContext) {
	localctx = NewInheritedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, pascalParserRULE_inheritedStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1651)
		p.Match(pascalParserINHERITED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1659)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-85)) & ^0x3f) == 0 && ((int64(1)<<(_la-85))&274877906955) != 0 {
		{
			p.SetState(1652)
			p.Identifier()
		}
		p.SetState(1657)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserLPAREN {
			{
				p.SetState(1653)
				p.Match(pascalParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1654)
				p.ParameterList()
			}
			{
				p.SetState(1655)
				p.Match(pascalParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmptyStatement_Context is an interface to support dynamic dispatch.
type IEmptyStatement_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsEmptyStatement_Context differentiates from other interfaces.
	IsEmptyStatement_Context()
}

type EmptyStatement_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatement_Context() *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_emptyStatement_
	return p
}

func InitEmptyEmptyStatement_Context(p *EmptyStatement_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_emptyStatement_
}

func (*EmptyStatement_Context) IsEmptyStatement_Context() {}

func NewEmptyStatement_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_emptyStatement_

	return p
}

func (s *EmptyStatement_Context) GetParser() antlr.Parser { return s.parser }
func (s *EmptyStatement_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatement_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatement_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitEmptyStatement_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) EmptyStatement_() (localctx IEmptyStatement_Context) {
	localctx = NewEmptyStatement_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, pascalParserRULE_emptyStatement_)
	p.EnterOuterAlt(localctx, 1)

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmpty_Context is an interface to support dynamic dispatch.
type IEmpty_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsEmpty_Context differentiates from other interfaces.
	IsEmpty_Context()
}

type Empty_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmpty_Context() *Empty_Context {
	var p = new(Empty_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_empty_
	return p
}

func InitEmptyEmpty_Context(p *Empty_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_empty_
}

func (*Empty_Context) IsEmpty_Context() {}

func NewEmpty_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Empty_Context {
	var p = new(Empty_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_empty_

	return p
}

func (s *Empty_Context) GetParser() antlr.Parser { return s.parser }
func (s *Empty_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Empty_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Empty_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterEmpty_(s)
	}
}

func (s *Empty_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitEmpty_(s)
	}
}

func (s *Empty_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitEmpty_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Empty_() (localctx IEmpty_Context) {
	localctx = NewEmpty_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, pascalParserRULE_empty_)
	p.EnterOuterAlt(localctx, 1)

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructuredStatementContext is an interface to support dynamic dispatch.
type IStructuredStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CompoundStatement() ICompoundStatementContext
	ConditionalStatement() IConditionalStatementContext
	RepetetiveStatement() IRepetetiveStatementContext
	WithStatement() IWithStatementContext
	TryExceptStatement() ITryExceptStatementContext
	TryFinallyStatement() ITryFinallyStatementContext

	// IsStructuredStatementContext differentiates from other interfaces.
	IsStructuredStatementContext()
}

type StructuredStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructuredStatementContext() *StructuredStatementContext {
	var p = new(StructuredStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_structuredStatement
	return p
}

func InitEmptyStructuredStatementContext(p *StructuredStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_structuredStatement
}

func (*StructuredStatementContext) IsStructuredStatementContext() {}

func NewStructuredStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructuredStatementContext {
	var p = new(StructuredStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_structuredStatement

	return p
}

func (s *StructuredStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StructuredStatementContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *StructuredStatementContext) ConditionalStatement() IConditionalStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalStatementContext)
}

func (s *StructuredStatementContext) RepetetiveStatement() IRepetetiveStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepetetiveStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepetetiveStatementContext)
}

func (s *StructuredStatementContext) WithStatement() IWithStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithStatementContext)
}

func (s *StructuredStatementContext) TryExceptStatement() ITryExceptStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryExceptStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryExceptStatementContext)
}

func (s *StructuredStatementContext) TryFinallyStatement() ITryFinallyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryFinallyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryFinallyStatementContext)
}

func (s *StructuredStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructuredStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructuredStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStructuredStatement(s)
	}
}

func (s *StructuredStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStructuredStatement(s)
	}
}

func (s *StructuredStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStructuredStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) StructuredStatement() (localctx IStructuredStatementContext) {
	localctx = NewStructuredStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, pascalParserRULE_structuredStatement)
	p.SetState(1671)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 188, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1665)
			p.CompoundStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1666)
			p.ConditionalStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1667)
			p.RepetetiveStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1668)
			p.WithStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1669)
			p.TryExceptStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1670)
			p.TryFinallyStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompoundStatementContext is an interface to support dynamic dispatch.
type ICompoundStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEGIN() antlr.TerminalNode
	Statements() IStatementsContext
	END() antlr.TerminalNode

	// IsCompoundStatementContext differentiates from other interfaces.
	IsCompoundStatementContext()
}

type CompoundStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundStatementContext() *CompoundStatementContext {
	var p = new(CompoundStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_compoundStatement
	return p
}

func InitEmptyCompoundStatementContext(p *CompoundStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_compoundStatement
}

func (*CompoundStatementContext) IsCompoundStatementContext() {}

func NewCompoundStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundStatementContext {
	var p = new(CompoundStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_compoundStatement

	return p
}

func (s *CompoundStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundStatementContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(pascalParserBEGIN, 0)
}

func (s *CompoundStatementContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *CompoundStatementContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *CompoundStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitCompoundStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) CompoundStatement() (localctx ICompoundStatementContext) {
	localctx = NewCompoundStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, pascalParserRULE_compoundStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1673)
		p.Match(pascalParserBEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1674)
		p.Statements()
	}
	{
		p.SetState(1675)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementsContext is an interface to support dynamic dispatch.
type IStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsStatementsContext differentiates from other interfaces.
	IsStatementsContext()
}

type StatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsContext() *StatementsContext {
	var p = new(StatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_statements
	return p
}

func InitEmptyStatementsContext(p *StatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_statements
}

func (*StatementsContext) IsStatementsContext() {}

func NewStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsContext {
	var p = new(StatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_statements

	return p
}

func (s *StatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementsContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementsContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *StatementsContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *StatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterStatements(s)
	}
}

func (s *StatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitStatements(s)
	}
}

func (s *StatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) Statements() (localctx IStatementsContext) {
	localctx = NewStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, pascalParserRULE_statements)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1677)
		p.Statement()
	}
	p.SetState(1682)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 189, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1678)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1679)
				p.Statement()
			}

		}
		p.SetState(1684)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 189, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionalStatementContext is an interface to support dynamic dispatch.
type IConditionalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IfStatement() IIfStatementContext
	CaseStatement() ICaseStatementContext

	// IsConditionalStatementContext differentiates from other interfaces.
	IsConditionalStatementContext()
}

type ConditionalStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalStatementContext() *ConditionalStatementContext {
	var p = new(ConditionalStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_conditionalStatement
	return p
}

func InitEmptyConditionalStatementContext(p *ConditionalStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_conditionalStatement
}

func (*ConditionalStatementContext) IsConditionalStatementContext() {}

func NewConditionalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalStatementContext {
	var p = new(ConditionalStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_conditionalStatement

	return p
}

func (s *ConditionalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalStatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *ConditionalStatementContext) CaseStatement() ICaseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseStatementContext)
}

func (s *ConditionalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterConditionalStatement(s)
	}
}

func (s *ConditionalStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitConditionalStatement(s)
	}
}

func (s *ConditionalStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitConditionalStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ConditionalStatement() (localctx IConditionalStatementContext) {
	localctx = NewConditionalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, pascalParserRULE_conditionalStatement)
	p.SetState(1687)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserIF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1685)
			p.IfStatement()
		}

	case pascalParserCASE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1686)
			p.CaseStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	Expression() IExpressionContext
	THEN() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	ELSE() antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_ifStatement
	return p
}

func InitEmptyIfStatementContext(p *IfStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_ifStatement
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(pascalParserIF, 0)
}

func (s *IfStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfStatementContext) THEN() antlr.TerminalNode {
	return s.GetToken(pascalParserTHEN, 0)
}

func (s *IfStatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(pascalParserELSE, 0)
}

func (s *IfStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, 0)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, pascalParserRULE_ifStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1689)
		p.Match(pascalParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1690)
		p.Expression()
	}
	{
		p.SetState(1691)
		p.Match(pascalParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1692)
		p.Statement()
	}
	p.SetState(1695)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 191, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1693)
			p.Match(pascalParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1694)
			p.Statement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1698)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 192, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1697)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseStatementContext is an interface to support dynamic dispatch.
type ICaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	Expression() IExpressionContext
	OF() antlr.TerminalNode
	AllCaseListElement() []ICaseListElementContext
	CaseListElement(i int) ICaseListElementContext
	END() antlr.TerminalNode
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	ELSE() antlr.TerminalNode
	Statements() IStatementsContext

	// IsCaseStatementContext differentiates from other interfaces.
	IsCaseStatementContext()
}

type CaseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseStatementContext() *CaseStatementContext {
	var p = new(CaseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_caseStatement
	return p
}

func InitEmptyCaseStatementContext(p *CaseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_caseStatement
}

func (*CaseStatementContext) IsCaseStatementContext() {}

func NewCaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseStatementContext {
	var p = new(CaseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_caseStatement

	return p
}

func (s *CaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseStatementContext) CASE() antlr.TerminalNode {
	return s.GetToken(pascalParserCASE, 0)
}

func (s *CaseStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseStatementContext) OF() antlr.TerminalNode {
	return s.GetToken(pascalParserOF, 0)
}

func (s *CaseStatementContext) AllCaseListElement() []ICaseListElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseListElementContext); ok {
			len++
		}
	}

	tst := make([]ICaseListElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseListElementContext); ok {
			tst[i] = t.(ICaseListElementContext)
			i++
		}
	}

	return tst
}

func (s *CaseStatementContext) CaseListElement(i int) ICaseListElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseListElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseListElementContext)
}

func (s *CaseStatementContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *CaseStatementContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *CaseStatementContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *CaseStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(pascalParserELSE, 0)
}

func (s *CaseStatementContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *CaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterCaseStatement(s)
	}
}

func (s *CaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitCaseStatement(s)
	}
}

func (s *CaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitCaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) CaseStatement() (localctx ICaseStatementContext) {
	localctx = NewCaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, pascalParserRULE_caseStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1700)
		p.Match(pascalParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1701)
		p.Expression()
	}
	{
		p.SetState(1702)
		p.Match(pascalParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1703)
		p.CaseListElement()
	}
	p.SetState(1708)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 193, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1704)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1705)
				p.CaseListElement()
			}

		}
		p.SetState(1710)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 193, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1714)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 194, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1711)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1712)
			p.Match(pascalParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1713)
			p.Statements()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1717)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserSEMI {
		{
			p.SetState(1716)
			p.Match(pascalParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1719)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseListElementContext is an interface to support dynamic dispatch.
type ICaseListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConstList() IConstListContext
	COLON() antlr.TerminalNode
	Statement() IStatementContext

	// IsCaseListElementContext differentiates from other interfaces.
	IsCaseListElementContext()
}

type CaseListElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseListElementContext() *CaseListElementContext {
	var p = new(CaseListElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_caseListElement
	return p
}

func InitEmptyCaseListElementContext(p *CaseListElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_caseListElement
}

func (*CaseListElementContext) IsCaseListElementContext() {}

func NewCaseListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseListElementContext {
	var p = new(CaseListElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_caseListElement

	return p
}

func (s *CaseListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseListElementContext) ConstList() IConstListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstListContext)
}

func (s *CaseListElementContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *CaseListElementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *CaseListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseListElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterCaseListElement(s)
	}
}

func (s *CaseListElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitCaseListElement(s)
	}
}

func (s *CaseListElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitCaseListElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) CaseListElement() (localctx ICaseListElementContext) {
	localctx = NewCaseListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, pascalParserRULE_caseListElement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1721)
		p.ConstList()
	}
	{
		p.SetState(1722)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1723)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRepetetiveStatementContext is an interface to support dynamic dispatch.
type IRepetetiveStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WhileStatement() IWhileStatementContext
	RepeatStatement() IRepeatStatementContext
	ForStatement() IForStatementContext

	// IsRepetetiveStatementContext differentiates from other interfaces.
	IsRepetetiveStatementContext()
}

type RepetetiveStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepetetiveStatementContext() *RepetetiveStatementContext {
	var p = new(RepetetiveStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_repetetiveStatement
	return p
}

func InitEmptyRepetetiveStatementContext(p *RepetetiveStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_repetetiveStatement
}

func (*RepetetiveStatementContext) IsRepetetiveStatementContext() {}

func NewRepetetiveStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RepetetiveStatementContext {
	var p = new(RepetetiveStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_repetetiveStatement

	return p
}

func (s *RepetetiveStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RepetetiveStatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *RepetetiveStatementContext) RepeatStatement() IRepeatStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepeatStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepeatStatementContext)
}

func (s *RepetetiveStatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *RepetetiveStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepetetiveStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RepetetiveStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRepetetiveStatement(s)
	}
}

func (s *RepetetiveStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRepetetiveStatement(s)
	}
}

func (s *RepetetiveStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRepetetiveStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RepetetiveStatement() (localctx IRepetetiveStatementContext) {
	localctx = NewRepetetiveStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, pascalParserRULE_repetetiveStatement)
	p.SetState(1728)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case pascalParserWHILE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1725)
			p.WhileStatement()
		}

	case pascalParserREPEAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1726)
			p.RepeatStatement()
		}

	case pascalParserFOR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1727)
			p.ForStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHILE() antlr.TerminalNode
	Expression() IExpressionContext
	DO() antlr.TerminalNode
	Statement() IStatementContext

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_whileStatement
	return p
}

func InitEmptyWhileStatementContext(p *WhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_whileStatement
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(pascalParserWHILE, 0)
}

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(pascalParserDO, 0)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (s *WhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, pascalParserRULE_whileStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1730)
		p.Match(pascalParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1731)
		p.Expression()
	}
	{
		p.SetState(1732)
		p.Match(pascalParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1733)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRepeatStatementContext is an interface to support dynamic dispatch.
type IRepeatStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPEAT() antlr.TerminalNode
	Statements() IStatementsContext
	UNTIL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsRepeatStatementContext differentiates from other interfaces.
	IsRepeatStatementContext()
}

type RepeatStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepeatStatementContext() *RepeatStatementContext {
	var p = new(RepeatStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_repeatStatement
	return p
}

func InitEmptyRepeatStatementContext(p *RepeatStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_repeatStatement
}

func (*RepeatStatementContext) IsRepeatStatementContext() {}

func NewRepeatStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RepeatStatementContext {
	var p = new(RepeatStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_repeatStatement

	return p
}

func (s *RepeatStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RepeatStatementContext) REPEAT() antlr.TerminalNode {
	return s.GetToken(pascalParserREPEAT, 0)
}

func (s *RepeatStatementContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *RepeatStatementContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(pascalParserUNTIL, 0)
}

func (s *RepeatStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RepeatStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepeatStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RepeatStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterRepeatStatement(s)
	}
}

func (s *RepeatStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitRepeatStatement(s)
	}
}

func (s *RepeatStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitRepeatStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) RepeatStatement() (localctx IRepeatStatementContext) {
	localctx = NewRepeatStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, pascalParserRULE_repeatStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1735)
		p.Match(pascalParserREPEAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1736)
		p.Statements()
	}
	{
		p.SetState(1737)
		p.Match(pascalParserUNTIL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1738)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode
	ForList() IForListContext
	DO() antlr.TerminalNode
	Statement() IStatementContext
	VAR() antlr.TerminalNode
	IN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forStatement
	return p
}

func InitEmptyForStatementContext(p *ForStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forStatement
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(pascalParserFOR, 0)
}

func (s *ForStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ForStatementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(pascalParserASSIGN, 0)
}

func (s *ForStatementContext) ForList() IForListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForListContext)
}

func (s *ForStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(pascalParserDO, 0)
}

func (s *ForStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatementContext) VAR() antlr.TerminalNode {
	return s.GetToken(pascalParserVAR, 0)
}

func (s *ForStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(pascalParserIN, 0)
}

func (s *ForStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (s *ForStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitForStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ForStatement() (localctx IForStatementContext) {
	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, pascalParserRULE_forStatement)
	var _la int

	p.SetState(1760)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 199, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1740)
			p.Match(pascalParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1742)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserVAR {
			{
				p.SetState(1741)
				p.Match(pascalParserVAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1744)
			p.Identifier()
		}
		{
			p.SetState(1745)
			p.Match(pascalParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1746)
			p.ForList()
		}
		{
			p.SetState(1747)
			p.Match(pascalParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1748)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1750)
			p.Match(pascalParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1752)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserVAR {
			{
				p.SetState(1751)
				p.Match(pascalParserVAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1754)
			p.Identifier()
		}
		{
			p.SetState(1755)
			p.Match(pascalParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1756)
			p.Expression()
		}
		{
			p.SetState(1757)
			p.Match(pascalParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1758)
			p.Statement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForListContext is an interface to support dynamic dispatch.
type IForListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InitialValue() IInitialValueContext
	FinalValue() IFinalValueContext
	TO() antlr.TerminalNode
	DOWNTO() antlr.TerminalNode

	// IsForListContext differentiates from other interfaces.
	IsForListContext()
}

type ForListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForListContext() *ForListContext {
	var p = new(ForListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forList
	return p
}

func InitEmptyForListContext(p *ForListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_forList
}

func (*ForListContext) IsForListContext() {}

func NewForListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForListContext {
	var p = new(ForListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_forList

	return p
}

func (s *ForListContext) GetParser() antlr.Parser { return s.parser }

func (s *ForListContext) InitialValue() IInitialValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitialValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitialValueContext)
}

func (s *ForListContext) FinalValue() IFinalValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinalValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinalValueContext)
}

func (s *ForListContext) TO() antlr.TerminalNode {
	return s.GetToken(pascalParserTO, 0)
}

func (s *ForListContext) DOWNTO() antlr.TerminalNode {
	return s.GetToken(pascalParserDOWNTO, 0)
}

func (s *ForListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterForList(s)
	}
}

func (s *ForListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitForList(s)
	}
}

func (s *ForListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitForList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ForList() (localctx IForListContext) {
	localctx = NewForListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, pascalParserRULE_forList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1762)
		p.InitialValue()
	}
	{
		p.SetState(1763)
		_la = p.GetTokenStream().LA(1)

		if !(_la == pascalParserDOWNTO || _la == pascalParserTO) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1764)
		p.FinalValue()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitialValueContext is an interface to support dynamic dispatch.
type IInitialValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsInitialValueContext differentiates from other interfaces.
	IsInitialValueContext()
}

type InitialValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitialValueContext() *InitialValueContext {
	var p = new(InitialValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_initialValue
	return p
}

func InitEmptyInitialValueContext(p *InitialValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_initialValue
}

func (*InitialValueContext) IsInitialValueContext() {}

func NewInitialValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitialValueContext {
	var p = new(InitialValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_initialValue

	return p
}

func (s *InitialValueContext) GetParser() antlr.Parser { return s.parser }

func (s *InitialValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InitialValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitialValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitialValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterInitialValue(s)
	}
}

func (s *InitialValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitInitialValue(s)
	}
}

func (s *InitialValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitInitialValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) InitialValue() (localctx IInitialValueContext) {
	localctx = NewInitialValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, pascalParserRULE_initialValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1766)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFinalValueContext is an interface to support dynamic dispatch.
type IFinalValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsFinalValueContext differentiates from other interfaces.
	IsFinalValueContext()
}

type FinalValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinalValueContext() *FinalValueContext {
	var p = new(FinalValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_finalValue
	return p
}

func InitEmptyFinalValueContext(p *FinalValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_finalValue
}

func (*FinalValueContext) IsFinalValueContext() {}

func NewFinalValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinalValueContext {
	var p = new(FinalValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_finalValue

	return p
}

func (s *FinalValueContext) GetParser() antlr.Parser { return s.parser }

func (s *FinalValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FinalValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinalValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinalValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterFinalValue(s)
	}
}

func (s *FinalValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitFinalValue(s)
	}
}

func (s *FinalValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitFinalValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) FinalValue() (localctx IFinalValueContext) {
	localctx = NewFinalValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, pascalParserRULE_finalValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1768)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithStatementContext is an interface to support dynamic dispatch.
type IWithStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	WithStatementVariableList() IWithStatementVariableListContext
	DO() antlr.TerminalNode
	Statement() IStatementContext
	Expression() IExpressionContext

	// IsWithStatementContext differentiates from other interfaces.
	IsWithStatementContext()
}

type WithStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithStatementContext() *WithStatementContext {
	var p = new(WithStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_withStatement
	return p
}

func InitEmptyWithStatementContext(p *WithStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_withStatement
}

func (*WithStatementContext) IsWithStatementContext() {}

func NewWithStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithStatementContext {
	var p = new(WithStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_withStatement

	return p
}

func (s *WithStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WithStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(pascalParserWITH, 0)
}

func (s *WithStatementContext) WithStatementVariableList() IWithStatementVariableListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithStatementVariableListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithStatementVariableListContext)
}

func (s *WithStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(pascalParserDO, 0)
}

func (s *WithStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WithStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WithStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterWithStatement(s)
	}
}

func (s *WithStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitWithStatement(s)
	}
}

func (s *WithStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitWithStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) WithStatement() (localctx IWithStatementContext) {
	localctx = NewWithStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, pascalParserRULE_withStatement)
	p.SetState(1780)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 200, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1770)
			p.Match(pascalParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1771)
			p.WithStatementVariableList()
		}
		{
			p.SetState(1772)
			p.Match(pascalParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1773)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1775)
			p.Match(pascalParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1776)
			p.Expression()
		}
		{
			p.SetState(1777)
			p.Match(pascalParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1778)
			p.Statement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryExceptStatementContext is an interface to support dynamic dispatch.
type ITryExceptStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRY() antlr.TerminalNode
	AllStatements() []IStatementsContext
	Statements(i int) IStatementsContext
	EXCEPT() antlr.TerminalNode
	END() antlr.TerminalNode
	AllExceptionCase() []IExceptionCaseContext
	ExceptionCase(i int) IExceptionCaseContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	ExceptionElse() IExceptionElseContext

	// IsTryExceptStatementContext differentiates from other interfaces.
	IsTryExceptStatementContext()
}

type TryExceptStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryExceptStatementContext() *TryExceptStatementContext {
	var p = new(TryExceptStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tryExceptStatement
	return p
}

func InitEmptyTryExceptStatementContext(p *TryExceptStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tryExceptStatement
}

func (*TryExceptStatementContext) IsTryExceptStatementContext() {}

func NewTryExceptStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryExceptStatementContext {
	var p = new(TryExceptStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_tryExceptStatement

	return p
}

func (s *TryExceptStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryExceptStatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(pascalParserTRY, 0)
}

func (s *TryExceptStatementContext) AllStatements() []IStatementsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementsContext); ok {
			len++
		}
	}

	tst := make([]IStatementsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementsContext); ok {
			tst[i] = t.(IStatementsContext)
			i++
		}
	}

	return tst
}

func (s *TryExceptStatementContext) Statements(i int) IStatementsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *TryExceptStatementContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(pascalParserEXCEPT, 0)
}

func (s *TryExceptStatementContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *TryExceptStatementContext) AllExceptionCase() []IExceptionCaseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExceptionCaseContext); ok {
			len++
		}
	}

	tst := make([]IExceptionCaseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExceptionCaseContext); ok {
			tst[i] = t.(IExceptionCaseContext)
			i++
		}
	}

	return tst
}

func (s *TryExceptStatementContext) ExceptionCase(i int) IExceptionCaseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExceptionCaseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExceptionCaseContext)
}

func (s *TryExceptStatementContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(pascalParserSEMI)
}

func (s *TryExceptStatementContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserSEMI, i)
}

func (s *TryExceptStatementContext) ExceptionElse() IExceptionElseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExceptionElseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExceptionElseContext)
}

func (s *TryExceptStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryExceptStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryExceptStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTryExceptStatement(s)
	}
}

func (s *TryExceptStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTryExceptStatement(s)
	}
}

func (s *TryExceptStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTryExceptStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TryExceptStatement() (localctx ITryExceptStatementContext) {
	localctx = NewTryExceptStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, pascalParserRULE_tryExceptStatement)
	var _la int

	p.SetState(1803)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 203, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1782)
			p.Match(pascalParserTRY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1783)
			p.Statements()
		}
		{
			p.SetState(1784)
			p.Match(pascalParserEXCEPT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1785)
			p.Statements()
		}
		{
			p.SetState(1786)
			p.Match(pascalParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1788)
			p.Match(pascalParserTRY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1789)
			p.Statements()
		}
		{
			p.SetState(1790)
			p.Match(pascalParserEXCEPT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1794)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == pascalParserON {
			{
				p.SetState(1791)
				p.ExceptionCase()
			}
			{
				p.SetState(1792)
				p.Match(pascalParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1796)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1799)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == pascalParserELSE {
			{
				p.SetState(1798)
				p.ExceptionElse()
			}

		}
		{
			p.SetState(1801)
			p.Match(pascalParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExceptionCaseContext is an interface to support dynamic dispatch.
type IExceptionCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	TypeIdentifier() ITypeIdentifierContext
	DO() antlr.TerminalNode
	Statements() IStatementsContext

	// IsExceptionCaseContext differentiates from other interfaces.
	IsExceptionCaseContext()
}

type ExceptionCaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExceptionCaseContext() *ExceptionCaseContext {
	var p = new(ExceptionCaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_exceptionCase
	return p
}

func InitEmptyExceptionCaseContext(p *ExceptionCaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_exceptionCase
}

func (*ExceptionCaseContext) IsExceptionCaseContext() {}

func NewExceptionCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptionCaseContext {
	var p = new(ExceptionCaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_exceptionCase

	return p
}

func (s *ExceptionCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptionCaseContext) ON() antlr.TerminalNode {
	return s.GetToken(pascalParserON, 0)
}

func (s *ExceptionCaseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExceptionCaseContext) COLON() antlr.TerminalNode {
	return s.GetToken(pascalParserCOLON, 0)
}

func (s *ExceptionCaseContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ExceptionCaseContext) DO() antlr.TerminalNode {
	return s.GetToken(pascalParserDO, 0)
}

func (s *ExceptionCaseContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *ExceptionCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptionCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExceptionCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterExceptionCase(s)
	}
}

func (s *ExceptionCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitExceptionCase(s)
	}
}

func (s *ExceptionCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitExceptionCase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ExceptionCase() (localctx IExceptionCaseContext) {
	localctx = NewExceptionCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, pascalParserRULE_exceptionCase)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1805)
		p.Match(pascalParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1806)
		p.Identifier()
	}
	{
		p.SetState(1807)
		p.Match(pascalParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1808)
		p.TypeIdentifier()
	}
	{
		p.SetState(1809)
		p.Match(pascalParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1810)
		p.Statements()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExceptionElseContext is an interface to support dynamic dispatch.
type IExceptionElseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELSE() antlr.TerminalNode
	Statements() IStatementsContext

	// IsExceptionElseContext differentiates from other interfaces.
	IsExceptionElseContext()
}

type ExceptionElseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExceptionElseContext() *ExceptionElseContext {
	var p = new(ExceptionElseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_exceptionElse
	return p
}

func InitEmptyExceptionElseContext(p *ExceptionElseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_exceptionElse
}

func (*ExceptionElseContext) IsExceptionElseContext() {}

func NewExceptionElseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptionElseContext {
	var p = new(ExceptionElseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_exceptionElse

	return p
}

func (s *ExceptionElseContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptionElseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(pascalParserELSE, 0)
}

func (s *ExceptionElseContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *ExceptionElseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptionElseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExceptionElseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterExceptionElse(s)
	}
}

func (s *ExceptionElseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitExceptionElse(s)
	}
}

func (s *ExceptionElseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitExceptionElse(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) ExceptionElse() (localctx IExceptionElseContext) {
	localctx = NewExceptionElseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, pascalParserRULE_exceptionElse)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1812)
		p.Match(pascalParserELSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1813)
		p.Statements()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryFinallyStatementContext is an interface to support dynamic dispatch.
type ITryFinallyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRY() antlr.TerminalNode
	AllStatements() []IStatementsContext
	Statements(i int) IStatementsContext
	FINALLY() antlr.TerminalNode
	END() antlr.TerminalNode

	// IsTryFinallyStatementContext differentiates from other interfaces.
	IsTryFinallyStatementContext()
}

type TryFinallyStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryFinallyStatementContext() *TryFinallyStatementContext {
	var p = new(TryFinallyStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tryFinallyStatement
	return p
}

func InitEmptyTryFinallyStatementContext(p *TryFinallyStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_tryFinallyStatement
}

func (*TryFinallyStatementContext) IsTryFinallyStatementContext() {}

func NewTryFinallyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryFinallyStatementContext {
	var p = new(TryFinallyStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_tryFinallyStatement

	return p
}

func (s *TryFinallyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryFinallyStatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(pascalParserTRY, 0)
}

func (s *TryFinallyStatementContext) AllStatements() []IStatementsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementsContext); ok {
			len++
		}
	}

	tst := make([]IStatementsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementsContext); ok {
			tst[i] = t.(IStatementsContext)
			i++
		}
	}

	return tst
}

func (s *TryFinallyStatementContext) Statements(i int) IStatementsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *TryFinallyStatementContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(pascalParserFINALLY, 0)
}

func (s *TryFinallyStatementContext) END() antlr.TerminalNode {
	return s.GetToken(pascalParserEND, 0)
}

func (s *TryFinallyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryFinallyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryFinallyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterTryFinallyStatement(s)
	}
}

func (s *TryFinallyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitTryFinallyStatement(s)
	}
}

func (s *TryFinallyStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitTryFinallyStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) TryFinallyStatement() (localctx ITryFinallyStatementContext) {
	localctx = NewTryFinallyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, pascalParserRULE_tryFinallyStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1815)
		p.Match(pascalParserTRY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1816)
		p.Statements()
	}
	{
		p.SetState(1817)
		p.Match(pascalParserFINALLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1818)
		p.Statements()
	}
	{
		p.SetState(1819)
		p.Match(pascalParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithStatementVariableListContext is an interface to support dynamic dispatch.
type IWithStatementVariableListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariableDesignator() []IVariableDesignatorContext
	VariableDesignator(i int) IVariableDesignatorContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWithStatementVariableListContext differentiates from other interfaces.
	IsWithStatementVariableListContext()
}

type WithStatementVariableListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithStatementVariableListContext() *WithStatementVariableListContext {
	var p = new(WithStatementVariableListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_withStatementVariableList
	return p
}

func InitEmptyWithStatementVariableListContext(p *WithStatementVariableListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_withStatementVariableList
}

func (*WithStatementVariableListContext) IsWithStatementVariableListContext() {}

func NewWithStatementVariableListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithStatementVariableListContext {
	var p = new(WithStatementVariableListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_withStatementVariableList

	return p
}

func (s *WithStatementVariableListContext) GetParser() antlr.Parser { return s.parser }

func (s *WithStatementVariableListContext) AllVariableDesignator() []IVariableDesignatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDesignatorContext); ok {
			len++
		}
	}

	tst := make([]IVariableDesignatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDesignatorContext); ok {
			tst[i] = t.(IVariableDesignatorContext)
			i++
		}
	}

	return tst
}

func (s *WithStatementVariableListContext) VariableDesignator(i int) IVariableDesignatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDesignatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDesignatorContext)
}

func (s *WithStatementVariableListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *WithStatementVariableListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *WithStatementVariableListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithStatementVariableListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithStatementVariableListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterWithStatementVariableList(s)
	}
}

func (s *WithStatementVariableListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitWithStatementVariableList(s)
	}
}

func (s *WithStatementVariableListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitWithStatementVariableList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) WithStatementVariableList() (localctx IWithStatementVariableListContext) {
	localctx = NewWithStatementVariableListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, pascalParserRULE_withStatementVariableList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1821)
		p.VariableDesignator()
	}
	p.SetState(1826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(1822)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1823)
			p.VariableDesignator()
		}

		p.SetState(1828)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeSectionContext is an interface to support dynamic dispatch.
type IAttributeSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	AttributeList() IAttributeListContext
	RBRACK() antlr.TerminalNode

	// IsAttributeSectionContext differentiates from other interfaces.
	IsAttributeSectionContext()
}

type AttributeSectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeSectionContext() *AttributeSectionContext {
	var p = new(AttributeSectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_attributeSection
	return p
}

func InitEmptyAttributeSectionContext(p *AttributeSectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_attributeSection
}

func (*AttributeSectionContext) IsAttributeSectionContext() {}

func NewAttributeSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeSectionContext {
	var p = new(AttributeSectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_attributeSection

	return p
}

func (s *AttributeSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeSectionContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserLBRACK, 0)
}

func (s *AttributeSectionContext) AttributeList() IAttributeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeListContext)
}

func (s *AttributeSectionContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(pascalParserRBRACK, 0)
}

func (s *AttributeSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAttributeSection(s)
	}
}

func (s *AttributeSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAttributeSection(s)
	}
}

func (s *AttributeSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAttributeSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) AttributeSection() (localctx IAttributeSectionContext) {
	localctx = NewAttributeSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, pascalParserRULE_attributeSection)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1829)
		p.Match(pascalParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1830)
		p.AttributeList()
	}
	{
		p.SetState(1831)
		p.Match(pascalParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeListContext is an interface to support dynamic dispatch.
type IAttributeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAttributeItem() []IAttributeItemContext
	AttributeItem(i int) IAttributeItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAttributeListContext differentiates from other interfaces.
	IsAttributeListContext()
}

type AttributeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeListContext() *AttributeListContext {
	var p = new(AttributeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_attributeList
	return p
}

func InitEmptyAttributeListContext(p *AttributeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_attributeList
}

func (*AttributeListContext) IsAttributeListContext() {}

func NewAttributeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeListContext {
	var p = new(AttributeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_attributeList

	return p
}

func (s *AttributeListContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeListContext) AllAttributeItem() []IAttributeItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeItemContext); ok {
			len++
		}
	}

	tst := make([]IAttributeItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeItemContext); ok {
			tst[i] = t.(IAttributeItemContext)
			i++
		}
	}

	return tst
}

func (s *AttributeListContext) AttributeItem(i int) IAttributeItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeItemContext)
}

func (s *AttributeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(pascalParserCOMMA)
}

func (s *AttributeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(pascalParserCOMMA, i)
}

func (s *AttributeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAttributeList(s)
	}
}

func (s *AttributeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAttributeList(s)
	}
}

func (s *AttributeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAttributeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) AttributeList() (localctx IAttributeListContext) {
	localctx = NewAttributeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, pascalParserRULE_attributeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1833)
		p.AttributeItem()
	}
	p.SetState(1838)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == pascalParserCOMMA {
		{
			p.SetState(1834)
			p.Match(pascalParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1835)
			p.AttributeItem()
		}

		p.SetState(1840)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeItemContext is an interface to support dynamic dispatch.
type IAttributeItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	ParameterList() IParameterListContext
	RPAREN() antlr.TerminalNode

	// IsAttributeItemContext differentiates from other interfaces.
	IsAttributeItemContext()
}

type AttributeItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeItemContext() *AttributeItemContext {
	var p = new(AttributeItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_attributeItem
	return p
}

func InitEmptyAttributeItemContext(p *AttributeItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = pascalParserRULE_attributeItem
}

func (*AttributeItemContext) IsAttributeItemContext() {}

func NewAttributeItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeItemContext {
	var p = new(AttributeItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = pascalParserRULE_attributeItem

	return p
}

func (s *AttributeItemContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AttributeItemContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserLPAREN, 0)
}

func (s *AttributeItemContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *AttributeItemContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(pascalParserRPAREN, 0)
}

func (s *AttributeItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.EnterAttributeItem(s)
	}
}

func (s *AttributeItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(pascalListener); ok {
		listenerT.ExitAttributeItem(s)
	}
}

func (s *AttributeItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case pascalVisitor:
		return t.VisitAttributeItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *pascalParser) AttributeItem() (localctx IAttributeItemContext) {
	localctx = NewAttributeItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, pascalParserRULE_attributeItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1841)
		p.Identifier()
	}
	p.SetState(1846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == pascalParserLPAREN {
		{
			p.SetState(1842)
			p.Match(pascalParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1843)
			p.ParameterList()
		}
		{
			p.SetState(1844)
			p.Match(pascalParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *pascalParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 132:
		var t *FactorContext = nil
		if localctx != nil {
			t = localctx.(*FactorContext)
		}
		return p.Factor_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *pascalParser) Factor_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
